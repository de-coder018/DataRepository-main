{
    "queries": {
        "1e61e4b1-0686-4ebb-b32e-c3bc9b62a11a": "Based on the context information, describe the role of the Human Microbiome Project and its significance in understanding the relationship between the human body and its microbial communities.",
        "6ade1c68-7361-45ed-8cd0-cb32a1a82dec": "Explain how the knowledge of the microbiome can be applied to improve human health, as indicated in the document, and provide an example of a specific area where this application could make a significant impact.",
        "89307f36-e5cc-4eac-b857-a4e9e381f8ac": "Explain the concept of OSPF (Open Shortest Path First) and its role in the TCP/IP network. What are some of the design decisions behind OSPF and how has it evolved to keep pace with the changing Internet environment?",
        "a92efa9c-3830-49b0-8969-ee292710adc9": "Describe the process of routing fundamentals, such as how a router forwards packets, IP addressing, CIDR, the routing table, and Internet routing architecture. Additionally, explain the difference between Distance Vector and link-state algorithms and in what scenarios each would be used.",
        "1eb597ba-34d6-460a-ac24-3fa73308df48": "The copyright page of the book includes a disclaimer regarding the warranty and liability of the book's content. What does this disclaimer imply about the author and publisher's responsibility for any errors or omissions in the book?",
        "7b2d96fb-9d3d-4114-9ca0-d7214137535f": "The book mentions that the publisher offers discounts for bulk orders. What information does the publisher provide for those interested in making such a purchase?",
        "fd0a1b66-100d-43a0-abe1-cab7283cb997": "What is the full form of OSPF as mentioned in the title of the document \"OSPF: Anatomy of an Internet Routing Protocol\" by John T. Moy? Describe the role and importance of OSPF in internet routing.",
        "366a195f-b9f6-4485-b024-6e451577cb8a": "Explain the concept of \"Link State Packets\" in OSPF as described by John T. Moy in his book. Additionally, discuss its significance in the overall functioning of OSPF and its contribution to the anatomy of an internet routing protocol.",
        "32647c20-6477-4cf6-b18f-997959f1e912": "Explain the role of routers in the Internet, as described in Chapter 1 of the document. What is the difference between the Internet Protocol Suite and IPv6? Provide examples of how forwarding IP datagrams works.",
        "24fa4312-a1e0-4a6f-bea0-4524bd81782d": "Describe the difference between Distance Vector Algorithms and Link-State Algorithms as discussed in Chapter 2. In the context of Internet Routing Protocols, what are routing tables and the Internet Routing Architecture? Explain the functional requirements and design decisions that led to the development of the OSPF protocol, as discussed in Chapter 3.",
        "51802372-a88a-4299-835b-852b25ac91f3": "Explain the concept of \"Link State Advertisements (LSAs)\" in OSPF and describe the purpose of the \"Router-LSA\" in detail.",
        "93629649-71d5-4ebb-ae88-1c5a3fe6724e": "Compare and contrast the different OSPF network types mentioned in the document, including Broadcast Subnets, NBMA Subnets, Point-to-MultiPoint Subnets, and their respective suitability in various network scenarios.",
        "0a3545d8-78cb-4761-9a7e-c6d36e97e948": "Explain the concept of Multicast Open Shortest Path First (MOSPF) and describe how it differs from traditional OSPF in terms of routing calculations. Include an example of how MOSPF is used in the MBONE.",
        "cf9ee608-c4a0-4c68-925f-461d35795405": "Discuss the role of SNMP in managing OSPF and the importance of SNMP MIBs in this process. Additionally, explain how the ping and traceroute tools can be used to debug routing problems and provide an example of their usage.",
        "64cd2cc7-c579-4fe0-ae57-1fe99cd767b7": "Explain the concept of \"Integrated IS-IS\" as described in Section 13.5 of the document. What are the advantages of using Integrated IS-IS in an OSPF network?",
        "f1553833-acdc-402e-8345-20e49cd09d99": "Compare and contrast the \"Broadcast-and-Prune\" and \"PIM Sparse\" multicast routing protocols discussed in Section 14.4. When would each of these protocols be most appropriate to use? Provide an example of a network scenario where one protocol would be preferred over the other.",
        "18de72a1-ad6d-4184-9394-1dcbb06dfecf": "Based on Table 1.1 in the document, explain the function of each division of IP address space. What is the purpose of each division and how is it used in the network?",
        "97f8bdfd-f191-4fdd-b5ee-96e55e5ad394": "OR",
        "234c722e-f49e-4dc0-99c5-695bda74dce3": "Given the information in Table 1.2, what are some of the special-purpose IP unicast addresses and their intended uses? Explain the significance of these addresses and how they differ from regular unicast addresses.",
        "593f03a1-8272-4ac1-b0c6-2e5cbe6afc00": "OR",
        "5b0766d0-7344-4266-a2d7-73614167bfd4": "Based on the information in Table 1.3, explain the historical class division of IP address space. How did this division work and what were the limitations of this approach?",
        "2ccd26f4-c8ce-4e3d-b52c-324274f5003d": "OR",
        "42ff2536-7eac-4010-beea-deb198f6064b": "Referring to Table 2.1, what is the routing table of the router C in Figure 1.5? Explain the purpose of each field in the table and how it is used in the routing process.",
        "e4beb525-87c2-4fc0-a53e-2ea57a1da02e": "OR",
        "ffb5f0da-0bee-4d58-ac9b-b132cf538906": "Based on the information in Table 4.1, what are the actions taken by an OSPF router based on the LS age fields? Explain the significance of these actions and how they contribute to the overall functioning of the OSPF protocol.",
        "d03608ec-da36-4e95-80ee-9ffd7ac3961a": "OR",
        "9cd6fc03-34cd-414f-9450-98b411863aab": "Referring to Table 9.1, what are the IP multicast address assignments? Explain the purpose of each address assignment and how they are used in the network.",
        "9936d0eb-732a-410a-b680-081c89de662c": "OR",
        "78d3319e-b58d-4de4-ac0f-d9e670893d27": "Based on the information in Table 11.1, what are the default timer values in OSPF? Explain the purpose of each timer and how they are used in the OSPF protocol.",
        "29e5e739-e149-4b4c-9e2c-08a8d6e70f31": "OR",
        "69e6a12c-edfa-4653-a561-282aade72bc7": "Referring to Table 12.1, what are some of the common failure indications of traceroute? Explain the significance of these indications and how they can be used to troubleshoot network issues.",
        "623a553d-e63f-4220-8ad2-61ee2cf646b5": "Classify the TCP/IP routing protocols and provide an example of each category. Explain the key differences between them, based on the information presented in Table 13.1.",
        "c7635775-bec6-411f-9965-98de5fb05657": "Describe an example of aggregation requiring AS sets using a diagram and explain how BGP path attributes are used in this scenario, referring to the examples given in Section 13.2 and Section 13.3. Additionally, explain the role of AS sets in this context.",
        "853eb0fd-3789-4557-9628-f057a2352a67": "Figure 1.2 in the document presents the seven-layer OSI reference model and its TCP/IP equivalents. Based on this figure, explain the functions of the Network layer in both the OSI and TCP/IP models. What are the key similarities and differences between the two models at this layer?",
        "103a8a8b-d0bc-409c-a29a-231aaa7140fe": "Chapter 3 of the document discusses Open Shortest Path First (OSPF), a popular Interior Gateway Protocol (IGP) used in modern networks. Refer to Figure 3.4 and the corresponding text that describes the INTEROP 91 ShowNet. Describe the role of OSPF in this network topology. Explain how the forwarding address is used in OSPF and why it is important in this context.",
        "7512ae68-f53a-4d4d-aed5-9ab5a7eaf23f": "Explain the purpose and structure of an OSPF Hello packet, as depicted in Figure 4.6. What information does this packet contain and how is it used in the OSPF protocol?",
        "8c758379-5389-43f2-a7dd-17498ae05794": "OR",
        "97d914d6-d64d-4a15-a928-068663b65926": "Consider the Frame Relay network with a partial PVC mesh in Figure 5.9. Describe how this network can be turned into a Point-to-MultiPoint subnet, as shown in Figure 10.11. What are the benefits of this configuration and how does it affect OSPF routing?",
        "dacc2d0b-ced3-4679-9336-aea71c5bd876": "OR",
        "a4572fd6-a129-4375-93dd-4478f937580d": "In the context of OSPF, what is a network-LSA and how is it used to represent a broadcast subnet? Provide an example of a network-LSA for a subnet, such as the one shown in Figure 5.7.",
        "16bdc312-8c0f-4a9f-b7c3-868f6dee91b0": "OR",
        "fdc59e0f-e092-490c-8978-9c654ccfaf98": "Explain the concept of hierarchical routing in OSPF and how it is used to improve the scalability of large internetworks. Provide an example of a sample area configuration and describe how summary-LSAs are used in this context, as shown in Figure 6.3.",
        "f0c41336-7743-4906-9437-dd6bbc3270d2": "OR",
        "48c5a95d-8d4b-4c61-bd17-fadddf394280": "Describe the process of inter-area routing exchange in OSPF, as illustrated in Figure 6.5. How are virtual links used to incorporate new networks into an OSPF autonomous system, as shown in Figure 6.6?",
        "4f4b345f-b375-4056-b6f9-3df28fe3f765": "OR",
        "856e480a-9e73-4907-bfad-6ce1d3cff840": "Explain the purpose and structure of an AS-external-LSA in OSPF, as depicted in Figure 6.7. What information does this LSA contain and how is it used in the OSPF protocol?",
        "72f7ee5d-16bc-4378-acc3-0203bfeee02d": "OR",
        "9a95a93c-f6f6-4866-81bb-45eea72182d2": "Describe the process of constructing an MBONE topology from a given network diagram, as shown in Figure 9.6. How are multicast routing tables used in this context and what are the benefits of using an MBONE topology for multicast communication?",
        "5fcdb447-ba68-4f25-8be6-c477b80ae75e": "OR",
        "23383196-f382-4ee3-a17f-98fb80749f0d": "Explain the concept of MOSPF and how it is used to support multicast routing in OSPF. Provide an example of an MOSPF routing domain and describe how group-membership-LSAs are used in this context, as shown in Figure 10.2.",
        "6ac60f86-358f-47b2-b621-b34896cea119": "OR",
        "00b26c03-29bc-474a-948f-6d43fa0ef83f": "Describe the structure and purpose of the OSPF MIB, as illustrated in Figure 11.1. Provide an example of a variable within the OSPF MIB, such as ospfIfMetricValue, and explain how it is used in the OSPF protocol.",
        "ed3660fe-e020-422d-a111-25dddec321f5": "Based on Figure 11.1 in the document, can you identify the different components of the Arkansas Public School Computer Network (APSCN) and explain their functions?",
        "935b32b7-7c39-4405-8317-9140298285b1": "Given the trace of RIP routing update behavior in Figure 13.2, can you explain the process of RIP operation and how it determines the best path to a destination network? Additionally, describe a scenario where RIP might not be the best routing protocol to use and suggest an alternative.",
        "9a4ff02a-e9e8-45de-8bdf-394c3ec6e4d1": "Explain the role of routers in the Internet and how they use routing protocols to make decisions about forwarding data.",
        "2445024b-c994-4a2d-89e1-2dc370b1ceef": "Why is it important for routing protocols to quickly react to changes in the Internet's infrastructure and what are some examples of such changes?",
        "e3d3d04e-3bec-45c2-89ef-31daa5eb6843": "Question for Part I of the book: Explain the role of a router in forwarding packets and the concept of IP addressing and CIDR. What is the interaction between hosts and routers in the context of Internet routing?",
        "2cc9954c-bad7-461e-8faa-553c503e184a": "Question for Part II of the book: What were the reasons behind the development of the OSPF protocol? Explain the basics of link-state routing and how OSPF behaves over various subnet technologies. Additionally, discuss the use of hierarchical routing and extensions to OSPF.",
        "ac9ea415-b841-4dc0-b95d-92e55447f0dd": "Explain the role of multicast routing protocols in the context of Internet routing and describe the key features of the Multicast Extensions to OSPF (MOSPF) protocol.",
        "8c344a06-8a9e-4577-9489-bde2f216f300": "Compare and contrast two Internet routing protocols covered in Chapter 13 of the document and explain one tool used to monitor and debug routing in a TCP/IP network from Chapter 12. Provide a rationale for your choices.",
        "2b933df9-2ef3-4cb2-8e7a-60d1bdd379c3": "Chapter 1 of the text discusses the role of routers in the Internet and the interaction between hosts and routers. Can you explain what IP addressing is and how CIDR addressing is used to improve the allocation of IP addresses? Provide an example of how CIDR addressing would be represented and explain its benefits.",
        "6372e709-331c-4abb-b961-c80beccbb2b6": "Chapter 2 of the text introduces the Internet's routing architecture and the two basic routing technologies in use: link-state and Distance Vector. Compare and contrast these two routing technologies. In your comparison, be sure to include the way each technology builds and maintains its routing table and any advantages or disadvantages of each approach.",
        "878f6246-b1a0-4e4f-bb70-e7a8e2d20167": "Question: Can you explain the role of routers in the Internet and how they help in exchanging information between different computers?",
        "4b51c63a-0e7a-4b1a-8d73-4bca18509274": "OR",
        "e8591df4-ac89-4366-b8c0-ae9f47dfbddb": "Question: What is the function of routing protocols in the Internet and how do they assist routers in making correct routing decisions?",
        "911a79b0-ad1b-43ea-8fa1-47255915a685": "(OR)",
        "26a09799-7aef-4893-8aa5-da0dff73f069": "Question: How do routing protocols help routers determine the optimal path for packet forwarding in a packet-switching network like the Internet?",
        "68cde1a5-63e9-4464-bd30-7a4990673147": "OR",
        "c0003cad-b12d-4f57-b8af-d43a66e1c805": "Question: Can you describe how routing protocols enable routers to adapt to changes in the network, such as when a router goes out of service, and find the new best path for packet forwarding?",
        "2767e1ac-964f-43c1-8d9d-2ffd8cb8443d": "(OR)",
        "57570a8e-9019-4525-86f3-201cdd0bf7e0": "Question: How does the Open Shortest Path First (OSPF) protocol, in particular, help routers in the Internet make routing decisions?",
        "b79d2c1e-4647-4447-9f42-ed68fc8c1aa5": "(OR)",
        "cdfb0cd7-a8dd-4466-b3f1-2337bdfc6dad": "Question: Can you explain how the example of the five interconnected routers (A through E) would work in practice, including how routing protocols help routers determine the optimal path for packet forwarding?",
        "0888c79f-c7b3-4446-8cd0-9c3f3d7e6c74": "Explain the role of routing protocols in the Internet and how they help routers to find paths from Internet sources to Internet destinations.",
        "6bb8b6aa-9f25-4a57-a36c-bed8b26d7371": "Describe the forwarding process within a router, including how routers interact with the packets' sources and destinations. Additionally, explain the organization of Internet addresses and the instructions they carry to identify the packet's destination.",
        "b3d04345-7341-4368-b480-1405543378da": "Based on the context information, how does the layering of Internet protocols simplify protocol design? Provide an example of how lower-layer protocols can impact the functioning of higher-layer protocols.",
        "78d7fa45-2c15-4be9-b15d-69dcfb2a3740": "Explain the process of data transmission in the Internet Protocol Suite, starting from the network application to the physical layer. Illustrate this process using the TELNET application being transmitted onto an Ethernet segment as an example.",
        "502ccbdd-e184-4f8a-98f1-5f8cf3ad3813": "Based on the information provided in Figure 1.3, explain the role of Internet headers in the transmission of TELNET data from a user client to a server. What benefits do these headers provide in the communication process?",
        "74f710df-d9b6-48bb-b1c2-89057ff5002f": "The protocol stack in the Internet provides multiplexing services to allow multiple instances of higher-level protocols to run simultaneously. How does the data-link protocol specifically enable packet multiplexing, and what role does packet type play in this process? Provide an example to illustrate your answer.",
        "ead8aa95-9cd6-4c15-9df9-f76c32db0b21": "Explain the role of the Address Resolution Protocol (ARP) in the Internet Protocol Suite and why it straddles the network and data-link layers. Provide an example of how ARP is used to map IP addresses into data-link addresses.",
        "a4d1680a-0043-4b73-b643-7628f8147582": "Compare and contrast the functions of the physical layer and data-link layer in the Internet Protocol Suite. Include examples of physical layer standards and data-link protocols used in the Internet. Additionally, explain the purpose of the 14-byte Ethernet data-link header and its components.",
        "d654bc14-ce20-4e4e-a43b-17873442eb10": "Explain the role of routers in the Internet and the basic functions of the Internet's network layer, including the use of IP addresses and routing protocols.",
        "c35b7c0f-1c35-48ce-8065-cd50e281f033": "Describe the two transport protocols in the TCP/IP protocol suite, Transmission Control Protocol (TCP) and User Datagram Protocol (UDP), and their respective uses and features, such as error detection, error correction, and data sequencing.",
        "59781c51-8661-445a-a321-40e23a20213a": "What are two examples of application protocols in the Internet, and what services do they provide?",
        "0d40bef1-2688-4206-a0eb-8b29bb871486": "In the context of IP datagram forwarding, what information does a router examine in the Ethernet header before stripping it off, and what does it do with this information?",
        "5e652742-c089-491b-9ec6-5958b35041ec": "Explain the role of the Time To Live (TTL) field in the IP header and how it is used to prevent packets from circulating indefinitely in the event of routing loops. Include a description of how the TTL field is adjusted by routers and what action is taken when the TTL field reaches 0.",
        "3ba58de6-4a57-445a-acf5-5031482998fb": "Describe the process of unicast packet forwarding by a router, including how the destination IP address is used to look up the best-matching routing table entry and what actions are taken if the packet is too large to be sent out the outgoing interface in one piece. Explain the concept of fragmentation and its potential impact on performance, as well as the use of the Don't Fragment (DF) bit to prevent fragmentation.",
        "36f8b89c-fbe2-49d6-a210-52373459d13e": "How do routers typically ensure that packets belonging to a given TCP connection travel over the same path, and what role does the Type of Service (TOS) field in the IP header play in affecting a packet's path?",
        "8235b226-98d1-4636-ba3b-3bbdbb5714a5": "What are IP options, and how are they used to modify the handling of packets? Explain the purpose and limitations of the strict-source route and loose-source route options.",
        "d2c2ebd1-3867-4049-891e-0f65f1faf24a": "What is the primary purpose of loose-source routing in the Internet, and why might some network operators consider it a security hole?",
        "9efb8f8a-a34d-419f-a12a-c6805412c9f7": "Answers to this question will demonstrate an understanding of the diagnostic and tunneling uses of loose-source routing, as well as the security concerns associated with it.",
        "75491da8-e197-4636-a66f-6f8df382eec3": "How do routers use ICMP messages to communicate with TCP/IP hosts, and what are some common types of ICMP messages that routers send to hosts?",
        "84b1a581-713a-437b-a8c6-b6586af155dc": "This question will test students' knowledge of ICMP messages, including Router Discovery, Redirect, Echo, and Echo Reply messages, as well as ICMP error messages such as Parameter Problem, Destination Unreachable, and TTL Exceeded. The question also asks about the role of ICMP messages in communicating with TCP/IP hosts, which will help students understand the importance of ICMP in network communication.",
        "71d09897-dada-4f79-a723-0ae9519ef5f6": "Explain how ICMP Destination Unreachable messages can be used to discover the MTU available to a destination. In your answer, include the role of the subtype Fragmentation Needed and DF Set.",
        "467e7bac-331b-4f45-a219-60f75f8c8958": "Describe the function of queuing algorithms, such as Weighted Fair Queuing (WFQ) and Class Based Queuing (CBQ), in TCP/IP routers. Additionally, explain the concept of RSVP and its potential role in dynamically signaling queuing preferences for specific applications.",
        "7f8da190-2cac-43ca-940b-4b68bdca7373": "Explain the concept of a firewall router in the context of the Internet and give an example of a situation where its use would be particularly beneficial.",
        "759fed7c-f0f6-4f79-927d-7f32a1067875": "Describe the role of the Remote Monitoring MIB (RMON) in routers and how it can be used to turn a router into a network analyzer. Additionally, explain how this compares to a dedicated network analyzer such as a Network General Sniffer.",
        "5c8e37ab-4dc0-46a3-a26f-1cc14f1fbcc5": "Explain the traditional method of using default gateways for forwarding IP datagrams and the problem of extra router hops. How does ICMP help in removing these extra hops?",
        "0e4e88a1-b0a0-43fb-9130-c21766b0870d": "What is the concept of a \"virtual IP address\" and how does it relate to the Virtual Router Redundancy Protocol being developed within the Internet Engineering Task Force (IETF)? Explain how this concept can improve the reliability of router systems.",
        "d593501e-a7b6-4438-9e1c-6e1a017dd0ce": "Explain the concept of a virtual IP address and its use as a next hop for a segment's hosts. Also, describe how the responsibility for the virtual IP address is dynamically allocated to one of the segment's routers.",
        "9b734235-4522-4dee-a405-7c8a511d829e": "Define IP addresses and their representation in dotted decimal notation. List the special-purpose addresses and their functions, and explain how a router can determine the type of an IP address by looking at its address.",
        "e7aa5566-87ae-47cd-9f21-5579b59faa8e": "Explain the concept of address prefixes in the context of TCP/IP routing. How does prefix aggregation help in conserving IP address space and managing routing table growth in the Internet?",
        "962c9508-b04d-42c4-a652-5f61989de254": "Describe the hierarchy of Internet Registries responsible for assigning globally unique Internet TCP/IP address space. Explain the role of Internet Assigned Number Authority (IANA) and how regional Internet Registries like InterNIC, RIPE NCC, and APNIC allocate address blocks to ISPs and their customers.",
        "5327de1f-374c-42ec-bad0-3b5e6a13b286": "Explain the concept of provider addressing in the context of routers in the Internet and discuss the challenges a customer may face when changing ISPs.",
        "b8b07c7c-3618-42c9-979d-e31c006c4b8e": "Look up the reserved purpose of the IP unicast address range 172.16/12 and explain its significance. Additionally, provide an example of a specific address that falls within this range and its intended use.",
        "5a90084e-ae33-4af5-8782-a71db64c6219": "Question: In the context of Internet addressing, why was the loopback address 127.0.0.1 reserved for use by a BSD system to send IP packets to itself, and how does this relate to the allocation of the entire prefix 127/8?",
        "a47c5bd4-c422-474a-be4b-6374c1496a74": "OR (for a more conceptual question)",
        "aacc5d2a-9c2d-4bd1-b368-929645e5a75e": "Question: Explain the historical class division of IP address space and how it led to the development of subnetting in the Internet addressing scheme.",
        "df27b136-5e06-439c-a6c1-e02c264a1d68": "(Note: The first question focuses on a specific detail of the addressing system, while the second question asks for a broader understanding of the historical context and its implications for the current system.)",
        "a5609f3d-c8e2-4c11-8049-336004736c03": "Explain the concept of subnetting and how it increased the number of segments that could be addressed within a single Class B network. In your answer, include the use of a subnet mask and the definition of directed-broadcast and all-subnets-broadcast addresses.",
        "c641236f-c3b0-48fb-add1-23d5714572a2": "Describe the limitations of fixed-size subnets and how variable-length subnet masks (VLSMs) were developed to address this issue. In your answer, explain how VLSMs allowed for subnets of varying sizes and the benefits of this approach. Additionally, discuss the concept of discontiguous subnet masks and its relationship with VLSMs.",
        "bbec2f1f-5f0b-4549-9669-24d71e27d865": "Explain why discontiguous subnet masks were discouraged by RFC 922 and how the introduction of VLSMs made them virtually unsupported. Also, mention the current status of discontiguous subnet masks as per the latest router-requirements RFC.",
        "07876773-1050-4bb2-af66-99a87aa76d2f": "Describe the concept of tunneling in the context of IP datagram forwarding. Explain why tunneling is necessary for the Internet's Multicast Backbone (MBONE) and how it helps in delivering packets to the intended destination.",
        "289a0d1e-a4f2-41ae-8552-30baa9d998f6": "Explain the purpose and mechanisms of tunnels in the context of Internet routers. What are the drawbacks of using tunnels and how can they impact network performance and security?",
        "7a33b7f9-d57c-4543-9801-e4e4c260eb00": "Compare and contrast IPv4 and IPv6, focusing on their differences and similarities in terms of routing and addressing architecture. Why do you think IPv6 has not been widely deployed despite the initial fear of IPv4 address space exhaustion?",
        "8594b166-a101-4278-8e8f-cedd2adb7eb2": "Explain the concept of \"address scoping\" in IPv6 and how it differs from IPv4's global-uniqueness requirement. Why was this feature added to IPv6 and what types of address scopes are supported?",
        "96c39784-2171-4278-a389-a6e65a947410": "Compare and contrast the IPv4 and IPv6 packet headers. What are the major differences and similarities between the two headers? Explain the purpose of the \"Flow Label\" field in the IPv6 header and how it differs from IPv4's \"TTL\" field.",
        "90af3d01-f8bb-4f6b-81c0-2f6da7c7b110": "Explain the role of the Time to Live (TTL) field in IPv4 and why it was not included in IPv6. Furthermore, discuss the current status of the Flow Label field in IPv6 and its intended function.",
        "a4bab7a9-30af-4de3-a148-020e949a803f": "Compare and contrast the data-link encapsulations used by IPv4 and IPv6. Include in your answer why new data-link encapsulations were defined for IPv6 and how it is assigned for Ethernet type, as opposed to IPv4. Additionally, mention the impact of these differences on packet-forwarding process in both versions.",
        "5849f636-9e3c-4a6d-a755-48f0ed0291ea": "How does IPv6 address the issue of packet fragmentation compared to IPv4, and what is the role of the Next Header field in IPv6 headers?",
        "3c257651-8907-45f2-98eb-75ce12e4e6f5": "In the context of IPv6, how does the Neighbor Discovery protocol differ from its IPv4 counterparts such as ARP and ICMP router discovery, and what additional functions does it provide?",
        "e23a8cab-4d84-492c-a2bc-2f58416f3329": "Based on the context information, explain the concept of Autonomous Systems and Interior and Exterior Gateway Protocols (IGPs and BGPs) in the Internet's routing architecture. What is the main difference between IGPs and BGPs?",
        "f9b8303a-f06b-442e-b3f1-43de33630f81": "Considering the routing tables and convergence time discussed in the context, why is a short convergence time preferred in routing protocols? How does the size and complexity of the network affect convergence time? Provide an example to illustrate your answer.",
        "68b721a1-8084-4a2f-9858-dbe7e1c213bf": "Explain the concept of a routing table in the context of Internet routing protocols, and describe how a router uses a routing table to forward packets. In your answer, be sure to include the terms \"address prefix,\" \"next hop,\" and \"matching.\"",
        "11e16c78-7926-4204-8dc2-dfda4dfa330e": "Describe a scenario in which a destination address matches multiple entries in a routing table. How does the router determine the best match in this situation? Additionally, explain why this scenario might occur in the context of an organization changing Internet Service Providers.",
        "7ebec2a5-304a-403e-9d5d-5d003d6a49e5": "Explain the concept of a default route in a routing table and describe a scenario where it would be particularly useful.",
        "261ee342-d078-4155-ae6b-6eef6eb292ae": "Compare and contrast the routing table of an edge router and a core router in the Internet, including the number of entries they typically have and the use of a default route. Additionally, explain how the contents of a router's routing table can be viewed.",
        "56c13886-fe01-443d-9097-e24fe6f917b0": "Explain the concept of static and dynamic routing, and why static routing may still be used today in the Internet despite its limitations. Provide an example of a situation where static routing would be preferred over dynamic routing.",
        "5ac6aded-20d7-49eb-8198-c70cecc3aebf": "Describe the implementation of routing tables using Patricia trees. How does this data structure minimize bit comparisons and improve forwarding performance in routers? What is the average number of bit comparisons required for a lookup in a routing table containing 45,000 entries? Discuss the potential limitations of using Patricia trees in routing table lookups.",
        "0ae9be3e-f348-46ac-b93d-65f422b4b4c0": "Explain how a front-end cache can be used in the Patricia-tree implementation of routing table lookup. What are the advantages and disadvantages of using such a cache in the Internet's core versus at the edge of the Internet or within organizations?",
        "d827b355-f4e1-4756-8307-9b7ed16fde34": "Consider the example of a front-end cache organized as a hash table, where the hash function is the sum of the third and fourth bytes of the IP destination. Describe the process of looking up a destination in this cache and discuss the potential impact of a failed hash lookup on the overall performance of the routing table lookup.",
        "19d5f404-fadf-4516-9e2f-2140708535a6": "Explain the concept of Autonomous Systems (ASs) in the context of the Internet's organization. What is the role of individual ASs in the hierarchy and how does it affect the routing tables within them?",
        "82b51aac-e38f-469a-9fce-b8f004acd236": "Discuss the challenges of routing table lookup algorithms and the reasons why new algorithms are still being developed. What are some of the factors that contribute to the frequent invalidation of caches in core routers?",
        "9db5e1b3-7c15-4ae6-8908-369604bf80a8": "Explain the concept of CIDR and its significance in the assignment of Internet prefixes. In your answer, include the difference between providers with their own CIDR blocks and smaller providers that must use addresses from their upstream provider's CIDR blocks. Provide examples of organizations that have their own Class A addresses.",
        "a3ccc0e1-0b4d-4852-96b3-3dd512d5484f": "Describe the evolution of the Internet's core and its changing identity over the years. Discuss the role of the ARPANET, the NSFNET, and the current composition of the Internet's core, including providers such as UUNET, MCI, and Sprint.",
        "90bd31d0-b1c1-4291-bdea-7a24118c1480": "Explain the role of Network Access Points (NAPs), Metropolitan Area Ethernets (MAEs), or Commercial Internet Exchanges (CIXs) and the importance of peering between Internet Service Providers (ISPs) at these exchange points.",
        "18081dc4-1251-4477-88c8-a258a7b84aa1": "Compare and contrast the features and uses of Interior Gateway Protocols (IGPs) and Exterior Gateway Protocols (EGPs) in the context of routing in large networks, and explain why the EGP/IGP split is not just a historical accident.",
        "83a09872-92b0-47b6-9cad-852ec29edef1": "Question (Short Answer): Explain the main advantage of Distance Vector algorithms in routing protocols.",
        "278dad65-eb3b-4a2a-9870-acdc0fa3c956": "Question (Problem Solving): Using the example in Table 2.2 and Figure 2.5, describe the sequence of events that occurs in RIP routers A, B, and C as they receive and process routing updates for the 192.1.4/24 prefix. Include the changes in routing table entries, metrics, and next hops for each router.",
        "4a441ca5-71b9-4f9e-a853-78b4079832f7": "Based on the information provided, explain how Distance Vector protocols get their name and what algorithm they are based on. In your explanation, include what a Distance Vector algorithm is used for in the context of routing updates.",
        "e6365fd3-a12d-463e-b12f-6face42dce8a": "Using the sample network topology in Figure 2.5, describe what happens to the routing table of router ABC during the convergence process when subnet 192.1.4/24 is added to the network. Be sure to include the time intervals and the changes in the routing table in your description.",
        "b5e369fa-7959-4a75-8bcc-1d7ee6f8e984": "Explain the concept of \"Counting to Infinity\" in the context of Distance Vector protocols, as described in the table 2.3. What are the reasons for this slow convergence, and how does it lead to the formation of forwarding loops?",
        "5cb371ed-67e1-4c8b-bfc2-0f01db0cf239": "In the given context, it is mentioned that \"A Distance Vector protocol's distributed calculation is quite robust, converging after network changes even if the updates from the various routers are not synchronized.\" Can you explain how this robustness is achieved, and what problems can arise from synchronization of updates in Distance Vector protocols?",
        "a522c089-10ec-484d-9182-7d51e027123e": "Explain the concept of \"counting to infinity\" in Distance Vector protocols, such as RIP, and describe how setting a maximum path cost can help mitigate this issue.",
        "2ba018cb-e357-42c9-8a6d-8b380df8801c": "Describe the split horizon and hold down modifications that are used to improve the convergence of Distance Vector protocols. In what situations is hold down more beneficial, and why is it not commonly employed by protocols like RIP?",
        "fc84b904-d8c2-42dc-9101-83c24fc57939": "Compare and contrast the incremental, distributed calculation approach used in Distance Vector algorithms with the replicated distributed database approach used in Link-State algorithms. In your answer, include a description of the information advertised by routers in each type of algorithm and how this impacts the convergence properties of the algorithms.",
        "cde32a8f-e856-43c8-a89a-8e51a6f9cd63": "Explain how the Internet's BGP and EIGRP solve the problems of routing loops and counting-to-infinity behavior in Distance Vector protocols. Compare and contrast the methods used by these two protocols and discuss any trade-offs between loop-free routing and protocol complexity.",
        "3b120e89-f0e1-4dbe-b45f-8f90bc21c39b": "\"Can you explain the difference in complexity between specifying Link-state routing protocols and Distance Vector protocols, and why writing good OSPF and BGP implementations are considered roughly equivalent tasks?\"",
        "17b1de02-ef80-4feb-8aa3-fd8c77671932": "\"How does the EGP/IGP split in the Internet allow for the best features of both routing protocol technologies, and how does OSPF use Distance Vector mechanisms in its two-level hierarchy?\"",
        "5f97f7cf-29b7-4ea4-9734-f46d71d7f7b0": "Question for Chapter 3, Developing the OSPF Protocol:",
        "46aa4ffa-8133-4c7e-a3cf-283a0ea67a92": "Explain the original requirements and design decisions that led to the development of the OSPF protocol. Discuss how OSPF has evolved over time, first due to interoperability testing and Internet deployments, and then in response to the evolution of the Internet. Provide specific examples of these changes and your understanding of their impact on the protocol.",
        "dc7c9424-1c49-42b6-aa66-96fc0ae94c61": "Question for Chapter 5, OSPF Network Types:",
        "8947b9ef-ac5d-43fd-af6a-fbcfd668623c": "Compare and contrast the two modes of OSPF operation over nonbroadcast subnets: Point-to-MultiPoint and NBMA. Describe the process of neighbor discovery and database synchronization in both modes. Additionally, explain how these segments are represented within the link-state database and provide a real-world scenario where one mode might be preferred over the other.",
        "91201d36-0815-434a-b1e6-b39c5757eb19": "Explain the concept of areas in OSPF protocol and the rules governing area organization, including the use of virtual links. Provide an example of a scenario where virtual links must be deployed.",
        "3b8d5854-b938-4913-b897-c2d1ad140745": "Describe the two area types, stub areas and NSSAs, that can be used to control the spread of external routing information in OSPF. Explain how these area types interact with external routes and how they can be beneficial in managing the routing information learned from other protocols.",
        "6b79e391-49d0-4b6c-88ae-ed13449f88d4": "Based on the context information, what was the primary motivation for the development of the OSPF routing protocol, and in what ways has the protocol evolved since its inception in 1987?",
        "7a54ffff-c14c-48d6-aecd-4d88a4878f09": "Why were TOS-based routing features included in the original OSPF design, and what factors may have contributed to their never being deployed? Additionally, explain what a Point-to-MultiPoint interface is and how it relates to the current features of OSPF.",
        "c8546bf2-194f-48e9-9a4c-d69be8f8bb54": "Based on the context information, why was there a need to develop a new routing protocol like OSPF to replace RIP, and what were the specific issues with RIP that needed to be addressed?",
        "2b411aaf-d6e5-4691-904c-93c62d64fef6": "The document mentions that the Routing Information Protocol (RIP) and the Exterior Gateway Protocol (EGP) were both having problems as the size of Autonomous Systems and the Internet routing tables increased. Can you explain how the limitations of EGP, such as its requirement for a tree topology, contributed to its becoming unmanageable?",
        "1bf1975e-fd0f-48ce-868c-54b4842cf37e": "Explain the concept of an Interior Gateway Protocol (IGP) and its significance in the context of the OSPF protocol. How does OSPF address the limitations of RIP's routing metric?",
        "4bf5b785-7114-453c-8ac8-202e7192baec": "What is the concept of Equal-cost multipath in the OSPF protocol? Why is it not necessary to standardize the choice of which path to use for a given packet when multiple best paths exist?",
        "3194f4f3-8759-42ca-99bc-71c858a212df": "Explain the concept of routing hierarchy in OSPF and how it is implemented through a two-level area routing scheme. Why is hierarchy important in building large routing domains?",
        "62a17930-ee3a-40bf-b181-29a018c54932": "Discuss the requirement of supporting more flexible subnetting schemes in OSPF. How does this anticipate classless Internet routing (CIDR) and what adjustments were needed to accommodate CIDR completely?",
        "582fd7eb-e189-4d37-81b1-e1a4dc811449": "Why was the implementation of TOS-based routing never deployed in the Internet, despite being supported by OSPF from the beginning? Explain the possible reasons for the lack of real need for TOS and the chicken-and-egg problem associated with it.",
        "ae9e5571-7aa8-4efd-99a4-12055ef7bee9": "In the context of OSPF design decisions, explain the difference between link-state and Distance Vector technologies. What was the most controversial design decision made during the initial development of OSPF, and why was it considered controversial?",
        "a30f8ce3-4ea8-4854-b4b2-dcb4cb2742ee": "Explain the difference between Distance Vector and Link-state protocols, focusing on their algorithm calculation and database models. Provide an example of a protocol that uses each type.",
        "bf1882e1-63eb-4fa1-b08a-99b3f417f59f": "Discuss the issues faced by the RIP protocol in larger Autonomous Systems, such as slow convergence and high bandwidth consumption. How did BBN's experience with the ARPANET routing algorithm influence the development of a link-state routing protocol for TCP/IP?",
        "d2a8311c-c580-4fd3-9866-c00d5129f522": "Based on the context, explain the difference between link-state and distance vector routing algorithms. What were the major link-state routing protocols developed for different major protocol suites?",
        "4aa0b005-06a6-4415-9bd7-e6d787b2440f": "Analyze the issues with the ARPANET link-state protocol and the proposed corrective measures in the 1983 paper by Perlman. How did the ARPANET environment differ from the current TCP/IP routing protocol environment?",
        "05088305-0d54-4fbb-ae1d-d1a7c3f7c7aa": "Based on the context information, explain the reasons why the IS-IS routing protocol was not adopted as a TCP/IP routing protocol despite its efficient mechanism for running link-state protocols over broadcast links. What technical issues were encountered and why was it considered simpler to design a new protocol?",
        "f31b8c5a-ef55-43b8-91ad-db6c9c46be87": "When designing a TCP/IP routing protocol, there are three choices for encapsulation of the new protocol's packets. Explain why running the protocol directly over the link layer is problematic and what services are typically provided by the link layer.",
        "c214fcec-337f-4933-9742-630bb2c09155": "Why did the designers of OSPF choose to run the protocol directly over IP instead of using UDP or TCP, and what were the advantages and disadvantages of this decision?",
        "2314f425-a627-48a2-b48e-2b01903dcd25": "What was the solution to the problem of all hosts on a broadcast subnet, such as an Ethernet LAN, receiving routing protocol packets even if they were not running the routing protocol or the TCP/IP stack? How did OSPF implement this solution, and what were the challenges in doing so?",
        "4922438f-4610-4e88-8b0a-49b55d489914": "Why did the developers of OSPF opt to keep LSAs as small as possible, advertising each separable piece of routing data in a distinct LSA, even though they could have made LSAs up to 65,000 bytes long by using IP fragmentation?",
        "3cba72fa-aeca-4aa6-a63e-516d6e4ca919": "How did the designers of OSPF ensure that the protocol would work over all of the Internet's link technologies and minimize any link-specific functionality, despite the wide variety of properties and capabilities of these technologies? Provide examples to support your answer.",
        "0fb86b40-5393-4902-8d4f-f29c32813677": "Explain the concept of the Designated Router in OSPF and its role in flooding LSAs over broadcast and NBMA subnets. Why is the Designated Router election designed to ensure that a switch of Designated Router only happens on failures?",
        "b9e99113-2360-40c2-a822-6604e548f14a": "Compare and contrast the modeling of a collection of routers attached to a broadcast LAN in the point-to-point flooding algorithm and the added level of indirection using a star network of point-to-point connections. What are the advantages of using the latter approach in minimizing flooding traffic on the LAN?",
        "6ecdb836-95d0-4375-9088-44c55847c8a3": "Explain the concept of a Backup Designated Router in OSPF and its role in ensuring a quick switchover during failures. Why is this feature important in a large-scale network?",
        "8176a837-a0fb-412a-bdd0-ed0dedaf0785": "Describe the use of the External Route Tag in OSPF and its original purpose when the protocol was designed. Discuss how this feature has been used in practice to convey policy information between routers on the boundary of an OSPF domain and its potential to replace IBGP in certain scenarios.",
        "089523dc-4de5-4afa-b369-82b59c5de113": "Why did the designers of OSPF choose routers, instead of network segments, as the boundaries between areas in an OSPF routing domain? What advantages does this decision provide in terms of address aggregation and routing table size?",
        "d262e851-0335-4a91-82b1-8d04769bab43": "Explain the concept of abstraction in the context of OSPF areas, and describe how it is achieved in OSPF through the summarization of addresses. How does this approach differ from the use of an analog of the OSPF network-LSA, and what are the advantages and disadvantages of each method?",
        "123af272-78ef-44aa-9a03-37d7c8dcc809": "Why was the implementation of OSPFv1 necessary even after its specification was published, and what problems were discovered during its implementation in Proteon's routers and UNIX workstations?",
        "2c986d7c-b61b-4b7b-b9f9-17cdd377c26e": "Explain how the LSA sequence space was organized in the original ARPANET link-state routing protocol and how it led to a flaw that could cause a network to \"melt down.\" Also, describe how OSPFv1 corrected this issue and what modifications were needed to completely patch the vulnerability.",
        "60ea8683-651c-492e-ba20-5e398247853e": "Why was it necessary to increment the OSPF version number from OSPFv1 to OSPFv2, and how did this help in addressing the interoperability issues between the two versions?",
        "8da323da-3021-4ea5-a495-1877dbbc2c86": "Explain the importance of interoperability testing in the development of a routing protocol. How does this type of testing help uncover potential issues and ensure a clear and unambiguous protocol specification? Provide an example from the context information to support your answer.",
        "e87d8d58-8cbd-4f8f-9418-6ee57a474cd1": "Why were \"bake-offs\" or interoperability sessions essential during the initial development of the OSPF protocol? Briefly describe the role they played in identifying bugs and improving the protocol.",
        "b1fd5c04-18b4-4a13-9f75-c2d7cd60c248": "What tools were used to monitor OSPF protocol performance during the testing and development process? Explain the purpose of these tools and how they contributed to the overall understanding of OSPF's functionality.",
        "9da4a5d4-9f2a-4d2f-a8b2-20f96f2f25ef": "Why did the authors modify the analyzers' software to decode OSPF packets and filter out non-OSPF packets during the 3Com testing session in February 1991?",
        "58921d72-03e8-4f0a-8b30-c6071c343cdc": "Answer options:",
        "bbdfcc95-3955-49b9-a837-8ecfc847df11": "A. To make analysis of the remaining OSPF packets easier",
        "2224c368-b2e1-4c10-aeb8-e0a32ad940f3": "B. To add new features to the analyzers",
        "ff45c228-9a63-4996-84bc-d193240d820b": "C. To compare the list of LSAs between routers",
        "3940060c-94ed-4b78-a8bc-558ffc392f93": "D. To determine whether the database was synchronized",
        "5ec200ed-e8ba-448e-b87f-7e17d0e8467d": "How did the authors determine if the OSPF databases were synchronized between routers during the interoperability testing?",
        "9691a64d-9025-455a-adbc-7f0ab4f3c812": "Answer options:",
        "f9271e34-833b-4ae1-a813-acae1fce0d92": "A. By having each router list its complete set of LSAs and then comparing the list",
        "bbd60dca-7fb7-4ffa-bb55-013ecfc18985": "B. By having each router print how many LSAs were in its database",
        "5a4d8bf1-eb4c-4fa2-9d45-50110004d0ab": "C. By checking if each router had the same number of LSAs",
        "c4f64928-eb18-4eec-afbc-cb5880ed94e2": "D. By comparing the up-to-dateness of particular LSAs between routers.",
        "48ba0c3b-842f-4c9d-a8a1-d2c7bb34c7ec": "Why were database checksums and other statistics added to the OSPF Management Information Base? What role did SNMP play in this process?",
        "8bbfe068-4c89-42a0-8c13-d4356fbf62fd": "Reference(s):",
        "b1ae8714-c77f-46b0-837e-deba13c4c41e": "- \"The database checksum and other statistics that we found useful during testing were eventually added to the OSPF Management Information Base (see Section 11.2), so that the information could be extracted via SNMP.\"",
        "40b20b13-203c-486b-a433-628695078815": "How did the incomplete specification of the default route in OSPF cause interoperability issues? What was the disagreement between different implementations, and how was it resolved?",
        "9646665c-2346-4f54-8aec-25db00c3a58e": "Reference(s):",
        "cdb90d17-c6f5-4d15-86d0-169905a5f824": "- \"The most common problem was incomplete specification, usually in the OSPF packet and LSA formats. For example, in the first round of testing, there was a disagreement on how to represent the default route in OSPF.\"",
        "bbd379f6-ad28-4b53-92ea-4801e8d45b03": "- \"During testing, one implementation originated a route with network equal to 0.0.0.0 and a nonzero mask. Some implementations interpreted this as a default route, but others did not, because they were expecting a mask of 0.0.0.0.\"",
        "763c1419-4a9d-4fbe-aca7-694f274a586d": "Question: Based on the context information, why was the selection of network configurations for OSPF testing described as \"fairly random\"? What was the result of the fifth round of testing that led to a significant change in the OSPF specification in March 1994?",
        "77e2b8d7-dda5-4259-ba1b-9897aeef9226": "Answer: The selection of network configurations for OSPF testing was described as \"fairly random\" because several people were drawing on the whiteboard at once, which sometimes yielded situations not anticipated when OSPF was designed. In the fifth round of testing, a virtual-link configuration was constructed that caused the OSPF routing calculation to fail, leading to a significant change in the OSPF specification in March 1994.",
        "4bb5940a-bd54-4bda-baf5-7f68432dab68": "Question: According to the context information, what was the purpose of the INTEROP 91 OSPF demonstration, and how was it carried out? What was the role of the HP Openview Network Management Station and the Excelan LANalyzer network analyzer in the demonstration?",
        "9d32e722-e508-46f5-8234-662f8fb02676": "Answer: The purpose of the INTEROP 91 OSPF demonstration was to showcase the interoperability of OSPF routers in a production environment, specifically INTEROP's ShowNet. The demonstration involved using OSPF to provide TCP/IP connectivity between the trade show booths and the Internet, with Ethernet and/or Token Ring drops to each booth, FDDI rings connecting the Ethernet and Token Ring segments, and a router running BGP connected to the Internet. The HP Openview Network Management Station was modified to display the OSPF routers' database checksums, while the Excelan LANalyzer network analyzer was modified to show the level of OSPF protocol traffic, separated by OSPF packet type.",
        "3bcacfed-2d25-4b04-9f21-a17747399e7d": "Based on the given context, why did the author convert Proteon's network from RIP to OSPF, and what challenges were encountered during the conversion process?",
        "24d58e0b-8c60-4832-b79d-02d9d42b55c5": "In the context, the Proteon network eventually ran OSPF extensions such as MOSPF and OSPF database-overflow mechanisms. Can you explain the reasons for implementing these extensions and their potential benefits for the network?",
        "d34665a1-5162-4246-8dd0-37c75e620027": "Why was the conversion of the SURANet network from RIP to OSPF abandoned in 1990, even though the NSF regional networks were the primary drivers for the design of the OSPF protocol? What challenges were encountered during the attempted incremental conversion, and why would the same conversion be easier today?",
        "d9b47ac3-1a95-49c1-b4a3-5fc22efc81b4": "How did the deployment of OSPF in the Internet lead to a number of protocol modifications? Specifically, can you explain the issue of extra hops being produced at the boundary between the OSPF routing domain and another Autonomous System, and how this concern was addressed?",
        "2b5e7321-89f8-4e4c-9b33-b9bbfd04e06a": "Explain the concept of a \"forwarding address\" in the context of OSPF routing protocol and how it eliminates the extra hop in routing traffic to a different autonomous system.",
        "2497a541-e895-4469-bb4c-505bbd0c754b": "What are OSPF stub areas and why were they invented? Describe their role in minimizing the number of routing protocols and reducing the routing tables of routers at the edge of an Autonomous System.",
        "60e0b45c-b038-4a41-afe1-ede5fced9c8d": "Explain the original requirement for address aggregation in OSPF and describe how it was amended to accommodate changes in address assignments across different areas.",
        "6907791f-75f6-47b6-9045-d461759d587d": "Discuss the challenges faced when implementing OSPF on slow links and over data-link technologies with ill-defined IP MTU. How did OSPF modify its mechanism to address these issues?",
        "bbe78248-cdbf-4fb2-a6d8-46088de5e180": "Explain the debate between OSPF and Integrated IS-IS as candidates for the common IGP in the Internet, focusing on the role of the tension between the TCP/IP and OSI protocol suites.",
        "eb2b887a-5144-4941-be1d-0a815acc7f57": "Discuss the integrated routing debate in the context of the choice for the Internet's common IGP, and how it relates to the deployment of multiple protocols such as IPv6 in the existing Internet. Additionally, explain the significance of the IETF's motto \"rough consensus and running code\" in this decision-making process.",
        "0003e7b1-28f2-4a96-81cb-5058a04eef16": "Explain how the growth of the Internet in 1993 led to the development of Classless Inter-Domain Routing (CIDR) and how it affected the advertising of prefixes by routing protocols. How did OSPF adapt to CIDR and what problem became apparent with the import of external routes in AS-external-LSAs?",
        "e4484e67-c14b-47f7-9cc4-d316e8d68e5d": "Describe the original model for an OSPF non-broadcast multiaccess network (NBMA) and the assumption it made about communication between routers. How does this assumption hold true for X.25 PDNs using SVCs? What types of links does OSPF run over, as mentioned in the context?",
        "4e2dbc8d-1de2-4b09-ad04-eb5ac6abf069": "Explain the concept of multicast and its significance in the context of the Internet. Discuss the evolution of multicast routing protocols, focusing on the Distance Vector Multicast Routing Protocol (DVMRP) and its limitations. How did the Multicast Backbone (MBONE) contribute to the development and deployment of multicast applications?",
        "453916e5-29a2-462b-b8d5-4c324f8210db": "Analyze the challenges faced when implementing OSPF over Frame Relay networks using NBMAs. Discuss the alternative approach of using Point-to-MultiPoint subnets and its advantages, such as autoconfiguration and robustness against PVC failures. Additionally, comment on the configuration difficulties associated with NBMAs and how they influenced the development of Point-to-MultiPoint subnets.",
        "0c243e42-dbf2-4ec5-99c8-40a027ca0290": "Explain the concept of security mechanisms in the OSPF protocol as mentioned in the context. Why was there a need for cryptographic hash algorithms in OSPF?",
        "aca889cb-bcb9-468c-83c5-da428d2a59de": "What was the primary motivation behind the development of IPv6, and how does it differ from IPv4 in terms of addressing and routing architecture? Also, explain how OSPF was updated to provide routing services for IPv6.",
        "3e2c20e7-2fef-4332-9cb8-bbf1ed2d9049": "What was the motivation behind the development of the first link-state algorithm in the ARPANET, and how did it address the limitations of the previous Distance Vector algorithm?",
        "ede3cc89-217c-4c69-a4c9-55e806164660": "Identify and explain the general category of routing protocols to which OSPF belongs, and name two other link-state routing protocols implemented for different protocol stacks.",
        "8c5d2c31-b174-472a-baa8-2666d587538d": "Explain the role and significance of Link-State Advertisements (LSAs) in the context of OSPF, and describe how they are used in the process of reliable flooding to create the link-state database.",
        "9c085fb9-0cec-4db8-af81-094082ed5f25": "Consider the point-to-point network topology illustrated in Figure 4.1. Describe the basic steps that a router would follow in this topology to calculate its IP routing table using the OSPF protocol and the link-state database.",
        "d8a38706-7c9b-4aa2-92cf-ddd90953d03b": "Explain the process of link-state database update and flooding in OSPF when a link failure occurs, using the example of the link between routers 10.1.1.2 and 10.1.1.4.",
        "3235fbfa-1e51-4dba-9030-88aaa4d7c02c": "Describe the role and significance of the OSPF Router ID in the OSPF routing domain, and explain how it is typically assigned in practice.",
        "99027409-b4ff-45f8-83a6-81c0d51d8e5a": "What is the purpose of the LS Type field in the OSPF LSA header and what are the five LS Types defined by the base OSPF specification?",
        "8fd4e7d3-2c42-45e6-b51b-6f03fe3b7f92": "How do router-LSAs contribute to the link-state database in an OSPF routing domain and in what type of network topology do they consist solely of router-LSAs?",
        "3e3718f5-b706-4b8b-899a-7fe9fc51bf81": "Explain the purpose and contents of Network-LSAs (LS Type equal to 2) in the OSPF protocol. What are the other LS Types used for in OSPF and what are their functions?",
        "4a625920-fbdf-4fd3-a425-2adbda505051": "Describe the role of the Link State ID and Advertising Router fields in OSPF LSAs. How do these fields help routers identify and use LSAs in the routing calculation?",
        "217a678f-42c0-424b-bde7-901d283f4e08": "Explain the role of the LS Sequence Number field in OSPF LSAs and how it is used to determine the most recent instance of an LSA.",
        "c152e2e3-0ac8-4ef1-9c90-7efae4190bea": "Compare and contrast the circular sequence number space organization used in the original ARPANET link-state algorithm with the sequence number space organization used in OSPF LSAs. Include in your answer a discussion of how the rate of new LSA instance generation is controlled in the original ARPANET algorithm.",
        "b323f89a-ee99-46c1-8103-2ebcb62dd059": "Explain the concept of the \"ARPANET sequence bug\" and the lollipop-shaped sequence number space that was proposed to address it. What limitations of the lollipop-shaped sequence space led to the adoption of a linear sequence space in OSPFv2?",
        "5555b633-42e5-43b7-b8e0-eda0acd253fc": "Describe the mechanism used by OSPFv2 to prevent the ARPANET sequence bug. How do checksums and the LS Age field contribute to OSPF's resilience against problems similar to the ARPANET sequence bug?",
        "58605ff6-fe14-4aa0-be9a-da81e3432fdb": "Explain the purpose of the LS Checksum field in OSPF LSAs and how it is used to detect data corruption. In your answer, describe the process of verifying the checksum of an LSA during flooding and in the link-state database.",
        "dd50eb3b-93da-44f8-b097-969141cefa8e": "Discuss the use of the Fletcher checksum algorithm in OSPF LSAs and its role in detecting patterns of data corruption. Additionally, explain how the LSA checksum is used to determine if two instances of the same LSA have the same contents, and the probabilistic nature of this comparison.",
        "8a055518-1395-4b55-ac59-fc3345f01e43": "Explain the process of removing Link State Advertisements (LSAs) from the distributed database in OSPF, including the role of the LS Age field and the concept of MaxAge. How does this process ensure that outdated information does not interfere with routing table calculations?",
        "01ee4530-cbd0-41dd-bf05-d21ed95bddeb": "Describe the procedure of premature aging in OSPF and its purpose. What measures are taken to prevent possible thrashing situations, and how are LSAs handled if a router crashes or is removed from service without prematurely aging its self-originated LSAs? Additionally, briefly discuss another function in OSPF where the LS Age field is utilized.",
        "c387499c-0624-4430-a987-40fcc1c140e6": "Explain the purpose of the \"Options\" field in the OSPF LSA header and describe the actions taken by an OSPF router when the LS Age field values fall into certain ranges, as presented in Table 4.1.",
        "81f98ffb-67d1-409f-86d9-3f604767689e": "Analyze the \"Length\" field in the OSPF LSA header and discuss its significance. Furthermore, calculate the maximum size of an OSPF LSA considering the IP packet size restriction, and provide examples of LSA types that are likely to have larger sizes compared to others.",
        "cc990f80-00c9-4741-a664-33d5794acfe5": "Based on the information provided in Section 4.3, what is the purpose of the Router-LSA in an OSPF network and which fields are set in its standard LSA header? Explain the significance of the Link State ID and LS sequence number in this context.",
        "d9ecd4a3-e099-4f38-9201-8228877a4ee9": "In Figure 4.4, examine the role of interface IFIndexes and OSPF output costs in the network topology. How do these values impact the operation of OSPF and the formation of the router-LSA? Provide a brief explanation of the relationship between the interfaces and the router-LSA.",
        "3f689149-2bed-4c46-9754-15c401b20fdb": "Based on the context information, describe the type of connections indicated by the Link Type field in a router-LSA. Furthermore, explain how the Link ID is determined for these types of connections.",
        "a7e6d76e-4195-4e41-95ec-69613aac603d": "In the scenario described, if the Link Data field indicates an Iflndex value of 3 for a point-to-point connection, what can you infer about the corresponding router interface's MIB-II Iflndex? Also, explain how this information can be used to identify the neighboring router's OSPF Router ID.",
        "17fdb4b8-418e-4797-a225-c5b394061bdd": "Explain the concept of metrics in the context of OSPF and provide an example of a meaningful metric. Additionally, discuss why bandwidth may not be a suitable metric.",
        "28746ab1-0730-44bf-a193-7ef54e517e8f": "Describe the purpose and contents of a router-LSA in OSPF. Also, explain the concept of stub networks and how they are advertised in a router-LSA.",
        "d0a23101-5be2-4af6-873b-5ff9edeba8d3": "Explain the process of determining if two OSPF routers have synchronized link-state databases. What variables from the OSPF MIB are used in this process and how do they contribute to ensuring database synchronization?",
        "d1e6da97-74ff-4f89-8cb8-662b260ba0c2": "Based on the information provided in Table 4.2 and Figure 4.4, identify the routers with rapidly changing router-LSAs in the sample network. What could be the possible reason for these changes, and how can this information be useful in network monitoring and maintenance?",
        "1b51905a-d2fe-4858-a2c6-4cdf3a16d05c": "Explain the role of Time To Live (TTL) in the IP packet when used for OSPF communication. What is the usual value set for TTL and under what conditions can it be different?",
        "09b0a602-b715-4d0d-8b76-93c9fa5919c6": "Describe the use of IP multicast addresses in OSPF communication. What are the two multicast addresses used in OSPF and what is their purpose?",
        "dd537ec2-f371-43ec-b630-3df4e518e01a": "Explain the role of Link State Update packets, Link State Acknowledgment packets, and their significance in OSPF's link-state database synchronization. Additionally, describe the purpose of the OSPF Router ID and the packet checksum in this context.",
        "80da634e-a59a-4770-8aca-0badb80c0618": "Describe the process of neighbor discovery and maintenance in OSPF, including the use of Hello packets and the Hello protocol. Also, explain how the Hello protocol helps in detecting neighbor failures and its impact on OSPF protocol performance.",
        "b7662bb3-4d96-4570-9f78-3b64a6e1e8be": "Explain the role of the Hello protocol in OSPF and its significance in ensuring a bidirectional link between neighbors. How does the Hello protocol prevent routing failures caused by unidirectional links, as demonstrated in RIP?",
        "71b2ded8-f974-46ad-bcc5-b916f2f90757": "Discuss the concept of database synchronization in a link-state protocol like OSPF. Why is it crucial for correct and loop-free routing? Additionally, explain how reliable flooding is used as a mechanism for continual database resynchronization in OSPF.",
        "3e2adf7d-740a-487d-95a4-df564e6b6741": "Based on Chapter 4 of the \"OSPF Basics\" document, explain the role of the Designated Router (DR) and Backup Designated Router (BDR) in an OSPF network. What are the key differences between their functionalities and how are they elected?",
        "d1b2c6d4-eb3b-4906-856a-112d6f05c644": "Considering the information presented in the same chapter, describe the process of OSPF router initialization and its neighbor relationship establishment. Additionally, outline the significance of the exchange of database description packets in this context.",
        "f905939c-94e1-44f9-96c4-576216f11086": "What was the major drawback of the ARPANET's strategy for initial database synchronization, and how does the OSPF protocol address this issue?",
        "12d3219a-5256-4b18-bc14-580aa2ccaf7d": "(This question tests the student's understanding of the limitations of the ARPANET strategy and the improvements made in the OSPF protocol to overcome those limitations.)",
        "6dc99a10-bbc9-4e10-8673-e05a582a2871": "Explain the process of Database Exchange in OSPF, and describe how the transmission and reception of Database Description packets resemble the TFTP protocol.",
        "3d22fa07-90c5-4475-98e4-3033e87c88c6": "(This question evaluates the student's comprehension of the Database Exchange process and their ability to compare it with the TFTP protocol.)",
        "f4fde016-8813-4d68-ad58-adeb9bca1cb2": "Explain the process of Database Exchange procedure in OSPF, highlighting the role of Link State Request and Link State Update packets in this procedure. Also, describe the conditions under which a router declares a connection as synchronized and considers a neighbor as fully adjacent.",
        "e83c82e9-3b30-48e0-8a89-4380b8b786d6": "Discuss the features of the combination of the Hello protocol and Database Exchange in OSPF that make it easier to detect link-level difficulties, such as MTU mismatches between neighbors or unicast working but multicast not working. Provide examples of such difficulties and how they can be detected using OSPF's Hello protocol and Database Exchange.",
        "9fd23b96-148a-4550-89d2-8a2286c15c53": "What is the main topic of Section 4.7 in the document, and what are the typical challenges faced during database synchronization?",
        "112404a9-e243-436b-8339-869c0dd5589d": "Explain the process of database synchronization and discuss the significance of ensuring consistency and accuracy during the synchronization process.",
        "496b6b5f-20d7-494b-852b-b7e8e8db6744": "Explain the process of reliable flooding in OSPF and describe how a router ensures the delivery of Link State Updates to its neighbors. Include in your answer the role of Link State Acknowledgment packets and the concept of implicit acknowledgment.",
        "1cf46653-efd2-49c4-a8a9-805d5d89c986": "In the context of OSPF, describe what happens when a router updates one of its self-originated LSAs and why the LS Age field is set to MaxAge when a router wishes to delete one of its self-originated LSAs. Also, explain the steps taken by a router upon receiving a Link State Update packet from one of its neighbors.",
        "a0b54ae6-d747-476a-ae5b-fe2f12ba0337": "Based on the information provided in Section 4.7, explain the property of the OSPF protocol that allows for only one update or acknowledgment to be sent in a single link direction during flooding.",
        "4541b23f-42e6-4ef3-8c09-056b37514a29": "As mentioned in the context, flooding can become more complicated when different network segment types and optional extensions to the OSPF protocol are present. Provide an example of such a scenario and explain how it can impact the flooding process, as illustrated in Chapters 5 and 7.",
        "d919ecff-fae1-4f74-9ccc-244993b37be1": "Why does OSPF not restrict flooding to a spanning tree, and what are the benefits of flooding over all links in terms of robustness?",
        "fbf34e02-bb54-439c-b91a-f974a008e2d1": "How does OSPF detect and handle corruption of Link State Advertisements (LSAs) during flooding, and what measures does it take to prevent flooding loops caused by implementation errors? Additionally, explain how OSPF controls the amount of control traffic generated by rapidly changing network elements.",
        "5a3862f8-4fb7-43e8-b927-1c9cf719b07d": "Explain the concept of OSPF costs and how they are determined in the example given in the context. Why are small integers assigned to more preferred links? How do asymmetric costs affect the routing calculation in OSPF?",
        "da2f9bdf-5f75-4afd-8afd-26d30ce5f252": "Describe the role of Dijkstra's Shortest Path First (SPF) algorithm in OSPF. How does this algorithm help in calculating the shortest paths to all destinations in the link-state database? Additionally, explain how the algorithm works incrementally and how it begins with the calculating router.",
        "2ce66d93-40fd-4aaa-8427-60c03783c98d": "Based on the example given in Table 4.3, explain how Dijkstra's algorithm calculates the shortest path tree. In your explanation, include the concept of the candidate list and how it is modified during the iterations.",
        "a42be183-8ec2-4cac-9a07-a2b18ece9f43": "Analyze the performance of Dijkstra's algorithm as described in the context information. Explain the time complexity of the algorithm and justify it with the provided details. Also, discuss any assumptions made in the analysis.",
        "635f6dfe-64d9-438d-9512-5072b875d84f": "Based on the information provided, why is the performance of Dijkstra's algorithm O(rt2) for fully mesh-connected networks, and how does this differ from its performance in other types of networks?",
        "53c916f4-affc-4746-8f9f-137992c2c610": "Explain the process of extracting the IP routing table from the collection of shortest paths calculated by a router in OSPF. Additionally, why is only the first hop needed for each destination in IP's hop-by-hop routing paradigm?",
        "e85adbd3-7fce-49e6-bf9c-8ee3e505e225": "Question (Link-State Algorithms): Explain the concept of link-state routing algorithms and describe the issue caused by the ARPANET's circular sequence space. Propose a solution to prevent similar occurrences in the future, referencing relevant sources from the provided context.",
        "e08f576c-bbe9-48d2-afd9-d84838622c37": "OR",
        "4adb085d-5a44-4a29-95b9-a2d5abc5df60": "Question (LSAs in OSPF): Based on Table 4.2 in the text, calculate the size in bytes of each of the Link-State Advertisements (LSAs). Explain the purpose of LSAs in the context of Open Shortest Path First (OSPF) and how they contribute to the overall routing process. Cite the relevant section in the text as your source.",
        "0a933e59-c806-4d39-9ac9-ba91b1f8a65a": "Note: I am a helpful AI assistant, and I don't have access to the actual document or table you mentioned. Therefore, I can't provide the correct answers to these questions without the necessary information. However, these questions should help assess the students' understanding of the concepts presented in the context.",
        "6738471e-8fcd-4264-95ab-eabeb3bd1bb4": "How does the OSPF protocol discover and maintain neighbors on different subnet types, and how does this process differ from the way it runs over point-to-point links?",
        "9552bb42-b39d-46a4-8f8a-ba7a53023655": "In the context of OSPF, how is database synchronization accomplished over different subnet technologies, and how do special properties of the subnet affect reliable flooding and adjacent router selection?",
        "3af78b8c-9a38-4427-9fc0-b707dfcdff56": "Based on the IP Subnet Model described in the context, explain why two hosts on different IP subnets cannot communicate directly with each other, and how the role of IP routers is essential in this scenario. Provide an example using address prefixes and subnet masks.",
        "51fc4258-abf9-4b6f-b01d-0cff59461f6b": "In the context, the document discusses four classes of subnet technologies used in OSPF: point-to-point subnets, broadcast subnets, nonbroadcast multiaccess (NBMA) subnets, and Point-to-MultiPoint subnets. Choose two of these subnet types and explain how OSPF represents subnet and router connectivity for each, highlighting the key differences between them.",
        "32bdd9ef-6389-4847-9edb-cf6663ccd08a": "How does the Next Hop Resolution Protocol (NHRP) propose to bend the rules of the IP subnet model, as mentioned in the context?",
        "051af2a0-55dd-4313-9021-95eb76c222da": "In what ways does the IPv6 protocol allow for direct communication between two nodes, and how does this differ from the IP subnet model's common IP prefix requirement? Provide specific examples from the context to support your answer.",
        "7d661e7a-da31-41fa-83dd-9374e3169844": "Explain the role of the Hello protocol in OSPF and how it enforces the IP subnet model. In the context of the figure 5.1, describe how a router with two addresses creates two OSPF interfaces and sends Hellos out both interfaces.",
        "ce5ef6a4-c301-4e23-ab1d-118f35ede43e": "Define a broadcast subnet and give examples. Also, explain the concept of multicast in the context of broadcast subnets and how it differs from broadcast. Explain how a node can program its Ethernet adapter to accept specific multicast addresses.",
        "89179b0e-47b7-45bf-87bf-dd372d9bbbde": "How do IP multicast addresses map to Ethernet multicast addresses in the context of OSPF routers on an Ethernet segment? Provide the algorithmic process and give an example using the IP multicast address 224.0.0.5.",
        "367ebc98-58de-4f94-ab8e-5f8506b6e7ec": "In the scenario described, how does the use of multicasting in OSPF help maintain relationships among routers attached to an Ethernet segment, and how does it reduce the number of packets required for communication compared to sending separate packets to each neighbor?",
        "c7a38c66-13d8-4b3d-8c94-00091a73039b": "Question: How does OSPF's Hello protocol enhance the efficiency of discovering neighbors on a broadcast subnet, and what is the impact of using the data-link broadcast address for this purpose?",
        "d6e95737-9b4a-47b0-bf60-5df74e9460f5": "Answer: OSPF's Hello protocol increases efficiency by multicasting to a well-known address, allowing neighboring routers to discover each other without any configuration. This method results in only n Hellos being sent every Hellolnterval seconds, where n is the number of OSPF routers on the broadcast segment. However, if multicast is not supported, OSPF maps its AllSPFRouters address into the data-link broadcast address, causing all nodes on the Ethernet to receive the OSPF Hello packets, consuming valuable processing time even if the nodes discard the packets.",
        "23e8bac8-2e1e-4c05-b816-2a78f46a61a7": "Reference: The advantages of OSPF's Hello protocol over broadcast subnets section.",
        "4ccaf587-39c3-4244-b36b-46cd98ba3de8": "Question: In the context of OSPF on a broadcast subnet, how does the election of a Backup Designated Router enhance the robustness of the database synchronization process, and what is the resulting number of adjacencies over the broadcast subnet?",
        "f78b1a12-373e-461d-bf5f-e8331eb064ca": "Answer: The election of a Backup Designated Router ensures that database synchronization over the broadcast subnet remains robust even if the Designated Router fails. All routers synchronize with both the Designated Router and the Backup Designated Router, allowing the Backup Designated Router to act as a hot standby in case of a failure. This setup results in 2n -1 adjacencies over the broadcast subnet.",
        "7c6a03e2-058f-46c3-b684-a93fd2e27592": "Reference: Database Synchronization section.",
        "0056fc82-5385-4bfd-a556-05b7a6481d03": "Explain the process of flooding a Link State Update (LSA) in an OSPF broadcast subnet, mentioning the IP multicast addresses used and the role of the Designated Router and Backup Designated Router in this process.",
        "bd3cad47-df5f-4460-b83b-fb9dd27f04b7": "Describe the election process of a Designated Router and Backup Designated Router in an OSPF network, including the initial election, the conditions for a change in their identity, and the role of Router Priority in the event of a failure.",
        "688e2961-70f5-4d34-8d97-4a0bd13ac167": "Explain the concept of Router Priority in OSPF and describe how it is used to prevent certain routers from becoming the Designated Router or Backup Designated Router on a subnet. Also, explain how Router Priority is used in the case of partitioned subnets.",
        "39fde691-7710-4b79-948b-7f678e1e48f8": "Compare and contrast the two alternatives for representing the router connectivity of a broadcast subnet in OSPF: including links to all other routers in each router-LSA and using a network-LSA to represent the broadcast subnet. What is the advantage of using a network-LSA and how does it reduce the number of links in the OSPF database?",
        "ebb0ec25-351b-4bfd-84aa-d3495fa20a53": "Explain the role of the Designated Router (DR) in OSPF's representation of a broadcast subnet, and how it relates to the origination of the network-LSA.",
        "0d0188bd-126c-49a6-a6dd-41bc651f4dc8": "How does the synchronization guarantee provided by the network-LSA and the Backup Designated Router ensure loop-free forwarding and uninterrupted data traffic in a broadcast subnet? Provide an example using Figure 5.3 and 5.7 as reference.",
        "9cf1879c-0606-438a-8fd9-3170645a6ad1": "Based on the information provided in the context, explain what the \"transitivity assumption\" means in the context of OSPF running over broadcast networks. Is this assumption always valid? Why or why not?",
        "8879e33a-f641-4e0a-b1b2-76ff806f7bef": "Referring to Figure 5.7, what is the role of the Designated Router (DR) in generating the network-LSA for subnet 10.4.7.0/24? How does this LSA enable routers to calculate routes to other routers on the subnet?",
        "13f059fe-96a5-4570-9cf9-78ddf18491c3": "Explain the concept of Nonbroadcast multiaccess (NBMA) subnets as described in Section 5.3. In your explanation, include the characteristics of NBMA subnets, the advantages of modeling them as Point-to-MultiPoint segments, and the weird failure modes that can occur.",
        "b7227782-f2ba-42ee-ba6e-73af4de483d5": "Describe the process of neighbor discovery and maintenance on an NBMA subnet as discussed in Section 5.3.1. Include in your answer the role of Designated Router election, the use of Hello packets, and the importance of Router Priority in the process.",
        "335c5815-0111-44ce-a402-3254769f7b8c": "Based on Figure 5.8 and the description of the network topology, explain the role of Router Priority in the election of Designated Router (DR) and Backup Designated Router (BDR) on a Non-Broadcast Multi-Access (NBMA) network, such as a Frame Relay subnet. In your explanation, include how the Router Priority value affects the behavior of routers A, B, and F in sending Hello packets and polling inoperational routers.",
        "292ffb77-53c9-4ef0-8eb8-ee11467d15c5": "Describe how Database Synchronization works on NBMA networks, as compared to broadcast networks. In your description, explain the process of Database Exchange and flooding of Link State Updates, and mention the role of the Designated Router and Backup Designated Router in this process. Additionally, discuss any differences in the process between NBMA and broadcast networks.",
        "3a0806a7-489e-45e5-84a0-5456b7a738a6": "Explain the concept of abstraction in NBMA subnets as described in Section 5.3.3. How is an NBMA subnet represented within the OSPF link-state database and what is the role of the Designated Router in this representation?",
        "57b30ed5-9c96-4459-9253-32beb5114d69": "Discuss the problems associated with using NBMA networks, as mentioned in Section 5.3.4. What are the implications of a failed or misconfigured PVC or an SVC that cannot be established? Provide an example to illustrate the potential impact of such failures on the network's operation.",
        "8bb5ed3e-6072-409d-b822-e56c8763b8d9": "Explain how the Point-to-MultiPoint model can be used on any data-link technology that the NBMA model can be used on, with the help of an example. Also, describe how partial PVC meshes can be modeled as single Point-to-MultiPoint networks using this model.",
        "3593f8b2-8203-4bc1-a0fb-096142b7ab3b": "Consider the Frame Relay network with partial PVC mesh implemented as multiple NBMA subnets in Figure 5.9. Describe how this network can be turned into a single OSPF Point-to-MultiPoint subnet with the prefix 10.6.6.0/24, and explain the OSPF interface configuration and neighbor relationships for each router in the resulting network.",
        "0e3f476a-c6af-486e-a465-5524b59d4bfd": "Explain the concept of Point-to-MultiPoint subnets in OSPF and how it differs from partial mesh topology. Also, discuss the role of the Hello protocol in Point-to-MultiPoint subnets and the conditions under which dynamic neighbor discovery is possible.",
        "40e6f46f-2c5b-4d15-ae41-ba1c95cff895": "What are the advantages of using the Point-to-MultiPoint model in OSPF, in terms of autoconfiguration and robustness? Additionally, explain how this model interacts with Demand Circuit extensions to OSPF and under what circumstances the failure of a PVC or SVC does not cause any problems.",
        "01adbc4e-252c-430f-bf6a-d776f0fe7275": "Explain the process of database synchronization on a Point-to-MultiPoint subnet as described in Section 5.4.2. How does a router flood an LSA to its neighbors in this type of network?",
        "98c18ed4-93a2-446f-9b73-10cb78dd4ff2": "In the context of OSPF network types, why might a full-mesh Frame Relay or ATM subnet be configured as a Point-to-MultiPoint network, even though it results in less efficient neighbor maintenance, flooding, and database representation that increases as O(n^2)? Discuss the trade-offs involved in this configuration.",
        "a3d10776-4ddc-4bd8-9701-56bebb552a5d": "Based on the information provided in [123], explain the role and functionality of NHRP (Next Hop Resolution Protocol) in the context of enhancing the IP subnet model for connection-oriented subnets such as Frame Relay and ATM.",
        "98388a21-1cc6-478a-b6f1-ee698a3bfa69": "In the context of OSPF NBMA subnets, describe the process of splitting up a partial-mesh Frame Relay or ATM subnet into multiple OSPF NBMA subnets as explained in [65]. Additionally, discuss the factors that influence the number of LSA (Link State Advertisement) copies a router may receive during flooding in such a network.",
        "7ea42f88-8dc7-42ce-bdbf-8de83c1b7051": "Based on the context information, how does hierarchical routing affect the growth rate of routing table size in an OSPF network, compared to flat routing?",
        "d106b518-a285-4a2e-89f6-c030ac19cd99": "In the context of OSPF networks, what are the three resources whose consumption is mentioned as growing with the size of the network, and how does hierarchical routing help to optimize their usage?",
        "c4370c4b-f5e6-438d-974a-85a0fce4ed09": "Based on Figure 6.1, compare and contrast linear and logarithmic routing table growth in the context of hierarchical routing. Provide an example to support your answer.",
        "7bfb6396-7df6-4f97-ac1f-488b66ac5764": "Describe the journey of an IP packet sent from host 10.1.1.6 to 10.3.3.5 in the hierarchical routing scenario illustrated in Figure 6.2. Explain how the packet is forwarded between different levels and partitions until it reaches its destination.",
        "da40fb7d-1e3e-4a1d-a71d-4eff9dce4b5f": "Explain how hierarchical routing reduces routing table size, using an example from the given figure. What is the resulting number of routing table entries for a router in the first-level partition labeled 10.1.1, and how does it compare to the number of entries in a flat routing system?",
        "c9dba5db-da14-418f-acc9-674737c31ae7": "Describe the potential trade-off involved in the routing table size reduction achieved with hierarchical routing. How can this reduction lead to suboptimal forwarding, and what impact does it have on the path taken by packets compared to a flat routing system?",
        "f6210e1a-21a2-4416-ae7f-d6d00d96c062": "Explain the concept of hierarchical routing and its significance in keeping routing table sizes manageable. How does OSPF implement a two-level hierarchical routing scheme using OSPF areas? Include the role of Area Border Routers (ABRs) and summary-LSAs in your answer.",
        "13fbf865-8df0-4156-8e49-db08e22dd4ba": "In the context of OSPF areas, described in Section 6.1, what is the purpose of having a separate link-state database for each area? How does this design decision help in reducing the detailed knowledge of the topology from being flooded beyond the area's borders? Provide an example using the sample OSPF area configuration in Figure 6.3 to illustrate your answer.",
        "eb4f460f-ef23-4a07-bd87-ccb137b12db6": "Explain the concept of OSPF areas and how they help reduce the demands for router and network resources. In your explanation, include the role of link-state databases and flooding traffic in the context of OSPF areas.",
        "bfd64467-3c81-4051-b6e1-50d888e15586": "Consider the scenario described in the context, where router B aggregates all of area 0.0.0.1's addresses into a single advertisement for the prefix 10.2.0.0/16. Describe the components of the summary-LSA that router B uses to leak area 0.0.0.1's addressing information into area 0.0.0.0. Additionally, justify the cost assigned to the summary-LSA in this scenario.",
        "3b7b7ad5-878e-42ee-bbf3-fe4ee77b2b16": "Based on the information provided, explain the concept of OSPF areas and their role in reducing the size of the routing table. Additionally, discuss how the cost of the shortest-path calculation is affected by the number of routers and router interfaces in an area.",
        "c701709b-3d0a-4328-be19-5c41b7eeeaa3": "The document mentions that the recommended size of an OSPF area is 200 routers, based on a 1991 estimate. However, it also states that this estimate is probably outdated due to increased router CPU speeds. Considering this, discuss the current recommended maximum size of an OSPF area and the factors that influence this recommendation. Also, explain how OSPF areas increase network robustness.",
        "f3571b26-611f-4038-9567-dfc8e1495124": "Explain the concept of \"routing protection\" in OSPF Areas and provide an example of how it can be beneficial in a real-world scenario.",
        "dd26471d-2482-44ba-90e3-46599cc3c285": "Describe the process of exchanging routing information between areas in OSPF, using the example of router D in Figure 6.3. Additionally, explain how router D determines the best path for a given destination and how it readvertises the destination into its attached area.",
        "e6430aba-5ba0-4cee-a805-8b7d77e4ca38": "How does the requirement of attaching all areas directly to the OSPF backbone in a hub-and-spoke topology impact the convergence properties of Distance Vector mechanisms in OSPF?",
        "35605ec7-2a8d-4f28-bf19-95a7b4ce53b5": "Explain the analogy between the operation of RIP and the area routing information distribution in OSPF as presented in Table 6.1. Include in your answer the functions of originating, receiving, adding cost, and choosing best routes for both RIP and OSPF area routing.",
        "8b519f61-ab35-49dd-8bd4-2cb29c0e3a96": "Explain the concept of OSPF virtual links and their usage in maintaining the hub-and-spoke topology for inter-area routing exchange. How do virtual links allow for a shortcut calculation in the forwarding of data packets, and when is it appropriate to configure them?",
        "3b38d58a-0535-4ce4-86ed-5f2c4ddb3981": "In the context of the Internet, which routing protocols are commonly used alongside OSPF? Describe the role of AS boundary routers (ASBRs) in importing routing information from these different protocols into an OSPF routing domain.",
        "38487bcf-449e-4c67-bf68-833cf971e22a": "How do virtual links in OSPF incorporate new networks and import external routing information into the routing domain?",
        "14c008d0-ba36-4edd-a5af-597aea31901b": "What is the role of AS boundary routers in importing external routing information into the OSPF routing domain, and how are external routes advertised within the domain?",
        "0b758329-9526-460c-86e2-7b412fa5c4d3": "Question (Short Answer): Explain the concept of OSPF's four-level routing hierarchy and provide an example of how it might be applied in the network described in Figure 6.6.",
        "994cf186-2816-4175-8a11-3a94f731c746": "In the context of the provided document, describe the four levels of OSPF's routing hierarchy: Intra-area routing, Inter-area routing, External Type 1 metrics, and External Type 2 metrics. Explain how these levels impact the routing preferences within an OSPF domain. Provide an example of how routers B, G, and H in Figure 6.6 might import routing information into OSPF at different levels.",
        "e5d7f970-e41a-4487-aacd-c03f254a0b94": "Question (Essay): Compare and contrast the use of external Type 1 and Type 2 metrics in OSPF and discuss their implications on routing decisions.",
        "8d7909bd-785f-4461-adcb-3e7124821de6": "In the context of the provided document, analyze the differences between external Type 1 and Type 2 metrics in OSPF. Explain their semantics and the assumptions made when using external Type 1 metrics. Discuss how these differences impact routing decisions within an OSPF domain and provide examples of when one might be preferred over the other.",
        "2dd62846-8fd2-4700-9abb-45b104bc18f5": "In the context of OSPF, how do external Type 2 metrics determine the significance of the external path cost compared to the internal cost to the AS boundary router? Why is this the case when BGP routes are imported as external Type 2 metrics?",
        "2e22b0bd-56fd-49e2-a84f-3caf0ee964a6": "Explain the purpose of the Forwarding Address field in an AS-external-LSA. How does specifying another router's IP address in this field affect traffic forwarding? Provide an example using the information in Figure 6.7.",
        "62e69db1-51ca-475e-9e97-76ce50bb29bc": "Question: (Short Answer)",
        "3218648a-dd3d-4777-b315-41b7c51e26e4": "In the context of OSPF, what is the purpose of the External Route Tag field in AS-external-LSAs and how is it used in the BGP-OSPF interaction?",
        "19995468-3824-465f-83f0-86a64ce21ea6": "Reference: Section 6.2",
        "e8f07706-71ad-4682-8047-6c3173ee7fdb": "Question: (Essay)",
        "3c8691bd-238e-432a-8226-72ac7350d1a2": "Explain how external routing information is conveyed across area borders in OSPF and why the approach of reoriginating AS-external-LSAs at area borders was considered expensive. Describe the mechanism used by OSPF to flood AS-external-LSAs across area borders and the role of Type 4 summary-LSAs (ASBR-summary-LSAs) in this process.",
        "1b1b6fd5-9ede-452e-9023-dbf4f9ad76d5": "Reference: Section 6.2.1",
        "5114a797-222a-474e-ab1f-05cb3380d627": "Based on the information provided in the context, explain what ASBR-summary-LSAs are and why they are used in OSPF routing. In your explanation, include the function of the fields \"Link State ID,\" \"Advertising Router,\" \"LS Sequence Number,\" \"LS Checksum,\" \"Length,\" \"Network Mask,\" \"TOS,\" and \"Metric0\" in the given ASBR-summary-LSA example.",
        "5a226878-aeb8-4b08-9cd0-3e208439b593": "Compare and contrast \"normal\" OSPF areas with \"stub\" and \"NSSA\" areas. What are the advantages and disadvantages of each type, and in what scenarios would each type be most appropriate? In your answer, consider the impact of each area type on processing and bandwidth resources.",
        "6cbdf729-137c-4b7f-9bfd-0de6f0e18a1e": "Why were stub areas introduced in the original OSPF design and what are the limitations imposed on the link-state database to conserve router memory?",
        "3e30a800-c66b-42c9-ac26-a0958504990d": "What is the purpose of NSSAs (not-so-stubby areas) and how do they differ from regular stub areas, as described in [47]? Provide an example of a typical use case for NSSAs.",
        "35db3f37-5ff4-4b3b-afbe-5eaa16531b8c": "Question: (Referring to Section 7.4 and Figure 6.3) Explain the concept of a Not-So-Stubby Area (NSSA) in OSPF and its role as a one-way filter for external information. Further, calculate the routing table for routers A, B, C, and D in Figure 6.3, assuming that router A is the NSSA border router.",
        "1e903fc7-2bb9-44ca-be9d-cab899a1fee3": "Question: (Referring to Figure 6.6) Considering the topology shown, determine the number of summary-LSAs and ASBR-summary-LSAs router E originates into area 0.0.0.4. Also, specify their associated costs. Additionally, propose a way to combine two areas in Figure 6.6 to eliminate the need for any virtual links.",
        "a6f0b08d-671f-48e6-80a7-a79bfeef400f": "What were the two optional capabilities built into the OSPF Version 2 specification at the very beginning, and how have they contributed to the extension mechanisms in OSPF?",
        "d5ea9011-bf19-462d-b581-4314844c96ed": "How can the network description be enriched in OSPF to add new capabilities, and can you provide an example of such an enrichment from the multicast routing extensions to OSPF (MOSPF)?",
        "b6a5a657-6525-4ee5-b5e2-15beab3d2597": "Explain the purpose of the Options field in OSPF and how it enables backward compatibility. What are some examples of OSPF extensions that use the Options field?",
        "30e6ae2b-f89a-4533-855a-b7a4eb3bc367": "Describe the mechanisms that OSPF uses to maintain backward compatibility when there are mismatches in router capabilities. Provide an example of how these mechanisms are used during database synchronization and routing calculations.",
        "76fb5a5c-b6b0-4378-872a-625dcdc8dd20": "Based on the information provided, why has TOS-based routing been omitted from the OSPF and IPv6 specifications, despite being supported in IP? What implications does this have for applications that require different types of service?",
        "90652c82-c2b8-49d4-a0c7-78192c6853f7": "The document discusses the use of stub areas and NSSA areas in OSPF. Can you explain the purpose of these extensions and how they affect routing calculations? Provide an example of a scenario where using stub areas or NSSA areas would be beneficial.",
        "77e28150-faf9-47fd-a941-8f4b56f8e85d": "Explain how TOS-based routing was implemented within the original OSPFv2 specification. In your explanation, describe how separate costs for each TOS value were advertised in a router-LSA and how separate routing calculations were performed for each TOS.",
        "210036ec-bf9e-4932-82e3-5f9793e34b22": "Considering the network shown in Figure 7.2, describe how router 10.9.0.3 advertised the cost of its attached satellite link to influence the forwarding of traffic requesting minimize-delay service toward 10.9.0.5. Also, explain why routers typically do not forward based on TOS and what types of applications or hosts might request TOS-based routing.",
        "518db412-017b-4d81-9156-dfe01dea28bb": "Explain how OSPF allows a mix of TOS capability within a routing domain. How does an OSPF router performing TOS-based routing handle the situation where it has a normal service path to a destination but not paths for other TOS values? Provide an example using Figure 7.2 to illustrate your answer.",
        "6300592f-6f0e-423d-9e5b-27004dfccdf9": "What are stub areas in OSPF and what is their purpose? How does not flooding AS-external-LSAs and summary-LSAs into stub areas reduce the link-state database size and memory consumption of routers within a stub area? Provide a numerical example to support your answer.",
        "14b9b7c2-4115-4245-8489-dfed4aed2514": "Explain the concept of stub areas in OSPF and why it is important for all routers within a stub area to agree on its status. What mechanisms does OSPF use to ensure this agreement and prevent potential flooding problems and routing loops?",
        "6533b69c-b47a-4f09-bd5f-dfa96b04017e": "Describe the OSPF Demand Circuit extensions and their purpose. What types of links do these extensions apply to, and what are the goals of using them? What types of routing protocol traffic are removed by the Demand Circuit extensions?",
        "cadb59fc-22c4-4de9-a5cd-76b9a9234a4f": "Explain how the OSPF Demand Circuit extensions reduce the amount of routing traffic over a demand circuit. In what scenarios would the dial-up connection be reestablished?",
        "5b4dba7b-a299-4b74-b906-877a7afd5514": "What is the purpose of the DoNotAge bit in OSPF and how does it affect the aging of LSAs in a router's link-state database? Discuss a scenario where setting the DoNotAge bit can be beneficial in OSPF networks with large databases.",
        "155934cd-58bb-4a6d-8bc0-9fc7fcde3501": "Explain the concept of LSA aging and the specific rules for removing certain LSAs from the link-state database in OSPF. What was the rationale behind choosing a time constant of 1 hour for this process?",
        "83aff24b-ff12-45b0-af3e-4ff9c55cce95": "Discuss the impact of Demand Circuit extensions on the robustness of OSPF and the caveats associated with their use. How do stub areas or NSSAs help isolate a demand circuit from frequent changes in a large OSPF routing domain?",
        "8da15bcc-7df6-43b1-8e64-94adef4e6389": "Explain the concept of Not-so-Stubby Areas (NSSAs) in OSPF routing and how it differs from stub areas. What is the purpose of Type-7-LSAs in NSSAs and how are they translated into AS-external-LSAs?",
        "43cacd43-60a9-4548-9dc3-61f25366c11c": "What is the role of the DoNotAge bit in OSPF routing and how is its use negotiated? Describe the reaction of an unmodified OSPF router to the DoNotAge bit and the steps taken to indicate the presence of routers that do not understand the DoNotAge bit across area boundaries.",
        "b17958d4-d809-49bc-867f-f5492456165f": "Why might an area border router not want to translate a Type-7-LSA into an AS-external-LSA in an OSPF network? Provide two possible reasons based on the context information.",
        "ec430744-c080-470c-afd4-cb34d7dbd994": "Consider the example given in Figure 6.6, where router H learns a route to 192.9.1.0/24 via RIP with a cost of 3. Explain the process of importing the Type-7-LSA into area 0.0.0.5 and its subsequent translation into an AS-external-LSA by router F for distribution to other OSPF areas. Include the relevant N/P-bit and LSA type information in your answer.",
        "4adb17ae-3012-482c-9881-d404117e1601": "Explain the mechanism used to ensure agreement among all routers in an NSSA area to prevent routing loops or continual retransmissions of LSAs. How does this mechanism prevent routers with differing opinions on the area's NSSA status from participating in database synchronization and routing calculations?",
        "8633341d-b6e3-47f1-b9e1-bbc5fdcd49b5": "Discuss the rationale behind limiting only nondefault AS-external-LSAs in OSPF's Database Overflow extensions. Why were these LSA types chosen, and how do they impact the link-state database size and predictability? Additionally, explain the concept of database-overflow state and the consequences of reaching the limit of ospf ExtLsdbLimit LSAs.",
        "573fe038-c9d4-428a-a15a-468eb892c0b5": "Explain the concept of \"database-overflow\" in OSPF and how it helps in controlling the number of nondefault AS-external-LSAs in the routing domain. Also, discuss the role of the timer in automatically transitioning the routing domain out of the database-overflow state.",
        "a5edb149-de0b-4bab-b465-216b1ee78ac9": "In the context of the Internet's structure, describe the function of Autonomous Systems (ASs) and the role of routers at the edge of an AS in exchanging routing information. Additionally, compare and contrast the Interior Gateway Protocols (IGPs) OSPF and RIP, and explain their use within an AS.",
        "a7d26aa2-be9e-49e7-a11f-b7b1c9e5e68d": "Explain the concept of Internal BGP (IBGP) and its limitations in terms of the number of IBGP sessions required. How does this issue impact the scalability of BGP in large Autonomous Systems (AS)?",
        "a951250d-240d-4f4a-9cd3-b4f06c54c4a9": "In the context of OSPF as a routing protocol within an AS, describe the role of the external-attributes-LSA (LS Type 8) in communicating BGP information. How does the use of the external-attributes-LSA help reduce space in the link-state database, and what is the significance of the Tag field in this context? Provide an example using the information given in Figure 6.6.",
        "e8ebdfe3-6332-4953-acec-6e44904761cb": "Explain how the AS-external-LSA is used to advertise a route in OSPF and its advantage over IBGP. In your explanation, include the role of the Tag field and the flooding property of OSPF.",
        "d6b1a917-775b-438c-99db-a52a1e1fb934": "Referring to the provided figure of the external-attributes-LSA, describe the function of each field in the LSA. Additionally, explain the significance of the Format ID field and its use in transmitting data for protocols other than BGP.",
        "79fc1834-cc72-46b7-9663-23375e6308bd": "Why has the external-attributes-LSA feature never been implemented or deployed in BGP networks, despite being an attractive alternative to IBGP?",
        "57f3bfbd-24fe-4be2-8a8e-3ff39b8dcda6": "What are the potential issues that can arise when some routers in an OSPF network are not capable of flooding external-attributes-LSAs, as described in the context information?",
        "32418495-071a-460a-a0c8-870a1042eaed": "Question for Chapter 7 of the \"150 OSPF Extensions\" document: Considering the area configuration in Figure 6.6, if router B and router G each import 1,000 external routes into OSPF as AS-external-LSAs, and router H originates 100 Type-7-LSAs in an NSSA (area 0.0.0.5), what is the size of the link-state database in area 0.0.0.1 and area 0.0.0.5? Explain your answer using the information provided in the chapter.",
        "c1bdae16-512e-402d-9b5c-7fa0fa332da9": "Question related to Section 7.3 and Figure 7.2: Suppose you want to avoid the high per-packet charge on the link between routers 10.9.0.1 and 10.9.0.2 for traffic between 10.9.0.6 and 10.9.0.4. What is the smallest IOS 16 cost that can be configured for the link to achieve this goal? Explain the reasoning behind your answer, considering the information provided in the section and figure.",
        "a5deecf4-38f8-4820-ab5f-704b7c174b54": "What is the significance of the University of Maryland (UMD) OSPF implementation in the history of OSPF software?",
        "43e670bb-2100-479e-ae5f-3030021c1125": "In what ways can GATED, a routing daemon for UNIX platforms, be used in relation to OSPF and other routing protocols?",
        "eed8f507-7e9e-4eb3-b895-c5d1aba9b75c": "Explain the process of participating in discussions about OSPF and where to send a subscription request to join the OSPF Working Group's mailing list.",
        "161bb523-6309-4e38-ac1a-12fb0c215f90": "Describe the restrictions and calculation of the OSPF link-state metric and explain the role of link costs in OSPF routing decisions.",
        "f20be62b-4c54-4eb3-ac4b-7ba1f674eaf5": "Based on the information provided, why does OSPF routing not respond to network load? Can you explain the concept of route thrashing and how it is related to OSPF's static metrics?",
        "1fe61e23-510b-415c-bee3-edbb5683e92e": "The representation of point-to-point links in OSPF is described as \"strange\" in the text. Can you explain how point-to-point links are represented in OSPF and why this might be considered unusual? Additionally, why does the resulting routing table instruct the router to forward packets for its own address out the point-to-point interface to the neighboring router?",
        "abd6b8a0-230c-454b-a0ec-53deb24ab9da": "Why does OSPF advertise the interface addresses separately for point-to-point links instead of advertising a single route, as done in RIP? Explain the benefits of this approach, focusing on the conservation of IP address space.",
        "e6af83ab-d47a-44d2-8433-68b92df76ba9": "In the context of point-to-point representation in OSPF, why is the neighbor's IP address advertised instead of the router's own IP address? Describe the advantages of this approach, specifically discussing its role in network booting and diagnostic purposes.",
        "4a09e87e-5141-4b7c-a9eb-22fd5d495976": "Why is it more likely for a ping to be routed into the addressed interface when advertising the neighbor's IP address in OSPF, as mentioned in the context? Can you provide an example to illustrate this concept?",
        "9bef8302-f510-4a18-907e-533fe3544099": "The OSPF MIB contains a large number of tunable parameters, as stated in the context. Why is it recommended to leave most of these parameters at their default values, and what are the implications of changing them? Provide some examples of these parameters and their default settings.",
        "c5b1691c-0b95-491f-911d-9c76788f46c5": "Question for Chapter 5: In the context of OSPF over non-broadcast networks like Frame Relay and ATM, can you explain the difference between the OSPF NBMA and Point-to-MultiPoint interface types, and under what circumstances might you choose one over the other?",
        "8e1438ea-8478-4ea5-908f-c4f609a74a0a": "Question for Chapter 11: In the interaction between OSPF and RIP protocols, why do router vendors have their own mechanisms for controlling the interactions, and where would be the best place to start when configuring this interaction?",
        "ae9a4fd6-1198-4ade-be1b-97750d05924c": "Based on the information provided in the context, explain the role of the Designated Router and Backup Designated Router in OSPF flooding. What are the responsibilities of each in terms of retransmissions, origination of network-LSA, and initial flooding of LSAs?",
        "0f915868-c19e-4c32-9db4-60d1c2130193": "Describe the factors that should be considered when deciding where to place area boundaries in an OSPF network. Explain how addressing structure, area size, and topology considerations can influence the placement of area boundaries and their impact on routing efficiency and resource utilization. Provide examples to support your answer.",
        "cd038bee-9b34-4270-976b-8c944ff87d2a": "Explain the role of an area border router in OSPF and why it is important for the area border router to be connected to the backbone area, either physically or through a virtual link. Include examples of the functions that an area border router can perform when it is attached to multiple areas but not connected to the backbone area.",
        "6f063d6c-79be-42b5-9458-c7f6ccfe56ff": "Describe the benefits of using virtual links in OSPF. What are the disadvantages of using virtual links, and in what situations might it be necessary to use them? Explain how virtual links can be used to free the network administrator from having to worry about maintaining physical connectivity of the backbone area.",
        "a61d2798-1e14-4453-a531-ef46037d91c4": "Explain the role of virtual links in OSPF and how they affect data and control traffic flow, using the example of the area configuration in Figure 6.6.",
        "283a2cfc-cb70-4e61-8cc7-4a2ec0f66cde": "Describe the problem that arises when there are two router-LSAs with the same LS Sequence Number in the network and how OSPF's rule for selecting the LSA with the largest checksum solves this problem.",
        "71c0e0fc-b545-41b3-89cf-84c7d89b6949": "How does OSPF handle the aging of link-state advertisements (LSAs) in its link-state database, and what is the maximum allowed difference in the age of an LSA between routers?",
        "3674eb6e-a4c4-44dc-9f81-302a9297e41b": "In the context of OSPF, why doesn't the link-state database get refreshed all at once every 30 minutes, and how are the individual pieces (LSAs) refreshed instead? Additionally, provide an example of LSA refresh times from the given figure.",
        "d684933d-6a29-4921-8a7e-b01b1689f403": "Why do current Internet Service Providers not import the entire Internet routing table into their IGPs, such as OSPF, and what impact would this have on OSPF control traffic if they did?",
        "712b8b3b-54be-4571-8b34-d2b0cffc53a5": "In the context of OSPF, what is the purpose of the DoNotAge bit and how can it be used to decrease the amount of OSPF control traffic? Additionally, what are the potential drawbacks of using this bit to modify the LSA refresh rate?",
        "20261996-32ca-4b2d-bf7a-c71faf223209": "Why would a router not flush LSAs originated by other routers, and what are the two exceptions to this rule in OSPF?",
        "66d63d7c-0e5d-49b0-b7f7-504172e4a6d6": "Explain the purpose of MaxAge LSAs in OSPF and describe a scenario where storing a deletion request in the link-state database is necessary to deal with possible race conditions in the Database Exchange process.",
        "b2422cd8-6f0a-49e1-9212-08b6b209a3e7": "Why does OSPF utilize a separate Database Exchange process during link start-up, as opposed to reloading the entire database over the link? Explain the benefits of this approach in terms of synchronization, controlled rate of data exchange, and the amount of data transmitted.",
        "ea751496-e431-4103-8570-80cc50a953f6": "In the context of multicast routing protocols, how does MOSPF differ from DVMRP and PIM Dense in terms of calculating efficient paths, robustness, and configuration? Additionally, explain the advantages of MOSPF in supporting hierarchical multicast routing and IP multicast's expanding ring search.",
        "682860e5-fde0-4fd8-a9f3-1dd0d945e091": "Why do asymmetric link costs in the network diagram presented in Figure 8.2 cause router E to forward unicast traffic to the multicast source SI along a circuitous path? Explain the role of OSPF's split-horizon rules in this context.",
        "12ecc499-3a01-46ed-a8f6-3769b850ac1d": "In the scenario described, why is it crucial for MOSPF to use reverse costs instead of forward costs in the inter-area and inter-AS cases for multicast routing calculations? Illustrate the consequences of using forward costs in this scenario, particularly for the delivery of multicast datagrams to group members in areas 0.0.0.1, 0.0.0.2, and 0.0.0.3.",
        "882f9fb9-5a80-4dfc-bd5f-ec560d61351b": "Based on Figure 8.2 in the document, can you explain the concept of reverse-link costs in an MOSPF (Multicast Open Shortest Path First) environment and why they are required?",
        "6f3587aa-d975-454b-aed0-b056c2aa2c37": "In the context of the OSPF (Open Shortest Path First) FAQ discussed in Chapter 8, what is one question you might have about OSPF and how would you answer it, based on what you have learned so far? Provide a specific example to support your answer.",
        "a0b2d141-1178-4342-9ea8-bbbd0709ecfe": "In the context of OSPF, why has the advertisement of point-to-point links been a source of confusion, and how would the proposed change of having each router advertise its own interface address address this issue?",
        "df6dad3c-089b-4ac7-bae5-c8b5ba78380f": "Explain the problem with matching two halves of a link within the link-state database in OSPF. How would this issue impact multicast datagrams in MOSPF, and how could it be resolved?",
        "aaa56857-7cda-4694-bee9-27ab9b5776d1": "In the context of OSPF for IPv6, how has the issue of looking up network-LSAs during the Dijkstra calculation been addressed, particularly in situations where the OSPF Router ID of the Designated Router changes and there are multiple network-LSAs with the same Link State ID present in the database?",
        "3ced0319-a0b4-4fbe-9361-f2b5b04c03df": "According to the current MOSPF specification, what measures should be taken to ensure that only one copy of each datagram is sent onto a link, even if there are multiple IP subnets configured on that link? Additionally, why is it more sensible to configure MOSPF on a per-physical link basis rather than on a per-IP subnet basis?",
        "cbb61f47-50e2-4100-829f-f1a760bd6a14": "Explain the role of a multicast router and the interaction between multicast hosts and routers, as described in Chapter 9 of the document.",
        "1fc05942-2915-4732-9fbc-e0fb0e063b80": "Describe the operation of MOSPF's two-level hierarchy and its interoperation with DVMRP on the MBONE, as discussed in Chapter 10 of the document. Include in your answer how MOSPF and IGMP interact with each other.",
        "8fc36ae4-9d08-42a0-b446-6c1301ce60df": "Explain the concept of network multicast capability and its importance in applications with one-to-many and many-to-many communication patterns. In your answer, include examples of such applications and how multicast delivery differs from sending multiple copies of each datagram.",
        "63a6827f-01cb-419a-bb33-26de997547ee": "Describe the two multicast forwarding paradigms presented in the chapter: source-based trees and shared trees. Additionally, explain the role of a multicast router in each of these paradigms and how they contribute to the delivery of multicast data.",
        "1a76de35-3e74-41a2-ba0c-487b93c44a18": "Explain the concept of IP multicast and how it differs from LAN multicast. Include in your answer a description of multicast groups, group membership, and the role of multicast routers in forwarding multicast datagrams.",
        "5cd56606-19dd-47b9-8db0-26b7a5da246e": "Consider the network shown in Figure 9.1. Describe the steps that a host on network segment 128.4.1/24 would take to send a datagram to multicast group G1, and explain how the multicast routers would ensure that the datagram is delivered to all group members. Additionally, describe how a host can join and leave multicast groups dynamically using the Internet Group Membership Protocol.",
        "4b8b8535-08df-45f4-b2af-1779671fed09": "Explain the process of mapping an IP Class D address to a data-link multicast address in the context of IP multicasting. Provide an example of this process when transmitting an IP multicast datagram over an Ethernet segment.",
        "395985b1-a7e7-4721-b5f7-b9d676c78ed0": "Compare and contrast the IP protocol stack for multicast and unicast, highlighting the modifications made for multicast at the physical through network layers. In your answer, consider the use of data-link multicast services when they exist and the implications for data-link destination setting.",
        "0b53ff64-bffc-4d27-b860-3be0c639d25f": "Explain why Class D addresses are restricted to appear only as destination addresses and cannot be used as IP source addresses or appear in IP source routes. What implications does this have for multicast routing at the network layer?",
        "72423db9-3a07-4751-a1d7-9aa9e9ba7a66": "Describe the role of IGMP in multicast datagram delivery at the network layer, and compare it to the function of ICMP in unicast datagram delivery. Additionally, explain why there is no multicast equivalent of Path MTU discovery and how multicast traceroute works differently than its unicast counterpart.",
        "be1a1af8-7a8c-4f4f-a9ee-d6576f77c652": "Explain the purpose of administrative scoping in IP multicast addressing and how it differs from TTL-based scoping currently deployed in the MBONE. Provide an example of how administratively scoped addressing can be used within an organization.",
        "a170e665-1af3-4aee-9c4f-898ea09ffe76": "Describe the use of IP multicast addresses in the range 224.252.0.0-224.255.255.255. What is the intended application for this range of addresses, and what protocol or standard is associated with it?",
        "eb72ee93-0593-421a-8f7e-beb51a65096b": "Question: How does the Internet Group Management Protocol (IGMP) help in the delivery of multicast datagrams? What role does the Querier play in IGMPv1 and IGMPv2?",
        "3cbd805c-3bbd-4948-a012-3e4491b5b5c5": "(This question covers the overall role of IGMP in multicast communication, the Querier's function, and the differences between IGMPv1 and IGMPv2.)",
        "b4e18c33-391d-4f3f-81f2-b048a01939f8": "Question: Describe the algorithm used by IGMP to minimize the number of Host Membership Reports. How does addressing reports to the group address being reported contribute to this optimization?",
        "d221fdc5-6dbf-4e52-bb81-816e16eb2065": "(This question focuses on the specific IGMP algorithm to reduce Host Membership Reports and the role of group-addressed reports in this process.)",
        "2e452ced-1101-40ff-9c08-083056561d1f": "Based on the context information, what is the main difference between IGMPv1 and IGMPv2, and why is the improvement in leave latency in IGMPv2 significant?",
        "f99920f2-3a7e-49a2-9f44-9f7d5ea46002": "Explain the role of the Type field in IGMP packets and provide examples of the different packet functions, as listed in Table 9.2. Additionally, discuss the presence of other protocols, such as DVMRP and multicast traceroute, using IGMP packet types.",
        "b6fc8cea-4eb6-41c1-b79d-3c139b15f95f": "Explain the role of the Querier in IGMPv2 and how it is elected on each network segment. How does this differ from the Querier selection process in IGMPv1?",
        "5508b6be-7ea4-4093-bd87-97b7de55ac06": "In the context of IP multicast, why have Internet broadcast addresses become less used, especially directed and all-subnets-broadcast addresses? How does the network in Figure 9.1 introduce IP multicasting mechanisms? Provide an example of a scenario where a router would want to send a RIPvl update message to multiple other routers using a local-wire broadcast address.",
        "af95052e-eff0-4183-9a5f-740ca9f494e0": "Explain the concept of directed-broadcast addresses and how they are used in the context of sending a packet to all hosts on a particular remote segment. Also, provide an example of a situation where a directed-broadcast address would be used.",
        "fbbe8136-75d9-4dea-9a83-273012e39769": "Describe the process of multicast datagram forwarding in the context of source-based multicast routing protocols. How does the path of a multicast datagram form a tree in this context? Additionally, explain the role of reverse-path broadcasting in preventing disastrous forwarding loops in multicast routing.",
        "0300da28-75fc-4fae-8ef1-2562670634f6": "\"Compare and contrast the operation of source-based and shared-tree multicast routing algorithms as described in the context. In your answer, include a discussion on the advantages and disadvantages of each approach, and provide examples of when one might be preferred over the other.\"",
        "2cbc52b4-3a03-497e-8ea9-a90f3a70d372": "\"In the context, it is mentioned that shared-tree protocols were designed to scale multicast to larger network sizes than were possible with older, source-based algorithms. However, shared-tree protocols also create problems of their own. Describe one such problem and explain how it might impact the performance of a multicast network.\"",
        "21e0ab05-6e52-4fc3-9916-6964c780b1aa": "Based on Section 9.3, how does source-based tree forwarding work for multicast group \"Gl\"? Can you explain the concept with the help of Figure 9.3 and describe the role of the source in this process?",
        "21b9a062-ecb7-450f-8084-e1826d687cae": "In the context of Figure 9.3, can you identify and explain the significance of two different nodes in the source-based tree for group \"Gl\"? Also, discuss any advantages or disadvantages of using this type of forwarding for multicast groups.",
        "92f4ac79-491e-4e14-bc85-5c3aba39d737": "Explain the role of the Rendezvous Point (RP) in shared multicast tree protocols and discuss the impact of its failure on the overall multicast forwarding. How can RP selection be done to ensure multicast forwarding works correctly?",
        "1606fca3-fe51-498a-b531-b35bd2f70721": "Describe the process of IP multicast datagram forwarding in a multicast router. What measures are taken to ensure the validity of the received datagram, and what happens if there are any problems with the IP header?",
        "fe2c88ad-fec1-4cd0-941d-937c4d4578ac": "Question (Source-Based Multicast Routing): Referring to the source-based multicast routing table entry in Figure 9.5(a), explain the role of the specified source network, destination group, incoming interface, and outgoing interfaces. Additionally, describe the action the router would take if the datagram was received on a different interface than the one specified in the routing table entry.",
        "0db29dd0-7949-4ced-b028-a33fe06da6a1": "Question (Multicast Routing Protocols): Compare and contrast the indexing methods used by source-based routing protocols and shared-tree protocols in multicast routing table entries. Illustrate your answer with an example, if possible. Furthermore, explain the significance of the TTL threshold as an optimization or scope control mechanism for multicast datagrams.",
        "3a10f24f-2cb4-4cb4-a2a6-3fe14d0c2e48": "Explain the role of multicast forwarding entries and the multicast traceroute facility in the context of the MBONE. How do these features aid in debugging and understanding multicast forwarding in the network?",
        "43a405c3-0eae-445f-b296-8c45ed465c47": "Describe the MBONE tunnel topology and its significance in providing multicast service over the Internet. Why is it challenging for network operators to manage MBONE tunnels, and what issues can arise due to the tunnel topology?",
        "dc46d860-2acd-4f7f-8bdd-b46766e7406d": "Explain how the MBONE uses IP TTL (Time to Live) in a unique way to control the flow of multicast traffic into an administrator's site. Also, describe how an administrator can configure TTL thresholds to prevent specific applications from entering the site.",
        "e6812490-2c3b-428e-88b6-279c3a308977": "Compare and contrast the different diagnostic tools used in the MBONE, such as the multicast traceroute facility, mrinfo, and map_mbone. Explain their functions and how they can be useful for network administrators in diagnosing and understanding the MBONE tunnel topology.",
        "55ef3119-d2c9-406d-86e8-fe3d540162a5": "Explain the concept of TTL thresholds in the context of MBONE applications and why they are being phased out in favor of administratively scoped group addresses. What adverse effect can discarding packets due to insufficient TTL have on DVMRP's pruning mechanism?",
        "99cd4b0b-f891-432a-ac21-b1cad25e5ed3": "Identify and explain two research papers and two theses that are considered foundational to the field of IP multicast routing. Provide a brief summary of each paper/thesis and its contribution to the field.",
        "035e5920-4a9a-48de-baca-19b0fea7d6ef": "\"Compare and contrast MOSPF and DVMRP, two multicast routing protocols mentioned in the context. What are the advantages of using MOSPF over DVMRP when introducing multicast routing capability in an existing OSPF unicast routing domain?\"",
        "d687237b-a99a-4a7f-9d38-7e7bba6d65ee": "\"Explain how MOSPF can be gradually introduced to an OSPF routing domain, as described in the context. How does MOSPF handle IP multicast datagrams around routers that are not capable of multicast routing?\"",
        "9dabc77f-fc62-4ba1-985c-d80a2deabbef": "Explain how MOSPF calculates the path for a multicast datagram in terms of the OSPF link metric. In the context of Figure 10.1, describe how a multicast datagram would be forwarded from workstation SI to all group members of multicast group Gl (address 226.1.7.6).",
        "2d9cbe80-69ad-4f69-b795-3621389a565d": "In the scenario of the Internet radio transmission using MOSPF, describe how the routing protocol responds to network changes such as hosts joining and leaving multicast groups. Additionally, explain how MOSPF handles network links and routers becoming inoperational and then returning to operation, and how this impacts the multicast forwarding process.",
        "5875f835-e0c1-498d-a026-8a47f6b1d6b9": "How are multicast audio packets algorithmically mapped to an Ethernet data-link multicast address in the given example? Provide the specific address that was used for the destination 226.1.7.6.",
        "1b92ca28-df9c-43dd-b82d-09d00068b8e8": "In the context of the MOSPF routing domain, describe the role of a multicast router, such as router A, in receiving and forwarding multicast packets. Explain why router A receives the audio packets and multicasts them onto the FDDI segment 128.186.3.0/24.",
        "5e70d45b-1092-4883-a23b-af23a89ae5fa": "Explain the process of how MOSPF (Multicast Open Shortest Path First) chooses one shortest path over another for forwarding multicast packets. In the context of the given document, why will Router C discard the audio packets received from the FDDI segment while Router D will forward them onto the Ethernet segment 128.186.4.0/24?",
        "0831e87b-abc5-4f74-ab5c-7fd16c12ca0c": "Describe the expanding ring search procedure and how it helps in finding the nearest server. In the context of the given document, why does Router B discard the multicast datagrams sent by S2 with TTL 1, 2, and 3, and forward the one with TTL 4? What causes the query to reach the nearest member of group G2 only when S2 sends a query with TTL of 4?",
        "792db2ab-eebf-44ab-99d3-5664024b5eb8": "How does the MOSPF algorithm react to a host joining a multicast group in terms of calculating the shortest path for multicast packets? Explain the role of the group-membership-LSA and its flooding throughout the MOSPF domain in this context, using the example of Host SI starting its radio broadcast in the given scenario.",
        "cd4accd7-5daa-4911-a8d7-5466e106926d": "In the given scenario, why does the group-membership-LSA label router F itself as requesting packets for group Gl when the listener on segment 128.186.5.0/24 tunes in, instead of labeling the stub network segment with group membership? Explain the concept of aggregation of group membership information in this context and why it is important for MOSPF routing.",
        "71b3d528-24a6-4c6c-94f7-83d582c7eb7d": "Explain the role of Group-Membership-LSAs in the MOSPF multicast routing protocol and how they are triggered and updated based on group membership changes.",
        "d4fe13f7-9edb-447b-94e1-9290c7f7ff24": "Describe the process that occurs when a point-to-point connection fails in a MOSPF domain, including the originating and flooding of new OSPF router-LSAs and the resulting path recalculation in affected routers. Additionally, explain how a listener tuning out impacts the MOSPF domain and the behavior of the designated router on the segment.",
        "9fcecfb9-8a20-4b93-8304-03f0fbf58c2c": "Explain the role of IGMP Querier in the context of multicast group membership and how it is selected in IGMPv2. How does this differ from the Querier selection process in IGMP as specified in [56]?",
        "37e3dce5-fb29-4585-8ab8-c5f0916ab1da": "Describe the process of originating and flooding group-membership-LSAs in MOSPF routing domain. How does a router determine whether to reference its own router-LSA or the network's network-LSA in the body of the group-membership-LSA? What is the flooding scope of group-membership-LSAs and how does it differ from the distribution of group membership information across area and Autonomous System boundaries?",
        "b5eb53e9-eddd-4a8a-8b08-9ad1ecd30403": "How does the calculation burden of MOSPF routers differ from OSPF unicast routing in terms of path calculation?",
        "6e759648-bc64-4de4-839b-15b0c0d06bb9": "In what situations does a MOSPF router calculate a multicast path for a given source network and multicast group, and how does this behavior differ from unicast routing? Provide a specific example using the information in Figure 10.2.",
        "6f02f038-7109-4098-b815-f0e1395efa7f": "Explain the concept of the multicast forwarding cache entry in MOSPF routing and its significance in storing the path information of multicast datagrams. What information is contained in each forwarding cache entry and why is it important to specify the network or router from which the datagram must be received?",
        "48000718-1258-43c9-8678-ab95cbc39c1a": "In the context of MOSPF routing, describe the aggregation of sources and destination groups achieved through hierarchical organization. How does this aggregation impact the number of paths calculated by MOSPF routers and what are the conditions that necessitate the recalculation of multicast paths?",
        "0a296783-5cff-4c0f-b17f-b8eb133b575f": "Explain how MOSPF routers maintain the multicast forwarding cache and what triggers the rebuilding of these cache entries. In particular, discuss the role of Link State Acknowledgements (LSAs) and the action taken by a MOSPF router when it receives a modified router-LSA, network-LSA, or group-membership-LSA.",
        "981ed5da-c824-4752-ac03-7e6b5c3aaca6": "Consider the example in Figure 10.1, and assume that the link between routers D and G fails. How will this affect the multicast forwarding cache entries in all routers? Explain the flooding process of new router-LSAs for D and G throughout the MOSPF domain and the subsequent clearing of all forwarding cache entries in all routers.",
        "b1d79023-34cc-4b60-8d95-b26903e39ade": "Explain why the shortest-path trees in MOSPF are rooted at the datagram source, as opposed to the calculating router in OSPF's unicast routing calculation. What are the implications of this root placement for every MOSPF router?",
        "9b8782e7-b039-4f31-a90b-a2512eb778d6": "In the context of MOSPF, contrast the treatment of stub networks between the unicast OSPF calculation and the MOSPF routing calculation. Why are stub network segments excluded in the MOSPF calculation, and how does group membership aggregation work in this context?",
        "12baaaf4-acd2-4f31-a952-2c623d1c4069": "Explain the process of pruning redundant shortest paths and links that do not lead to group Gl members in a MOSPF shortest-path tree, as illustrated in Figure 10.3. Provide examples of the links that are pruned in each case.",
        "341166f8-cfce-4553-b17b-74d3c3e78c16": "In what situation can MOSPF not automatically detect the presence of redundant paths? Explain the concept of assigning multiple IP subnets to the same physical segment and how it affects multicast forwarding, as mentioned in Section 5.1.",
        "867665a2-962e-49ee-8c67-e949b8e89755": "Explain how MOSPF uses OSPF's area organization to implement a hierarchical multicast routing scheme. Include in your answer how this hierarchical routing can reduce the resources consumed by the routing algorithms and the potential disadvantage of hierarchy in MOSPF.",
        "fa84d115-b715-4cd2-ab69-9729219497b0": "Describe how the location of datagram sources and multicast group membership is conveyed across area boundaries in a hierarchical MOSPF domain. Provide an example using the hierarchical MOSPF domain pictured in Figure 10.4, including the role of virtual links and area aggregation.",
        "8e2ccba7-54a0-42a9-8966-66d2819a895c": "Based on Figure 10.4 in the document, how does a hierarchical MOSPF routing domain help in optimizing the distribution of link-state information? Explain the role of Area Border Routers (ABRs) and Autonomous System Boundary Routers (ASBRs) in this context.",
        "3866ab58-832d-4d05-9508-c5f3740afe84": "In the given hierarchical MOSPF routing domain, what could be the potential drawbacks or limitations, if any? Justify your answer with reasons and reference to the document or your understanding of the underlying technology.",
        "9f6962a4-df6d-4c97-a8b8-0cd390e6b196": "Explain how multicast source information is advertised across area boundaries in a MOSPF network. How does aggregation of multicast sources reduce resource requirements on MOSPF routers? Provide an example using Figure 10.4.",
        "e45b3e29-249e-4e71-96ef-0c89568e68be": "Describe the role of area border routers in advertising multicast group membership in a MOSPF network. How does the concept of wildcard multicast receivers help in delivering multicast datagrams to other areas? Provide an example using Figure 10.4.",
        "5d374ac5-0f16-4f99-ab89-8ce45fac69c4": "Question (Short Answer): Based on the concept of hierarchical MOSPF routing, explain why the datagram sent by S2 to group G2 is unnecessarily sent to router D, even though it is later discarded. What is the trade-off being made in this scenario?",
        "4a77cb8a-b82c-4546-95e9-c6223227c176": "Answer guidelines:",
        "723f93b8-753a-42e4-bb6e-c6be3412d9ad": "* Identify the reason for sending the datagram to router D",
        "65b7ed7b-edbd-4ca1-b920-0f45ef7e5554": "* Explain the trade-off between network bandwidth and cache entries",
        "6a46b7f5-424e-49c1-ad83-af2f726c591a": "Question (Essay): Describe the process of calculating the path of multicast datagrams in hierarchical MOSPF routing. Explain how the path through area 0.0.0.2 is determined and how area border routers merge the shortest-path trees for the individual areas to create the entire path throughout the MOSPF domain.",
        "8694e722-0b5a-449e-9164-2d1bb0a9be11": "Answer guidelines:",
        "147d0808-734c-4a6f-a6df-5ab08f215e1c": "* Explain the impact of area hierarchy on multicast datagram path calculation",
        "46ced9d8-202b-407d-bec6-14ca05289944": "* Describe how source location is estimated using summary-LSAs",
        "f4f50171-6710-4570-85ee-7d23aedf4a2e": "* Explain how wildcard receivers affect the path determination",
        "daf64b18-550e-4930-ab49-b14c43fa08ca": "* Describe the process of merging shortest-path trees for individual areas",
        "e626b28e-72fa-4f0c-89e1-16f87651a3e0": "* Discuss the role of MOSPF tiebreakers in determining the forwarding interface",
        "da89f413-addf-490a-a09a-a3aa55b3d778": "Explain how MOSPF hierarchical routing can produce extraneous forwarding hops, using the example provided in Figure 10.6. Additionally, discuss the potential benefits of implementing a DVMRP-like pruning message in this context.",
        "b3f01c9f-1f75-4bbc-adbb-aac761f7c20b": "In the context of incrementally deploying a multicast routing capability, describe the challenges that can arise when the multicast topology is different from the unicast topology. Furthermore, explain how a multicast routing protocol should handle such situations to ensure backward compatibility with nonmulticast routers.",
        "551e71a4-18fd-445a-83b6-180c9051f11c": "Based on Figure 10.6 in Chapter 10 of the MOSPF document, describe the complete path taken by the datagram from source SI to multicast group Gl.",
        "132d461c-af45-4b89-916f-9f39e4e9ce64": "In the context of MOSPF and referring to Figure 10.6, explain the significance of the routers (R1, R2, R3, R4) and their role in forwarding the datagram to the multicast group Gl.",
        "9e137f01-4170-4c6a-bafd-ac179d16d290": "Explain how MOSPF routers handle differences between multicast and unicast topology in an OSPF domain. In your explanation, include how multicast sources are advertised across area boundaries and what the MC-bit in router-LSAs and summary-LSAs signifies.",
        "cf1cdadf-9cdc-473e-bcf3-66c5051690be": "Describe the role of the OSPF Designated Router in relation to MOSPF and IGMP on a LAN. Additionally, explain why the flooding of unknown LSA types, such as group-membership-LSAs, had to be changed in OSPF for IPv6.",
        "3a86ae7a-c5de-4d73-a58a-dc525a0e9a10": "Explain the role of MOSPF and DVMRP in the context of exchanging multicast routing information between different routing protocols. How do these protocols interact with each other, and what is the analogy used to describe their roles?",
        "5dc4cfdb-b376-493c-b548-3d126485115f": "In the example provided in Figure 10.7, describe the purpose of routers A and D running both MOSPF and DVMRP. Additionally, explain the significance of the BGP connection on router C and its relationship with unicast connectivity to the Internet.",
        "4e4420da-4dcc-423d-945e-e82a26788a3b": "Explain how DVMRP routers determine whether to send prune messages within a MOSPF domain. What are the conditions that must be met for a DVMRP router to send prune messages in this context?",
        "85d181b9-1515-4bce-ac55-ddf4da7d3d6e": "Describe the process of exchanging DVMRP routing information across a MOSPF domain. How are DVMRP routing messages multicast within a MOSPF domain, and what is the purpose of using the group address 224.0.1.21 in this context?",
        "9fb1e5d4-6054-4615-9f06-8c617b0ada1d": "Explain the process of importing DVMRP information into MOSPF and the role of the MC-bit in the AS-external-LSA's Options field. How does this differ from the advertising of inter-area source information in OSPF?",
        "3c4bcff5-bef0-4d9d-8cd0-046c517427c2": "Why are multicast group members on 10.20.2.0/24 and 10.20.3.0/24 an exception to the pruning process in MOSPF? What is the significance of this exception in the context of group G2 members within the MOSPF domain?",
        "97a98d37-1985-4696-924e-b3980fb88766": "0 A network administrator is considering the implementation of MOSPF in their OSPF domain. Explain how the addition of MOSPF to the existing OSPF implementation might impact code size and performance. Additionally, describe how the impact on code size might change if the MOSPF domain were to be split into areas.",
        "f891c581-9c4c-4488-bbcd-55ac54424f8f": "0 Referring to Figure 10.7, identify the routers that originate group-membership-LSAs. Furthermore, explain which routers are declaring themselves as wildcard multicast receivers and why this is important in the context of MOSPF.",
        "cc455fd8-bd41-4e08-8b5f-f00883f86c85": "Explain the process of configuring and managing an OSPF network, including the use of SNMP and the OSPF MIB. Also, describe a real-life example of an OSPF network configuration, such as the Arkansas Public School Computer Network.",
        "78a1e42c-164f-43ba-8361-d4148138781e": "Describe the common tools used for debugging routing problems in a TCP/IP network, such as ping, traceroute, SNMP, network analyzers, and multicast traceroute. Explain how each tool is used, how it works, and its strengths and weaknesses.",
        "88b225c5-d27f-4eda-a085-8781443ad3b2": "Based on the information provided, explain the role of a network administrator in organizing an Autonomous System (AS) that runs OSPF as its routing protocol. What are the key decisions that the administrator needs to make, and why are they important for the smooth functioning of the network?",
        "0effb9c5-8a6c-4c84-8c32-da5fc6b00b06": "OR",
        "83b18947-58bb-4223-99b3-6df4a772f626": "In the context of OSPF management, describe the significance of dividing the OSPF Autonomous System into areas. What factors should be considered when deciding where to place the area boundaries, and what benefits does this provide for the overall network performance and security?",
        "0910a629-b7f7-4b86-924f-f08d6cad929a": "Note: The second question assumes that the reader has some basic understanding of what OSPF areas are. If this is not the case, you may want to rephrase the question to focus on the factors that influence the placement of area boundaries, without explicitly mentioning the term \"areas.\"",
        "b1c4df72-8232-4984-b183-28f6b0b507c6": "Based on the context information, define the concept of Simple Network Management Protocol (SNMP) and explain how it is used for configuring and monitoring Internet protocols and devices.",
        "79224256-ee09-4297-91fe-010b0b63aa30": "Explain the structure of Management Information Base (MIB) in the context of Internet devices. Additionally, describe the role of MIB-II and how it relates to the management of Internet protocols.",
        "fea867b5-2055-4b85-917d-82c09a5dd063": "Based on the given context, explain the role and importance of the Object Identifier (OID) in the SNMP protocol. Provide an example of an OID from the OSPF MIB and explain how it is used to locate a variable within the global MIB.",
        "8263b1be-9b50-4c08-9317-5d926786df4f": "Describe how context dependence is captured in MIBs using tables. Explain the purpose and structure of the ospfIfMetricTable and ospfIfMetricEntry, as well as the role of the INDEX clause in specifying the value of a set of variables within a specific context. Additionally, explain the function of the ospfIfMetricStatus variable in deleting rows from tables.",
        "11b56239-8ebe-41a1-b7bb-74a095973616": "Based on Figure 11.3 in the document, what are the OSPF interface metrics specified in the table? Explain the significance of these metrics in OSPF network behavior.",
        "28cb42fa-fc67-4116-8037-676fbb518c94": "Using the context information provided, create a short essay question that asks students to explain how the OSPF interface metrics discussed in the figure are used to determine the best path in an OSPF network. The question should also ask students to provide an example of how changing these metrics could affect the path selection process.",
        "bb17fd12-c1f5-4ce2-b754-3b136d03bf7e": "Using the information provided in Figure 11.4, explain how the object identifier for a particular instance of ospf IfMetricvalue is formed. In your answer, be sure to include what the numbers 1, 3, 6, 1, 2, 1, 14, 8, 1, 4 represent and how they are used to specify an instance of the variable.",
        "d620827a-39b6-4848-ae76-84b5ab6ba668": "Describe the process of using the SNMP get-next function to walk through the entire management database. In your answer, explain how the lexicographic order of MIB variable instances is used and provide an example of how get-next can be used to list all of a router's OSPF interface costs by walking through the ospf ifMetricTable.",
        "f4ab4c1a-9a72-46ba-ab05-03544afadeba": "Explain the purpose and functionality of the SNMP set command in the context of OSPF management. Provide an example of how this command can be used to configure an OSPF interface.",
        "c0af2c13-444f-4f91-a8f2-7d379800b337": "Analyze the structure of the OSPF MIB and discuss its key features. How many tables does the OSPF MIB contain, and what percentage of the management variables are configurable? Identify and explain the purpose of one configurable table in the OSPF MIB.",
        "cbaea85a-593f-4700-9a30-52fecb7c8994": "Based on the information provided in Section 11.2 of the document, what is the difference between shaded and unshaded tables in the OSPF MIB? Can you provide an example of a configurable parameter in a shaded table and a variable that can be monitored in an unshaded table?",
        "8b35bb2a-7692-47bf-a67b-7fc3897976c0": "In the context of Figure 11.6 of the document, can you explain the organization of the OSPF MIB? Furthermore, can you identify one monitoring objective that can be achieved by using the unshaded tables in the OSPF MIB?",
        "7b677b76-07ea-4ba6-b4c2-bce9d1c62521": "Explain the purpose and function of the 'ospf GeneralGroup' table in the OSPF MIB. What are some of the key variables that can be configured in this table and what are their roles in managing the OSPF protocol?",
        "b8b42760-cc5d-48a5-9452-7f59b10c5a01": "Consider the 'ospf AreaTable' and 'ospf stubAreaTable' in the OSPF MIB. How do these tables contribute to the configuration of OSPF areas, and what are the key variables used to control the behavior of stub areas and their border routers? Additionally, describe the role of the 'ospf HostTable' and 'ospf if Table' in managing OSPF interfaces and directly attached hosts.",
        "8b2eb898-189e-4093-b324-a24d6bee89f5": "Explain the purpose and functionality of the `ospf ifMetricTable` in the OSPF MIB. How is the cost of an interface advertised and used in the router's routing table calculation?",
        "51fca553-7aa6-4060-8657-55cd902b11ca": "Consider a network using NBMA subnets. Describe the process of configuring neighbors and setting the Router Priority for each neighbor in the `ospf NbrTable`. Additionally, explain the purpose of hiding a range of IP addresses from other areas using the `ospfAreaAggregateTable`.",
        "194c1bd2-e9be-4ded-b23a-7c1b812e739f": "Explain the purpose of the OSPF MIB traps and provide an example of two distinct OSPF MIB traps and their \"virtual\" counterparts. What events do these traps monitor?",
        "7b58ad2e-d864-42c4-80c1-fcd70c6b2958": "OR",
        "f784326b-002a-440f-861e-b2e9d68f6829": "Describe the basic configuration process for OSPF and compare it to RIP. What is the significance of specifying the router's OSPF Router ID, and what problems can arise if it is not explicitly configured? Provide an example of a basic OSPF configuration for a router with three interfaces, including an Ethernet interface and two point-to-point links.",
        "34b68b00-33dc-48eb-81df-2961eddda15d": "Explain the process of how a Router ID is selected in the GATED routing daemon for UNIX workstations. What are the order of preferences given to different types of interfaces while selecting a Router ID in GATED?",
        "b7cf53db-5283-4f84-be95-536323b23f25": "Compare and contrast the process of enabling basic OSPF configuration on a Cisco router with that of GATED. How does the loopback address play a role in setting the Router ID in a Cisco router?",
        "8cd84934-cd7c-493c-93a3-70b284aa0d74": "Explain the role of the \"network\" command in the basic OSPF configuration and why it is important. Also, describe how the router automatically determines the OSPF interface type.",
        "bd91ec72-f4c4-4ab7-a009-7ad24b79a75a": "In the context of OSPF, describe the purpose of authentication and why it may be necessary to secure OSPF packet exchanges. Additionally, explain how to enable authentication in OSPF.",
        "d5f0aba7-ab51-407e-af1f-c0a187c9949e": "Why are OSPF interface costs assigned and how do they affect the path calculation within an OSPF routing domain? Provide an example of how setting different costs for T1 and T3 links can influence the routing decision.",
        "7c97312a-b0e4-48cd-9882-dbeecc8d7901": "Besides the default cost schemes in OSPF, explain the concept of weighted hop count and delay-based cost schemes. Additionally, discuss the approach of reverse engineering link costs based on a traffic matrix and its relevance to network design.",
        "d0b00060-bcc7-4bb2-bd4c-a68bcf5f1ebb": "How does the use of OSPF areas help reduce resource demands in a large OSPF routing domain? Explain the impact of OSPF areas on router CPU usage and link-state databases.",
        "722f871b-9eba-4359-b8a7-b38eb1d01392": "In the context of OSPF areas, define the terms Area Border Routers, Area Summarization, Default routes, and Virtual links. Also, explain when and where virtual links should be configured.",
        "93f66db9-01a6-4358-b609-282db0c13279": "Explain the process of transitioning to a new OSPF area while maintaining data forwarding across the segment. Why is it necessary to allocate a second IP subnet to the segment during this process?",
        "52f6581f-fef7-49b1-b545-1732fdbb7e61": "What is the purpose of OSPF Hello packets and the ospf If Hellolnterval and ospf RtrDeadlnterval variables? How do these variables affect the detection of failed neighbors in OSPF? Why should these variables be set identically in all router interfaces attached to a common IP subnet?",
        "23ea4d23-5ef4-4d24-af35-03e04cbe6f1e": "Explain the concept of \"polling\" in OSPF NBMA subnets and the role of the variables ospf if Pollinterval and ospf if Hellointerval in this process. Why are these values typically set larger than the Hellointerval to avoid wasting network bandwidth?",
        "413f0565-fda9-4833-a90e-6e711461c71d": "Describe the configuration of the Arkansas Public School Computer Network (APSCN) as illustrated in the document. What is the role of the backbone area and the hub routers in this network? How does the network provide Internet connectivity to the district routers and collect administrative data from them?",
        "ca67238f-c119-4049-8bf0-0b48b7be9c47": "Based on Figure 11.10 and Section 11.4, what is the primary purpose of the Arkansas Public School Computer Network (APSCN)?",
        "c907928e-a9a2-4782-90bf-75a63392dd36": "a) To provide internet access to individual student homes",
        "a2302a3d-8447-41b9-9816-057e38d8d2b9": "b) To facilitate communication and resource sharing among Arkansas public schools",
        "8fda367a-f8de-42cd-b7ae-1a9a5c0b9d3a": "c) To offer online courses for students",
        "96f1cba9-cdc7-4397-9ea6-58b9826cd468": "d) To store personal student data",
        "9d355b30-a8be-4fdc-89e1-50cd731fdfbd": "How does the APSCN support Arkansas public schools, as described in Section 11.4? Provide an example of a specific service or resource it offers.",
        "b5f5af9f-4654-4852-9444-f74e2d0bdea2": "a) Providing high-speed internet connectivity",
        "8466c760-652f-44e1-be2d-c203b3816dcd": "b) Offering professional development for teachers",
        "fb3fa327-144c-41c4-ad38-704e8d69be26": "c) Coordinating statewide standardized testing",
        "eb90e368-9d7f-4fa7-9195-ec32f0dfac84": "d) Managing student information systems",
        "04da4ac3-06f8-4025-8dea-904c495f0c68": "Answer Key: 1. b) To facilitate communication and resource sharing among Arkansas public schools; 2. a) Providing high-speed internet connectivity",
        "43323c5b-7f2d-459f-bbf9-c88e74ce393b": "Explain the role of backup servers (S2) in the APSCN's data collection process and how OSPF is used to manage the communication between these servers and other network devices.",
        "f096e252-5f57-4987-ac26-364be3dc9520": "Analyze the approach used by APSCN for reducing the size of the routing table within their routers. Describe the process of prefix aggregation at the hub router and how it helps in achieving the desired outcome. Also, discuss the impact of this approach on the overall network performance.",
        "d4f474af-4d52-4964-a595-5b1bc6e64a47": "Explain the role of the OSPF MIB's database checksum in diagnosing synchronization problems in an OSPF routing system. How does this feature help in verifying synchronization network-wide at a single glance?",
        "bce98077-c4b6-4647-afc2-bfd28e912aec": "Describe the process of checking the contents of individual LSAs in the OSPF database when databases are synchronized. How can this examination help in ensuring that the required links or inter-area routes are being advertised? Additionally, discuss how special routers with sophisticated searching and event-monitoring capabilities can aid in debugging networks.",
        "5880dc77-5012-4d42-afe5-20cd647bb8d6": "What is the purpose of initial database synchronization in OSPF and under what conditions may an adjacency fail to form between routers? Provide examples of physical, configuration, and implementation problems that can prevent adjacencies from being established.",
        "5b17ee06-a45b-44fa-9c74-a0639feac1e5": "Explain how monitoring OSPF routers can help detect network performance problems. Describe the significance of an increase in ospf Spf Runs, frequent changes in particular LSAs, and long retransmission queue lengths on a link. Additionally, discuss how enabling SNMP traps or using logging facilities can provide asynchronous notification of events in an OSPF network.",
        "da2af809-b5d3-4af5-803b-60b4c6a4fda7": "Why is it necessary for a network administrator to configure the exact set of destination prefixes to be readvertised from OSPF to BGP and vice versa, as stated in [252]?",
        "bdfa2ad6-ca93-417d-b53a-2847217bb561": "In the context of the interaction between OSPF and BGP, what is the significance of configuring the BGP multiexit discriminator when readvertising an OSPF-learned prefix into BGP? What impact does this have on the BGP route selection process?",
        "7757f4eb-e9c1-4cc6-8a58-73183f5bee2e": "Explain the concept of \"third-party information\" in both BGP and OSPF, and provide an example of how they are used to avoid extra hops for data traffic.",
        "d6c95dec-b952-43f3-a7bb-4e8bd81b3e73": "(The question covers the topic of advertising third-party information in BGP and OSPF, which is discussed in the context information.)",
        "49c7469f-654a-4ab0-bc41-a7d27d9709d9": "Describe the process of using OSPF to replace IBGP in some circumstances, as mentioned in the document. Include an explanation of how AS path information is maintained during the advertisement of BGP updates.",
        "578a218f-3f9a-47b0-bb3e-3f5c323babf5": "(The question covers the subject of using OSPF to transport BGP information across the OSPF routing domain, which is the main part of the document and not explicitly covered in the provided context information.)",
        "e8d70e47-0e99-48a0-84f2-77dcf992258d": "Explain the concept of using the OSPF Tag field to carry BGP origin and AS path information in the context of getting rid of IBGP in certain network configurations. How does this mechanism allow for the reconstruction of the proper AS path when readvertising routing information back into BGP?",
        "8e09b5e8-661d-4bb6-bcde-3f278d584ecf": "In the interactions between OSPF and RIP within a single Autonomous System, how do Type 1 and Type 2 external metrics allow for different strategies without requiring metric translation or hand-configured routing filters? Illustrate these strategies using the provided network as an example.",
        "01a89be2-5a41-4308-a0f2-dc87d2ebba8c": "Question (Short Answer): Explain the concept of \"convexity\" in the context of OSPF routing domain and its significance in deploying new features and protocol-independent multicast schemes.",
        "5185071a-b4c8-4dd4-b465-2e710131a1d7": "Question (Essay): Compare and contrast the two methods of integrating OSPF and RIP in a network, as described in Figure 11.11. In your comparison, be sure to include the advantages and disadvantages of each method, as well as the appropriate use cases for each. Also, discuss how OSPF's cryptographic authentication is designed to prevent unauthorized access and attacks on the OSPF routing domain.",
        "353e9526-927e-4b52-a181-de6b1ba13926": "Explain the process of OSPF cryptographic authentication, highlighting the role of the shared secret key and the cryptographic hash algorithm in ensuring the authenticity and integrity of OSPF packets. (Section 11.7.1)",
        "bc6e8f78-254e-4f77-8e3f-cbad621f4043": "Describe the properties of a good cryptographic hash function as applied to OSPF's use of hash functions for packet authentication. How does the inclusion of a secret key in the input help prevent the generation of false packets? (Section 11.7.1)",
        "91a81f0b-561c-4b0f-9a7c-f94a4fe182ac": "Based on the context information, why may other hash algorithms, such as SHA, be more appropriate than MD5 for OSPF cryptographic authentication?",
        "f581e6a6-cca6-45da-8d47-1fdf8f33efb1": "The security of simply appending the secret to the packet before hashing has been questioned. How does the HMAC construction address this issue in OSPF authentication?",
        "bd9a0689-dd5a-4884-8b89-87c5c6686dfb": "Explain the process of message verification in OSPF cryptographic authentication. How does OSPF ensure that received packets are valid, have not been modified, and are up-to-date?",
        "dd9d3c64-61fa-45fd-b2c3-051e86f66df5": "Describe the key management challenges in OSPF's cryptographic authentication. What measures should be taken to ensure that the secret key is chosen randomly, distributed securely, and stored safely in the routers?",
        "5fda714f-747c-468f-97e5-30dcf8669253": "Explain the process of changing keys in OSPF's cryptographic authentication to maintain security. How does the use of multiple keys at once help prevent routing disruption during the key-changing process?",
        "b78c9ffb-90b2-4356-ac4d-6ad3d444dfde": "What additional security benefits are gained by implementing Digital Signatures in OSPF, as opposed to using OSPF cryptographic authentication alone? Provide examples of how this feature can prevent errors in trusted routers from corrupting LSAs and detect router failures. Also, explain the role of public-key cryptography, private keys, and certification authorities in OSPF with Digital Signatures.",
        "0899ff0f-4732-4a9c-a237-6f86bffa5081": "Based on the information provided in Section 11.7, explain how OSPF with Digital Signatures protects routing via authentication. What are the limitations of this security mechanism?",
        "77ff658a-5fdd-4a9c-877c-02f3e054a11e": "Consider the scenario described in Exercise 11.4. Describe how an attacker could replay old OSPF packets and what impact it could have on the current OSPF routing exchanges. Also, explain how this type of attack could be prevented.",
        "a463e25c-3218-4429-a5dc-2f6137459bea": "Based on the context information, why is it important for network administrators to be familiar with routing tools, and what are some examples of these tools?",
        "4c27907e-8857-4d9a-b74b-187033ba9068": "The text mentions that firewalls can deliberately hamper IP connectivity. How can a network administrator determine if a particular tool will work through a firewall, and what steps should be taken to ensure that the necessary packets can pass through?",
        "3cfe20b3-b76e-4507-b88e-1e80761dd0bb": "Based on the war story in the text, if a router is not populating its routing table correctly after a software update, what steps could a network operator take to diagnose and resolve the issue?",
        "4daaa740-7f7f-4d5f-9d06-16ec86f9c56c": "Explain how an ARP problem could lead to a subnet losing its Internet connectivity, as described in the second war story. How could this issue be prevented or resolved?",
        "a6b7ef51-f899-450b-9fcc-63db3ddd80c7": "Based on Section 12.3, explain the importance of displaying domain names instead of IP addresses when using routing debugging tools. Describe a scenario where having the domain name would be more beneficial in identifying the source of a routing problem.",
        "cd718422-999c-4e7a-bc27-e228709c7fb0": "According to Section 12.2, what are some common ways to find useful routing debugging tools over the Internet? Describe the process of using Archie, an example of a search engine predating the Web, to find ping software. Additionally, briefly discuss the advantages and disadvantages of using Archie compared to popular Web search engines.",
        "85f5c867-7e04-4469-b702-0ede0576a65d": "In the context of network troubleshooting, what is the purpose of the -n command line option in UNIX-based tools, and how does it affect the output of tools like those used in the figures in Chapter 12 of the text?",
        "8d0dec25-655e-457f-baaa-f7fa5e03ec5d": "Describe the process of using the whois command and the Network Information Center (NIC) database to obtain contact information for a domain name. Provide an example of how this command can be used in a real-world scenario.",
        "41c329d9-aa1e-4f06-9954-ded71e5c2db3": "What is the purpose and basic usage of the \"ping\" tool in the context of network connectivity testing? Provide an example of its usage and explain the meaning of the output.",
        "16925f07-795e-4d05-8870-3545e6144413": "How can the \"whois\" command be used to obtain contact information for a specific AS number or IP address? Explain the correct syntax for these types of queries and provide an example of each. Additionally, where can one find help on using the \"whois\" command for other types of queries?",
        "3c3fcd96-d022-43e5-9809-8c3ff893009c": "What is the purpose of using a ping program with specified intermediate hops, and how can it help in debugging connectivity issues between two remote hosts or routing problems?",
        "bf9dbe6c-be00-4487-881c-6f6a44c44ec6": "How can the options in a ping program, such as the number of packets sent, packet size, and data contents, be used to indicate the quality of a connection and uncover data-sensitivity problems in certain network paths?",
        "721f241e-3487-4aff-87c7-1029046d7346": "How is the ping tool implemented and what type of IP packets does it use for sending and receiving data?",
        "8a5dd72f-92aa-48ef-a0bb-be3b8d41c695": "What are the benefits of using the ping tool in diagnosing intermittent routing problems and how did it help uncover issues with a particular ISP's routing protocol implementation?",
        "b6b13f6d-7ff5-4241-bbd1-c795e1fe9701": "Based on the information provided, explain the limitations of using \"ping\" as a diagnostic tool for determining the route that data packets are taking. What problems are solved by the \"traceroute\" tool in this regard?",
        "6ce63b8b-13f7-4ba1-abf5-cb605506eb81": "Describe the functionality of the \"traceroute\" tool and how it can be used to trace the route between two remote hosts or to trace paths for traffic of different IP Type of Service. Additionally, explain what information is displayed when a \"traceroute\" probe fails for a given hop.",
        "79eefa17-6114-4056-8fd1-d247427eba03": "Based on the information provided in Section 12.5, explain the purpose of the traceroute tool and how it can help in diagnosing network issues. Include an example of a possible traceroute output in your explanation.",
        "6185be28-be61-491a-8634-8525734b5a00": "According to Table 12.1, what are the common failure indications of the traceroute tool? Describe a scenario where each of these failure indications might occur and how a network administrator might troubleshoot the issue.",
        "c0050614-d341-4348-a054-505e44774425": "Based on the information provided, explain how traceroute utilizes UDP packets and IP TTL values to determine the path to a destination host. Include in your explanation the role of ICMP TTL Exceeded and ICMP Port Unreachable messages in the traceroute process.",
        "5ad103c6-50c9-469e-9f81-05a2159ba88e": "Describe pathchar, a tool extended from traceroute, and how it differs from the original traceroute tool. Explain how pathchar analyzes the performance of the path, including its estimation of bandwidth, propagation delay, packet loss, and queuing delay for each link in the path.",
        "816b2965-378c-42c7-b256-2ad8d88f4f35": "Why is the size of the UDP packets used by the traceroute tool set to 38 bytes, and how can this size be changed for diagnosing routing problems?",
        "20304700-f261-4d5b-a446-3131d8af6fa8": "Describe a scenario where a traceroute may not provide accurate information about the path to a destination host and explain the reason behind it. Also, suggest a workaround for this issue.",
        "383686eb-4a3b-45ee-b95d-412b2e2be3af": "Explain the role of SNMP in monitoring and controlling Internet devices. How are routing tables and routing protocol state dumped and examined using SNMP?",
        "1ba4ab8f-3b16-4843-a633-6704f9644b39": "Compare and contrast the following MIBs in terms of their purpose, features, and limitations: MIB-II, the IP Forwarding MIB (RFC 1354), the recently revised IP Forwarding MIB (RFC 2096), the OSPF MIB (RFC 1850), and the BGP MIB (RFC 1657). In what scenarios would each MIB be most useful for debugging routing problems?",
        "2ef6e18b-151b-4fdd-9b5e-d0ac77e560da": "Explain the role and functionality of the RIPv2 MIB, as described in RFC 1724, in the context of network management using SNMP. In your answer, include the types of data that can be accessed and the SNMP packet types used to interact with this MIB.",
        "148b3760-053e-448d-98cb-11548a0753fa": "Describe the structure and purpose of the Object Identifiers (OIDs) in the SNMP protocol. In your answer, explain how OIDs are used to identify instances of data within a device and how they are organized into groups, tables, and MIBs in the SNMP tree structure. Additionally, provide an example of an OID and its corresponding ASCII name.",
        "86a94374-5257-4dcd-8c54-3f6a3dbd673e": "Why is the implementation of MIBs beyond MIB-II not consistently supported by vendors, as mentioned in the document? What might be the implications of this for network management?",
        "a3550532-3966-4d34-a288-28801e593941": "The document mentions that when MIBs are implemented, they often contain a large amount of data, which can make finding specific information challenging. How can the use of MIB-based tools help address this issue, as described in Section 12.7?",
        "f6d9dec8-60a4-4feb-abd9-27bc7bf64a80": "Explain the limitations of using SNMP as a debugging tool for Internet devices, considering aspects such as security provisions, processing of SNMP GetRequests and GetNextRequests, and the reliance on communication with the device.",
        "f96a1341-5515-4d4b-ae58-72c83f7f5cfc": "Describe the role and features of MIB-based tools in network management, including their ability to automate SNMP data retrieval, organize and display data, and provide MIB browsers and compilers. Provide an example of a specific task for which a MIB-based tool could be built easily.",
        "24528bf8-319b-43e3-9514-d9e655dcff8b": "Based on the information provided, explain the purpose and functionality of the \"ospf query\" program written by Tom Pusateri. What are the command line options available with this program and how do they help in managing OSPF networks?",
        "249941fb-1bf9-461a-85e7-43ee27f879b5": "Compare and contrast the ease of building MIB tools for specific tasks versus developing general-purpose SNMP network management stations. What role do publicly available SNMP programs, user interface and scripting libraries, commercial databases, and other management protocol stacks play in these development tasks?",
        "d8d950af-b5d0-421d-a9dd-bc28f8bbfe0e": "What is the main advantage of SNMP tools, as mentioned in the text, and what is one potential issue with SNMP MIBs that can be a disadvantage when using SNMP tools?",
        "27799913-a335-4ef3-89ab-d6ea7055cc12": "Answer the following question:",
        "0b6df22f-b4a5-4830-9d8a-2134fc9aac70": "a) The main advantage of SNMP tools is their vendor independence, meaning they can provide graphical configuration and monitoring tools for any device that implements standard SNMP MIBs. One potential issue with SNMP MIBs is that many are not widely implemented, which can limit the functionality of SNMP tools.",
        "12d9cd92-ddb6-4f3f-a190-7b08dd2a1fca": "Network analyzers are tools used for troubleshooting and monitoring networks, as well as for developing and debugging protocols. What is one feature of network analyzers that can help with analyzing packet contents, and what is an example of a protocol for which parsing routines can be written?",
        "2f195be7-9f01-4fee-966e-9a48c730e42e": "Answer the following question:",
        "240a2094-bc62-4663-87e3-a6c218b15ac6": "a) Network analyzers can decode packets of a given protocol into fields to make analysis of packet contents easier. An example of a protocol for which parsing routines can be written is the OSPF protocol.",
        "6fdc3381-d49e-48c7-a1ae-f0a00024bdc5": "Based on Figure 12.8 in the text, what information can you gather from a packet trace using a Network General Sniffer?",
        "d193d13b-f9f5-4ddd-bfaf-e6298ccfcf0a": "Explain how the example in Figure 12.8 could be used to help debug routing problems as discussed in Chapter 12 of the text.",
        "807d607d-2557-4d0e-b291-e16e66cc7487": "Based on the context information, describe the functionality of the tcpdump program and explain how it collects packets for analysis.",
        "ebc80bfb-0e5f-4680-999e-54b05b1142c3": "What is Remote Network Monitoring (RMON) as described in RFC 1757 and how can it be used for packet capture and analysis? Include in your answer a description of how a host or router can be configured to implement RMON.",
        "6505a24e-9ddb-4137-9972-2577d1d2da3d": "Why are network analyzers considered invaluable for debugging complex protocol interactions, and what are some of the strengths and weaknesses of using them as a diagnostic tool?",
        "b724217f-6b08-4cd1-a693-734ea1902b54": "In the context of the document, network analyzers are described as being extremely useful for debugging complex protocol interactions. Can you explain why this is the case, and what specific strengths and weaknesses are associated with their use as a diagnostic tool? Please be sure to draw on examples and details provided in the text to support your answer.",
        "4cce0f27-0a37-4d12-95f2-18dc8556aa1f": "How do privacy and security concerns factor into the use of network analyzers, and what measures can be taken to mitigate these risks?",
        "3fddd47e-73ce-468d-a58e-e9347cb89da5": "The document notes that the use of network analyzers can raise privacy and security concerns, as they capture all traffic transmitted on a given network segment and can potentially be misused to capture sensitive data. Can you explain how these risks arise, and what steps can be taken to mitigate them? Please be sure to draw on examples and details provided in the text to support your answer.",
        "75d0391c-f0ba-453b-a21f-8446c92ccf53": "Based on the information provided, what is the purpose of the \"ripquery\" program and what kind of output does it produce, as shown in Figure 12.9?",
        "14b037d8-59ec-4508-bea8-cd5f996b0d79": "Explain the functionality of the \"ospf_monitor\" program, including the information it can display and the types of OSPF-related data it can provide. Additionally, describe the authors of this program.",
        "9c4a246d-968d-4dfe-97d9-0de839e4ccb9": "Based on the information provided, how does the mrinfo program query the state of a DVMRP router, and what kind of information does it display?",
        "afda0fed-0f9a-4ea3-b72c-bd56df6bb873": "In the context of OSPF routing protocol, how can an instrumented OSPF implementation be used to monitor the routing domain and locate issues such as flapping links or duplicate OSPF router IDs? Explain with examples.",
        "9ee5675e-8e9a-4f2d-a6e2-acd821b79254": "Why is it generally difficult to retrofit diagnostic capabilities into a routing protocol that did not include them from the start, as mentioned in the context? Provide an example to support your answer.",
        "bf94c668-e6ef-4a39-8cbc-17aec15bf83b": "List and briefly describe three monitoring commands or tracing facilities that have been built into most OSPF implementations, as mentioned in the last paragraph of the context. Explain how these features could be useful for troubleshooting and monitoring a network.",
        "b524d429-9f2d-48d3-bead-7e0d14c32192": "Based on the information provided in the context, explain the purpose and functionality of OSPF's link-state database and database synchronization procedures. What commands can be used to examine these features in an operational OSPF network?",
        "d2f5b46b-901a-487b-a3a9-3f7e5fdeb2d8": "Describe the use and functionality of the multicast traceroute tool, mtrace. How does it differ from unicast traceroute and what are its benefits in troubleshooting multicast datagram delivery issues?",
        "e6618314-92b9-46e1-ae26-bc6c78f57931": "What is the purpose of using Multicast Traceroute and how does it differ from traditional traceroute methods? Provide an example of a situation where Multicast Traceroute would be particularly useful.",
        "decd65ab-d964-4cde-aa5a-1b1e89e48826": "Explain the process of how Multicast Traceroute works, highlighting the key differences in message transmission and response handling compared to traditional traceroute. Include a description of the role of the receiver group in this process.",
        "a7c16ff8-6024-4f3a-83a6-121fad675da9": "Explain the role of the mtrace program in identifying multicast routing problems. How does it help in discovering configuration errors and detecting congestion along the multicast path? Provide an example of the information mtrace provides in its output.",
        "bc9dd419-09ca-4c77-841c-f3bfcc56593e": "In the context of multicast delivery, what are the additional semantics of the IP TTL field beyond simple hop count? How does mtrace utilize TTL information to help find problems affecting multicast datagram delivery? Describe a scenario where incorrect TTL threshold configurations could lead to multicast delivery issues.",
        "db7d2173-a7ce-438e-8450-7b0ee6461bc2": "Based on the context information, explain the concept of Multicast Traceroute (mtrace) and describe the error reports that a router may issue during the tracing of multicast datagrams. Provide an example of mtrace output and explain how it differs from the output of traceroute.",
        "ae63f5ee-17ef-496e-8a04-c199a852027d": "Describe the two additional IGMP packet types, OxlF and OxlE, that were created to implement mtrace. Explain their purpose and processing in the context of multicast datagrams. Additionally, discuss a scenario where these packet types would be used and their significance in troubleshooting multicast network issues.",
        "d693f81f-1515-46ad-a901-6f63eb4bc159": "Explain the process of executing the mtrace program to debug multicast routing problems. What information is reported by the multicast router at each hop and under what conditions does the forwarding of the traceroute request packet stop?",
        "7e470645-112b-4d23-935c-7402b07490b1": "Compare and contrast the process of tracing a multicast datagram's path using traceroute request packets and using SNMP and the multicast forwarding MIB. What are the advantages of using traceroute requests in this scenario?",
        "36a0687c-f3b1-485e-a536-20a840d93dd4": "Explain the concept of multicast traceroute and how it differs from unicast traceroute. What are the \"weak points\" of multicast traceroute, as described in the text?",
        "40657792-b9bb-4101-9702-93952bb36390": "The text mentions several tools and resources for network monitoring and management, including the Tk/TCL toolkit, Perl, and the MBONE. Choose one of these tools and explain its purpose and functionality. Additionally, provide a specific example of how it can be used for network troubleshooting or management.",
        "bd4ff663-3f75-4a13-8c9c-b4450c46fc58": "Question (Quiz/Examination): Explain the purpose and significance of the Routing Server created as part of the NSF-funded Routing Arbiter project, and describe how it is built on top of gated.",
        "173de5dc-62e6-4d60-80bc-ed37de07d3ec": "OR",
        "519aac52-d3d7-4458-b73b-511017f7992b": "Question (Quiz/Examination): How would you modify the ping program to return whether the destination is reachable and, if so, the number of hops to the destination, assuming a symmetric path? Provide a brief explanation and pseudo-code for your solution.",
        "3a42e6a1-3c7f-4c98-955c-23cdee6c99ee": "Note: The first question is more conceptual and factual, while the second question is more hands-on and technical. Both questions are diverse in nature and cover different aspects of the document.",
        "a182caec-3f49-4f44-8f00-a30f5cda2854": "Question for Chapter 13: Compare and contrast RIP and OSPF, highlighting their neighbor discovery, distribution of routing data, and routing calculation mechanisms. Briefly explain how routing information is exchanged between these two routing protocols.",
        "3bcf80cf-d1e2-44f7-853f-8758b54f4c32": "Question for Chapter 14: Describe the operation of broadcast-and-prune protocols in multicast routing. Identify and explain the main differences between DVMRP and PIM Sparse multicast routing protocols.",
        "0227c4e7-9f1d-455e-9293-4d4c4ae113cd": "Based on the classification of TCP/IP routing protocols in the table provided, categorize the following protocols as either Distance Vector or Link State: GGP, Hello, RIP, IGRP, BGP, OSPF, Integrated IS-IS.",
        "64c6ac9c-cce9-42cc-ab27-d93cfee11fd7": "Explain the difference between IGPs (Interior Gateway Protocols) and BGPs (Border Gateway Protocol) in the context of unicast routing protocols used in today's Internet. Provide an example of a scenario where each type of protocol would be used.",
        "2f3cbf11-e959-4f9e-98b7-1d8db6754a17": "Question (Neighbor discovery and maintenance): Describe the methods used by routing protocols for neighbor discovery and maintenance. How does a router determine if a neighboring router has failed, and how does it update its routing information accordingly?",
        "a461ae08-aa6b-4e72-a323-45ac2a8fa31e": "Question (Policy controls): Explain how network administrators can use policy controls to influence the path calculation of routing protocols. Provide examples of scenarios where policy controls might be used, such as keeping traffic within a particular network or avoiding traffic from certain autonomous systems.",
        "28fb33a0-e526-4d3d-9151-d6cc30720d67": "Explain the role of BSD UNIX in the development of TCP/IP and the Internet, with a focus on its contribution to the creation of the Routing Information Protocol (RIP). How did the BSD networking developers adapt XNS RIP to make it multiprotocol?",
        "a6d35e7d-f526-4511-8888-0701c15bcf38": "Describe the operation of RIP as a Distance Vector protocol and its use as an IGP within the Internet. How does RIP employ a distributed computation scheme to allow routers to cooperate and update their routing tables? Additionally, explain the necessity for the development of RIPv2 in support of Classless Inter-Domain Routing (CIDR).",
        "58e077c6-2828-4439-b1b1-f9ba60f8800a": "Explain the process of route distribution in RIP and how it differs from OSPF and BGP in terms of data storage.",
        "bf20350c-7617-490d-a3a6-45e57be2035f": "How does RIP handle changes in the network and what are triggered updates? Describe a scenario when triggered updates would occur and how they help in maintaining the accuracy of the routing table.",
        "1a878ce1-6666-4e44-bf5f-d5148d4be694": "Explain the concept of \"routing filters\" in the context of RIP and how it allows the implementation of routing policies. Provide an example of how a network administrator can use routing filters to control which subnets a RIP router will advertise.",
        "64e6dcce-e1c4-4b6b-9b06-b1b553bb2602": "Compare and contrast the convergence behaviors of RIP and RIPv2. How does RIPv2 support CIDR and what additional fields does it advertise with each route? Explain the purpose of the \"next-hop\" field in RIPv2 and how it helps eliminate extra forwarding hops at the edge of a RIP routing domain.",
        "fb3ac206-2fc9-4b23-91b0-df339f7db647": "Based on Chapter 13I of the textbook \"280 Unicast Routing Protocols,\" explain the key differences between distance vector and link state routing protocols. Provide examples of each type of protocol and discuss their advantages and disadvantages.",
        "bfab05bb-769f-45b3-8a1b-816d60f5afab": "Consider a network engineer who is configuring a router using a specific unicast routing protocol covered in Chapter 13I. Describe the steps this engineer would follow to properly configure and verify the operation of the chosen routing protocol on the router, including any necessary neighbor relationships or network topology updates.",
        "cf700707-3ade-4d6c-a059-7c92ff02945d": "What is the main difference between RIPv2 and OSPF, and in what type of network environments would each be more suitable?",
        "e5d55d8b-2db3-430c-a5c9-1fa3b6133e5c": "The text describes RIPv2 as a distance-vector protocol that uses hop count as its metric, while OSPF is a link-state protocol that constructs a distributed database of the network topology. OSPF is designed for the Internet and is recommended by the IETF as the IGP for the Internet. It provides quick convergence with only a small amount of routing control traffic, even in ASs with a large number of routers. On the other hand, RIPv2 may be more suitable for smaller networks with fewer routers.",
        "30e0207a-4e43-44b0-8b56-c2e0f9ffa063": "For the second question, you could ask:",
        "bb2865ed-c3d3-4467-9e5a-5c9caf591954": "Explain how OSPF maintains a synchronized link-state database between routers.",
        "11bca7e3-c03f-426f-a156-9843c7db73d6": "The text explains that OSPF uses multicast OSPF Hello packets to discover neighboring OSPF routers and synchronize link-state databases with them. The link-state database is a distributed replicated database that contains information about the network topology. As long as every OSPF router has an identical link-state database, OSPF calculates loop-free paths. Most of the protocol machinery within OSPF is dedicated to keeping the database synchronized between routers.",
        "487582c7-be35-4b3a-ad75-dd95d2541973": "Explain the process of how a new connection is advertised and integrated into the OSPF network using the link-state advertisement (LSA) and reliable flooding mechanism. What algorithm is run by the routers as a result of receiving the new LSA and how does it affect the path characteristics in the network?",
        "8f1cec9a-c973-41a5-9f3c-be39d0f68008": "Describe the two-level routing hierarchy implemented in an OSPF domain using OSPF areas. How can routing information from other protocols be imported into the OSPF domain and readvertised as external routing information? Additionally, explain the role of the network administrator in assigning costs to the output side of each router interface and how this affects the path selection process.",
        "1d21a61e-b605-4020-85b9-db4ad10213af": "Explain the process of flooding in OSPF and its role in ensuring reliability and robustness of the routing protocol. Include in your answer the mechanism of LSA acknowledgement and retransmission, as well as the use of LS Age field for deleting LSAs.",
        "bd93580b-0199-4976-845c-bd1dfb9ca349": "Describe how routing policies can be implemented in OSPF using area border configurations. Explain the concept of route aggregation at area borders and how it can be configured by the network administrator. Also, discuss the impact of area border configurations on path selection in OSPF.",
        "9e0940de-6769-4add-9165-c98ce6e277d5": "Explain the concept of address ranges being configured as \"no advertise\" in OSPF and how it helps in keeping information about certain network segments local to a given area. Also, discuss how an external route tag is attached to each external route imported into the OSPF routing domain and its benefits in simplifying the configuration of redistribution into other protocols.",
        "b686c679-cedf-4608-8dcf-1f720dba026e": "Compare and contrast the security features of OSPF with the proposed stronger security measures using digital signatures for OSPF LSAs. Additionally, explain how OSPF keeps the size of its LSAs small and classifies them according to function, and how it was designed with variable-length subnet masks in mind.",
        "883b9c65-4923-44e6-a75e-d67ea4489c81": "Based on Figure 13.4, trace the OSPF protocol exchange between Router A and Router B. What type of OSPF packets are exchanged, and what information is included in these packets?",
        "72dc0381-f7a7-4786-bc4a-43072be2349d": "Despite BGP's crucial role in keeping the Internet running, it is rarely used in private TCP/IP networks. Can you explain why this is the case, and discuss some alternative interior gateway protocols (IGPs) that are commonly used in private networks instead of BGP?",
        "f50c295d-f1c4-4cfd-9f0f-bf8ff72cdccd": "Explain how BGP differs from a standard Distance Vector protocol, such as RIP, in terms of the way it handles routing updates and the maintenance of loop-free paths. In your answer, discuss the concepts of RIB-In, Keepalives, and the AS path.",
        "d78e0f76-8daf-490f-81d1-dd2d6262f010": "Describe the process of establishing a BGP session between two routers, including the role of BGP Open messages, BGP Update messages, and BGP Notification messages. Additionally, explain what happens when a BGP session with a peer is terminated, and the significance of the BGP router's RIB-In in this context.",
        "01181f58-5d61-4c22-8ad7-2a850bf2e6c6": "How does BGP prevent the formation of loops in contrast to standard Distance Vector protocols, using the example of the AS configuration in Figure 13.6?",
        "f4364d61-aab3-43d9-a07d-08c3f3f0c079": "Explain why BGP is referred to as a Path Vector protocol, and differentiate its update mechanism from that of standard Distance Vector algorithms.",
        "0fd5c2dc-22c3-4e78-a9d5-db13ddbf72ae": "Explain how BGP ensures loop-free paths and how it selects the most preferable path when multiple paths to a destination are available. What are some common policies used in BGP for path selection?",
        "93e807cb-1b38-46a5-919e-7e12f6d8f63d": "Describe the process of neighbor discovery and maintenance in BGP. How are BGP peers configured and how is the Hold Time negotiated between them? Also, explain how routing data is distributed in BGP and how it differs from other routing protocols in this aspect.",
        "52cae49a-8d04-4428-ba98-071bf1b57232": "Explain how BGP routers keep a prefix's AS path up to date, as described in the context information. In your explanation, include the role of prepending the router's own AS number to the prefix's existing AS path.",
        "d7438e3a-64f9-4825-8f23-d90949b4ebc8": "In the context information, a specific scenario is described where router G accepts and installs an update for 200.19.8.0/24 from router A with a certain AS. Describe a situation where this update process might not work as intended and why. Additionally, explain how BGP's design choices help to avoid common distance vector convergence problems, such as counting to infinity, in this scenario.",
        "effa3ef4-334c-4198-b2c6-268a04038898": "Explain the concept of \"Decision Process\" in BGP routing protocols and describe how it is invoked.",
        "c2ba37d4-7993-438c-9615-a1adf33f4027": "In the context of BGP, what is the purpose of an \"AS set\" and how does it help in aggregating routing information? Provide an example to illustrate its usage.",
        "20cee6ec-f972-496f-b7e7-b2bebded032d": "Explain how BGP routing policies can be configured automatically using ISP databases such as the RIPE database. Include a description of the security measures that are still needed to prevent denial of service attacks even with the use of MD5-based authentication algorithms in BGP.",
        "a0583f76-7f6d-4635-8451-d30c714b145c": "Discuss the potential problems that can arise when BGP does not have a true routing metric and instead allows routers to pick their routes based on configured policies. Provide an example of how grossly inconsistent policies can lead to routing oscillations and/or unreachable destinations.",
        "b9279487-0e2d-420e-b76a-ffcb5011e270": "Explain the main differences between BGP and IDRP, and discuss why IDRP was initially considered for IPv6 routing.",
        "56ca4805-4c72-4480-828d-7ac00007fc8f": "Describe the concept of full-mesh IBGP and discuss the potential issues that can arise from policy inconsistencies between IBGP peers.",
        "0e13d31c-1472-47f9-aee7-088e828c9b20": "Question: In the context of BGP route reflection, as described in Section 13.3 of the document, explain the role of a Route Reflector (RR) and how it forwards IBGP updates to its client peers and other regions. Also, provide an example by referring to Figure 13.8 and identify the Route Reflector in the leftmost region.",
        "7fb2f3df-dbb2-4cf9-a344-0ae17303acc1": "Question: The document discusses two significant proposals for avoiding the full-mesh IBGP requirement in BGP. BGP route reflection and BGP confederations are the two proposals. Compare and contrast these two proposals by highlighting their similarities and differences, and explain how they help in reducing the strain on BGP routers.",
        "e9898f30-e879-4d41-a015-cc97d4160f3c": "Explain the concept of IBGP mesh and IBGP route reflection, and how they help resist routing loops. Additionally, describe the two mechanisms employed by IBGP route reflection to prevent loops in the case of misconfiguration.",
        "ea847545-206a-4aff-9102-753770365c53": "Compare and contrast BGP confederations and BGP Route Servers. Include details about the handling of loops and the assignment of unique identifiers in each approach. Furthermore, explain how the use of an Interior Gateway Protocol, such as OSPF, can be utilized to propagate BGP information across the AS.",
        "3ed1a451-271a-49b0-a874-5c6c061b491c": "Explain the role of the AS\\_PATH attribute in BGP and describe how it is used to prevent routing loops. In addition, discuss the significance of the ORIGIN attribute and how it can be used in policy decisions.",
        "00e93cf2-2349-4f7e-afe9-cf86b4a61ff5": "Describe the function of the NEXT\\_HOP attribute in BGP and how it can be used to eliminate extra forwarding hops. Compare this to the concept of third-party routing information in other protocols, such as OSPF's forwarding address. Finally, explain the purpose of the MULTI\\_EXIT\\_DISC, LOCAL\\_PREF, and DPA metrics and how they are used in routing decisions.",
        "f016a476-326a-4e30-914f-3519fb709f0c": "Explain the concept of the Destination Preference Attribute (DPA) in BGP routing protocols and discuss its proposed use in encouraging symmetric routing in the Internet. Also, comment on its widespread deployment.",
        "45c82a06-032e-439a-ab37-2f72476aa7d5": "Describe the function of the COMMUNITY attribute in BGP and how it facilitates grouping prefixes for configured BGP policies. Additionally, discuss the transitivity of the COMMUNITY attribute and its treatment at AS boundaries.",
        "f76ff15a-0e13-4900-ade1-593decadae37": "Explain the concept of using IBGP between all routers in a default-free AS, also known as Universal IBGP. How does this approach help in reducing the size of routing tables and encouraging aggregation?",
        "a3767102-93a8-4c6b-9941-ae3e4bea0b00": "Describe the issue of BGP routing instability within the Internet and how route dampening is used to reduce BGP routing oscillations. In what scenarios would you want to find the ISP and people contacts associated with a particular AS number, and how can this information be obtained?",
        "094a885e-6fb0-4479-b40c-fad706fa514c": "Explain how IGRP calculates its composite metric for path selection and how it differs from RIP's hop count metric. Also, discuss how IGRP's composite metric allows for better path discrimination.",
        "982b5b36-9fef-4680-afc1-e5df8784e8a7": "Describe IGRP's approach to neighbor discovery and maintenance, and compare it with its approach to routing data distribution. Include in your answer a discussion of how IGRP responds to changes in the routing table and how it calculates the new routing table.",
        "3e92001d-eba9-437c-9ae9-bf0e073e7ef1": "Explain the concept of \"composite metric\" used in IGRP for path selection and how it is calculated. What factors does it take into account?",
        "58e5e91f-1547-4303-9e6f-6a5a2095659e": "In the context of IGRP, describe the purpose and functionality of \"routing filters\" used for implementing routing policies. How do they help in controlling which routes are advertised and received by IGRP routers?",
        "11099a12-0bed-4629-9dfd-4c13dc7b5a03": "Explain how EIGRP maintains loop-free paths and avoids counting to infinity in a network. In your answer, be sure to include the role of the Distributed Update Algorithm (DUAL) and the synchronization of distributed routing calculations across routers.",
        "7c3dfb0b-76be-4208-b400-05b50dbca41e": "Compare and contrast Integrated IS-IS and the alternative of running separate routing protocols for each protocol stack, which is referred to as \"Ships in the Night\" or SIN. In your answer, explain how Integrated IS-IS is an adaptation of the standard OSI connectionless data routing protocol, IS-IS, for IP routing.",
        "9d7fb753-c341-41a2-9660-83f0c092b98e": "Explain the concept of link-state PDUs (LSPs) in Integrated IS-IS and how they are used in the routing process. What is the significance of the pseudonode LSP in this context?",
        "cd6f2ff3-a78c-483d-aa52-3cc8e7ab4d0d": "Describe the process of neighbor discovery and maintenance in Integrated IS-IS. How does the Hold Time value contribute to the stability of neighbor connections?",
        "e37ed638-dc8f-438f-b2f4-9890e34ac405": "Explain the process of purging an LSP from the IS-IS routing domain. How does IS-IS ensure that the purging of an LSP is efficient and effective in removing it from all ISs' link-state databases?",
        "bc3e2925-5119-47b9-8ce5-637e3f1d6411": "Describe the role of area boundaries in Integrated IS-IS. How do area boundaries help implement policy controls and ensure that data traffic stays within a single area if possible? Additionally, explain how the security of Integrated IS-IS can be enhanced using PDUs authentication.",
        "c15b3710-255f-4e4a-8493-e57a216c1220": "How does IS-IS achieve flooding reliability over LANs compared to OSPF's approach? What are the advantages and disadvantages of this method?",
        "51fe61f3-22fa-47dc-8103-8fcffe3aee1d": "Compare and contrast the area routing scheme in IS-IS and OSPF. How do they differ in terms of physical connectivity, repair of area partitions, and hierarchical routing between areas?",
        "e25d112b-0cde-4cdb-a318-11b3b07255bd": "\"Compare and contrast the characteristics of GGP and EGP, including their routing metrics, packet formats, and convergence properties. Why was GGP declared down and replaced by EGP in the Internet?\"",
        "7038f624-4ad5-4ebd-bc56-0026da47581b": "\"Explain the concept of Inter-Domain Policy Routing (IDPR) and its differences with other Internet routing protocols. What features of IDPR, such as expressing sophisticated routing policies and superior security provisions, made it a potential replacement for the Internet's EGP protocol? Discuss why IDPR was eventually abandoned in favor of other routing protocols.\"",
        "949c9348-27f3-4682-8b4c-b68077cb27ff": "Question (Route Filtering in Multiple Routing Protocols): Explain how route filters are used in the context of multiple routing protocols in a router. Also, discuss the challenges in implementing route filters for routes learned by a link-state routing protocol such as OSPF.",
        "14f15eda-b68d-499a-9888-e223a766a769": "Question (Routing Metrics and Route Preference): Given the different routing metrics used by various routing protocols (OSPF, RIP, BGP, and Integrated IS-IS), discuss the challenges in deciding which routing protocol's route to prefer. Provide an example to illustrate your understanding of the concept.",
        "a3f365c5-63ae-49c9-9906-9771e5ca56a2": "Why is information loss during readvertisement a concern when transporting BGP routing information across Autonomous Systems (ASs), and how does IBGP address this issue?",
        "ef37e007-d4e8-4c5b-94fa-3befd23153c2": "In the context of the GATED program, explain the process of arbitrating between multiple routing protocols wishing to write the same routing table entry. Additionally, describe how to configure GATED to accept specific networks from BGP and RIP neighbors, and how to handle situations where the same network is received from both protocols.",
        "80d32328-107e-4d26-b277-b22cdcd87066": "Based on Figure 13.9 in the context, explain the interaction between different routing protocols in GATED. Provide an example of how two routing protocols (e.g., BGP and RIP) might interact with each other and how a network administrator might configure this interaction.",
        "689bfb47-ff17-43ac-b047-860737e7e005": "In the provided configuration snippet, identify the routing protocols being used and their respective configurations. Explain the purpose of the 'autonomoussystem' and 'gateway' statements in the context of the routing protocols. Additionally, discuss the significance of the 'preference' values and how they influence the routing decision-making process.",
        "ab929301-db39-4259-bd66-6e2879a68317": "Question (Short Answer): Based on the information presented in the table, categorize the following multicast protocols into either source-based trees or shared tree: DVMRP, MOSPF, PIM Dense, PIM Sparse, and CBT.",
        "0c82697f-2182-4cc3-8558-a81f71ea7197": "Question (Essay): Compare and contrast the operation of source-based trees and shared trees in the context of multicast routing protocols. Provide specific examples of when each type of tree would be appropriate, and explain how each of the following protocols builds and maintains its tree: DVMRP, PIM Dense, and PIM Sparse.",
        "97a82a2c-d5d3-4bc3-bf5e-4edfdad7e125": "\"Can you explain the difference between how DVMRP and MOSPF advertise source information in multicast routing protocols, and how Protocol Independent Multicast, Dense Mode (PIM Dense) constructs the path of each multicast datagram? Provide examples of when each method would be appropriate.\"",
        "7225ba8c-c051-4801-b379-167b254a41e0": "\"Describe the concept of broadcast-and-prune protocols in source-based multicast protocols. How does this approach initially build the source-based tree and how does pruning work in this context? Provide an example of a situation where a router would send a Prune message to its upstream neighbor.\"",
        "b0b8c6d1-fcca-43c7-aeb9-3234c4a085a3": "Explain the process of the broadcast-and-prune protocol in the context of the multicast network example given in Figure 14.1. How do prune messages and graft messages affect the tree formation and what is their significance in making the routing robust?",
        "d6f460be-8ff0-4e6c-9841-8fd749dbb517": "Compare and contrast the data-driven actions in a router during the forwarding of a multicast datagram with the control-driven actions of MOSPF protocol. How does MOSPF's group membership information broadcasting help in avoiding the broadcast-and-prune procedure entirely?",
        "a8d624bc-9c8b-4afd-b131-59846904fc63": "Explain the process of how DVMRP routers calculate the previous hop on each multicast source's path in DVMRP. What convergence problems are associated with this process and how does DVMRP attempt to improve convergence?",
        "a3840f06-0aaf-4c97-bf26-3d212db80f70": "Describe the role of Route Reports in DVMRP and how they are used to initiate the pruning process and eliminate equal-cost paths to group members. Provide an example using the figure 14.1 provided in the context.",
        "5a27c4a3-a0a7-45b2-840b-cf57f1ba8821": "Explain the concept of Group-membership-LSAs in MOSPF and how it helps in the multicast routing process.",
        "8ad4d377-a7fe-4938-b786-ffb07fca6081": "How does MOSPF optimize network bandwidth usage in the MBONE through the examination of a multicast datagram's TTL? Describe the conditions under which a MOSPF router would discard a multicast datagram.",
        "115d34e6-8d20-4980-87a1-85e0ef559a76": "Explain the concept of",
        "d28968db-bedb-4f51-97cc-b6d76770fe48": "Question (Short Answer): Explain the role of the Designated Router in both PIM Sparse and CBT multicast routing protocols. How does the Designated Router facilitate the addition of a new branch to the shared tree in each protocol?",
        "bb7d239c-c741-4dfb-a4d0-764ef4a26723": "Provide a brief explanation of the Designated Router's role in both PIM Sparse and CBT multicast routing protocols. Describe how the Designated Router helps add a new branch to the shared tree in each protocol when a host joins a multicast group.",
        "d402bb33-ff4b-4cc3-b704-ae20d944bdff": "Question (Essay): Compare and contrast the mechanisms for maintaining and tearing down shared trees in PIM Sparse and CBT multicast routing protocols.",
        "c0d2a03e-6bf2-459e-8d42-f37e1e67a748": "Discuss the mechanisms used in PIM Sparse and CBT to maintain and tear down shared trees when hosts join or leave a group. Include details about the message types and procedures involved in each protocol. Finally, evaluate the advantages and disadvantages of each approach in different network scenarios.",
        "10436c41-9007-43a6-9acd-9b3c2f464b5b": "\"Can you explain the main difference between source-based multicast routing protocols and shared-tree multicast routing protocols, as mentioned in the context?\"",
        "a8dfeefd-1632-4a12-92cc-836ebfdd0407": "\"Based on the context, what can you say about the progress of connecting specific multicast protocols and the development of routers that attach MOSPF and PIM domains to the MBONE's DVMRP? Also, briefly describe the proposals that have started coming out of the IDMR Working Group for structuring interactions among various multicast routing protocols.\"",
        "66301e41-8144-4c16-8159-87b7e065eb1c": "Explain the concept of \"Address Lifetime Expectations (ALE)\" and describe its significance in the context of Internet Protocol version 6 (IPv6). What are the key factors that influence the ALE value?",
        "3b9ca290-1045-4149-bb69-1330ec40734a": "What is the Routing Policy Specification Language (RPSL) and how does it aid in the configuration and management of routing policies in the Internet? Describe the main components of an RPSL document and provide an example of its usage.",
        "6d7165bc-f4cf-4abe-8e86-dec4dd7cfe9e": "Question: Can you explain the purpose and significance of OSPF Version 2 Management Information Base as described in RFC 1850?",
        "e980dc8b-93a7-44de-8239-04247392050c": "OR 1. Question: Explain the concept of Core Based Trees (CBT version 2) Multicast Routing Protocol Specification as outlined in RFC 2189.",
        "2c851534-d495-400e-ba42-a2f6299a463d": "Question: What are the requirements for IP Version 4 Routers as described in RFC 1812?",
        "f0312b24-531f-4ae3-a467-d42898724b69": "OR 2. Question: Explain the use of OSI IS-IS for Routing in TCP/IP and Dual Environments as described in RFC 1195.",
        "aba37a44-6f43-4231-bb20-d8bbacebdb46": "Note: The first question in each pair is more specific and requires a deeper understanding of a particular topic, while the second question in each pair is more general and covers a broader range of knowledge.",
        "4db18b1f-9396-4d5b-8d32-09afb8c973be": "Explain the purpose and benefits of the OSPF for IPv6 protocol, as described in RFC 2740. What are the key differences between OSPF for IPv4 and OSPF for IPv6?",
        "7a52fcb2-a1e4-47a1-808f-693c91fd32c8": "Describe the concept of Service Allocation in the Internet, as presented in the work in progress by Clark and Wroclawski. How does this approach aim to address the challenges of resource allocation and management in the Internet? Provide examples to support your answer.",
        "eacda8ee-1ca7-456d-9727-1b13c26939f3": "Explain the concept of \"Reverse Path Forwarding of Broadcast Packets\" as described in RFC 1972 by Crawford. What problem does this method aim to solve and how does it work?",
        "7bf21773-722c-4e9a-a007-1721fc47f9ed": "Compare and contrast the two multicast routing papers by Deering: \"Multicast Routing in Internetworks and Extended LANs\" (ACM SIGCOMM Summer 1988 Proceedings) and \"Multicast Routing in a Datagram Internetwork\" (Stanford Technical Report STAN-CS-92-1415). What are the key similarities and differences between these two papers, and what can we learn about the evolution of multicast routing from comparing them?",
        "d2a67a1a-7ff9-4dad-9845-3460344b2627": "Explain the concept of Classless Inter-Domain Routing (CIDR) and its significance in the context of the IP Internet. What are the benefits of using CIDR, as described in RFC 1519?",
        "f18e582e-f2d3-413f-962f-f808806ba8ef": "Describe the \"Random Early Detection Gateways for Congestion Avoidance\" mechanism presented in the paper by Floyd and Jacobson. How does this approach help in managing network congestion and improving overall network performance? Include any relevant insights from the authors' other works on link-sharing and resource management models for packet networks.",
        "1d74a408-fb55-4a00-acdc-bb986ed0f88e": "Explain the purpose and functionality of the Open Shortest Path First (OSPF) protocol as described in RFC 322. What issues in routing for large and dynamic networks were discussed in Hagouel's Ph.D. thesis (Reference 88)?",
        "8d698b46-e6a6-4fd7-b1f1-09bf77ba2abb": "Describe the S/KEY One-Time Password System presented in Haller's paper (Reference 90). How does the Virtual Router Redundancy Protocol (VRRP) work, as mentioned in Hinden et al.'s work in progress (Reference 100)? Provide a brief overview of its purpose and functionality.",
        "c35e69bd-7022-409d-93f7-64701db4aca7": "Explain the purpose and significance of the Open Shortest Path First (OSPF) protocol as described in RFC 1370 and",
        "afc7b183-a38f-48c8-9d81-aec3a0c426d6": "Question: Explain the key idea behind the paper \"Fragmentation Considered Harmful\" by Kent and Mogul (RFC 125). What problem does it address and what solution does it propose?",
        "b3969a00-19b5-45a6-8ee1-23dec7f87437": "OR",
        "b1d97bbe-7bac-446c-982d-e12f63ef3f7e": "Question: Describe the purpose and significance of the Hot Standby Router Protocol (HSRP) as presented in the work in progress by Li et al. (RFC 136). How does it work and what are its potential benefits?",
        "5ce912b6-bc8b-4427-bc5d-b7a7f16e91ba": "---",
        "84fab205-2f69-4bc2-9f89-c33600a18058": "Question: In the paper \"Hierarchical Routing for Large Networks: Performance Evaluation and Optimization\" by Kleinrock and Kamoun (1977), what are the main advantages of hierarchical routing in large networks? How does it improve network performance and efficiency?",
        "9e4cdcf0-94c7-450b-9026-7d6d2c74cfad": "OR",
        "15c36943-d3d8-4ff7-8157-306e420d9a9a": "Question: Explain the Border Gateway Protocol (BGP) as described in the RFC 1105 by Lougheed and Rekhter. What is its role in internet routing and how does it differ from other routing protocols?",
        "67f17d70-8bf5-49c5-891e-05561361e4db": "---",
        "8fbab345-e1dc-4d15-813d-c4488dbcf76c": "Question: In the work in progress by McCloghrie, Farinacci, and Thaler, what is the Internet Group Management Protocol MIB and what is its purpose? How does it help manage and monitor internet group communication?",
        "43008b17-cc96-44ff-baea-89de2ff5e9e8": "OR",
        "8837ba36-9bc8-4215-a0b7-ab9fef82bfe8": "Question: Describe the significance of the Transmission of IP Datagrams over the SMDS Service as presented in RFC 1209 by Lawrence and Piscitello. How does it enable the integration of IP datagrams with SMDS networks and what are its potential benefits?",
        "b1a5ffe7-ee3a-4755-b86b-83528ba1ff0f": "Explain the purpose and significance of the \"IP Multicast Routing MIB\" document (RFC 1422) by McCloghrie, Farinacci, and Thaler. What are the potential use cases and benefits of implementing this MIB in a network management system?",
        "f344a8e6-e690-4132-93ac-289bfade9fde": "Analyze the \"SPF Routing in the Butterfly Gateway\" presentation (April 1987) by Mallory. What are the key features and advantages of the Shortest Path First (SPF) routing algorithm in this context? How does the SPF algorithm contribute to improving the performance and efficiency of the Butterfly Gateway?",
        "b4f24663-84d7-41fa-9093-fe9d1b913df6": "Explain the concept of \"Path MTU Discovery\" as described in RFC 1191 and provide an example of how it is used in network routing.",
        "4a597577-633c-4e56-b568-abec02992eb4": "Compare and contrast OSPF (Open Shortest Path First) as described in RFC 1131, RFC 1247, and RFC 1583, highlighting any major changes or improvements made in each version. Additionally, explain the use of digital signatures in OSPF as described in RFC 2154.",
        "2241011c-d228-4161-bcf8-babee4a793d6": "Explain the concept of \"IP Encapsulation within IP\" as described in RFC 2003. What are the use cases and benefits of this technique?",
        "8dd220eb-d0e0-41f4-96d7-38d74d34d4d0": "Compare and contrast the two Interior Gateway Protocols (IGPs) IS-IS and OSPF. Discuss their strengths and weaknesses, and when an engineer might choose one over the other. Include at least two references from the provided bibliography in your answer.",
        "129f5fd1-58a2-4b05-a906-25e6fb2a5678": "Explain the purpose and significance of \"Address Allocation for Private Internets\" as described in RFC 1918. What are the benefits of using private IP addresses and how does it help in conserving global address space?",
        "4c017b30-f705-49da-8a97-836558e22f0f": "Describe the role and functionality of the Remote Authentication Dial-In User Service (RADIUS) as outlined in RFC 2138. How does RADIUS help in managing and securing network access for remote users? Provide an example of a scenario where RADIUS would be beneficial in a network environment.",
        "ab318786-8998-438b-9343-9abf021704e0": "Explain the purpose and functionality of the Point-to-Point Protocol (PPP), as described in RFC 1548. What makes it important in networking environments?",
        "e9ccf607-b51a-4c24-9a9a-998c6fcb34f6": "Describe the concept of \"Kerberos: An Authentication Service for Open Network Systems\" as presented in the Usenix Conference Proceedings from February 1988. How does this system enhance network security and what are its primary components?",
        "a8f4e212-c5ca-43b5-ab41-5fd1469bdbfc": "Explain the concept of \"Scalable High Speed IP Routing Lookups\" as described in the ACM SIGCOMM '97 paper by Waldvogel, Varghese, Turner, and Plattner (document number 257). What problem does it aim to solve and how does it propose to improve IP routing lookups?",
        "7d90057b-aa77-40e9-a7c5-7d76a42ff7ec": "The document contains several references to routing protocols such as OSPF, BGP, IDRP, and DVMRP. Choose two of these protocols and explain their main differences and use cases in a networking context. Justify your answer by citing the relevant document numbers.",
        "8e00b5f0-5bb5-43a2-9425-6ff09939afc4": "Explain the concept of address scoping in the context of IP routing and provide an example of how it is used in multicast addressing.",
        "3c4c3ae2-c18e-4d30-b537-ec92a1099b73": "Describe the role of ABRs (Area Border Routers) in OSPF and explain how the process of aggregation is implemented in OSPF for summarizing routes. Additionally, provide an example of a scenario where the use of ABRs and route aggregation would be beneficial in a network design.",
        "e6a535de-d7e3-4bcd-8b20-cdc6da403fd0": "Explain the role and configuration of Area Border Routers (ABRs) in OSPF areas. Include a description of their function and where they would be used in a network.",
        "e89e855d-1c81-48db-a884-a6c230ede8da": "Describe the problem of broadcast storms in broadcast subnets and how OSPF addresses this issue. Include an explanation of the database synchronization process and neighbor discovery and maintenance in broadcast subnets.",
        "1b39459a-65da-43be-aed4-78929c5aae70": "Explain the concept of CIDR (Classless Inter-Domain Routing) and its role in hierarchical routing. Include an example of how CIDR blocks are represented in notation.",
        "49bbf805-104a-434e-aba8-71dfccaf9016": "Describe the process of database synchronization in OSPF and its importance in maintaining a consistent link-state database. Discuss the use of Database Description packets and the Database Exchange procedure in this process. Additionally, explain how database synchronization is achieved over Demand Circuits using the Demand Circuit extensions.",
        "2ec8df78-6faa-4f96-9018-6e3ea3c37066": "Explain the concept of Designated Routers (DRs) in the context of OSPF and other routing protocols. What is their function and how are they elected? Include a description of the role of DRs in database synchronization and in different network environments such as NBMA subnets and PIM Sparse.",
        "8f97892c-a542-470e-8ee6-d07c51e959ea": "Compare and contrast Distance Vector and Link-State routing protocols. What are the advantages and disadvantages of each type? In what scenarios would you use one over the other? Provide examples of specific routing protocols that fall into each category and explain how they address issues such as convergence and counting to infinity.",
        "3b229b2f-30a5-4c9d-aaaa-f79c05aa2639": "Explain the concept of \"External routing information\" in OSPF and discuss the differences between External Type 1 and External Type 2 metrics. What is the purpose of external route tags in OSPF and where are they used in AS-external-LSAs?",
        "e01a6c68-0403-4754-b02c-b7bc0da20ff8": "Describe the role of Area Border Routers (ABRs) in OSPF and explain the concept of ABRs becoming fully adjacent. What are some common configuration difficulties with ABRs and how can MaxAge LSAs be installed on them? Additionally, explain the purpose of Designated Router with Backup Designated Router in OSPF.",
        "746535e6-04e1-4350-91b2-00402f8c91b9": "Explain the concept of hierarchical multicast and its implementation in MOSPF. Include in your answer the advertising information and routing calculations involved in hierarchical multicast.",
        "40e8d5ed-1b77-4400-a4ec-693a3d142491": "Describe the role of IBGP (Internal Border Gateway Protocol) in OSPF areas and its interactions with external routing information. Additionally, explain the concept of full mesh IBGP and its alternatives.",
        "0c55d994-2416-4e30-ba48-75a70fb65ff1": "Explain the concept of Intermediate Systems (ISs) in the context of the IS-IS routing protocol. What is its role and how does it differ from other routing protocols mentioned in the text?",
        "af5d69e5-7656-46af-ad09-70711446fafc": "In the context of multicasting, describe the process of \"Leaf detection\" in DVMRP and PIM Dense mode. How do these protocols use this mechanism to improve the efficiency of multicast traffic? Additionally, explain the concept of \"Leave latency\" and its significance in IGMPv2 and IGMPvS.",
        "e1d1c27c-6bb7-4008-98dd-7a446a4412b1": "Explain the role of Link State Advertisements (LSAs) in the OSPF routing protocol. In your answer, describe the process of LSA synchronization and the significance of MaxAge LSAs in the link-state database.",
        "8ba2c5bf-3593-4585-a067-4c118dc8c5e9": "Discuss the concept of Management Information Bases (MIBs) in the context of OSPF. How do MIBs aid in debugging routing problems and managing OSPF protocol monitoring? Additionally, briefly explain the role of SNMP in managing MIBs.",
        "96d98267-5c62-4da5-a27f-a2287e113f1b": "Explain the concept of Multicast Extensions to OSPF (MOSPF) and its role in multicast routing. Include in your answer the explanation of backward compatibility in MOSPF and the use of group-membership-LSAs in this protocol.",
        "9d24feb3-acbc-4345-9e7a-4c660688c05e": "Describe the process of neighbor discovery and maintenance in OSPF. Include in your answer the explanation of the steps taken during this process and any issues that may arise during neighbor discovery and maintenance in OSPF.",
        "b7256d95-fff9-4f4c-8cdd-c6746b5681cd": "Explain the concept of \"Network-LSAs for NBMA subnets\" in the context of OSPF routing protocol. What are the challenges associated with NBMA subnets and how does OSPF address them through the use of Network-LSAs?",
        "3d75f182-8b02-4093-8d74-42d59b2ea822": "(This question tests the student's understanding of OSPF and its implementation on non-broadcast multiaccess networks.)",
        "7aa0cb7d-037c-4ece-944f-6270abf52952": "Describe the role of \"Network management stations\" in network operations. In the context of the provided document, what are some examples of tools and protocols used for network management and debugging?",
        "cfc24d9b-c309-4068-9cdd-3eae56aee260": "(This question tests the student's understanding of network management and the various tools and protocols used for network monitoring and debugging.)",
        "5d10761a-cc46-425b-998d-b9297aa28983": "Based on the provided context, explain the role and importance of the \"ospfIfMetricTable\" in the OSPF routing protocol. Additionally, provide an example of how this table might be used in determining the best path for data transmission.",
        "2b8e31fc-8463-4eab-be6f-8bc2723e02fb": "In the context information, there are several variables related to OSPF neighbor states and state changes. Describe the purpose of these variables and how they contribute to the overall functionality of the OSPF protocol. Also, briefly explain the role of \"ospfVirtNbrTable\" and \"ospfVirtNbrStateChange\" variables in the context of virtual links.",
        "5c954cf1-965a-4c09-af79-ef62488916e5": "Based on the context information, compare and contrast the path characteristics of RIP, OSPF, IGRP, and IS-IS. What are some of the key differences between these routing protocols in terms of path calculation and attributes?",
        "c035de54-84db-4ef8-bb77-f90f16d8be2c": "Explain the concept of Path Vector protocols, as mentioned in the context. How do they differ from other routing protocols, such as Link State or Distance Vector protocols? Additionally, discuss the role of Partial Sequence Number PDUs in the context of Path Vector protocols.",
        "28ad8e3f-bc24-4f9c-a815-1330c1e0fbfa": "Explain the concept of \"Reliable Flooding\" in the context of link-state routing protocols, as described in the provided document. In your answer, discuss the robustness and scope of reliable flooding, and provide examples of where it is used (such as AS-external-LSAs, NBMA subnets, and Point-to-MultiPoint subnets).",
        "f83db60a-690f-4725-91d0-64b6aa362be7": "Compare and contrast the Distance Vector protocol RIP (Routing Information Protocol) with other routing protocols mentioned in the document, considering aspects such as algorithm type, counting to infinity, and interactions with other protocols. Additionally, discuss the tools available for monitoring and using RIP for wiretapping, as described in the document.",
        "f99323dd-1e12-4edf-8ca2-51043f534222": "Explain the concept of Route Reflectors (RRs) in BGP and describe how they contribute to the robustness and reliability of the BGP routing protocol. Include in your answer a comparison of RRs to Route Servers.",
        "f9517af6-f0d3-4507-a357-286a84b6997d": "Describe the role of Router-LSAs in OSPF and explain how they are used in different scenarios, such as in OSPF areas, NBMA subnets, and IOS-based routing. Additionally, discuss the significance of the Router IDs and the Router Priority field in the context of Router-LSAs.",
        "259d35f9-2e7b-4ece-8a58-a9e40b33439c": "Explain the concept of \"Security\" in the context of OSPF and SNMP, including the use of security protocols, key management, and message verification. Provide examples of security improvements in OSPF and SNMP.",
        "e1e136c1-8b33-4a5c-869e-3209e6f96b19": "Describe the role of SNMP in network management and the use of SNMP MIBs and SNMP tools. Explain how SNMP can be used for statistics collection and debugging. Provide an example of an SNMP tool and its function.",
        "beb183c5-f504-4953-b905-3d7bb4e5492c": "Explain the concept of Type-7-LSAs in OSPF and its role in handling external routes. Also, describe the process of translation of Type-7-LSAs.",
        "fe1cc54d-7b10-4544-8877-16112cfaf163": "Define Transit ASs and the significance of transit provision by ISPs. Explain the difference between Universal IBGP and IBGP and their roles in BGP. Additionally, discuss the challenges that arise when unnumbered point-to-point links are used in OSPF.",
        "d38a8f13-5c6c-46ce-a1ff-212cadb31ade": "Based on the document titled \"PathofaPacketIntheLinuxKernelStack\" by Ashwin Kumar Chimata, what is the role of the Linux kernel stack in handling network packets?",
        "ee642274-b570-4654-9927-0886e2b14919": "Explain the concept of the Linux kernel stack's path of a packet, as described in the document. Furthermore, discuss how this process is critical to the overall functioning of the Linux kernel.",
        "b6a0eb45-9d46-4639-91f2-0d79218b5c85": "Question for Section 3 (Transport Layer):",
        "c2f5d027-387e-4f51-a5a1-39fbb8fbb5a0": "Describe the role of the Transport Layer in the TCP/IP model. What are the main responsibilities of the Transport Layer when data is sent through a socket?",
        "2fe08f9b-6087-43ca-ba8f-81bc25dd8bf8": "Question for Section 4.3 (Transport Layer):",
        "725653bc-e74a-4ea9-9545-1712bf2c5b7b": "When data is received from the medium, explain the function of the Transport Layer in processing the received data. Additionally, discuss how the Transport Layer interacts with the Application Layer in this context.",
        "1881d9e8-0abf-4b3a-8dfb-c37b341ea2ee": "Based on the given document, explain the role and importance of the Transport Layer in the TCP/IP protocol suite, including the functions of both connection-oriented (streaming sockets) and connectionless (datagram sockets).",
        "1a866fdb-b28c-43d1-ae03-d505fb70efa5": "Describe the path of a network packet through the Linux network stack, as outlined in the document. Include in your answer at least two KURTDSKI instrumentation points that are useful in monitoring packet behavior in the kernel.",
        "4ccd3186-5653-4d74-a1e9-cdd08ae54d58": "Explain the role and functions of the Network Layer (Layer 3) in the TCP/IP protocol suite, including its understanding of network topology, addressing schemes, and routing protocols. Provide examples of how this layer interacts with other layers in the stack.",
        "7f73d65c-98c3-4cb2-92bc-b6717d22ed26": "Describe the differences between the send(), write(), and writev() system calls provided by the socket API at the Application Layer (Layer 7) of the TCP/IP protocol suite. Explain the scenarios in which each system call would be most appropriate to use, and discuss their similarities and differences with respect to connected sockets and specifying the destination address.",
        "93354e97-d9c1-4b97-ab18-4c46a0eee4dd": "\"Can you describe the role and function of the `writev` system call in the context of message sending in network communication, and explain how it differs from the traditional `write` system call?\"",
        "e078dca2-9d8a-483c-9384-080a4182bf1f": "\"Explain the concept of the socket interface layer, also known as the 'glue layer,' in network communication. How does this layer act as an intermediary between the Application layer and the lower Transport Layer, and what benefits does it provide?\"",
        "909157e4-9682-450d-abae-3abc93c81deb": "Based on the provided context, describe the role and responsibilities of the Transport Layer Interface in the kernel. Be specific in explaining how it handles socket creation and system call translations.",
        "2b5fc739-03a5-4fe6-ba17-e5354faaa6a3": "Explain the concept of instrumentation points in a KURT enabled kernel, as mentioned in the context. List the specific instrumentation points that occur at the socket layer and briefly describe the purpose of each event.",
        "22e7fe77-45e9-428d-b58d-6ef81dccf2df": "Question: (Short Answer) In the context of the Transport Layer in the network stack, what is the role of the tcpsendmsg routine, and why is it necessary to wait for a connection to be established before sending data in the TCP case?",
        "e0d17a53-e094-4715-8b24-6cee94fbcc79": "OR",
        "3cdf2036-cd87-4979-9fe0-896d17d5b422": "Question: (Essay) Explain the process of sending a message in the TCP case, as described in the tcpsendmsg routine. Discuss the mechanisms used for handling the socket buffer, including the use of the IO vector structure, and the process of copying data from user space to kernel space. Also, explain the role of the Maximum Segment Size in this context.",
        "62767d8c-9b57-43a7-bc16-2ec8dbfb0689": "Based on the context information, explain the role of the \"tcptransmit skb\" function in the TCP transmission process. What are the different ways this function can be called, and what are the important data structures it uses?",
        "9cda8b36-b6bd-425e-a8e2-cd820a59bd53": "Describe the process of building the TCP header in the \"tcptransmit skb\" function. What information is set up in the header, and what are the checks and calculations performed before the packet is queued for transmission? Additionally, explain the significance of a return value less than zero in this context.",
        "34e1523c-7145-4b22-b774-114ebb107cfc": "Question (Short Answer):",
        "c95cd4b8-3ea0-47e0-bf32-07cb72d3aed3": "In the context of TCP data and header formation, describe the purpose of the `EVENT_TCP_TRANSKB` instrumentation point and explain where it is placed in the TCP transmit process.",
        "0c262bc8-81cf-4fdb-86d0-de0e4ac33140": "Question (Essay):",
        "0ddaf29b-fb6a-429b-8bba-048e32e5b4aa": "Explain the role of the IP layer in the network stack, including its responsibilities in packet handling, route lookup, and TTL management. Additionally, describe how the IP layer interacts with the TCP stack when the `ipqueue_xmit` function is called from within the `tcpsock` structure.",
        "91ac4799-9bd2-4e4c-bd6f-e8762cc0e110": "Based on the given context, explain the role of the iproute function in packet routing and describe the two methods it uses to find a route. What happens if a route is not found in either of these methods?",
        "0c79a483-2347-46c0-a21a-d603a7defece": "In the Data Link Layer, as described in the context, what is the role of this layer beyond just handing over the packet to the device? Explain the concept of the queuing layer and how most queuing discipline implementations take place in this layer.",
        "335e5177-95aa-41f6-9ec9-73df19c4ac09": "Explain the role of the devqueue xmit function in the data link layer and describe the steps it takes to deliver a packet to an external destination. Be sure to include how it interacts with queue disciplines and the EVENT DEV QUEUE instrumentation.",
        "dfa77c42-d78d-4ef3-a2cb-4b04a711b2cf": "Describe the process of packet transmission when the queue disc is called in the process context. Explain the role of the netif queue stopped function, the qdisc restart function, and the dev->hard start xmit routine in transmitting the packet out of the system. Also, mention what happens if the transmission fails and how the packet is requeued for future processing.",
        "500d3931-76ea-4e80-bb8b-ead8dca34bf3": "Explain the role and functioning of the \"netif schedule\" function in the context of packet transmission in the Linux kernel. How does this function help in scheduling packet transmissions and handling interrupts?",
        "32bcebe9-8f04-468b-bf13-4cb7a9276f8f": "Describe the path of a network packet from the physical medium to the application layer, with a focus on the role of the \"rxring\" structure and the \"NET RXSOFTIRQ\" in packet processing. How does the Linux kernel handle incoming packets and manage their transfer to kernel memory?",
        "52c69ad7-5573-4a40-a234-6e075aefa5ff": "In the context of the netif rxschedule function and NET RXSOFTIRQ, what is the role of the EVENT NET RXACTION instrumentation point and when is it triggered? Explain the sequence of function calls that occur from the time a packet is received until it is processed by the process backlog function.",
        "d083bca4-0e3b-4489-b458-c58e63299688": "Consider the backlog device and its role in removing packets enqueued in the input pktqueue by network drivers. Describe the mechanism by which the backlog device is added to the poll list and how its poll function is used to process each packet. Additionally, explain the role of the netif receiveskb function in classifying and directing packets to appropriate packet handler functions.",
        "a929d46f-7836-4e40-8a2c-407a17a52951": "Explain the role of the \"iprcv\" function in the Network Layer-IP and describe the steps it takes to process a received packet. Include in your answer the events and functions that are associated with this process in a KURT enabled kernel.",
        "290b80ee-f406-4bd4-9388-da3169c62479": "Describe the relationship between the Transport Layer and the Network Layer-IP in the Linux kernel. Explain how a packet is passed from the Network Layer to the Transport Layer, specifically focusing on the TCP protocol and the function \"tcpv4rcv\". Include in your answer the data structures and files where these functions are defined.",
        "73212af9-f6f7-4576-87b3-c4f478fa2113": "Based on the given context, explain the role of the `tcpv4rcv` function in processing incoming TCP packets. Be sure to include details about how it checks for a valid TCP header, extracts required fields, and handles the discovery of an open socket.",
        "17145c41-0ba4-4da5-ab75-bb349379d3a7": "Describe the functionality of the `tcpprequeue` function and its role in the transfer of packets from kernel space to user space. Explain the conditions under which `tcpv4dorc` is called and why this might occur during the packet delivery process.",
        "fdd647e3-6117-4b90-9c69-a007a9f96285": "Explain the role of the \"tcp\\_rcv\\_established\" function in the TCP slow packet transfer path. What conditions must be met in order for a packet to be processed in the fastpath, and what actions does the function take when this occurs?",
        "e7fdfb11-f3e4-4f54-be3e-c46085d40a7e": "Describe the function of the \"sysctl\\_tcp\\_low\\_latency\" variable in the context of the \"tcp\\_prequeue\" function. How does the function handle sockets when this variable is set to false, and what is the significance of the \"tp->ucopy.task\" variable in this context?",
        "9cf45ecc-3b73-473d-a1ac-dec89ceadca9": "Describe the path a packet takes from the medium to the user application, as illustrated in the network instrumentation diagram provided at the end of the document. Be sure to include the key instrumentation points at different layers of the network stack.",
        "d6a625e0-bbd3-403f-852d-68b49a6b5273": "Explain the role of the `tcprecvmsg` function in the processing of segments in the socket's receive queue for INET sockets, specifically in the case of TCP. Additionally, describe the basic mechanism involved in processing urgent data when communicated through the SIGURG signal by any process.",
        "cce00f13-0c7d-40e1-8c94-b99153f787ce": "Based on the given context, describe the concept of the stimulus response loop that exists between a Master and a client/slave machine. What would be the path of a stimulus, and how does it correspond to the path of a network packet in the TCP/IP network stack?",
        "4ff63fec-26ef-43ec-85d7-84fd6500cd21": "Referring to Figure 1 in the context information, identify and explain the significance of two instrumentation points in the Linux Network Stack. Additionally, discuss how these points might be useful in monitoring and managing network communication between a Master and a client/slave machine.",
        "4a015f50-ba99-4382-b06a-4eb5ea032924": "Based on the document, explain the importance of understanding the Linux TCP network protocol stack for both the sending and receiving sides of transmission. Provide an example of how referring to external resources like LXR can enhance this understanding.",
        "8e44d2e7-d80e-4669-b72f-344e38ec2888": "Considering the master's theses by Badri Subramanian and Hariprasad Sampathkumar mentioned in the document, discuss how Time Division Multiple Access (TDMA) can support real-time networking on Ethernet. In your discussion, include the potential benefits and challenges of implementing TDMA-based Ethernet for real-time applications.",
        "b90db959-2793-489a-9a2b-f31148ec7d8e": "Based on the conference paper by Deepinder Sidhu and Raj Nair titled \"Open Shortest Path First (OSPF) Routing Protocol Simulation,\" explain the significance of the OSPF routing protocol and its role in computer communication.",
        "9a4be212-b2f0-4517-a5f3-758db181304e": "According to the information provided, when did Raj Nair upload the content related to the OSPF routing protocol simulation, and why might the user have requested enhancement of the downloaded file?",
        "38895151-3dbf-472d-9bcd-e90a7141008d": "Explain the concept of the OpenShortest PathFirst (OSPF) Election Protocol and describe the conditions under which the Designated Router (DR) can be elected in constant time, as well as the factors that can cause an oscillatory behavior during the election process.",
        "a7736d76-85a0-4a04-a9a8-e90a8985eec9": "Analyze the results of the OSPF Flooding Protocol simulation using 20, 50, and 80 router point-to-point networks. Describe the impact of link speed and input buffer size on the probability of overflowing the input buffers and the bootup-convergence time. Additionally, explain how reducing the value of the RxmtInterval can lower the bootup-convergence time at high link speeds.",
        "c5b6e0e2-43ee-4504-89fa-86940ef6c5cf": "Question: Based on the information provided, describe the role and function of the Designated Router (DR) and Backup Designated Router (BDR) in the OSPF Election Protocol.",
        "41e18579-253c-4b02-98fb-80fb08fccce6": "Question Type: Conceptual Understanding",
        "ab4a3b25-a099-4db7-af91-dfa1657f04bc": "Question: In the experiment conducted to determine the DR-election time, what was the objective and what were the assumptions made? Additionally, explain the difference in DR-election time in the results shown in Figure 1a and Figure 1b.",
        "08bd24ee-4ec1-4644-b5c9-40cffb19003c": "Question Type: Analytical Interpretation",
        "72078218-cdcd-453b-8a39-3464297ddb2b": "Based on Figure 1a, how does the DR-election time change as the number of routers increases for a specific experiment time of 7 seconds? Explain the reason for this trend.",
        "5f654de5-4804-42a3-b8dc-52298f1836f4": "In the context of the experiment, what is the significance of the 40-second period that routers R1 and R2 spend in the WAIT state after broadcasting a hello packet? Propose a scenario where changing this waiting time could impact the overall DR-election time.",
        "3d63a315-5cdf-4259-bf1a-03d9ea676637": "Based on the information provided, explain the process of router election in a network with two routers. Include in your explanation the concept of the Wait Timer and the Backup_Seen event, and how they determine the election time.",
        "7ea031e3-c84e-4e35-84ae-93a652ebdcdd": "Consider a network with n routers, where the boot time of each router is a multiple of 7 seconds. Explain how the DR-election time is calculated in this scenario, and discuss how the election time increases linearly due to the inability of a Backup_Seen event to be triggered at any router. Additionally, explain why each router, excluding R1 and Rn, runs the Election Protocol two additional times.",
        "64354722-feea-4096-bce5-23d01d5fcd15": "Based on the context information, explain the concept of DR (Designated Router) election time and how it increases linearly. What event prevents the Backup_Seen event from being triggered at any router, causing the DR election time to increase?",
        "8a10e710-fea1-4be3-a4c4-fea11d205fac": "Analyze the role of routers Rn and R._l in the Election Protocol. Why do they broadcast a hello packet declaring themselves as the DR and BDR (Backup Designated Router), and what events does it cause at other routers? Also, explain the difference in the number of times Rn and R._l run the Election Protocol compared to other routers.",
        "2e221f40-2e23-453d-a549-c13f083fbe62": "Based on the information provided, explain the process of DR (Designated Router) election in an OSPF (Open Shortest Path First) network. What factors affect the DR-election time and how can a constant DR-election time be achieved?",
        "d364485c-9609-4b40-ade7-732ba2e7942d": "In the context of OSPF, what is the role of the DR and BDR (Backup Designated Router) in a broadcast network? How are the DR-agreement time and BDR-agreement time measured, and what is the significance of these times in determining the network's stability after a topological change?",
        "9ad992f3-7781-41f1-a958-8de2fbe9ded6": "How does the experiment measure the DR-agreement-time and BDR-agreement-time, and what are the values of A used in the experiment?",
        "ce75fee7-19f2-4e60-926f-5ab8d64dfcab": "In the given context, how are the groups Gi determined, and how do they affect the detection of the expiration of the RouterDeadInterval for the DR and BDR? Additionally, explain the partitioning of the groups into sets S1, S2, and S3 for calculating the DR-agreement-time and BDR-agreement-time.",
        "30c024b2-4f1f-459b-82f8-6c5b7dbd827d": "Based on the information provided, explain the process of determining the set ($G_k$) to which a router $R_j$ in the DR-OTHER state belongs. Be sure to include the role of the Hello Time, Router Dead Interval, and the Hello Interval in this process.",
        "5be7dd83-2541-4656-9b3f-93f251c96e43": "Describe the sequence of events that occur when the condition \"At is a multiple of the Hello Interval\" is met in the process of electing a new DR and BDR. Include the concept of Neighbor\\_Change event, DR-agreement-time, and BDR-agreement-time in your answer.",
        "da40c5ed-f896-44ca-bf04-0357df685275": "Consider the scenario where condition 3 holds and routers in sets S1 and S3 need to elect new DR and BDR, respectively. Describe the steps that a router in set S3 takes to detect the absence of the BDR and elect a new one. Furthermore, explain the role of the newly elected DR in this scenario.",
        "f1977ef3-aece-4dda-8c73-d474cd057129": "In the experiment that investigates the interaction between the Flooding and Election Protocols, it was observed that the size of the input-control-packet queues affects the DR-election time and DR(BDR)-agreement time. How does the competition between flooding packets and hello packets for the input buffer influence these times? Additionally, discuss how reducing the size of the queues might impact the election and agreement times.",
        "71ee8d69-8ea3-4ac3-93fa-476ce9cbdd0b": "Based on the experiment results mentioned in the context, how does the competition between flooding packets and hello packets in the input-control packet queue impact the election and agreement times in an OSPF implementation?",
        "f2e42b3e-5b1e-435e-af90-5b9a3b9283fc": "In the scenario where a router, R, has a limited amount of input buffer space and observes oscillatory behavior in the identity of the DR, what assumption does R make when it does not receive a hello packet from the DR within aRouter DeadInterval seconds? What could be the possible reason for this behavior, and how can it be mitigated?",
        "31822edd-6bd6-4a75-bcc4-5d456c89d5d2": "Question: Explain the role of the Flooding Protocol in ensuring identical topology information among routers within an area. Also, describe the concept of bootup-convergence-time and how it is measured.",
        "4974f98b-293a-41ce-80b9-7c4debc60e05": "OR",
        "27a140ae-7b9c-4115-9739-4c83b85e612f": "Question: Considering a network with 50 routers, a network diameter of 6, and a maximum router degree of 4, explain the process of measuring the convergence-time after a topological change. Additionally, discuss the impact of link speed on the bootup-convergence-time and convergence-time.",
        "8304f9cf-5517-4175-9718-7c22b92ca840": "AND",
        "1a09ea0a-4c0f-46c0-aac6-4e8164b2f404": "Question: In the context of the Flooding Protocol, describe the process of database synchronization between neighboring routers. Also, explain the importance of having a separate queue for hello packets in networks with strict performance requirements.",
        "17729bf7-9aa7-4d6e-b464-2a2cb4332f3d": "OR",
        "1f39f043-94ca-4097-aace-c579c9a4bf49": "Question: In the experiment described, the authors use topologies with random interconnections and varying link speeds. How do you think these factors influence the overall performance of the Flooding Protocol? Justify your answer.",
        "d97704fe-b23a-4872-bef3-25be6b9f813a": "Based on the information provided, how is the bootup-convergence-time calculated and what is its relationship with the link speed and RxmtInterval? Can you give an example of how this value is determined?",
        "2bfe5768-c5f3-4e81-99cf-cad1ae25dae2": "According to the text, as the link speed increases, what is the impact on the probability of input-buffer-overflow and how does this affect the number of retransmissions? Also, what happens when a router receives a flooding packet from another router?",
        "562dd263-af21-48ed-8974-f4a7a5a0db85": "Based on Figure 3, how does the Link Speed impact the performance of a network, and what specific Link Speeds were tested in the experiment? Provide two possible explanations for the observed trends.",
        "4426cb23-e455-4b5d-82fc-926b56a485f5": "Analyze the context information and identify the relationship between Rxmt Interval and Buffer Size. Propose a hypothesis for their interaction and suggest a method to test this hypothesis in a real-world networking scenario.",
        "ad33dfa6-3eee-4a73-9da8-7f03e23f256d": "Based on the information provided, why does the size of the input buffer have an impact on the convergence time of an OSPF network with 20 or more routers? What is the lower bound of the input buffer size that ensures the operation of such a network?",
        "b2ca4b70-a636-441b-a070-e80732daaec2": "In the context of the experiment described in the document, how does reducing the value of the retransmission timer affect the bootup-convergence time for different link speeds? Does this reduction have a significant impact on the performance of the network?",
        "bdc40123-40b6-46af-9b7f-efa9c7df353c": "Based on the information provided, why is it recommended to avoid a linear search of the retransmission list in the context of the Flooding Protocol in an OSPF implementation?",
        "5a064192-33a3-476f-99f3-d073a97c1eb2": "In the simulation of the OSPF Election Protocol, what were the observed results when the Designated Router (DR) was elected in constant time, and how did the number of input buffers at a router affect the election time and stability?",
        "f1402dce-6943-47bf-8a19-bfeb2937b5c8": "Based on the information provided, how does the link speed affect the probability of overflowing the input buffers and the resulting increase in bootup-convergence time in a 50-router network using OSPF?",
        "9e8495b8-7401-4ac4-b082-cf1509187d37": "According to the context, how significant is the impact of reducing the value of RxmtInterval on the bootup-convergence time for high link speeds in networks with 20, 50, and 80 routers using OSPF? Additionally, explain the effect of input buffer size on the bootup-convergence time for these networks.",
        "dc97e01f-72b8-4211-b117-2a5cffc09837": "How does the NDN architecture differ from the current Internet architecture in terms of data identification?",
        "a50acbc8-7a55-4c2c-a072-2ddf9d768ef6": "In the context of NDN, what is the role of OSPFN in providing name-based routing capability? Describe the current deployment status of OSPFN in the NDN testbed.",
        "07e4a3e7-a24b-46dc-80a4-cb8531d44bcf": "Explain the motivation behind the development of the dynamic routing protocol for Named-data (OSPFN) and the reasons for choosing Open Shortest Path First (OSPF) as the basis for the extension.",
        "a41c81c4-ac4e-4ca3-aace-904c4f1f7f21": "Describe the features of OSPFN version 2.0, including the support for name prefix advertisement from multiple sites and the configured multipath feature. Also, discuss how the configured multipath feature has helped in understanding the forwarding behavior of the current CCND implementation.",
        "c54245ec-977b-48e5-b311-54f4fa5baf79": "Question (Short Answer): Explain how the proposed \"OSPFN\" protocol extends the current OSPF protocol to support routing in Named Data Networking (NDN). In your answer, include how the protocol supports the dynamic calculation of routes to name prefixes based on the network topology.",
        "a7772540-d529-4061-8bab-884d93d76bbd": "OR (for more depth)",
        "3d8f774d-334e-4d79-8710-9f44cd0a1db6": "Question (Short Essay): Compare and contrast the traditional IP routing with the routing approach in Named Data Networking (NDN). Explain how the proposed \"OSPFN\" protocol supports routing on names and multipath routing in NDN. Additionally, discuss how the use of Opaque LSAs in OSPF provides extensibility for future use in NDN.",
        "1fac3620-6c09-4f0d-85cf-464674fefff1": "Question (Short Answer): Describe the role of Opaque LSA (OLSA) in the OSPF protocol. Explain how the OLSA distribution in the network is limited by the flooding scope, and how this feature can be used to support routing in NDN.",
        "88f58782-2c10-4dec-8d7a-45fd6e8f077a": "Based on the context information, how do Name OLSAs differ from regular LSAs in OSPF, and what is their role in the network, particularly in relation to the CCND and the forwarding of Interest and Data messages?",
        "fc363be3-83b4-4605-9571-dfc7fe876bac": "Explain the process of calculating routes to name prefixes in OSPFN and the steps involved in delivering and installing Name OLSAs in the network. Additionally, describe the fields in a Name OLSA message and their purposes.",
        "9f736258-a026-4e2a-a973-66971bc8b3ee": "Question (covering Section 3.1): Explain the format of the Name Opaque LSA message in the context of Named Data Networking (NDN). In your explanation, be sure to include the details of the various fields such as LS Age, Options, LS Type, Link-State Type, Advertising Router, and Opaque Information.",
        "d17176aa-1277-4d1f-872b-559220cdb3bd": "Question (covering Section 3.2): Describe how the OSPFN (NDN Open Shortest Path First) performs route calculation for a given name prefix. In your answer, explain how OSPFN queries the OSPFD for the next hop to the origin router of a name prefix, and how it adds a FIB (Forwarding Information Base) entry containing the name prefix and the returned next hop. Additionally, discuss how OSPFN generates one route for each single-origin name prefix, and how NDN's forwarding strategy differs from OSPF's approach.",
        "18c570e7-af9d-4a7b-883b-53c09ba57a2c": "Explain the \"configured multipath routing\" feature in OSPFN and describe how it generates a list of FIB entries for each name prefix. What is the role of CCND's forwarding strategy in this process?",
        "c321535c-d587-45cc-8803-56a8ec3c7cbe": "Describe the message exchange process between a router, OSPFD, and OSPFN when advertising a name prefix. What is the purpose of the Name OLSA and how does OSPFN use the information received from OSPFD to update its Name Pre\ufb01x Table?",
        "4908fe15-ee1c-4087-a5e2-a4ab141c6497": "Based on the information provided, what are the steps involved in the sequence of messages exchanged between OSPFD, OSPFN, and CCND when OSPFN receives messages from OSPFD about deleting a Name OLSA? Briefly describe the role of each entity in this process.",
        "61045ada-129f-4a82-a147-87bac1d1456b": "Explain the configuration commands supported in the current OSPFN implementation as shown in Table 1. What are the key components that need to be configured for OSPFN to operate correctly? Provide examples of how to use these commands in a real-world scenario.",
        "864ba43a-cb20-47a0-b5d8-36cd6952f796": "Question: (Referring to Section 4.2 of the context information) Suppose you are configuring an OSPF router and you want to originate a Name OLSA with a name prefix of \"campus/\" and a unique op ID of 123. If the ccnnametype is set to 0 (URI), what would be the Opaque Data field in the Name OLSA?",
        "6c2e793f-a6c1-4ac5-b7eb-392c9c0618f2": "OR",
        "960db0e5-82c9-4b19-b289-39fcc1b9f115": "Question: (Referring to Section 4.3 of the context information) Consider a router with three interfaces having next hop addresses and preferences as follows: multipath-order 10.0.1.2 3, multipath-order 10.0.2.1 2, multipath-order 10.0.8.2 1. How would the routes be injected into the CCND FIB, and what would be the preference of the best path in this scenario?",
        "3555f344-9c87-4313-80db-7fb4360d62c2": "Note: Please select only one of the two options provided for question 1, as they are alternative ways of asking the same question.",
        "9176bea0-1fad-45ce-8a87-4e462e87204e": "Based on the network topology provided in Figure 4, suppose RTR 6 has just joined the network and needs to advertise its name prefixes to the rest of the network. Which command(s) would you use to configure RTR 6's advertisement of its name prefixes, and what would be the corresponding FIB entries constructed by OSPFN?",
        "4a9ddb9b-ccbe-48ce-8272-7ee2521981ba": "Consider the scenario where the best next-hop for a name prefix changes in the network topology. How does OSPFN adjust the FIB entries accordingly, and what would be an example of such an adjustment based on the information provided in the context?",
        "b6e81128-30dd-4e6b-b8ec-5a911abe3373": "Referring to the Router Configuration Files in Table 3, why does RTR1 have a higher multipath-order for 10.0.1.6 compared to 10.0.1.2? What could be the potential reason behind this configuration decision?",
        "cd3c2445-10f7-4da9-839d-17fe34660cbf": "Considering the Name Prefix Table for RTR3 (Figure 6), and the FIB entry construction process described, explain how a FIB entry would be created for the name prefix /ndn/sports/soccer. Describe the steps involved and any necessary lookups that need to be performed.",
        "272ca934-fb55-4f7a-a9ce-b9c00938f87f": "Based on the information provided in Figure 6, if a consumer makes a request for data with the name prefix \"/ndn/leisure/theater\", how many next hops will be in RTR3's FIB and what are they? Explain the process of constructing the FIB entries for this name prefix.",
        "7bcdf0bb-9ab6-45af-96b9-0344a1ab0bc3": "In the context information, there is a mention of a \"path cost\" for determining the order of FIB entries when multiple routers advertise the same name prefix. How is this path cost calculated and what is its significance in the operation of the CCND FIB? Provide an example of how path cost would affect the order of FIB entries for a specific name prefix.",
        "d2893a41-9e9b-45d1-aca5-ef081d8514f1": "Based on the information provided, explain the process of determining the next hops in the OSPF routing table and how the path cost is calculated. Use the example given to support your explanation.",
        "8efc48d2-4118-4286-b382-74001e493e14": "Describe the deployment status of OSPFN over the NDN testbed as of June 28, 2012. Mention the sites that have deployed OSPFN 2.0 and any notable platforms used in the deployment.",
        "45a4a65a-9c0e-4064-9a96-bba5e94ca70d": "Based on the context information, what are the main issues the authors noticed with the current GRE tunnel setup and configuration in di\ufb00erent OSes, and how do they plan to address these issues in the next version of their design?",
        "f93f8d34-bcdb-4035-bd3b-debbe9f2bce7": "Explain the purpose of the web-based monitoring tools used for OSPFN and OSPFD at each NDN hub. Additionally, describe the function of the CCND status web page in verifying the correct installation of routes by OSPFN.",
        "857e30f8-69ca-42e8-adc0-516ff1126f63": "Based on the document, who are the individuals acknowledged for their contributions to the implementation and development of OSPFN 1.0, the web-based OSPFN status monitoring tool, and the CCND status webpage?",
        "17216c61-5120-4c6b-95d1-c8c74c0a4b92": "According to RFC 5250, what is the purpose of the OSPF opaque LSA option, and what are the names of the authors who contributed to its publication in July 2008? Additionally, what is the significance of the OSPF version 2 mentioned in RFC 2328?",
        "79c328c2-2915-4b62-baa0-88ed40a31bdd": "Based on the context information, what is the name of the routing software suite mentioned and what is its official website?",
        "86e22a6f-a99a-4aa6-b383-aa439b7c6bbe": "Given the context, if you were to research more about the Quagga routing software suite, what would be the first step you would take and why?",
        "e91ca712-5530-4065-96c4-c2d933e075e8": "In the dissertation by Saif Ur Rehman Malik, what are the three main aspects of large scale computing systems that are validated using formal methods?",
        "f42d9100-9e64-43b1-b495-6e7efa8af9ab": "Can you name the major department in which Saif Ur Rehman Malik pursued his Doctor of Philosophy degree, as indicated in the title and acknowledgement pages of the document?",
        "4a3bf7e4-52db-4be0-a72b-d6bca7c15a04": "What is the title of Saif Ur Rehman Malik's doctoral dissertation?",
        "e1d522b8-7a71-403c-bc00-32e1e1db452a": "Who are the members of Saif Ur Rehman Malik's Supervisory Committee for his Doctor of Philosophy degree?",
        "1cdf7938-4a21-4272-b6be-afa0a8c65e8a": "How does the increasing complexity of large scale computing systems, such as cloud computing systems and Data Centers, impact their reliability and correctness?",
        "b5d408fb-88d8-4e6c-9d5c-b6f339a6197e": "Can you explain the role of Formal Methods (FM) in increasing the reliability and correctness of large scale computing systems, and give an example of a strategy that could be analyzed using FM tools and techniques?",
        "3396c8a8-abe4-4950-a868-33ee14cb39f8": "Based on the given context, can you explain the challenges faced in adopting Facility Management (FM) strategies in complex architectural and topological patterns with large-scale servers?",
        "c4b425ad-af6a-4877-9f65-fdde703317e0": "Drawing from the context, how do the predefined complex architectural and topological patterns in different layers of the underlying network impact the adoption of FM strategies?",
        "43e60763-e3ca-48eb-b06a-a28fa649c019": "Who is the senior advisor of the author and what role did they play in the completion of the author's disquisition?",
        "b00f32c0-92b8-4ce5-bc21-152999a649e0": "Identify two individuals, besides the senior advisor, who offered support and guidance to the author during the pursuit of their PhD and mention the specific help they provided.",
        "0fead5c5-b30f-4380-8744-86a79b6e8813": "Based on the context, who does the author express gratitude towards and what are the positive emotions the author associates with these friends?",
        "b3c0c9d5-486e-472d-bc69-4d57d283b8bf": "How does the author describe their social connections in the context, and can you identify the locations where these friends are from?",
        "a21b234c-90da-4099-9bcd-e6408e613d22": "What is the significance of the Roman numeral \"vii\" at the beginning of the dedication section?",
        "b250f7da-678c-443d-91f7-c4fb3ca508db": "Who are the two specific individuals mentioned in the dedication and what is their relationship to the author?",
        "409d3eab-0558-4bbc-9568-103bfc58a5c8": "Based on the information presented in Section 1.1 of the document, what are large scale computing systems and why are they important? Explain any three points in detail.",
        "6fad823a-de51-4757-8815-0990574c18be": "Section 2.2 of the document discusses energy efficient data centers. What are some of the key approaches to making data centers more energy efficient? Also, explain how these approaches can contribute to reducing the overall carbon footprint of data centers.",
        "49bc6863-4de0-44c1-a840-c22d2749e5d9": "Question for Section 3.2:",
        "8dedaa02-5d96-449d-98a1-0b2d68c4edbd": "Can you explain the concept of High-Level Petri Nets (HLPN) in the context of cloud management platforms? What are the key components and properties of HLPN that make it suitable for modeling cloud systems?",
        "1ece225b-ef55-4776-9f86-fdf22a58bed2": "Question for Section 4:",
        "b479057a-6101-4124-b756-6875bde4b30b": "Describe the problem formulation of the Convergence Time Analysis of Open Shortest Path First (OSPF) routing protocol in Internet Scale Networks. How does the analysis help in improving the performance of cloud-based networks? What are the potential challenges in implementing this analysis in real-world scenarios?",
        "e2183ebe-e965-44ce-b08b-41ae6b69bedd": "Question for Section 5: Modeling and Analysis of the Thermal Dynamics of Cyber Physical Data Centers",
        "6c0da8be-2b92-47a8-8387-4d897996b0c2": "Explain the concept of Thermal Aware Control Strategy (TACS) mentioned in Section 5.3. What are the benefits of using TACS in cyber physical data centers and how does it contribute to the thermal management of these systems?",
        "d7670e41-6bc2-4dcd-b1a0-cc9688f20171": "Question for Section 6: A Methodology for OSPF Routing Protocol Verification",
        "6f1c80ac-70c0-4a11-ac05-0e9496423fdf": "Describe the process of verifying the OSPF routing protocol using the proposed method in Section 6.4. What are the key steps involved in content verification and route verification, and how do they ensure the correctness of the OSPF routing protocol?",
        "deab3f9f-9aad-436e-9a20-683027547d2d": "Explain the concept of File Assured Deletion (FADE) and its purpose as described in Section 7.2 of the document. Include in your answer the different components of FADE such as File Upload, File Download, Policy Revocation, and Policy Renewal.",
        "f6fa6f94-0795-4b32-906e-464577fb85ce": "Choose one of the verification methods described in Section 7.3 (Attack Verification through Scyther, HLPN, SMT-Lib and Z3 Solver, Verification through HLPN Model, or Formal Verification) and explain how it works and how it is used to verify the FADE system. Provide specific examples and details from the document to support your answer.",
        "8f8ce3a0-9979-4c62-a9fe-0a4cce34fd86": "Based on Section 7.4.6, \"Analysis of DaSCE through the HLPN,\" explain the purpose and significance of the DaSCE (Data Storage and Communication Entity) and how it is analyzed using the HLPN (High-Level Petri Net) model. What are the benefits and limitations of this approach?",
        "b8ef5050-4b26-4b96-91d4-b943d67227c0": "Consider the implementation and performance evaluation in Section 7.5, specifically the file upload/download scenarios with a single key manager (7.5.1) and multiple key managers (7.5.2). Compare and contrast the two scenarios in terms of security, efficiency, and scalability. In your opinion, when would each scenario be most appropriate, and why? Provide specific examples to support your answer.",
        "b8f1b36b-4100-4220-8655-b55c2f842c68": "Based on the information presented in Table 3.1, \"Places and Mappings of Eucalyptus,\" and Table 3.3, \"Data Types Used in the Model of Open Nebula,\" compare and contrast the data types used in the models of Eucalyptus and Open Nebula. Identify any common data types and any unique data types to each model.",
        "74377276-b42c-415d-90a2-a1af7f234ad8": "Referring to Table 7.2, \"Data Types Used in FADE HLPN Model,\" and Table 7.4, \"Data Types for HLPN of DaSCE,\" list and explain the differences between the data types used in the FADE HLPN Model and the HLPN of DaSCE. Additionally, provide an example of how each data type might be used in the context of cloud computing.",
        "44a3fa6a-1e36-497d-ad43-59036448b87d": "Based on Figure 3.3 and Figure 3.5, what are the main differences in the process of instantiating a VM between Eucalyptus and Open Nebula architectures?",
        "b5b20fd0-2110-42b5-b0be-e01da6a8d848": "Referring to Figure 4.1, describe a scenario where the concept of Discrete Roles (DRs) could be beneficial in managing a topology of 1000 routers. Additionally, explain how the \u03c4 value would be affected in this scenario.",
        "8e8b521e-8bd5-477c-b1e0-a7889d153708": "Explain the concept of Three-Tier DC Architecture mentioned in section 5.2. What are the advantages of this architecture and in what type of data centers is it most commonly used?",
        "e5a58f9b-6ea8-4d17-8a39-8a1b95339a3a": "Consider the example of Kripke Structure and Computational Tree given in section 5.8. Describe what these concepts are and how they are used in the verification of a system. Additionally, explain the HLCC and LLCC HLPN Model in DC Environment discussed in section 5.9 and how it relates to the Kripke Structure and Computational Tree example.",
        "3856d338-a8a7-4f38-9872-7f312d970ad9": "Question (File Download Operations in DaSCE): Referring to section 7.10, 7.11, 7.12, and 7.17 in the document, compare and contrast the file download operations in DaSCE when using a single key manager versus multiple key managers. Highlight the potential benefits and drawbacks of each approach.",
        "cf8881ce-b716-4a3b-89ba-3d68855a4a1d": "Question (Key Management and Policy Renewal): Based on section 7.4, 7.5(b), 7.13, and 7.14, discuss the importance of key management and policy renewal in secure file transfer systems. Explain how the exploitation of the policy renewal process can lead to security vulnerabilities and how proper key management can mitigate such risks.",
        "7f929528-78b8-4794-8f7b-4b0fdc46db13": "What is the concept of Large Scale Computing Systems (LSCS) and how does it help in managing large data streams?",
        "477e78b8-e70e-4987-b6ff-b40e883da1bf": "Why are on-premises enterprise databases not suitable for managing the explosive growth of data and what makes cloud computing a mainstream research topic in LSCS?",
        "679cbb12-280d-4f11-860a-880e6deb5587": "How do Large-Scale Computing Systems (LSCS) ensure the delivery of specified Quality of Service (QoS) attributes to meet the increasing demands of users, and why is it crucial for their income?",
        "bf04dd2f-e03b-404a-afa9-169be83bc357": "Can you explain the role and significance of Formal Methods (FM) in developing computer systems, and how they contribute to increasing the quality of software by mathematically proving program correctness?",
        "44587ba5-e18a-4d8d-9d80-710d559d68c2": "How do formal methods (FMs) aid in the software development process, and what are the main benefits of using FMs at different stages of this process?",
        "53384072-b3b2-4e12-9e5b-bf70063aaa7c": "What are the primary concerns in achieving high performance in complex and sensitive tasks, and how does the increasing complexity of hardware and software systems, such as cloud computing systems, impact these concerns?",
        "3c1bfbae-e0c3-4d6d-9fbc-b686b9663eb0": "How do the increasing complexity and density of computational devices in large scale computing systems (LSCS) impact the cost of errors and the effectiveness of traditional validation methods such as simulation and testing?",
        "014688b1-7bc0-46b1-b5b5-1b1f1e381a0d": "Explain the limitations of testing as a verification strategy for LSCS, including the challenges of building a prototype, identifying bugs, and fixing them at later stages. Also, discuss the impact of these limitations on the perceived reliability and robustness of LSCS.",
        "65bb0ca5-651e-4ed7-9b13-c7d561c81f05": "How does the pricing model of cloud services, specifically the pay-per-usage model, impact the importance of providing specified service level agreements to end-users? Can you provide examples of real-world scenarios where performance degradation and errors led to significant losses for companies?",
        "4054d659-3854-4f8c-a14e-f6d8f8284fd4": "In what ways can formal methods (FMs) be beneficial for verifying the functionality and reliability of large scale computing systems, such as cloud services? How do FMs differ from traditional testing methods, and what advantages do they offer in terms of analyzing program semantics and proving properties for any possible inputs?",
        "6b3d1ed5-5cd9-43da-97bb-b3ebe136edda": "Based on the context information, what are the specific architectural and topological characteristics of large scale computing systems, such as Data Centers, that differ from conventional random networks?",
        "8086c488-fc6a-4d1a-8a2b-c68eefcfc51f": "The text mentions that formal methods (FMs) can be challenging to apply in large scale computing systems. According to the authors, what are the potential issues that arise due to the characteristics of the underlying network and the large scale of servers in these systems?",
        "f4036a73-6ff1-4f9e-bba4-fae702d69a71": "Question: Based on the related work presented in the document, discuss the security approaches proposed in [2.1], [2.2], and [2.3] for Virtual Machine (VM) based cloud management platforms. What are the key differences between these approaches?",
        "cae21cdb-2124-4249-9428-ac082b68973a": "OR",
        "be00db16-c2bc-4412-9c2a-187edabbe51b": "Question: Explain the resource allocation models proposed in [2.5] and [2.6] for VM-based cloud management systems. How do these models differ in their approach to resource allocation? Additionally, why is there a lack of work in the area of modeling and analysis of cloud management systems, specifically VM-based systems, as mentioned in the document?",
        "879e0c9d-03da-43ca-8ae3-fb9c37cc6a98": "How have Colored Petri Nets (CPN) been used in the context of Model-based Diagnosis in the Cloud (MBD) and what is the significance of this combination in the research domain?",
        "3fafeac4-c486-40a8-a7fc-03909b875212": "In the context of Energy Efficient Data Centers (DC), describe the power consumption and thermal properties of devices and explain how Dynamic Voltage and Frequency Scaling (DVFS) can be used to manage power consumption. Also, discuss any control-theoretic approaches to DVFS that have been proposed in the literature.",
        "653582c8-8fc2-461d-8393-20cb60f57011": "Explain the concept of Per-Core Power Gating (PCPG) proposed in [2.17] and discuss how it helps in reducing power consumption in multi-core processors in data centers.",
        "30dd1c0b-a690-41e3-9b74-31d215d08769": "Compare and contrast the two thermal-aware strategies proposed in [2.20] and [2.23] for data centers. What are the advantages and disadvantages of each approach, and in what scenarios would each be most applicable? Provide specific examples from the papers to support your answer.",
        "4445ecf4-940a-4b13-af51-0eccdd390428": "Based on the information provided in section 2.2 and 2.3, explain how thermal management strategies have been proposed at both the CRAC unit level and the Data Center (DC) level. Additionally, discuss a formal verification of ad-hoc routing protocols using the SPIN model checker as described in [2.29].",
        "bb8d22f0-9e43-419a-8454-778d997b6ae3": "According to section 2.4, what are the main costs involved in Data Centers (DCs) today? Explain a thermal-aware resource allocation strategy and discuss the use of colored Petri nets in modeling AODV as described in [2.31] and [2.32].",
        "1d5dbeef-c908-4718-8a34-7ef6271aa8b2": "Explain the concept of Dynamic Voltage/Frequency Scaling (DVFS) and how it can be used to improve energy efficiency in data centers. In your answer, be sure to discuss any potential trade-offs or limitations of this approach.",
        "3194fd2c-69af-4b71-a73b-3c1a81f3d946": "Describe a proactive solution for managing hotspots and thermal threshold approaches in data centers. In your answer, explain the concept of a band-limited predictor and how it is used in this solution, as well as any potential issues that may arise in case of mispredictions.",
        "0729235a-a44b-492d-a695-b359e428d7e8": "Explain the concept of Dynamic Voltage Scaling (DVFS) and its control-theoretic approach as proposed in [2.15]. What are the limitations or drawbacks of this technique, if any?",
        "f0697950-5f8d-4b94-bc66-24eafd06cc90": "Discuss the thermal-aware scheduling approach named XInt, presented in [2.45]. How does this approach help minimize inlet temperatures, heat recirculation, and cooling costs for data center operation? Additionally, critique the strategy by identifying any potential limitations or areas for improvement.",
        "16b8c82a-8cf5-4c17-91d2-2277a5f6c2de": "The document discusses a study on the thermal impact of job allocation in a data center. How does the proposed scheduling scheme help maintain thermal uniformity within a data center, and what statistical techniques were used to observe the thermal impact of job allocation and the ambient effect on other servers?",
        "e019ede9-5924-4f71-84a1-83c963fff8c1": "In the context of data security over the cloud, how does the technique presented in [2.47] ensure data integrity, freshness, and availability? Additionally, what are the limitations of this technique, and how does the cryptographic file system presented in [2.48] address those limitations by providing confidentiality and integrity services to outsourced data?",
        "d3e6f806-6956-48ec-a0d2-4f7f3781e865": "Explain the concept of block-wise encryption used for the construction of a MAC tree and the potential threat posed by the presence of cryptographic metadata on the storage side. How does the virtual private cryptographic storage service proposed in [2.49] address these concerns?",
        "db462824-3ec1-4f14-81b0-9965c0b16005": "Describe the cloud storage system based on secure erasure code presented in [2.50]. How does the system use threshold key servers for storing a user's key and how does it provide the functionality of data forwarding? Compare and contrast this system with the similar scheme presented in [2.51] in terms of features and implementation level changes required on the cloud side.",
        "31f87fd5-b594-438b-922f-6957ba07155d": "Explain the concept of \"NoHype: virtualized cloud infrastructure without the virtualization\" as presented in [2.1]. What are the potential benefits and drawbacks of this approach compared to traditional virtualization techniques?",
        "2cd6c144-50fc-4217-b002-0eab8796dbe4": "Based on [2.2], describe a general model for virtual machines resources allocation in multi-tier distributed systems. What factors are considered in this model and how do they contribute to efficient resource allocation?",
        "f41ea412-17fd-4c53-93c0-d5c2f196474a": "Explain the concept of \"energy-aware clock-frequency assignment in microprocessors and memory devices for dynamic voltage scaling\" as presented in [2.12]. What are the potential benefits and drawbacks of this approach?",
        "73bb06bc-f4c4-4248-b8ec-56e50182679d": "Describe the \"CPN Provenance Model of Workflow\" introduced in [2.11]. How does this model contribute to diagnosis in the cloud? Provide an example of how it can be used to troubleshoot a problem in a cloud environment.",
        "3bc49f86-b09b-4a06-844e-a63ed1fc3d35": "Question (Short Answer): Based on the information presented in [2.20] and [2.22], explain the concept of temperature-aware workload placement and automated, online, and predictive thermal mapping in data centers. How do these techniques contribute to energy efficiency and thermal management?",
        "117bb55a-72af-4b26-b7a7-c2021cdb5642": "Question (Essay): According to [2.23] and [2.26], discuss the importance of dynamic thermal management and control systems in air-cooled data centers. How do these approaches help in optimizing energy consumption and maintaining desired temperature ranges for high-performance computing environments? Include any relevant examples or case studies from the papers in your answer.",
        "84ec869c-ca06-48f3-b379-bc4024ad49e7": "Explain the concept of a \"potential flow-based compact model of air-flow transport in data centers\" as introduced in [2.27]. What are the potential benefits of such a model in the context of data centers?",
        "ff7d592f-78b2-472b-becd-d80b1789e540": "Discuss the use of formal verification techniques in the analysis of routing protocols, as described in [2.29] and [2.34]. How do these techniques differ from static analysis and what are their advantages and limitations?",
        "d6cbab92-c4d0-4214-ace3-c780545460e9": "Question (Short Answer): Explain the concept of \"Counter-example based predicate discovery in predicate abstraction\" as introduced in [2.35]. Provide an example of its application in the context of software design.",
        "53f32be0-5a56-42f9-8007-7e841d73d1e2": "Question (Essay): Discuss the importance of thermal-aware task scheduling in modern computing systems, as described in multiple papers within the context information. In your answer, compare and contrast the approaches presented in [2.40] and [2.42], and evaluate their potential benefits and drawbacks. Additionally, suggest potential future research directions in this area.",
        "130c7641-5c5c-4442-aae9-55f6cc4965de": "Explain the concept of \"guarded power gating\" for multi-core processors as presented in [2.44]. What are the potential benefits and drawbacks of this approach?",
        "d8ed530a-a249-4355-8634-c97d501b801f": "Compare and contrast the two erasure code-based cloud storage systems presented in [2.50] and [2.51]. What are the key differences between the two systems, and what advantages does each offer in terms of security and performance?",
        "6401ef7d-55bf-421e-a534-bae6b168cbea": "Explain the concept of virtualization and its role in cloud infrastructure, as mentioned in the introduction of the paper. How does the use of virtual machines (VMs) in cloud computing provide flexibility in resource provisioning?",
        "b2829e98-0ef0-463c-8668-9947eb417be9": "The paper mentions several solutions for virtual infrastructure management in cloud environments. Describe one of these solutions, including its main features and benefits, based on the information provided in the context.",
        "fd2a69d0-5a34-491e-ae5c-ed91092ce7ea": "Explain the role of open source VM-based cloud management platforms in the development of cloud computing management platforms. Why have Eucalyptus, Open Nebula, and Nimbus been selected for study, and what design interests do they advocate?",
        "ce92c70b-7386-4249-9fe0-d99743f2a0eb": "In the context of open source IaaS providers, why are Xen and KVM the most widely used open source hypervisors? What level of customization does Open Nebula provide, and how does it benefit both end-users and administrators?",
        "18f47bb6-2a4d-4277-95d2-31042665de74": "In the context of cloud management platforms, how does the level of customization in Open Nebula differ from that in Nimbus and Eucalyptus, and what makes each platform more suitable for different types of users or organizations?",
        "98094c8a-dfdc-4c4b-9c9b-ce36e1f2b56b": "The study mentioned in the context information uses High-Level Petri Nets (HLPN) and Z language for the modeling and analysis of cloud management platforms. How do these tools help in reducing the level of abstraction and providing detailed modeling and formal analysis of the systems, and what aspects of the systems can be analyzed using these tools?",
        "26c7562c-5b36-4b18-83d8-558d07a9d5ab": "Question: Can you explain what High-Level Petri Nets (HLPN) are and how they were used in the research described in the document?",
        "452efbcd-7a84-444d-b011-24f1e9d96849": "OR",
        "da8376a8-6c3f-4570-82fa-fb82b5ec3902": "Question: Explain the role of the Z3 solver and SMT-Lib in the Bounded Model Checking technique used to verify the open-source cloud management platforms in the research.",
        "1bbd0e27-452a-47fc-8c58-58df66999033": "Question: How did the research verify the feasibility of the cloud management platform models as the number of virtual machines (VMs) scaled, and what were the results of this verification?",
        "b80ca22f-b6b9-4049-a258-7f2506bf5efd": "(Note: You can choose either question 1 or question 2, as they cover different aspects of the research.)",
        "093a4c16-500c-40c8-8c08-c8076d9e3a12": "Can you explain the concept of High-Level Petri Nets (HLPN) and differentiate it from Low-Level Petri Nets (LLPN) by highlighting the key features of HLPN?",
        "3abec855-e638-472b-a698-c3577f74ebe8": "Given a HLPN with nodes P and T, and a flow relation F, define the pre-condition and post-condition for any node in the net and explain how an input and output node is determined in the net.",
        "cd032469-df02-4c4b-9271-9ddc29712d78": "Question: In the context of the document, what is the difference between Satisfiability Modulo Theories (SMT) and Boolean Satisfiability Solvers (SAT)? Provide an example of a theory of interest that SMT solvers can check the satisfiability of, that SAT solvers cannot.",
        "df7c71ca-3182-4ca3-b47e-e91018879d6b": "OR",
        "7fd69fa0-27ee-4574-a00f-16b24a9f5f7b": "Question: Considering the High-Level Petri Net example given in the document, explain the role of pre-conditions and post-conditions in transition enablement. How do the variables from incoming and outgoing flows impact the transition firing? Provide an example using variables x and y from places P1 and P2, respectively.",
        "8c5b5428-5880-4b21-a2b8-206d601cd941": "(Note: Both questions are diverse in nature, first one is focused on SMT and SAT solvers and the second one is on pre-conditions, post-conditions and transition firing in Petri Net example)",
        "1df7c700-557e-454a-a742-e542b0fc5d67": "Question for Section 3.2: Explain the role of a SMT solver in the verification of the OSPF routing protocol. Briefly describe two features that distinguish SMT solvers and explain how the Z3 solver, in particular, functions as a high-performance theorem prover.",
        "6243ef2d-5bc0-4599-815e-556c74933eb1": "Question for Section 3.3: Describe three benefits of VM-based cloud management platforms. Then, discuss one component of the hardware and operating systems category in the context of a generic open-source cloud computing system. Provide a specific example of a VM-based cloud management platform and explain how it utilizes this component.",
        "c680c59c-89d4-4bad-9636-9f42a276e805": "Explain the role and benefits of the Eucalyptus cloud computing management framework. What are the key components of its architecture and how do they communicate with each other?",
        "4061c46b-cd10-40be-8f3b-163858da37e2": "Describe the process of installing Eucalyptus and its various components. What is the significance of using Amazon Web Service APIs in Eucalyptus and how does it benefit users?",
        "c4548951-fb42-45ca-8f13-5226a693e2a4": "Based on the information provided, describe the role and responsibilities of the Cloud Controller (CC) in the Eucalyptus architecture.",
        "cc48f69d-6b8e-445f-b93c-78475a9caef0": "Explain the concept of modeling and analysis in the context of spawning a VM instance in Eucalyptus. Include in your answer the significance of the HLPN 7-tuple and the process of specifying the initial marking and associated types. Additionally, refer to the Eucalyptus architecture diagram and identify the components involved in this process.",
        "e64bc1d7-e442-457b-9d05-d8e515a073d9": "Based on Figure 3.3, describe the role and significance of the 'V\\_Req' component in the process of starting a VM instance in Eucalyptus.",
        "514dbad0-9266-4291-affd-d553ccf8d351": "In the context of the provided figure, identify and explain the function of the 'Euca2\\_conf' and 'Co\\_PaCo\\_PaCo\\_PaDI' components and their relationship with other elements in the VM instance startup model.",
        "92918bcb-b58c-4765-937a-bf2c1eb4c430": "Based on the information provided, explain the process of initiating a VM instance in the context of the Eucalyptus cloud model. Be sure to include the steps of configuring the front-end, requesting the VM, and the role of the Eucalyptus Cloud Controller and Network Controller in the process.",
        "9f3df87c-0fc0-4dfa-8a8e-c45302d49d7c": "Considering the set of transitions T in the Eucalyptus cloud model, describe the rule for the creation of new tokens in the model. What is the significance of this rule in the context of the overall system?",
        "080226f3-c60f-4618-9a9e-3c931532354d": "Based on Table 3.1, describe the role and purpose of the \"ECC\" place in the Eucalyptus system, and explain how it relates to the creation of virtual machines.",
        "6f9b2c78-026e-4dbe-8a88-0f88db7c3ef3": "Using Table 3.2 as a reference, identify and explain the data types that are used for authentication in the Eucalyptus system, and provide examples of how they are used in the system's architecture.",
        "1d7cd445-6001-4fca-90c1-f6eea400d1db": "Based on the information provided, describe the success scenario for the euca2ools authentication process. What conditions must be met for the authentication to be successful?",
        "bf50f1d1-1237-40ba-88f4-2867fc5330ca": "Explain the role of the administrator and user configurations in the VM creation process. In what locations are these configurations stored, and what happens when they are compared during the transition (3.3) and (3.4)?",
        "42b41406-7c03-473b-bebd-c3d6a842e606": "Explain the mapping process in Eucalyptus and the constraints imposed on the mapping of virtual machines to physical resources. What is the significance of this mapping design in a corporate enterprise computing setting?",
        "ea3322cc-7307-4751-9ce2-601013ab341e": "OR",
        "546b1d6a-68de-4e71-8221-f52f5d2afb56": "Describe the architecture of Open Nebula and how it provides a flexible level of orchestration and configuration for VMs in a datacenter. How does Open Nebula's design make it suitable for building private, public, and hybrid clouds?",
        "000c7177-cba0-4cca-8ead-aa889e648203": "How does Eucalyptus support corporate enterprise computing settings by separating the administration space from the user space? What are the benefits of deploying Eucalyptus on top of existing resources and its open-source nature for experimentation?",
        "db6166b3-dfdf-4aa8-9d6b-fe1ca544d75d": "OR",
        "f38ef170-49a6-4c13-9290-96a66a1b38d8": "What was the initial purpose of Open Nebula as a research project in 2005? How has Open Nebula evolved since then, and what are its key technical aspects that make it a popular toolkit for building private, public, and hybrid clouds?",
        "9dab0487-366c-4ad3-af8d-a0cf04e95cdd": "Based on the given context, explain the role of the \"Tools\" layer in the architecture of Open Nebula. What are some examples of tools that can be developed using the Open Nebula core interfaces?",
        "04d889f2-c4aa-4b38-8df2-0b8416ee5885": "Describe the potential drawback of using the default customization with NFS file system in Open Nebula. What measure can be taken to mitigate this issue, if any is mentioned in the context?",
        "b25def79-e99c-4055-a05e-28c1730b9524": "Based on the context information, can you explain the role and functionality of drivers in Open Nebula? Furthermore, describe how drivers are used in the initialization of a virtual machine.",
        "b32248e2-153f-41bd-b5f2-1671d1d959e3": "The process of modeling a system in Open Nebula involves identifying required types, attributes, and mapping. Can you name and describe the types mentioned in the context? Additionally, explain how these types are mapped in Open Nebula configuration.",
        "20fed2ab-2e02-4cda-95c9-2b55e31ade99": "Based on Figure 3.5, which component or interface is responsible for user account management in the Open Nebula model for instantiating a VM?",
        "7c587b1e-86c6-43e5-8928-ffbf6f8d0824": "Identify and explain the role of two components in the Open Nebula model, from the figure, that are involved in the deployment and configuration of virtual machines. Provide their abbreviated names and full names in your answer.",
        "c94c0872-e4bd-4ea5-9cef-7ee2384b6e92": "Explain the role of the \"Open Nebula Daemon (oned)\" in the life cycle of a Virtual Machine (VM) and describe the steps it takes to create an instance of a VM in Open Nebula.",
        "17d56ffc-e527-42a1-acb3-9b214712737d": "Describe the data types used in the Open Nebula model and provide an example of how they are used in the context of VM creation. In your answer, include an example of how the \"NMI\" type and \"SSH\\_Cert\" and \"SSH\\_Pass\" string types might be used in the creation of a VM.",
        "12778c51-262a-4fe9-a625-c430cf283a06": "Based on the information provided in Table 3.4, what type of information is held in the place named \"Holds user requests\" and what is its corresponding mapping?",
        "e3ae8798-73d8-4ba9-b995-babda9e86495": "Using the transitions given in the context, describe the state changes that occur when creating a new VM instance, including the places and mappings involved in the process.",
        "659158bc-6c7a-44e5-803e-8356b54a7ed3": "Based on the information provided, create a new account for the Open Nebula cloud. What are the transitions and formulas involved in authenticating whether the requested user already holds an account or not? Explain the process in detail.",
        "2eaa9690-fc94-45e1-8422-f6f7727082d1": "Describe the steps that occur when a user logs into the Open Nebula cloud and requests for a VM. In particular, explain how the user account information is used to match the login credentials and forward the command. Additionally, describe the role of the disk image repository in this process.",
        "b22a67d1-a94d-4116-b027-f48daa3dbee1": "Based on the context information, describe the process of authenticating configuration parameters for spawning a virtual machine. What happens if the provided configurations do not match the administrator's settings?",
        "659ba4c3-4cc4-4b66-b88d-e99d5e3730be": "(3.10) and (3.11) refer to the authentication of configuration parameters during the generation of virtual NIC and MAC. Explain what actions are taken if the configurations match or do not match the administrator's settings.",
        "62c806d5-0ca8-48de-9f1d-e35a41590342": "In the context of the provided document, what is the role of Secure Shell (SSH) in the process of managing virtual machines? What are the consequences if the SSH certificate or password provided is incorrect?",
        "80995f57-f414-4b7a-9ae3-534c9247b837": "Explain how SSH is used in the process of logging into the compute node and mapping virtual NIC and MAC to physical NIC. Additionally, describe what happens if the SSH certificate or password is incorrect.",
        "98c131ad-6432-4a6b-8898-eb75ca95a9f9": "Based on the given context, compare and contrast the customization options available in Open Nebula and Nimbus. What are the benefits and drawbacks of having a high level of customization in each platform?",
        "b8a18c33-e3b2-46bc-bda8-a5d4519b87d3": "In the context of setting up a cloud system for research purposes, discuss the role of user authentication in Nimbus and how it differs from Open Nebula. Additionally, explain how the centralized nature of Open Nebula can make administration easier.",
        "5ad2046f-381f-4f75-b0d6-3ebc9f78a2b0": "Question (Easy): Explain the role and functionality of the \"Cumulus\" storage cloud implementation in the Nimbus system, and describe how it relates to the Amazon Web Service S3 REST API.",
        "2c66bb92-e696-4991-8d46-e5f01d29ea5f": "Question (Medium): Describe the components of the Nimbus Workspace and their roles in managing and deploying virtual machines. In particular, explain the functions of the Workspace Service, Workspace Resource Manager, Workspace Pilot, and Workspace Control.",
        "0527773d-ec0c-4027-bcf8-1ad27a982a85": "Based on the information provided, explain the role of the Context Broker and Context Client in the large virtual cluster setup. How do they interact and what is their function during VM startup?",
        "4654b939-187d-4bf3-af23-32f31ea14130": "Describe the process of requesting a VM in a Nimbus configuration, highlighting the role of the Cloud Client and the steps that follow the receipt of the request by the head node. Additionally, explain the concept of Network bridging in this context and its significance for Virtual MAC and NIC.",
        "33afca21-c207-4819-b2cd-1488f7030585": "Based on Figure 3.7A, identify and describe the role of the 'Cl_ClientCredCredCred' component in the Nimbus model. What can you infer about its function and importance in the overall system?",
        "014667ca-f969-4602-ae05-697f3e3606d7": "In the context of the Nimbus model presented in the figure, analyze the components and processes related to 'ACACPhy_HWDHCP'. What conclusions can you draw about its significance and interaction with other parts of the model?",
        "1c28a71c-4300-4f67-acd5-6010764c5af7": "Referring to Table 3.5 in the given context, what are the two data types associated with cloud client authentication?",
        "deb71f43-81a1-4a67-87ef-16f2d6dee4f8": "According to the transitions mentioned in the context, what are the necessary conditions that need to be fulfilled for the model to authenticate the credentials of the cloud client?",
        "8326df2c-02d1-40c5-9193-81b8e2ffaff6": "Based on the information provided in the context, describe the role of the \"Places\" mentioned in the model of Nimbus. Provide specific examples of how these \"Places\" are used in the system.",
        "03606ddd-65ac-44b9-9837-4bbdfe931f60": "Explain the conditions under which the transition from one state to another will not occur in the Nimbus system, as described in (3.15). What are the consequences of mismatched credentials and how does the system handle this scenario?",
        "258d8a32-d92c-43f2-8c06-e1da705741fd": "Based on the context information, explain the process that occurs when transition (3.18) is fired in the system. What happens to the VM template disk image, and where is it copied and pushed?",
        "2230b5da-1bfb-4a9c-8982-7471b8ba0244": "In the context information, Nimbus is described as having the ability to provide different resource leases to different users as a means of scheduling. How does this flexibility and customization make Nimbus suitable for the scientific community to perform experiments? Additionally, what are the workspace tools available in Nimbus, and how do they operate with Xen hypervisor and KVM?",
        "a4728498-0c2d-4b98-aa1b-b6f772174f3e": "Can you explain what the OpenStack is and describe its three main open source projects? (Refer to section 3.3.5)",
        "8fec4d5a-2d87-46d5-8b57-93f3bc86331d": "What is verification in the context of systems and models, and how is bounded model checking using SMT-Lib and Z3 solver used to perform verification? (Refer to section 3.4)",
        "324e5f73-235d-446e-a836-81fec3452fac": "For the first question, the student is expected to demonstrate their understanding of the OpenStack and its main components. For the second question, the student is expected to explain the concept of verification and how it is carried out using bounded model checking with SMT-Lib and Z3 solver.",
        "71f116b1-74eb-419b-b986-529a1f581dcc": "Question (Specification and Modeling): Given a system description and a set of acceptable inputs, explain the process of creating a formal specification for Bounded Model Checking. Additionally, describe how you would model the system using a Kripke structure.",
        "383332c8-7cdf-4140-b757-0651e7580422": "Question (Verification): Using the Kripke structure and the bounded model checking problem definition, explain how you would find an execution path of a certain length that satisfies a given formula. Also, describe the role of the computational tree in this process.",
        "995d020b-400b-492a-a0d4-5985ebbd10e1": "Question: Consider the definition of a path in a Kripke structure as an infinite sequence of states. Explain the concept of a model producing a path set and the use of the formal language CTL* to describe the property of a model. What do the operators \"For all paths\" and \"For some paths\" represent in CTL*?",
        "2d5c19e4-485f-46c3-86db-53af6db6bfde": "Question: Given the definition of an SMT Solver and its role in checking whether a formula satisfies a theory, explain how an SMT Solver can be used to determine if the states of a model satisfy a specific formula under a given bound. Additionally, explain the meaning of the operators \"Next,\" \"For future paths,\" \"Globally,\" and \"Negation\" in the context of CTL*.",
        "698898ca-d072-4c80-a2c2-92d484d0d5be": "How does the Z3 solver determine whether a model satisfies a given property or formula, and what are the possible outcomes of the verification process?",
        "498cc1f8-105f-411a-878a-fd1172fe3c77": "Can you explain the concept of a computational tree in the context of model verification, and how it is used to demonstrate that a model terminates after a certain number of iterations? Additionally, describe the role of terminating states in the verification process.",
        "639c604e-b55f-4d26-b49a-d72ee7a4b5ad": "Based on Figure 3.10, describe the structure of the computational tree in Eucalyptus. What role does each component (e.g., V\\_Req, E2\\_C, Ad\\_Co, Run, etc.) play in this tree?",
        "3ccfc67e-e982-4692-9839-e3920a32c090": "Referring to the data presented in Figure 3.11, how does the verification of Eucalyptus change as the memory size and execution time vary? Analyze the trends in verification based on the given memory sizes (in MB) and execution times (in msec).",
        "c7d4595c-c59f-493b-9842-239bf44c5a38": "Based on the verification results of Open Nebula and Nimbus presented in Figure 3.12 and Figure 3.13, discuss how the properties of VM-based systems were verified. What were the properties verified and how were they satisfied by the models?",
        "f54fb02f-2be1-4999-adac-aa2861ada487": "Analyze the Time vs. Memory graph for the verification of Open Nebula and Nimbus. Based on the graph, how does the memory size in MB(s) and execution time in msec(s) vary with the number of VM instances for both systems? What conclusions can be drawn from this analysis?",
        "6bd7ce88-d4c4-4a39-942d-1c47474920cb": "How are the models of VM-based systems verified for correctness in the given context? Explain the process of translating models and properties to SMT and using the Z3 solver.",
        "bef15a0e-65e7-4abb-80fe-b94bcbbe789c": "According to Figure 3.14, how does the execution time of Eucalyptus, Open Nebula, and Nimbus change as the number of VMs increases? Analyze the chart and provide specific execution time values for a given number of VMs.",
        "d6ee61a2-421b-436f-b21e-d9ee2fd78ae3": "Alternative questions:",
        "5fa3ca37-7019-434c-b966-c52d3fe05d10": "What is the main goal of the verification process described in the context, and why is it important to differentiate it from performance measurement and analysis?",
        "9808b92f-367a-4267-8c66-6e2a9985ae3b": "Examine Figure 3.15. How does the memory utilization of Eucalyptus, Open Nebula, and Nimbus change as the number of VMs increases? Compare the memory utilization of the three systems for a specific number of VMs.",
        "dcbd5fd6-060a-47e5-a4db-31b2c1cc1c88": "Based on Figure 3.11, 3.12, and 3.13, how does the execution time of the models for Eucalyptus, Open Nebula, and Nimbus change as the number of VMs increases? Can you explain the reason behind this trend?",
        "c057c252-4609-40ad-aca6-411f15654712": "According to the context information, what is the goal of the verification process and how does it differ from evaluating the performance of the models or the systems? Additionally, why is it important to demonstrate the correctness of the models and their feasibility with respect to scalability and execution time?",
        "eabdf043-8fe3-42a2-8b55-98972050a3a0": "Based on the references provided, explain the concept of \"Market-Oriented Cloud Computing\" as introduced in [3.1]. What are the potential benefits and challenges of this approach?",
        "51a0482a-5ee0-4491-b827-b6c035edfb19": "Explore the use of open-source cloud computing systems, as described in [3.10] and [3.11]. Compare and contrast the Euca Lyptus Open-source Cloud Computing System and oVirt in terms of their features, architecture, and use cases.",
        "136b7a60-113d-446e-9294-8110463d55ba": "Explain the concept of Cloud Computing and its aspects as discussed in the article by Panzieri et al. [3.13]. What are some of the open-source VM-based cloud management platforms mentioned in Cerbelaud et al. [3.16] and Endo et al. [3.17]?",
        "1d09645b-fa90-4b56-8c1e-ab3fc89158e0": "What is the Xen hypervisor and how can it be subverted, as discussed in Wojtczuk [3.14]? Additionally, explain the use of Petri Nets in analyzing and modeling concurrent systems as discussed in Murata [3.20] and Lectures on Petri Nets I [3.21].",
        "6882f56c-48c7-44e3-b4d5-f02c2218ffa1": "Question: Consider the paper by L. Moura and N. Bj\u00f8rner on Satisfiability Modulo Theories (SMT) in the context of software verification. Briefly explain what SMT is and describe one practical application of this technology according to the authors.",
        "787e70fd-9af7-4319-927e-2aa715eb869a": "Reference(s):",
        "9545c45b-d645-41a9-8f41-c774cbcbc0d2": "[3.23] L. Moura and N. Bj\u00f8rner, \u201cSatisfiability Modulo Theories: An appetizer,\u201d In Marcel Vinicius Medeiros Oliv eira and Jim Woodcock, LNCS, vol. 5902, pp. 23 -36, Springer, 2009.",
        "110d38a2-f0d8-45cd-ade3-c53afecc95c3": "Question: In the context of cloud computing, compare and contrast the features of OpenStack and Eucalyptus, Nimbus, and OpenNebula. Your answer should include at least two points of comparison for each platform.",
        "f9eb60a4-5ae2-4175-97a3-8c8efc23319e": "Reference(s):",
        "6fc2227b-1bf9-4303-a28a-6037e739d2ed": "[3.25] OpenStack, <http://www.openst ack.org/downloads/openstack-overview-datasheet.pdf>, on July, 2013.",
        "51b90b5c-e754-4aa0-929c-1c209b365c26": "[3.34] P. Sempolinski and D. Thain, \u201cA comparison and critique of Eucalyptus, OpenNebula and Nimbus,\u201d Cloud-Com, pp. 417 -426, 2010.",
        "4d440058-a5c3-46f5-ae6b-85b84c190907": "Question (Short Answer): Define Eucalyptus and explain its significance in cloud computing based on the information presented in [3.35] and [3.36].",
        "c4dc50b1-87dd-483d-8683-0ea7e5a045f8": "Question (Essay): Compare and contrast OpenNebula and Nimbus, two cloud management tools, by using [3.38], [3.39], [3.40], and [3.42]. In your answer, consider their features, benefits, and potential applications in managing cloud resources.",
        "5c4ee090-61e9-46ea-a702-3156cf215ca7": "Explain the concept of \"hypervisor control-flow integrity\" and describe the approach taken by the HyperSafe system as presented in [3.48]. What are the potential benefits and limitations of this approach?",
        "ccf78c2e-d436-4f1a-94d5-bad7e5f3cd92": "Compare and contrast the contributions of the following papers with respect to cloud computing and virtualization security: [3.47], [3.49], and [3.50]. In your comparison, be sure to discuss the different techniques used, their advantages, and any potential drawbacks.",
        "6b5bbb23-188c-4536-a4ec-cce7629a7eb8": "Explain the concept of Open Shortest Path First (OSPF) routing protocol and the role of Designated Routers (DR) in improving the convergence time of a segment in an area. (4.1, 4.2)",
        "102cac21-3633-4982-bd9a-4d99c344c279": "Why is fast convergence time critical in modern dynamic large-scale routing domains, such as data centers, and how does the paper address the convergence time analysis of OSPF that incorporates DRs? (4.1, 4.3, Conclusion)",
        "78305255-f976-45bc-89f2-dc0d157efbf3": "Based on the information provided, how does the BRITE topology generator help in creating realistic simulations for the OSPF protocol? What specific characteristics of the Internet does Otter represent in the generated topologies?",
        "2b547285-9d5d-4d84-b008-697e8e80294c": "In the context of the problem formulation, how is the communication cost between two routers defined? Also, explain the significance of studying the effect of DRs (Designated Routers), cascading failures, and topological changes on the convergence time of routers in an OSPF network.",
        "a94eb26e-7a90-4ca1-933e-b5fcf57d0e8e": "Given the expression for calculating the minimum time for transferring a message between two nodes, define the terms used and explain how the expression takes into account the physical distance, propagation delay, message size, and available bandwidth.",
        "5b37e94a-c6b0-4b3f-b0b6-38a5b3927f72": "Describe the process of handling a router failure in the context of the given document. Explain the roles of the DR (Designated Router) and non-DR routers in detecting and responding to a failure, as well as the concept of Dead Interval (DI) and the formula for calculating the time it takes for a router to receive an update.",
        "bb138150-aa08-4ec1-81c0-2cbb5de8fc27": "Based on the given context, calculate the Convergence Time (CT) of an area \u03c4, given the maximum delay diameter (DD) and the time when the update is initiated (TI). Explain each step of your calculation and provide the equation used.",
        "e01b61be-58b1-41c5-8b5e-27d1873a0874": "What is the significance of the \"Hello\" interval in the context of router updates and how is it related to the Dead Interval (DI) of routers? Also, explain how the DI is used in calculating the CT of an area \u03c4.",
        "e69dd5f9-eaba-4f71-8ed9-f3b06124877e": "Based on the information provided, how does the number of Designated Routers (DRs) affect the convergence time (\u03c4) of a network? Explain using Fig. 4.2 and the results for N=1000 and N=300.",
        "cc94fe56-b068-4bbd-a7b2-185a6e76d508": "Given the assumptions about the communication medium and message size in the context, what is the significance of the constant bandwidth value of 100Mbps in evaluating the convergence time (\u03c4)? Explain how this value might impact the network's stability.",
        "30202fe1-7016-418e-9ece-c4de3ac56f4b": "Based on the information provided, why does increasing the number of DRs in an area not always result in a decrease of the convergence time (\u03c4)? Provide an example to support your answer.",
        "2fae0d90-11bb-4eae-a319-9a7ed7d9a21e": "In the context of Fig. 4.3, describe the relationship between the number of failures (both node and link) and the mean value of \u03c4. Additionally, explain how the degree and placement of a failed node or link can impact the value of \u03c4.",
        "796a3300-e19d-4f80-b5ce-6a31e585eac0": "Based on the information provided, how does the failure of a node affect the value of \u03c4, compared to the failure of a link? Explain the reasons for this difference.",
        "df1ddab1-adef-47ee-89ce-6541f6843c73": "In the context of OSPF (Open Shortest Path First) routing protocol, how does the addition of a new shortest path by a router impact the value of \u03c4? Discuss with reference to Figure 4.4.",
        "74adcd14-fa81-4635-8032-2007e1651c23": "Explain the concept of Open Shortest Path First (OSPF) version 2 as described in RFC 2328 [4.2]. What are the key components and features of this routing protocol?",
        "b3c8bc11-3e0c-4083-9a90-f405c44fe18f": "According to the paper \"Improving Convergence Speed and Scalability in OSPF: A Survey\" [4.3], what are some of the techniques that have been proposed to improve the convergence speed and scalability of OSPF? Briefly describe one of these techniques and explain how it addresses the convergence and scalability challenges in OSPF.",
        "a2ba177e-e5d9-49b2-af05-fc4729712ce0": "Why is the Data Center (DC) considered the backbone of cloud systems, and what are the QoS attributes it must maintain for high-performance computing applications?",
        "be604d5f-da42-47ed-ac9b-3ed142c9a575": "How do blade servers help minimize physical space and energy usage in Data Centers, and what was the expected cost of peak power consumption of DCs in 2011, according to the EPA report mentioned in the document?",
        "e48c38dc-f4c8-4057-b708-c3c145c93a05": "How does the Service Level Agreement (SLA) impact the income of a Data Center (DC) and its energy consumption? Explain with examples from the given context.",
        "26cee446-37ce-44c4-981f-60b9ebb2dac8": "In the context of the paper, how does the Cyber Physical System (CPS) model help in understanding the thermal properties and energy efficiency of a DC? Explain the importance of modeling the \"Cyber\" and \"Physical\" portions of the CPS in detail.",
        "954e0d86-8816-43be-8297-33bc08b5e5b7": "Based on the given context, explain the hierarchical model of the data center's physical infrastructure and the layers involved in it. What are the components present in each layer and how are they arranged?",
        "02e8cd32-45e3-4a11-8d1c-894b62a7c8cf": "The document proposes a Thermal Aware Control Strategy (TACS) to manage and control the thermal dynamics of the data center. Describe the role of High Level Centralized Controller (HLCC) and Low Level Centralized Controller (LLCC) in TACS. Also, explain how the simulation of TACS was performed and what real data center workloads were used for the simulation.",
        "25571f11-fcc4-4332-b961-f6a2a265e349": "Explain the role of High-Level Petri Nets (HLPN) and Z language in the analysis of a data center (DC) as a cyber-physical system (CPS) and provide examples of how they are used to simulate, provide mathematical representation, and analyze the behavior and structural properties of the system.",
        "b04791cc-c761-4258-ad24-935734df6a06": "Describe the proposed Thermal Aware Control Strategy (TACS) and its use of High-Level Cyber-Physical Control (HLCC) and Low-Level Cyber-Physical Control (LLCC) to manage, control, and coordinate the cyber and physical portions of the CPS in order to maintain a unified thermal threshold range. Additionally, discuss the results of the simulation and comparison of the proposed strategy on a real data center workload.",
        "b5afc8f6-cd82-43fc-8589-86cefd21b906": "How does the proposed methodology in the paper analyze the thermal dynamics of the cyber and physical portions in a data center (DC), and what is the main goal of this analysis?",
        "f8d5080d-7473-4003-93d3-3c4ac2a21a8c": "Describe the hierarchical model of the data center's Cyber Physical System (CPS) as presented in Figure 5.2. Include the components and layers of this model and their roles in the DC architecture.",
        "ad42bc74-1508-428f-8a4d-4a2e55581955": "Based on the given network infrastructure model, explain the concept of energy conservation in the context of Data Center (DC) systems. How is mechanical energy consumed by the physical portion of the DC system as it performs cyber tasks?",
        "570a86d1-92a1-42f7-bfd6-e07cec0ea399": "In the given CPS model of Data Center networks, derive the formula for calculating the number of nodes in a pod (zones). Explain the significance of each component in the formula and how they contribute to the overall network architecture.",
        "97f05c45-3aba-4dd6-a282-1dd792742959": "Using the formulas provided in the context, calculate the heat dissipated by the high-end switches in the core layer, given the workload and the fixed heat dissipation value. Explain each step of your calculation.",
        "c5754cda-ff1b-454d-9955-6d4c84087277": "Define the terms \"static power\" and \"processing\" as they relate to the heat dissipation of a server component. Additionally, explain how the heat dissipated by memory is modeled and calculated, and what factors it depends on.",
        "aac4b800-1662-4715-94d2-4a523579514f": "Based on the given context, explain the difference between the functions and features supported by a spine switch versus a leaf switch in a data center network. Additionally, describe how the heat dissipation of these switches is different and how it relates to their respective roles in the network.",
        "8f79ca87-6bfc-4dd4-a0b0-d98083d5a146": "Given the equations provided in the context, calculate the heat dissipation of high-end switches (core layer) using (5.5), (5.6), and (5.7). Explain the significance of the requirement that the value of heat dissipation for high-end switches must always be greater than that of top-of-rack switches, and discuss the potential implications of this requirement on the overall design and operation of a data center network.",
        "0d2ffafc-1abc-4ac9-9517-1dbde9b6bc7a": "Using equation (5.9) and (5.10), write a question that requires the student to calculate the total heat dissipation of all access and aggregate switches in a single rack.",
        "cc0e70f0-c114-4a6e-9cc3-fb5f91aa66a1": "Example: \"Given the heat dissipation of an access switch and an aggregate switch in a rack are 300 watts and 500 watts respectively, calculate the total heat dissipation of all access and aggregate switches in that rack using equations (5.9) and (5.10).\"",
        "bb9158ee-5f6f-4928-ad86-83420d93b38f": "Using equation (5.11), write a question that requires the student to calculate the overall heat dissipated by the entire CPS (Cloud Processing System) without considering the ambient effect.",
        "00b918aa-4c53-4b43-88c2-ce0313e3b5c9": "Example: \"Given the heat dissipation of a single rack in the CPS is 2000 watts, calculate the overall heat dissipated by the entire CPS using equation (5.11). Assume there are 10 racks in the CPS.\"",
        "9601d47b-cbee-4a27-83ca-46466ffdbc09": "Based on the information provided, explain the role of ambient temperature in the heat dissipation of a component in a Cyber-Physical System (CPS) environment. What are the red and blue dotted lines in Figure 3 representing?",
        "c00567f8-a4a3-49f8-bb93-82d9dcdd0be5": "Consider the input temperature calculation for a node in a CPS environment as given by equation (5.12) in the context. Define all the symbols used in the equation and explain how the input temperature of a node is affected by the heat dissipated by the node and the surrounding temperatures.",
        "10e6776d-4470-455e-8fe8-411603b3d819": "Using the information provided in the context, explain the concept of the air coefficient and its role in the representation of air density, heat of air, and flow rate of air. Be sure to include the formula for calculating the air coefficient.",
        "198a8780-b5e0-4e46-8321-7d141022e906": "Given the power distribution vector of all the servers in a data center, describe how the temperature profile of all the servers can be calculated. Additionally, explain the concept of the cross interference coefficient matrix and how it is used to represent the heat distribution and its effect on the surrounding machines. Be sure to include the formula for populating the thermal effect of one server on another.",
        "be0c31eb-5b44-4aff-8ddc-df8cb04efdaf": "Based on the given figure and algorithm in the context, explain the role of High Level Centralized Controller (HLCC) and Low Level Centralized Controller (LLCC) in the Thermal Aware Control Strategy (TACS) for managing and controlling the thermal dynamics of a Cyber-Physical System (CPS).",
        "16fe6010-18de-40d0-a39a-266ded8092ed": "Describe the steps involved in the Low (server) Level of TACS as presented in Fig. 5.6. Explain the purpose of each step and the conditions that trigger the migration of tasks between servers.",
        "b7790139-5de0-4592-b743-8d2dfd4688dc": "Explain the role of High-Level Thermal Control Center (HLCC) and Low-Level Thermal Control Center (LLCC) in maintaining the thermal threshold in every pod of the Cyber Physical System (CPS). Also, describe the process of task allocation and migration in the CPS.",
        "11b64665-9baa-42a6-bf16-4b2369d891a9": "What is the purpose of the constraint in the context of task migration within the same pod in the CPS? Explain the steps involved in high (access and aggregate) level as depicted in Fig. 5.7. Additionally, what is the significance of the threshold temperature in the task migration process?",
        "8c88868c-5844-4d83-b106-b2339c965128": "Explain the concept of task migration in the context of the CPS network infrastructure and describe the conditions under which high-level task migration is performed.",
        "650263b0-bef6-4b4d-af68-c68a7ef26227": "How does the LLCC make decisions for traffic redirection within the same pod and between different pods to avoid hotspots and stabilize the temperature of the pod? Describe the role of redundant paths and the maximum threshold temperature in this process.",
        "f16e7631-0ae2-4454-94c0-0cebeb863ad0": "Question (Short Answer): Explain the role of the High-Level Control Component (HLCC) and Low-Level Control Component (LLCC) in maintaining the thermal threshold value in a CPS. Include their responsibilities and communication in the process.",
        "919e739f-0897-428a-aa2c-af1f70546c48": "Question (Problem-Solving): Given a scenario where the thermal signature of a pod starts to exceed its maximum thermal threshold value, describe the steps the HLCC would take to migrate tasks to other pods. Additionally, explain how the server selection and task allocation are performed in this scenario.",
        "f9730318-9da6-47ae-b6bc-586907104662": "Question for Specifications task in Bounded Model Checking:",
        "820c842f-7586-442c-be4b-e9990221a365": "Given a system with acceptable inputs, explain how you would create a specification for Bounded Model Checking to verify if any of these inputs drive the system into a state where it always terminates after a finite number of steps. Provide an example of such a specification.",
        "dc836322-7365-4058-9dd2-b33875bf3793": "Question for Kripke Structure in Bounded Model Checking:",
        "0beff110-4292-4b90-8e32-89690c63e098": "Describe the components of a Kripke Structure and how it is used to represent the behavior of a system. Using the example Kripke Structure provided in the context, demonstrate how to find an execution path of length 2 that satisfies a formula ppp or pqp. Explain the process and the steps taken to reach the conclusion.",
        "c2f52b5d-fd0c-4a3b-9020-8e54b2fc8afd": "Define \"SMT Solver\" as described in Definition 3 and explain how it is used in the verification of models with Z3. What does the solver's response of \"satisfiable (sat)\" or \"unsatisfiable (unsat)\" mean in the context of model verification?",
        "e1ddc751-ac2f-44a1-a400-bf8069b6c46c": "Describe the first step in modeling High-Level Control Component (HLCC) and Low-Level Control Component (LLCC) using High-Level Petri Nets (HLPN). What are the required types, places, and mapping, and how are they identified? Provide an example using the information presented in Tables 5.1 and 5.2.",
        "b29b3d4c-1657-4a55-a31f-69ea201a5971": "Based on the information provided, define the \"Task\" type and explain its role in the High-Level Cloud Controller (HLCC) and Low-Level Cloud Controller (LLCC) model. Provide a brief example of how this type might be used in a transition's post-condition.",
        "67e3c17c-7ccb-4afd-b1ed-8795d72e41c8": "Explain the concept of thermal signatures (Th. Sig) in the HLCC and LLCC model. Additionally, describe the roles of \"Th_P\", \"Th_S\", \"Th_Ac\", \"Th_Ag\", and \"Th_Co\". Finally, provide an example of how the thermal threshold values (Max_Th_P, Max_Th_S, Max_Th_Ac, Max_Th_Ag, Max_Th_Co) might be used in a pre or post-condition of a transition.",
        "aecfdc45-8467-463b-b6f5-935842e609ed": "Based on the information provided, can you identify the components of the authentication process in the HLCC and LLCC model? Specifically, what are the places and transitions mapped to the formulas (5.16) and (5.17) in the model?",
        "ea431f08-d2f6-46e5-b04f-a7809caf8fb6": "In the context of the HLCC and LLCC model, what is the role of the places associated with the variables Th\\_P, Th\\_S, Th\\_Ac, Th\\_Ag, and Th\\_Co? Can you provide specific examples of how these places are used in the authentication process?",
        "eb47284e-9e40-411e-bee0-74831c085ba5": "Based on Figure 5.9, describe the HLCC and LLCC HLPN Model in a DC Environment, and explain the role of the \"Job-Req-SGS\" component within this model.",
        "b0fc716a-4119-4038-9528-6c40ee55df3e": "Analyze the context information and identify a term that represents a process related to job migration. Provide a detailed explanation of this term, including its potential impact on the overall system.",
        "d4d7e33d-5ada-4720-83fa-251f6fd9808b": "Explain the role of the HLCC in monitoring the thermal signature of pods and the process of acquiring and sending thermal information to the resource manager. What are the conditions under which a job will be rejected by the resource manager?",
        "6a860386-4068-4a2d-b8f6-c96862210012": "Describe the involvement of the LLCC in the resource allocation process. How does it acquire and provide information about the servers that satisfy the given constraints? Additionally, explain the role of heat sensors in this process and how their readings are used by the HLCC and LLCC.",
        "bd4ca105-2faa-4e52-85eb-f5960facfed9": "Explain the concept of local redirection and migration (LcMg and LcRd) performed by the HLCC and LLCC within the same pod, as mentioned in the context. What are the conditions under which these actions are triggered?",
        "89cbdb22-1837-4749-a6b7-cfb66ef71d08": "In the event that local migration or redirection is not possible, the LLCC requests HLCC to provide information about the pods where the tasks can be migrated. Describe the process of inter-pod migration and the role of HLCC and LLCC in this process.",
        "e80eba9b-f517-4a57-b346-52de69049bc3": "Based on the information provided, how is inter-pod migration performed in the context of CPS, and what triggers this action? Provide a detailed explanation using the given figures and descriptions.",
        "d9f02ad0-b38f-40e0-a745-8d3a28d42801": "In the context of the Kripke structure and computational trees presented in Fig. 5.10 and Fig. 5.11, what property is being verified, and how does the verification process ensure that there will be no hotspots (overheating) in the system? Explain the role of the HLCC and LLCC in this context.",
        "660753cb-490e-4551-91e0-28d6b92a4ac3": "Based on the information provided, explain the role of the \"OverHeat\" state in the context of the control strategies. What actions are taken when this state is reached, and how do these actions help to stabilize the temperature?",
        "e5bf495e-c534-4589-b85f-b0bf7541ce50": "Analyze the computational tree presented in Fig. 5.11. Describe the significance of the \"Complete\" state in the tree and explain the meaning of the states labeled with \"x x\". Also, discuss the importance of terminating states in the models and how the solver ensures their existence.",
        "f0ed2e45-caff-4350-9438-cd3b20284e3f": "Comparison of Scheduling Strategies: Explain in detail how the First Come First Serve (FCFS) scheduling approach differs from the Thermal Aware Task Allocation approach in terms of handling long-running jobs and thermal awareness, using examples from the CCR dataset.",
        "ca5e25b6-67f0-4a1f-ba1f-4a07eeead687": "Genetic Algorithm for Thermal-Aware Scheduling: Describe the steps of the Genetic Algorithm (GA) based thermal-aware scheduling approach as mentioned in the document. Also, explain how the fitness function is used in this approach and what role it plays in selecting the best task allocation.",
        "fed797ce-c230-4620-b9df-21229fdd4503": "Based on the information provided, explain the concept of the TASA algorithm and how it is used to address hotspots in a data center. What is the theory behind this algorithm and how does it help in load balancing?",
        "04314a87-bd4b-4c34-8eff-124159b4a603": "According to the context, what could be the reasons for the occurrence of hotspots in the data center, as observed in Figure 5.12(a)? Propose a solution to prevent the formation of such hotspots and explain how it would help in improving the overall performance of the data center.",
        "703bd7b1-018c-4907-950d-45de8743da62": "Based on Figure 5.12, which scheduling algorithm, (a) FCFS, (b) GA-based, (c) TASA, or (d) TACS, appears to have the lowest average thermal signatures for the pods, and what can you infer from this observation?",
        "38a582a4-3c86-46e8-90ff-91ce0980b4fe": "From the time-temperature data provided in the context information, can you determine which pod experienced the highest temperature at any given time? If so, which pod was it and at what time did it reach its maximum temperature? If not, explain why this information cannot be determined from the given data.",
        "a807953f-e4bf-4afe-b2f5-54febd7df402": "Based on the information provided, how does the random nature of the GA-based approach contribute to the occurrence of thermal imbalances and hotspots in a data center? Provide specific examples from the text to support your answer.",
        "1e6fab28-94c2-421f-902c-eb488eb5b36d": "Based on Figure 5.13, which scheduling algorithm (FCFS, GA-based, TASA, or TACS) shows the most significant difference in average thermal signature between the highest and lowest servers? Provide a brief explanation to support your answer.",
        "2edb03e0-255a-4f10-a9d3-1b7b126367f3": "In the context of the given figure, what might be the potential benefits of using a scheduling algorithm that results in a smaller average thermal signature difference between servers? Consider system performance, energy efficiency, and server lifespan in your response.",
        "a67fe2db-8de6-4302-a74b-0caae7800b50": "Based on the information provided, how does the Z3 solver verify the thermal balance in the data center (DC) after task allocation is complete? What property is used for verification and how does it match with the simulation results?",
        "87b9b3be-676c-41b5-b19c-23dd178c3c26": "In the context of thermal balance in a data center, what are the differences in the average thermal signatures between the highest and lowest servers for FCFS, GA-based, TASA, and TACS scheduling techniques? What can be inferred from these differences?",
        "b86c7118-bc10-48a5-b2f0-1d257336cfeb": "Based on the information presented in Table 5.3, under what number of jobs did the GA-based scheduling approach transition from unsatisfiable to satisfiable for the first time?",
        "c25bf986-ea8e-4da2-bb23-bbfc30cca21d": "Figure 5.15 compares the verification time of different scheduling approaches. According to this figure, which approach had the lowest verification time for 60 jobs, and what was its verification time in milliseconds?",
        "ede19713-8142-4866-b2c8-cb7f23ededca": "Based on the given context, explain the role of bounded model checking technique in the verification process and how the execution time serves as a bound over the verification models. Also, mention what the solver returns when the stated assertion is not true and when the property is met by the model.",
        "b967858b-46d0-4cfd-9504-b5774cda1a57": "In the context, it is mentioned that strategic decisions performed by HLCC and LLCC based on the thermal signatures of the components help in reducing the possibility of hotspots. Explain the concept of hotspots in this context and why it is important to reduce their possibility. Additionally, mention two references from the context that discuss the concept of hotspots or thermal signatures in more detail.",
        "0b35d939-dfdb-4410-bc8b-fe94397a62d2": "Explain the concept of \"temperature-aware workload placement in data centers\" as presented in [5.5.7] by Moore et al. Discuss how this approach can improve energy efficiency in data centers.",
        "0fbda270-bb68-4b50-9007-2fe1f259f0aa": "Based on [5.5.9] and [5.5.10] by Parolini et al., describe the \"Cyber-Physical Systems Approach\" to data center modeling and control for energy efficiency. What benefits does this approach provide in managing energy consumption in data centers?",
        "6d663b94-0ce5-4f3b-b1da-cb0f66d33bf0": "Based on the information presented in [5.15], explain the concept of per-core power gating for power management in data centers. What are the potential benefits and drawbacks of this approach?",
        "e6c67f3d-da0a-48ed-a73e-6e313361149c": "Considering the content of [5.16], [5.19], and [5.21], discuss the role of thermal management in data centers. How do the CPU fan, heat sinks, and automated thermal mapping contribute to maintaining optimal operating temperatures? Additionally, explain the importance of considering thermal constraints when controlling processor speeds (as described in [5.17]).",
        "3e918f37-38f1-40da-8b94-b774fff562af": "Explain the concept of \"energy-efficient thermal-aware task scheduling for high-performance computing data centers\" as presented in [5.23]. What are the main contributions and benefits of this approach?",
        "fe91ef5c-46e1-47f2-b105-42546cc48539": "Describe the use of Petri Nets in the context of computer systems, as discussed in [5.28], [5.29], and [5.30]. What are the properties, analysis methods, and applications of Petri Nets, and how do they contribute to the understanding and design of concurrent systems?",
        "26962cf3-367a-4fc8-b96f-dfca8e0ad273": "Question (Theory/Concept): Explain the concept of \"Satisfiability (SAT) Solvers\" and its significance in the context of knowledge representation. Refer to the information provided in [5.33] for your answer.",
        "661ab646-dbad-4793-a45c-cb2d7a833ba3": "Question (Application/Practical): Given the paper [5.36] on \"A Methodology for OSPF Routing Protocol Verification,\" discuss the importance of verifying routing protocols in data center networks. Additionally, suggest a scenario where the methodology discussed in the paper could be practically applied.",
        "d372b776-b8df-4dc1-9a7b-2680a19eb56e": "Question (Quiz/Examination): Explain the \"common fragment of CTL and LTL\" as mentioned in the paper by M. Maidl in the Symposium on Foundations of Computer Science, 2000. What are its implications and applications in the field of computer science?",
        "68d1d775-1fed-4b84-b18f-5cbb404cb4a1": "OR",
        "39fe634d-d73d-4ba7-b7bb-6ffc14de8305": "Question (Quiz/Examination): According to the paper \"A Taxonomy and Survey on Green Data Center Networks\" by K. Bilal et al., what are the key components and considerations of Green Data Center Networks? Provide a brief overview of the taxonomy and survey presented in the paper.",
        "9149eb61-e266-47e4-8a74-bcbd815b1b2c": "OR",
        "24d406f1-747d-4853-9886-521e0ddb2c2a": "Question (Quiz/Examination): In the paper \"SMT-based bounded model checking for embedded ANSI-C software\" by L. Cordeiro et al., what is the significance of using SMT-based bounded model checking for embedded ANSI-C software? Explain the methodology and its advantages over traditional methods.",
        "5d8a3f38-9e7a-4d53-b7b3-da8d6e7f9fed": "OR",
        "20dcbcd6-50c2-49b5-b1e2-3bc0cabcab0b": "Question (Quiz/Examination): According to the paper \"SMT-based bounded model checking for embedded ANSI-C software\" by L. Cordeiro et al., what are the limitations and challenges of using SMT-based bounded model checking for embedded ANSI-C software? Provide a critical analysis of the methodology and its potential for future research.",
        "846dc8a8-6abb-49ec-8863-e08cfb7f5bf9": "Explain the concept of Open Shortest Path First (OSPF) as described in the context, including its role in distributing routing information within a single Autonomous System (AS). Also, describe how OSPF divides the network into areas and what a segment constitutes in this context.",
        "fd9c6f63-beee-4f2c-91d3-f02357f586c1": "Discuss the importance of verifying the working of the routing protocol in large scale networks, as mentioned in the context. Why is it compulsory to ensure reliable communication amongst the systems in the network? Furthermore, in what ways can the performance and stability of the network depend on the performance of the routing mechanisms implemented within the architecture?",
        "648bd193-84af-43f1-9eda-06b8dd2b5c0b": "Question (Short Answer): Explain the role of Satisfiability Modulo Theories (SMT) in the context of automated deduction and how it is used in fields such as deductive software verification, planning, model checking, and automated test generation.",
        "2a315e6f-01af-4e5c-abf0-121ff0235c1f": "Question (Essay): In the context of maintaining high service availability in modern routing domains like data centers, discuss the importance of fast convergence in OSPF and how the correct routing of information can help avoid message loss. Also, explain how SMT-Lib and Z3 Solver were used to verify the OSPF protocol and the potential consequences of slight misinformation leading to huge packet loss.",
        "8dae6a09-b3f8-4121-a330-a0747b4dc5bb": "Question: In the context of the paper discussed, can you explain the role of the Z3 solver and how it is used in the verification process of the OSPF routing protocol?",
        "70b3ad13-f4f2-4646-bec1-f815ee1a9444": "OR",
        "69f3cd9d-86d4-439b-bc93-a9e082d3da13": "Question: How does the proposed method in the paper use delay information of the router as a property to verify the OSPF routing protocol and what benefits does it provide in terms of scalability?",
        "3b944595-45a8-41f3-8f79-409d1ed6eb2c": "OR",
        "4cea2e4a-9ead-42d9-a9e8-1b399b6975b8": "Question: In the given context, can you describe what a link-state routing protocol is and how the OSPF protocol fits into this category?",
        "2c4c3373-7400-4013-97a1-c2d556b41432": "OR",
        "8634bcac-1857-4917-9ce2-f9a69a59d301": "Question: According to the document, how does the BRI TE topology generator represent the characteristics similar to those of the Internet and how is it used in the verification process of the OSPF routing protocol?",
        "757d1aba-dc92-48f6-b379-abe0ae9ec41b": "Question (Short Answer): Using the information from Table 6.1, explain the role and characteristics of an \"Autonomous System Boundary Router\" in an OSPF network.",
        "93feafa5-d342-40ef-a17c-30c5ef4af318": "Reference: Table 6.1 - The OSPF Routers",
        "b6dd74c9-02e8-4226-aef6-30a236396b51": "Question (Essay): Describe the concept of Designated Routers (DR) in OSPF and how it helps to decrease intra-area convergence time. Compare and contrast this with the process of how routers communicate topology information using Link State Advertisements (LSAs).",
        "2f12bd36-e81d-41e9-aaec-a4ad74d42658": "Reference: 6.6, 6.14, and Table 6.1 & 6.2 - The OSPF Routers and Types of LSAs supported by the routers",
        "ad777c26-68b1-4d5b-8057-d1966231d0ce": "Based on the information provided in the context, what are the four types of Link State Advertisements (LSAs) in OSPF and what is their associated router? Briefly describe the purpose of each LSA.",
        "7f8bc32b-80e3-4ea2-baf9-b5de88ee6410": "Consider a network with routers R1 and R2 connected by a link with a communication cost (del) represented by the expression \u03b4(R1, R2) = \u03b2L + \u03bd/m, where \u03b2, L, \u03bd, and m are constants. Given this expression, how would you interpret the meaning of the constants in the context of the link's communication cost? Explain your answer.",
        "0dfd1fb7-e350-4206-850b-84a1d5827be2": "Consider the communication cost formula given in the context information. Explain the significance of each variable in the formula and describe how the formula changes if the routers are directly connected.",
        "80a68577-8e13-4c0a-bd7e-4cc114d183db": "In the context information, the process of link state verification is explained in two aspects: content verification and routing verification. Explain the concept of content verification and describe how the Link State Database (LSDB) is used to ensure correct calculation of the link state. Also, provide an example to illustrate your explanation.",
        "3c9a0781-ada2-4c1c-98d1-8bb9dfdfd201": "Using the formulas provided in the context, calculate the convergence time (\u03c4) of an area given that the delay in receiving updates (DI) is four times the \"Hello\" interval, which is 10 seconds for broadcast and P2P networks. Assume that the number of routers in the area is 20 and the maximum time taken to receive an update from the corresponding router is 15 time units.",
        "ab4d0fcc-5581-4ec5-b13b-ebef0facbc87": "Explain the components of the formula used to calculate the time for a router to receive an update. What do the variables in the formula represent and how are they used to calculate the time? Provide an example to illustrate your explanation.",
        "2dbe1e23-4689-4f6f-803d-4103a30a041b": "\"Can you explain the concept of verification in the context of OSPF and describe the two methods used for verification: content verification and route verification? Provide examples of how each method is used to demonstrate the correctness of the OSPF protocol.\"",
        "434e915c-d255-4ac8-94c4-cdc5c5163421": "\"In the process of verifying the OSPF protocol using the proposed method, the authors mention the use of SMT-Lib and Z3 Solver for model checking. Describe how these tools are used in the verification process and how they help to reduce the size of the state space and narrow down the verification to a single parameter.\"",
        "5f0b0a3f-0ec1-473a-bb06-7ffa0e02eab8": "Consider the scenario where OSPF is implemented on multi-access segments with multiple DRs in one area. Explain the role of the LSDB in ensuring proper protocol functioning and how the delay information of routers can be used to verify the route. Provide an example using the topology described in the context, and calculate the update time difference between the DRs and routers to verify the routing.",
        "9b45e27a-3ff1-477a-ba9b-d1fcd089f338": "Analyze the importance of having the same LSDB on all routers within an OSPF area after convergence is achieved. Describe the process of LSA generation and propagation in case of updates. Additionally, propose a method for ordering events as an update occurs, and discuss how maintaining this order can help reduce the state space during verification.",
        "c58440a1-d2a5-4381-b670-073c0e35896e": "Based on the information presented in Table 6.3, what can you conclude about the correct functioning of the routing protocol in the example topology? What implications would non-identical values have on the performance of large scale networks?",
        "772a0fff-6202-45d0-833c-47df97d1ac13": "Figure 6.2 illustrates an example topology with associated delays. How do these delays impact the routing protocol's performance in large scale networks? Additionally, explain how the update time and ordered list of routers, as compared in Table 6.3, can be used to optimize the network's performance.",
        "ccc2afcf-7016-4796-809e-b6ad8d7f0981": "Based on the information provided, why was a message size of 1KB chosen for the OSPF implementation, and what issues might arise if a larger message size was used given the Ethernet channels' MTU of 1500 bytes?",
        "a105f10b-89bc-42d2-a46d-055de568423a": "In the context of the Fig. 6.3, describe the relationship between the number of routers and the execution time for the content and route verification in OSPF. Additionally, explain what the DR=02 notation in the figure represents.",
        "7733780e-6ba7-482f-b892-510a7ee06d7c": "Based on the information provided, explain the role of the Open Shortest Path First (OSPF) protocol in network convergence and route verification. What are the specific values that must be identical for the protocol to work properly?",
        "a6903e87-df59-4d4c-8a01-098fa65c9d34": "The system model in your implementation is verified using SMT and the Z3 solver with QF\\_AUFLIA logic. Describe the purpose of using this logic and how it is beneficial in checking the property of the system model. Additionally, provide an example of a scenario where this type of verification would be necessary.",
        "a759cd92-428e-485e-9a7b-bb960a4e833c": "Explain the concept of \"Link Recovery Comparison Between OSPF & EIGRP\" as presented in the research paper [6.7]. What were the key findings of this comparison and how can they be applied in a real-world networking scenario?",
        "d07d6ad4-4603-481b-8f77-0936c8921c36": "Based on the information provided in [6.14] and [6.15], describe the purpose and functionality of the \"Traffic Engineering (TE) Extensions to OSPF Version 2\" and the \"OSPF Opaque LSA Option\". Additionally, explain how these extensions can be verified using the concepts discussed in [6.16], [6.17], and [6.18].",
        "9ff36bae-efe2-4e0e-8466-41114c7136ab": "Explain the concept of \"Formal verification of ad-hoc routing protocols using SPIN model checker\" as presented in [6.21]. What are the benefits and limitations of using this approach?",
        "927abc1d-1cd8-4db0-92d8-21bfb8b9d94e": "Based on [6.28], what is BRITE and its significance in universal topology generation? Discuss the challenges in this area and how BRITE addresses them. Additionally, provide an example of a scenario where BRITE could be applied.",
        "77234fb2-33ff-42b5-ae0d-8d5182928e70": "Explain the concept of \"Pure Nash Equilibrium\" as presented in the research article by Khan and Ahmad (2009, [6.29]). How does this concept contribute to the development of a game theoretical method for data replication across multiple servers?",
        "94e66068-7885-43d7-9174-6cc5300b9f7e": "Discuss the significance of the SMT-LIB Standard: Version 2.0, as described in the proceedings by Barrett, Stump, and Tinelli (2010, [6.30]). How does this standard impact the field of satisfiability modulo theories? Additionally, briefly comment on the relevance of the standard to the research conducted by Khan, Ahmad, Malik, and Srinivasan in their respective works.",
        "271e9d12-8633-43e4-a066-5bf152dc0e28": "What are the benefits of cloud computing that make it attractive for organizations and individual customers, as mentioned in the paper?",
        "61c69117-8692-4873-b8be-6e31de1579dc": "What are the risks associated with multi-tenancy and virtualization in cloud environments, and how can they impact the security of off-site data storage?",
        "c1b2c0c1-a4d8-401d-9c5b-0e0151bf57e7": "Explain the role of cryptographic keys and their management in ensuring data security in public clouds. What are the potential consequences of compromising or failing to protect cryptographic keys?",
        "f996e7d4-f5f9-41fb-96d4-344e314a3234": "Describe the data security scheme proposed in the document. How does it address the critical issues of data confidentiality, access control, and key management in public clouds? Include in your answer the use of Shamir\u2019s (k, n) threshold scheme and policy files for access control.",
        "6b208601-c511-4f84-a2c3-18d897e6b341": "Explain the role of the client in the DaSCE scheme and outline the steps taken by the client for file encryption and decryption.",
        "9ee4142a-bf14-416b-addc-61083ea0094e": "Analyze the security concerns identified in the FADE scheme and describe how the DaSCE scheme addresses these issues, focusing on the enhanced key security and authentication process.",
        "6f8d743f-d0ed-4eb9-a006-e5b2c0b3ca27": "Explain the \"Development of a security scheme (DaSCE)\" in the context of outsourced data to cloud security. How does it ensure data confidentiality, access control, and integrity?",
        "5254ced1-b38d-420a-9f7a-7aa7c2205ca2": "Describe the File Assured Deletion (FADE) protocol mentioned in the context. How does it provide privacy, integrity, access control, and assured deletion to outsourced data using symmetric and asymmetric keys?",
        "098671c0-f2c7-4ebe-8c32-81911fdceb5c": "Based on the given context, explain the role of Shamir\u2019s (k, n) scheme in FADE protocol and how it contributes to the trust level in the key. Also, describe the usage and significance of the keys K and S in the FADE protocol.",
        "56bbe48d-296d-4744-a022-ca7356dcd5c9": "Considering the notations presented in the table, describe the process of file upload in the FADE protocol. Additionally, explain the concept of policy revocation and how it is supported in the FADE protocol. Provide notations and descriptions to support your answer.",
        "b63ff698-1214-4e7d-8f91-cee2720cc2ea": "Explain the file upload process in FADE (Flexible Attribute-based Encryption for Data Sharing) when data must be uploaded to the cloud and the system is working with a full quorum of KMs. Include in your explanation the role of the client, KM, and the cloud in this process.",
        "6402a06b-48be-466c-b9d7-0e276be01147": "What is the purpose of generating a public/private key pair in the FADE system and how is it associated with the policy file (Pi) in the file upload process? Additionally, explain the concept of secure overwriting in the context of the FADE system.",
        "592d80c1-bdbd-4ae4-b6d3-c7a02553b1ad": "Explain the role of the Key Manager (KM) and the client in the FADE protocol during the file upload process. Specifically, detail the steps taken by the client to encrypt and upload the file to the cloud, as well as the responsibilities of the KM in generating the key pair and sending the public key to the client.",
        "bea47983-9ba9-4d9c-90cd-636fd8af2916": "In the scenario where FADE works with a full quorum of KMs, how is the data share Si divided and encrypted? Describe the encryption process, including the use of Shamir's (k, n) threshold scheme, and explain why this method is beneficial in this context.",
        "dcad5864-c6be-456b-b7a3-7046353ec41f": "Question (File Download and ABE): Describe the process of file download using Attribute-Based Encryption (ABE) as explained in Section 7.2.2. How does the client check the integrity of the file and decrypt the keys for file encryption? Include any necessary notations and steps in your answer.",
        "2108f71d-541d-4a0a-83e2-b0622395deb3": "Question (Policy Revocation): Explain the policy revocation process described in Section 7.2.3. How does the Key Manager (KM) revoke a policy (Pi) and acknowledge the client? What are the steps taken by the client and the KM during this process? Illustrate the flow of messages using a diagram or a list of steps.",
        "b4ef629e-1ea1-441a-86a5-de2d10900a84": "Question: Based on the analysis of the FADE protocol in the context information, identify and explain one major security issue that can occur during the file upload process. What countermeasures could be implemented to prevent this issue?",
        "14ff1867-61f5-4461-a923-f28752ec0153": "Your answer should include:",
        "d8adbace-f409-4ef4-bef7-3da2179a8cff": "a. Identification of the security issue",
        "d4c2fe08-5502-41e7-8bbc-6a73a609fc58": "b. Explanation of how the attack can occur",
        "83d7c45e-7cfe-40d4-84c4-8091d7900e63": "c. Proposed countermeasures to prevent the attack",
        "4a4ab3ab-5a66-480f-a501-222ead4570fc": "Question: In the context information, it is mentioned that the FADE protocol is a lightweight protocol that does not require heavy modifications in cloud architecture. Analyze the importance of using lightweight protocols in cloud computing and provide two reasons why organizations might prefer using such protocols. Additionally, discuss one potential drawback of using lightweight protocols compared to heavier, more complex alternatives.",
        "5d7918d3-b417-4f0d-8cbb-966c605a697b": "Your answer should include:",
        "7b80c401-3b96-4a69-b8e1-1a3f9e1ca0be": "a. The importance of lightweight protocols in cloud computing",
        "34a70323-5018-4deb-8dca-2be8c6da52ab": "b. Two reasons why organizations might prefer using lightweight protocols",
        "ca0b2e20-d3d0-4277-952c-7ec23ce56a00": "c. One potential drawback of using lightweight protocols compared to heavier alternatives",
        "3ea3ffbd-bf59-4d10-91ad-90d6eea6422a": "Based on the information provided in section 7.3.1.2, describe how an intruder can deny access to data during the download operation in the FADE system. What measures can be taken to prevent this attack?",
        "dcd7da0f-7d39-49ef-a55d-26c965c49253": "Explain the exploitation of the policy renewal process by the intruder as described in section 7.3.2. How can this attack be mitigated, and what are the potential challenges in implementing such countermeasures?",
        "44ef7cd2-f565-498b-a649-bcad038fb2ba": "Based on Figure 7.6, describe the roles of the entities involved in the man-in-the-middle attack with multiple key managers. Explain the notations used in the figure and the function of each entity in the attack scenario.",
        "5a38f6a9-0d2e-4fa3-bf75-bf4ee3fcb580": "Using the information from Section 7.3.3 and Figure 7.7, explain how Scyther is used to verify the attack on the FADE protocol. Describe the steps taken to perform the attack verification and any insights gained from the Scyther verification output.",
        "3a05a642-6061-49e1-b9fd-e8072ac8070e": "Based on the information provided in section 7.3.4, explain the concept of High-Level Petri Nets (HLPN) and its components. What is the role of the structure and static semantics of HLPN in representing a system?",
        "63fa84fb-2dfc-4be7-8c7d-34ffdb725a79": "In the context of the verification process described in the document, can you explain the purpose of using the SMT-Lib and Z3 solver as mentioned in section 7.3.5? How do these tools help in the evaluation of systems? Additionally, briefly describe the origins of SMT in Boolean Satisfiability Solvers (SAT).",
        "7423e9bc-62c8-496a-b10c-505877eff588": "Based on the given context, explain the role of Z3, an automated satisfiability checker, in the verification of the FADE protocol. How is it used in conjunction with High Level Petri Nets (HLPN) and SMT-Lib to analyze the man-in-the-middle attack?",
        "c0d659e0-c618-42a8-a071-d6bcf5cf9c9a": "Describe the process of formal verification using bounded model checking as mentioned in the context. In the verification of the FADE protocol's man-in-the-middle attack, how is the HLPN model used and what tools are involved in this process?",
        "3fd79908-04c6-43a2-b6f5-8c9d140624d1": "Based on the information provided, what is the difference between the string types `K` and `S` in the FADE HLPN model? Provide an example of how each might be used in the context of file encryption.",
        "a5640da9-45db-4432-8970-d5c61652b2f0": "Explain the purpose of the public key parameters `e` and `n` in the FADE HLPN model. Additionally, describe how they are used to encrypt a symmetric key, as denoted by `Se`.",
        "7765c0b6-5ae3-4b45-bfc5-19ce1c0395fa": "Based on the FADE HLPN model with Intruder presented in Figure 7.8, identify and explain the role of the entities involved in the communication of Pi and Pj.",
        "422bf7e6-f642-444e-b28d-73bef25fbda8": "In the context of the Key Manager Client Intruder in the given figure, describe the potential security implications and the possible measures to mitigate the risks associated with the intruder in the system.",
        "6e62747b-5bd5-4f1d-a8fb-9bb5f25dfb34": "Based on the context information, can you identify the transitions and rules associated with the intruder intercepting and generating a fake Pi (Pj)? Explain the sequence of events and transitions (Gen\\_fake, 7.3, 7.4, 7.5) that take place when the intruder intercepts the original Pi file.",
        "8d2ec26a-0e52-4614-aab3-2c3220fd6cc5": "In the context given, how are the keys generated and sent by the Key Management (KM) intercepted by the intruder? Describe the transitions (not specified in the text) and rules (7.6 and 7.7) that are involved in this process, and discuss the potential impact of the intruder intercepting these keys.",
        "3ebe7668-6c96-443e-b849-147368d01aae": "Based on the information provided in (c3) and (c4), what can you infer about the data type `(e \u00d7 n)`? Write a detailed explanation of your understanding and any assumptions you make.",
        "d0fa68d7-4497-415f-9566-54c6e64f2556": "Using the mapping of data types and places in Table 7.3, describe the possible meaning and implications of the intruder's action in generating and sending `(ej, nj)` as depicted in (7.9) and (7.10). Analyze the potential consequences of this action on the system's security and the possible data types involved.",
        "bfe5bdd6-3e7a-4ccf-95bb-8310ea29828b": "Based on the context information, can you identify the cryptographic operation that was verified using SMT-Lib and Z3? What is the property of this operation described in Computational Tree Logic (CTL*) using temporal operators?",
        "ae7d06c1-3db9-4ad0-b2e7-d243135e0d44": "In the given context, why is the encryption operation's security highly dependent on the transition \"Encr\\_data\"? What would be the impact on data security if the encryption is performed using the wrong keys, as mentioned in the SMT-Lib model?",
        "b19c5f2c-5d13-4c37-9822-c0dc78808a36": "Explain the role of the DaSCE keys in the FADE system and describe how they are generated and distributed securely, as discussed in Section 7.4.1. In your answer, be sure to include the use of symmetric and asymmetric keys, as well as the session key establishment and digital signatures for authentication.",
        "c1202515-b6a6-4f1b-896a-a24a93386c03": "According to Section 7.4, what is the reason for the key exchange attack on Si in FADE, and how does the proposed solution using the station-to-station (STS) protocol and linking communication steps help prevent this attack? Additionally, discuss the modifications required in the subsequent operations of the protocol due to the introduction of session keys.",
        "5f05cd8e-c5e5-4d3e-aa7d-e7862138af62": "Explain the key management process in the given DaSCE system, highlighting the role of the Key Manager (KM) and the steps involved in the key exchange and protection.",
        "0139d887-537b-4f5b-8366-f5751909ff6d": "In the file upload process of the system, describe the parameters used for the establishment of the session key and the steps taken by both the client and the Key Manager to generate and calculate the session key. Also, explain the purpose of the random number generation in this process.",
        "92317831-dd68-47a2-9fa9-3904999633e6": "Explain the role of the Key Manager (KM) in the DaSCE File Upload process with Single Key Manager. In particular, detail the steps taken by the KM to verify the client's signature and generate the encrypted data (EK(ei,ni)).",
        "6048d41f-0de6-45b7-9c16-538d2795e948": "Analyze the security measures in place during the file upload process in the given context. Describe how the use of digital signatures, session keys, and encryption contribute to the security of the data being transmitted. Also, discuss any potential vulnerabilities or attacks that could be considered in this process.",
        "31416ae4-3839-495f-a089-fc773dcd7197": "Explain the file upload process with multiple Key Managers (KMs) in the DaSCE system, highlighting how it prevents man-in-the-middle attacks and the role of the (k, n)-threshold scheme.",
        "7614fefa-eb30-4366-9da1-27b171eb4edd": "Describe the file download process in DaSCE with multiple Key Managers, and discuss the purpose and usage of the Cloud Client Key manager, session keys, and the encryption of shared information during the download process.",
        "b64cd763-362e-4e66-99b3-b040cc8c3bc1": "Explain the process of key establishment and authentication between the client and KMs in DaSCE, and how the session key is used to encrypt and decrypt the SiR value.",
        "b3936a37-adee-4731-b9b9-3270e20d9083": "How is policy revocation achieved in DaSCE, and what components are deleted during the revocation process? Additionally, why is it important for the client to receive an acknowledgement after the revocation process has been completed?",
        "59950ae7-6af0-4233-a48c-ab7cb5f4e619": "Explain the concept of \"assured deletion\" as discussed in the context information. How does it differ from physical deletion of data?",
        "aa799215-66ce-4beb-bf7f-ea670766348e": "How does the proposed scheme use Shamir's secret sharing scheme to boost the level of trust and prevent malicious attacks? Describe the process of decryption and the role of KMs in this scheme.",
        "d92dae59-b683-4381-b194-162d31d7f46a": "Based on the description of the DaSCE policy renewal process, explain the role of the key manager (KM) and its interactions with the client. Include in your answer a description of the keys and parameters that are exchanged between the client and the KM during the policy renewal process.",
        "e9c3abf3-0c86-4cd5-af56-d827bf36dbfa": "Using the HLPN model for DaSCE, describe how the system is able to detect a man-in-the-middle attack during the policy renewal process. Explain the information flow in the HLPN model and how it would change in the presence of an intruder.",
        "eccb009d-f1f1-44ec-8642-3f59a0eb8258": "Based on Figure 7.14 in the HLPN for DaSCE, describe the role of the 'Client' and the 'Intruder' in the system, and explain their interactions with other components.",
        "645f3882-3545-4bf1-b990-9e1587a95412": "Analyze the process of message encryption and decryption in the system using the 'Key Manager' component. Describe the flow of messages and keys between different entities and explain the security aspects of this process.",
        "32d67599-1cc8-430d-95c0-fd8faab5f025": "Based on the information provided in Figure 7.14 and the data types in Table 7.4, describe the role of the Key Manager (KM) in the authentication process. What are the data types associated with the KM and what are their intended purposes in the protocol?",
        "59c5517d-9174-4f0d-8add-1a0d89340ee5": "In the context of the attack scenario mentioned in the text, if the lines connecting (c1, c2) and (c3, c4) represent the information flow of Xa and Xb, respectively, in the absence of an intruder, then how would the presence of an intruder affect this information flow? Additionally, what would be the expected behavior of the data types X, Z, Y, and M1\u2019 in this attack scenario?",
        "4435c5b7-e967-42e1-9723-83decd93ac60": "Based on the information provided in the context, what are the parameters calculated by the client for the random number x before sending it to the Key Management (KM) system? Identify the corresponding transition and data types from the table.",
        "f246a149-17ea-46a7-aa1d-857b7f3c7668": "Explain the role of the intruder in the described process of uploading data to the cloud. How does the intruder intercept the messages, and at which transitions does this occur? Provide specific transition names and their corresponding data types from the table.",
        "646fe0b2-50a5-4565-aaa4-ac4e61c44ec9": "Based on the context information, can you identify and explain the role of the transition \"I_Cmpt\\_K IC\" in the intrusion scenario?",
        "7da32b1a-fd7a-43a5-9ac9-01ea205ee10f": "According to rules (7.16) - (7.19), how does the intruder generate a key and send a fake message to the Key Management (KM)? Describe the steps taken by the intruder in this process.",
        "a7fdff48-b13b-4e3e-9eee-f3e14ce512ab": "Based on the context information, can you identify the role of the \"KM\" and explain the process of session key generation between the \"intruder\" and the \"KM\"? (7.22)",
        "3e2f6527-517e-4e39-b609-c8fa560ca977": "Analyzing the rules (7.25) to (7.29), describe the response preparation by the \"intruder\" for the \"client\" and the purpose of using the \"intruder's private key\" in the signing process. Also, discuss the potential implications of the client accepting the response thinking it to be from the \"KM\".",
        "0fdb1008-bef5-4b87-8858-e624c414bd53": "Using the information provided, construct a CTL* property that represents the situation where if state I1 (intruder side) is reached during communication, the control will terminate at state a5, indicating a failure to authenticate the Key Management (KM).",
        "9f57bafc-37fc-4725-82a2-b157a50b9903": "Explain the process that takes place if there is no intruder and communication progresses on a normal course. How does the control flow until it reaches state a6, which represents successful communication with the KM? Provide a detailed explanation based on the transitions and rules provided in the context information.",
        "50fa0123-d149-4067-9fdd-d41c62d3f4f7": "Based on the information provided, explain the role of the Key Management Server (KM) in the DaSCE system and describe the functions it performs during the key establishment process.",
        "8cbaac74-e505-4706-8085-d0dbea699553": "The document mentions that the DaSCE system was evaluated based on four parameters: key establishment time, key transmission time, file transmission time, and cryptographic operations time. Provide a brief explanation of each of these parameters and discuss their significance in the overall performance of the system. Additionally, explain how the system's performance was evaluated using single and multiple KMs.",
        "be147826-ece4-42d6-a558-dbb6e22f389d": "Based on the experiment conducted, how much time do cryptographic operations take as a percentage of the total file upload time for a 10 MB file in the DaSCE protocol?",
        "bf6ea11e-8e5b-4838-9004-1992af41b920": "How does the key establishment process impact the time consumption of the DaSCE protocol compared to other protocols that do not establish session keys, and what could be the possible reason for the additional overheads in DaSCE?",
        "5722b856-e227-41be-a4b3-f0b9594a5e1a": "Based on Figure 7.16, how does the key establishment time change with an increase in the number of Key Managers (KMs) for a 1MB file size? Explain the reasons for this change.",
        "d914e90c-8848-4b6f-be9f-45c57d9984bf": "Analyze Fig. 7.15 and discuss the trends observed in the time taken for Key Transmission, CryptoOp, and File Transmission as the File Size increases. Which operation appears to have the most significant impact on the overall time and why?",
        "359b5351-ff65-41b8-8340-52937647cb41": "Based on the information provided, how does the key establishment time vary with an increasing number of key managers? Explain the trend and discuss the impact of this variation on the overall security level.",
        "3c04a6ad-7945-4a62-8575-ae7c6d09b97d": "In the context of the figure 7.16, can you compare and contrast the time consumption between cryptographic operations and key establishment? Additionally, suggest a scenario where the number of key managers and crypto operations time (sec) might remain constant, but the key establishment time (sec) could vary. Justify your answer.",
        "bb9c5355-7f19-4426-ae02-951d5c6ee41c": "Based on Figure 7.17, how does the key establishment time compare to the cryptographic operation time for a file of the same size as the final symmetric encryption? Also, explain how the key establishment time changes with an increase in file size, as depicted in Figure 7.18.",
        "2d635d2e-6f48-4e97-960a-0b52a3824579": "In the context of DaSCE, discuss the issues faced by FADE in securing cryptographic operations and key establishment. Additionally, explain how the mutual exclusion of communication events between the client and the KM impacts the security of the keys.",
        "dc3b8b32-8f62-490c-8e93-89212c3b1469": "Based on the given context, compare and contrast the key establishment process in FADE and DaSCE. Which protocol provides higher security standards, and why?",
        "0e7493e8-70c0-458a-bec6-6138c756d193": "Explain the concept of \"assured file deletion\" in the DaSCE protocol. How does it enhance the security of data transmission and what are its implications for file management?",
        "f48f181e-1eec-4ef6-bce0-dbfe2c48a2d9": "Based on [7.1], \"A View of Cloud Computing\" by Armbrust et al., explain the benefits of cloud computing and provide an example of a real-world application that utilizes this technology.",
        "e2138c10-ffee-4f7c-bc53-d16a2021938b": "Based on [7.4], \"Controlling data in the cloud\" by Chow et al., describe the concept of outsourcing computation without outsourcing control and explain the significance of this approach in ensuring data security in cloud computing. Additionally, discuss one challenge in implementing this concept and suggest a possible solution.",
        "a283079b-edf1-42b2-afa8-d0dd6a7c73fe": "Explain the issues and challenges of cloud computing as discussed in the paper by Dillon, Wu, and Chang in [7.10]. What are some of the potential solutions to these challenges?",
        "28e55fa3-7bd1-4e11-960c-741bcc28f100": "In the context of cloud computing and data security, describe the concept of a \"secure decentralized erasure code\" as presented in the work by Lin and Tzeng in [7.18]. How does this approach enhance the security and reliability of distributed network storage?",
        "4147852c-4736-489a-b92a-3ffc1622ca82": "Explain the concept of \"A secure erasure code-based cloud storage system with secure data forwarding\" presented in [7.19] by H. Lin and W. Tzeng. What are the benefits of this approach and what potential issues might arise in its implementation?",
        "656899f6-e8fe-4e3a-95fe-025532395d35": "Define the \"Satisfiability Modulo Theories\" (SMT) concept presented in [7.22] by L. Moura and N. Bj\u00f8rner. Explain the significance of SMT in computer science and provide an example of a problem that can be solved using this approach.",
        "97afdb3f-0488-4d57-a2f2-92dd974ea61c": "Based on the research presented in [7.28] by Takabi, Joshi, and Ahn, what are the major security and privacy challenges in cloud computing environments? Provide specific examples from the paper to support your answer.",
        "1dd8a668-9908-48f7-9cc1-cd9711bd76fb": "In [7.34], Perlman discusses the concept of \"assured delete\" in file system design. How does this concept differ from traditional deletion methods? Explain the benefits of assured delete and provide an example of its application from the paper.",
        "257b542c-27f2-4c51-a3ad-8f9b3dc866f4": "Based on the information presented in the context, explain the role of Formal Methods (FMs) in ensuring the reliability and correctness of large-scale computing systems. In your explanation, include an example of how FMs were used to investigate the reliability and correctness of specific applications running in these systems.",
        "e2442bfc-c022-458d-b72e-5e6a92d2df30": "Considering the three state-of-the-art VM-based open-source cloud management platforms discussed in the context (Eucalyptus, Open Nebula, and Nimbus), describe how High-Level Petri Nets (HLPN) were used to model these systems. Additionally, explain the Model Checking approach used to verify the models and provide an example of a property that was specified and verified during the process.",
        "eac91f8d-9558-4600-93cf-bdae52b37162": "Question for Chapter 4:",
        "1a91240a-796a-4b5a-b7e6-d7d16a762846": "Explain the factors that significantly affect the convergence time of an OSPF area, based on your understanding of the simulation results discussed in the chapter. Furthermore, justify the observation that having more DRs in an area can improve the convergence time of a specified segment, but decrease the overall convergence time of the area.",
        "977967ca-2053-4b8c-b2bf-493e9df0aa93": "Question for Chapter 5:",
        "8475b24d-16fe-4570-b200-b9f76904494c": "Describe how a data center (DC) was modeled as a Cyber Physical System (CPS) in the chapter. Additionally, explain the proposed thermal aware scheduling approach, and discuss how it utilizes the heat dissipation information of major DC components, such as servers and switches, to improve thermal management.",
        "83ec71af-6863-4325-b794-fdab4c655dbe": "As a researcher, how did the authors use the SMT-Lib and Z3 solver to analyze and verify the thermal uniformity among pods in a data center? What were the key findings of this analysis?",
        "3760cab2-95b2-4934-9ba9-50bdf0cfb4f5": "In the context of formal analysis of routing protocols, explain how the authors proposed to verify the properties of the OSPF protocol using delay information of the routers. Additionally, describe how the authors used the BRITE topology generator to simulate the detailed implementation of OSPF.",
        "34174781-71d5-417b-8ec3-b45a945ca550": "Explain the (k, n) threshold secret sharing mechanism used in the key management of the DaSCE protocol. How does this mechanism improve the security of outsourced data in clouds?",
        "682ec822-3bb4-4e8d-b2d6-ddda7874d929": "Describe the issues highlighted in the analysis of FADE's key management. How does the DaSCE protocol address these issues and improve the authentication processes? Provide examples or evidence from the context information to support your answer."
    },
    "corpus": {
        "e059ca6f-68f8-40e1-a89f-0fbc4ad05e97": "",
        "cfd52154-2e0e-47ae-8957-7e036f75aa8c": "OSPF; Anatomy of an Internet Routing Protocol\nWritten for TCP/IP network administrators, protocol designers, and network application developers,\nOSPF: Anatomy of an Internet Routing Protocol gives the most complete and practical view of the\ninner workings of Internet routing. OSPF (Open Shortest Path First) is a common TCP/IP routing\nprotocol that provides robust and efficient routing support in the most demanding Internet environments.\nA methodical and detailed description of the protocol is offered and OSPF's role within the wider context\nof a TCP/IP network is demonstrated.\nPractical throughout, this book provides not only a theoretical description of Internet routing, but\nalso a real-world look at theory translated into practice. For example, Moy describes how algorithms are\nimplemented, and shows how the routing protocols function in a working network where transmission\nlines and routers routinely break down.\nReaders will find clear explanations of routing fundamentals, such as how a router forwards packets,\nIP addressing, CIDR (Classless Inter-Domain Routing), the routing table, Internet routing architecture, and\nthe two main routing technologies\u2014Distance Vector and link-state algorithms. OSPF is discussed in depth,\nwith an examination of the rationale behind OSPF's design decisions and how OSPF has evolved to keep\npace with the rapidly changing Internet environment. Topics covered by the book include:\n\u2022 OSPF areas and virtual links\n\u2022 NBMA (Nonbroadcast multi-access) and Point-to-MultiPoint network segments\n\u2022 OSPF configuration and management\n\u2022 Interaction with other routing protocols\n\u2022 OSPF cryptographic authentication\n\u2022 OSPF protocol extensions, including the Demand Circuit extensions\nand the multicast extensions to OSPF (MOSPF)\nIP multicast and multicast routing are also discussed. Methods for debugging routing problems are\nexplained, and are supplemented with a catalog of available debugging tools. An OSPF FAQ answers\nsome of the most frequently asked questions about the OSPF protocol. The book also offers side-by-side\ncomparisons of all the unicast and multicast routing protocols currently in use in the Internet.\nReaders will gain a sophisticated understanding of Internet routing and of the OSPF protocol in\nparticular. Moreover, the book's practical focus will enable you to put this knowledge to work in your\nnetwork environment.\nJohn T. Moy is a Senior Consulting Engineer at Ascend Communications. He is the author of the\nOSPF and MOSPF protocol specifications and currently chairs the OSPF and MOSPF Working Groups in\nthe Internet Engineering Task Force. Mr. Moy has been involved in the design and development of router\nsoftware for fifteen years, currently at Ascend, and previously at Proteon and at Bolt Beranek and Newman.\nMr. Moy holds a master of arts in mathematics from Princeton University and a bachelor of engineering in\nmathematics from the University of Minnesota.",
        "b01f000b-896f-49f6-8110-0765a9d3ecbb": "Many of the designations used by manufacturers and sellers to distinguish their products are claimed as\ntrademarks. Where those designations appear in this book, and we were aware of a trademark claim, the\ndesignations have been printed in initial capital letters or in all capitals.\nThe author and publisher have taken care in the preparation of this book, but make no expressed or\nimplied warranty of any kind and assume no responsibility for errors or omissions. No liability is\nassumed for incidental or consequential damages in connection with or arising out of the use of the\ninformation or programs contained herein.\nThe publisher offers discounts on this book when ordered in quantity for special sales. For more informa-\ntion, please contact:\nPearson Education Corporate Sales Division\nOne Lake Street\nUpper Saddle River, NJ 07458\n(800) 382-3419\ncorpsales@pearsontechgroup.com\nVisit AW on the Web: www.awl.com/cseng/\nLibrary of Congress Cataloging-in-Publication Data\nMoy, John T.\nOSPF : anatomy of an Internet routing protocol / John T. Moy.\np. cm.\nIncludes bibliographical references and index.\nISBN 0-201-63472-4\n1. Internet (Computer network) 2. Computer network protocols. 3. Computer network\narchitectures. I. Title.\nTK5105.875.I57M69 1998\n004.6'6-dc21 97-39463\nCIP\nCopyright \u00a9 1998 by Addison-Wesley\nAll rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or\ntransmitted, in any form, or by any means, electronic, mechanical, photocopying, recording, or other-\nwise, without the prior consent of the publisher. Printed in the United States of America. Published\nsimultaneously in Canada.\nCover art: Turner & Devries, The Image Bank\nISBN 0-201-63472-4\nText printed on recycled paper\n56789 10-MA-0403020100\n5th printing, May 2000",
        "c3cefdf1-d539-4b7a-a10f-7e8ed303f649": "OSPF\nAnatomy of an\nInternet Routing Protocol\nJohn T. Moy\nTT\nADDISON-WESLEY\nBoston \u2022 San Francisco \u2022 New York \u2022 Toronto \u2022 Montreal\nLondon \u2022 Munich \u2022 Paris \u2022 Madrid\nCapetown \u2022 Sidney \u2022 Tokyo \u2022 Singapore \u2022 Mexico City\nCM'",
        "8f29b5c2-3715-44d0-a5cc-cdd4d5c64475": "Contents\nList of Tables\nList of Figures\nPreface\nPart I. Internet Routing Overview\nChapter 1. Role of Routers in the Internet\n1.1 The Internet Protocol Suite 4\n1.2 Forwarding IP Datagrams 9\n1.3 IPv6 22\nChapter 2. Internet Routing Protocols\n2.1 Routing Tables 27\n2.2 Internet Routing Architecture 32\n2.3 Distance Vector Algorithms 35\n2.4 Link-State Algorithms 39\nPart II. The OSPF Protocol\nChapter 3. Developing the OSPF Protocol\n3.1 Functional Requirements 43\n3.2 Design Decisions 47IX\nxi\nxv\n1\n3\n.3\n27\n41\n43",
        "b704195b-71e1-4c7d-bdfb-160844d0d65f": "vi OSPF: Anatomy of an Internet Routing Protocol Contents\n3.3\n3.4\n3.5\n3.6\n3.7\nChapter 4.\n4.1\n4.2\n4.3\n4.4\n4.5\n4.6\n4.7\n4.8\nChapter 5.\n5.1\n5.2\n5.3\n5.4\nChapter 6.\n6.1\n6.2\n6.3\nChapter 7.\n7.1\n7.2\n7.3\n7.4\n7.5\n7.6\nChapter 8.\nPart III.\nChapter 9.\n9.1\n9.2OSPFvl: A False Start 56\nInteroperability Testing 57\nField Trials 61\nOn Becoming a Standard 66\nThe Internet Evolves 67\nOSPF Basics\nAn OSPF Example 72\nLink State Advertisements (LSAs) 74\nA Sample LSA: The Router-LSA 81\nThe Link-State Database 83\nCommunicating between OSPF Routers: OSPF Packets 85\nNeighbor Discovery and Maintenance 86\nDatabase Synchronization 87\nRouting Calculations 95\nOSPF Network Types\nThe IP Subnet Model 102\nBroadcast Subnets 104\nNBMA Subnets 111\nPoint-to-MultiPoint Subnets 114\nHierarchical Routing in OSPF\nOSPF Areas 122\nIncorporating External Routing Information 127\nOSPF Area Types 132\nOSPF Extensions\nTOS-Based Routing 137\nStub Areas 139\nDemand Circuit Extensions 140\nNSSA Areas 143\nDatabase Overflow Support 145\nThe External-Attributes-LSA 146\nAn OSPF FAQ\nInternet Multicast Routing\nInternet Multicast Routing\nInternet Multicast Model 171\nThe Multicast Protocol Stack 17371\n101\n119\n135\n151\n169\n171",
        "3344ec8e-f59e-43a6-8080-70d6b9912db6": "Contents OSPF: Anatomy of an Internet Routing Protocol vii\n9.3\n9.4\nChapter 10.\n10.1\n10.2\n10.3\n10.4\n10.5\n10.6\nPart IV.\nChapter 11.\n11.1\n11.2\n11.3\n11.4\n11.5\n11.6\n11.7\nChapter 12.\n12.1\n12.2\n12.3\n12.4\n12.5\n12.6\n12.7\n12.8\n12.9\n12.10\n12.11\nPart V.\nChapter 13.\n13.1\n13.2\n13.3\n13.4Broadcast Forwarding 178\nMBONE 184\nMOSPF\nAn Extended Example 188\nGroup-Membership-LSAs 192\nMOSPF Routing Calculations 194\nHierarchical Multicast in MOSPF 199\nBackward Compatibility: Mixing with Nonmulticast Routers\nMOSPF in the MBONE 206\nConfiguration and Management\nOSPF Management\nSNMP 214\nOSPF MIB 218\nConfiguring OSPF 222\nAn Example: The Arkansas Public School Computer Network\nMonitoring the OSPF Protocol 230\nInteractions with Other Routing Protocols 233\nOSPF Security 236\nDebugging Routing Problems\nWar Stories 244\nFinding Tools for Debugging Routing Problems 245\nTool Interpretation 245\nThe ping Tool 247\nThe traceroute Tool 250\nSNMP MIBs 254\nMIB-Based Tools 257\nNetwork Analyzers 259\nProtocol-Specific Tools 263\nProduct-Specific Monitoring and Tracing 265\nMulticast Traceroute 266\nRouting Protocol Comparisons\nUnicast Routing Protocols\nRIP 277\nOSPF 281\nBGP 284\nIGRP 297187\n203\n211\n213\n228\n243\n273\n275",
        "2704e5d3-cb35-46bc-ac66-493efa5973c9": "viii OSPF: Anatomy of an Internet Routing Protocol Contents\n13.5 Integrated IS-IS 300\n13.6 Historical Protocols 303\n13.7 Interaction among Routing Protocols\nChapter 14.\n14.1\n14.2\n14.3\n14.4\n14.5\n14.6\n14.7\nBibliography\nIndex305\nMulticast Routing Protocols\nBroadcast-and-Prune Protocols 310\nDVMRP 312\nMOSPF 313\nPIM Dense 314\nPIM Sparse 314\nCBT 315\nInteraction among Multicast Routing Protocols309\n315\n317\n331",
        "460ea788-4b77-42f5-a3dd-54b2e0113882": "List of Tables\n1.1 Division of IP Address Space by Function 16\n1.2 Special-Purpose IP Unicast Addresses 18\n1.3 Historical Class Division of IP Address Space 19\n2.1 The Routing Table of Figure 1.5's Router C 28\n2.2 RIP Convergence When Subnet 192.1.4/24 Is Added to Figure 2.5 36\n2.3 Distance Vector Convergence When Subnet 192.1.4/24 Is Deleted from\nFigure 2.5 37\n4.1 Actions Taken by OSPF Router, Based on LS Age Fields 80\n4.2 Link-State Database for Sample Network 84\n4.3 Dijkstra Calculation Performed by Router 10.1.1.3 97\n4.4 Router 10.1.1.3's IP Routing Table 98\n6.1 Distribution of Area Routing Information, Using Distance Vector\nMechanisms 126\n6.2 OSPF's Four-Level Routing Hierarchy 129\n7.1 Summary of OSPF Extensions 137\n8.1 Summary-LSAs Generated for Segment 10.15.6.0/24 166\n9.1 IP Multicast Address Assignments 175\n9.2 IGMP Packet Types 177\n9.3 Default TTL Values for MBONE Applications 186\n11.1 Default Timer Values in OSPF 227\n12.1 Common Failure Indications of traceroute 251\nIX",
        "f832b692-0b51-48a3-a2dd-10ea992ef043": "x OSPF: Anatomy of an Internet Routing Protocol List of Tables\n13.1 Classification of TCP/IP Routing Protocols 275\n13.2 Aggregation Example Requiring AS Sets 291\n13.3 BGP Path Attributes 295\n14.1 Categorization of Internet Multicast Protocols 309",
        "8299134c-34d1-4dd8-82d9-7d09dccedc2d": "List of Figures\n1.1 Simple routing example 4\n1.2 The seven-layer OSI reference model, together with the TCP/IP\nequivalents 5\n1.3 Internet headers prepended to TELNET data 6\n1.4 ICMP Redirect messages remove extra router hops 15\n1.5 Sample TCP/IP network showing prefix aggregation 18\n1.6 The IPv6 network-layer packet header 24\n2.1 Size increases in the Internet's routing tables (logarithmic scale) 29\n2.2 Patricia-tree implementation of routing table lookup 31\n2.3 Hash-table front end to a routing table 32\n2.4 Organization of the Internet into Autonomous Systems 33\n2.5 Sample network topology to illustrate Distance Vector protocol behavior 36\n3.1 Timeline of OSPF development 44\n3.2 Configuring metrics to avoid links with high delay 45\n3.3 One configuration tested during the 3Com testing session in\nFebruary 1991 59\n3.4 Running OSPF on the INTEROP 91 ShowNet 62\n3.5 Use of OSPF's forwarding address 64\n4.1 Point-to-point network topology 72\n4.2 The LSA header 74\n4.3 Various LS Sequence Number space organizations 76\n4.4 Point-to-point network topology 81\n4.5 Router 10.1.1.1's router-LSA 82\nXI",
        "7c11f596-4b82-4a1d-8343-42827e1067d2": "xii OSPF: Anatomy of an Internet Routing Protocol List of Figures\n4.6 An OSPF Hello packet 88\n4.7 Sample Database Exchange 91\n4.8 Reliable flooding 93\n4.9 Link-state database as directed graph 96\n4.10 Shortest paths, as calculated by router 10.1.1.3 98\n5.1 Ethernet segment with two IP subnets 103\n5.2 Resulting IP connectivity 103\n5.3 Ethernet segment with five OSPF routers attached 105\n5.4 Flooding adjacencies 107\n5.5 One possible representation of router connectivity of a broadcast\nsubnet 108\n5.6 OSPF's representation of a broadcast subnet, using a network-LSA 109\n5.7 Network-LSA for subnet 10.4.7.0/24 110\n5.8 Sample NBMA subnet 112\n5.9 Frame Relay network with partial PVC mesh 114\n5.10 Turning the partial mesh of Figure 5.9 into a Point-to-MultiPoint subnet 115\n6.1 Linear versus logarithmic growth 120\n6.2 An internet employing hierarchical routing 121\n6.3 A sample area configuration 123\n6.4 Summary-LSA advertised by router B into area 0.0.0.0 124\n6.5 Inter-area routing exchange in the sample OSPF network of Figure 6.3 126\n6.6 Virtual links incorporate new networks 128\n6.7 An AS-external-LSA 130\n6.8 ASBR-summary originated by router F into area 0.0.0.5 132\n7.1 The OSPF Options field 136\n7.2 Sample network implementing TOS-based routing 138\n7.3 An example Type-7-LSA 144\n7.4 The external-attributes-LSA 148\n8.1 Point-to-point representation in OSPF 154\n8.2 An MOSPF example requiring reverse-link costs 165\n9.1 Network diagram illustrating IP multicasting principles 173\n9.2 IGMP Host Membership Report 177\n9.3 Source-based trees for group Gl 181\n9.4 Shared multicast tree for group Gl 182\n9.5 Router RT6's multicast routing table entry 183\n9.6 Constructing an MBONE topology from Figure 9.1 185\n10.1 An MOSPF routing domain 189\n10.2 Sample group-membership-LSA 194\n10.3 MOSPF shortest-path tree 198\n10.4 A hierarchical MOSPF routing domain 200\n10.5 Path of datagram sent by SI to group Gl, through area 0.0.0.2 203\n10.6 Complete path of datagram from SI to group Gl 204\n10.7 Example MOSPF domain within the MBONE 206\n11.1 The structure of Internet management information 214\n11.2 Specification of variable ospf ifMetricValue within the OSPF MIB 215",
        "676f490a-cd7d-45ea-809f-07088a4b4a4c": "List of Figures OSPF: Anatomy of an Internet Routing Protocol xiii\n11.3 Table specifying OSPF interface metrics 216\n11.4 Object identifier of ospf ifMetricValue specifying instances 217\n11.5 Walking the ospf I fMetricTable, using SNMP's get-next function 217\n11.6 Organization of the OSPF MIB 219\n11.7 Basic OSPF configuration, using SNMP 223\n11.8 Basic OSPF configuration, GATED syntax 223\n11.9 Basic OSPF configuration, Cisco router syntax 224\n11.10 The Arkansas Public School Computer Network (APSCN) 229\n11.11 A sample BGP/OSPF environment 233\n11.12 Message generation when performing OSPF cryptographic\nauthentication 238\n12.1 Sample of sites supplying ping software 246\n12.2 Sample output of ping 247\n12.3 Sending ping to a multicast address 248\n12.4 Sample output of traceroute 251\n12.5 Sample output of traceroute, showing probe failures 252\n12.6 Dumping a routing table using SNMP's get-next function 256\n12.7 Examination of OSPF neighbor status, using the ospf query program 258\n12.8 Example of a packet trace from a Network General Sniffer 260\n12.9 Sample output from the ripquery program 263\n12.10 Dumping the OSPF link-state database through a terminal interface 267\n12.11 Implementation-specific tracing of OSPF events 268\n12.12 Sample mtrace output 269\n13.1 Operation of RIP 277\n13.2 A trace of RIP routing update behavior 280\n13.3 Operation of the OSPF protocol 281\n13.4 Packet trace showing the beginning of an OSPF protocol exchange 285\n13.5 Operation of BGP 286\n13.6 Sample Autonomous System configuration 287\n13.7 Beginning of a BGP routing session 289\n13.8 Partitioning AS 1 to avoid a full IBGP mesh 293\n13.9 Interaction between routing protocols in GATED 307\n14.1 Operation of a broadcast-and-prune protocol 311",
        "9f1c3c00-02d0-4b16-9249-71a5963cc4ef": "Preface\nIntroduction\nThe Internet is a global communications network. With connections in more than 100\ncountries, tens of millions of people use the Internet for business, education, and recre-\nation. Electronic commerce is beginning on the Internet as businesses connect to sell their\nproducts and services. Academics collaborate over the Internet by exchanging electronic\nmail. People can converse using Internet phones, send faxes, participate in online chats\nand bulletin boards, play multiuser games, and experiment with virtual environments.\nSpecial-purpose computers called routers connect the Internet together. As data is for-\nwarded from one place in the Internet to another, it is the routers that make the decisions\nas to where and how the data is forwarded. The protocols that dynamically inform the\nrouters of the paths that the data should take are called routing protocols. It is the job of\nthese protocols to react quickly to changes in the Internet's infrastructure, such as trans-\nmission lines going in and out of service, routers crashing, changes in network policies,\nand so on.\nRouting is what makes the Internet tick. Although many users of the Internet and the\nWorld Wide Web are unaware of the machinery underlying the network applications,\nrouting is an interesting but complicated subject. Routing protocols are sophisticated dis-\ntributed algorithms that must also be extremely robust to keep a large, decentralized net-\nwork like the Internet running smoothly.\nxv",
        "73fd2f91-f1fa-4acf-a1f0-1cb158ef1121": "xvi OSPF: Anatomy of an Internet Routing Protocol Preface\nAudience\nThis book is for students of data communications, TCP/IP network administrators, proto-\ncol designers, developers of routing protocol software, and other professionals involved\nin the design, development, and management of TCP/IP networks. The book is a practi-\ncal, hands-on description of Internet routing rather than a theoretical treatment. Although\nwe describe how the various protocols were intended to work, we also describe how well\nthe design has translated into practice. Internet protocol design is a practical undertaking\nitself, with efficiency of implementation often dictating design choices. For this reason,\nthis book gives an in-depth treatment of how a router really works. Instead of just describ-\ning the algorithms, the book goes beyond to show how the algorithms are implemented.\nWe often present ideas in a historical context, showing how Internet protocols have\nevolved. This is done for two reasons. First, you can learn a lot from the mistakes (and\nsuccesses) of the past. Second, in order to participate in Internet discussion groups, many\nof which are dominated by old-timers, it is good to have some context.\nThis book is not an elementary introduction to TCP/IP and its routing. Instead we\nassume that you have some familiarity with the TCP/IP protocol suite and some exposure\nto the basic concepts of routing. These assumptions allow us to explore many of the facets\nof Internet routing in greater detail than possible in an introductory text.\nOrganization of This Book\nThis book is organized into five parts. Part I sets the groundwork for a discussion of\nInternet routing. After a brief description of how routing fits together with the rest of the\nInternet's protocols, Chapter 1 describes in depth how a router forwards packets. This dis-\ncussion naturally leads to an explanation of IP addressing and CIDR, as well as of the\ninteraction of hosts and routers. Internet routing protocols are introduced in Chapter 2,\nbeginning with a treatment of the end product of all routing protocols: the router's rout-\ning table. Chapter 2 ends with an overview of the Internet's routing architecture and the\ntwo main routing technologies in use in today's Internet: Distance Vector and link-state\nalgorithms.\nPart II describes the Internet's OSPF routing protocol. We start in Chapter 3 with an\nexplanation of why the OSPF protocol was developed in the first place. Chapter 4 dis-\ncusses the basics of link-state routing; Chapter 5, how OSPF behaves over various subnet\ntechnologies; Chapter 6, its use of hierarchical routing; and Chapter 7, extensions to OSPF.\nEach chapter not only describes how OSPF works but also explains why it works that way.\nWe explore the reasons behind OSPF's design decisions and how the OSPF protocol has\nevolved to keep pace with the rapidly changing Internet environment. Part II concludes\nwith an OSPF FAQ (Chapter 8).\nPart III (Chapters 9 and 10) describes TCP/IP multicast routing, including broadcast\nand multicast forwarding, the MBONE, and the two distinct types of multicast routing\nprotocols: source-based trees and shared-tree algorithms. As we did with unicast routing,",
        "56e8e9bc-b888-4447-adeb-f5ada09dea2e": "Preface OSPF: Anatomy of an Internet Routing Protocol xvii\nwe go further into the subject of multicast routing through the examination of a particular\nmulticast routing protocol: the Multicast Extensions to OSPF (MOSPF).\nPart IV covers the configuration and management of Internet routing. The configura-\ntion and management of OSPF is explained in detail in Chapter 11. Chapter 12 describes\nthe tools used to monitor and debug routing in a TCP/IP network. For each tool, we\ndescribe its use, how it works, and its advantages and drawbacks.\nPart V is a comparison of Internet routing protocols. Chapter 13 compares and\ncontrasts the routing protocols in use in the Internet: RIP, OSPF, BGP, IGRP, and IS-IS. In\nChapter 14, we examine the available multicast protocols: DVMRP, MOSPF, PIM Dense\nand Sparse, and CBT.\nFollowing Chapter 14 is an extensive bibliography arranged and numbered in\nalphabetical order. Within the text, the citation [85], for example, refers to item 85 in the\nbibliography.\nCompanion Book: OSPF Complete Implementation\nThe forthcoming companion book OSPF Complete Implementation, in keeping with the\nInternet tradition that reveres \"working code\" over all else, explores even further the\nmechanics of Internet routing through examination of a real, working OSPF implementa-\ntion. The book contains a complete implementation of OSPF on CD. Written in C++, the\nOSPF implementation is intended to be portable to a wide range of environments. Two\nsample ports are included: an OSPF routing daemon (called ospfd) for FreeBSD 2.1 and\nan OSPF routing simulator that can be run on Windows 95. The OSPF implementation has\nbeen developed using publicly available tools.\nAcknowledgments\nI would like to thank the technical reviewers who improved this book through their\nthoughtful and timely reviews: Ran Atkinson, Eural Authement, Fred Baker, Howard\nBerkowitz, Jeffrey Burgan, Joel Halpern, Mukesh Kacker, Robert Minnear, Jim Reid, and\nW. Richard Stevens. Thanks also to Tim Stoddard and the Arkansas Public School Com-\nputer Network (APSCN) for letting me collect OSPF statistics on the APSCN network and\nuse that network as an example of OSPF configuration in Chapter 11, OSPF Management.\nThanks to S. Randall McLamb for drawing the figures.\nI would also like to acknowledge the help of my editors at Addison Wesley Longman\nover the long life of this project: Carol Long, Karen Gettman, and Mary Harrington.\nAnd special thanks to my wife, Sonya Keene, who designed the book, edited rough\ndrafts, created the index, and gave encouragement while this book was being written.\nJ.M.\nOctober, 1997",
        "6f55c23a-920a-418f-8ff1-e56318457e40": "Part I\nInternet Routing Overview\nIn Part I, we lay the groundwork for an examination of Internet routing. Chapter 1, Role\nof Routers in the Internet, introduces routing through a detailed examination of the\nspecial-purpose computers executing these protocols: the Internet's routers. The interac-\ntion between hosts and routers, IP options, the ICMP protocol, and CIDR addressing\nare covered. The chapter ends with a short synopsis of the next generation of the IP\nprotocol: IPv6.\nChapter 2, Internet Routing Protocols, begins to describe the routing protocols\nthemselves. First, we describe a router's routing table, which is the forwarding database\nthat all routing protocols attempt to build. We explain the Internet's routing architec-\nture. The two basic routing technologies in use in the Internet, link-state and Distance\nVector, are then compared and contrasted.",
        "183f614b-7d53-45f0-b364-7b04b613983f": "Role of Routers in the Internet\nThe Internet is a packet-switching network that enables its attached computers\u2014the PC\non your desk, the high-end workstation that enables you to enroll in your local univer-\nsity over the Web, the mainframe that checks your credit card balance, the supercom-\nputer that you use for simulations in your physics labs\u2014to exchange information. This\ninformation is encoded as long strings of bits called packets. As these packets travel\nthrough the Internet on their way to their destination computers, routing decisions are\nmade: Should the packet be sent this way or that way? The devices making these deci-\nsions are themselves computers, called routers. The distributed algorithms that the\nrouters run among themselves in order to make the correct routing decisions are called\nrouting protocols. These routing protocols, and, in particular, the specific routing protocol\ncalled the Open Shortest Path First (OSPF) protocol, are the main subject of this book.\nA simple example is shown in Figure 1.1. Five routers, A through E, are pictured,\ninterconnected via telephone lines of various speeds. Suppose that workstation SI sends\na packet for delivery to workstation Dl. Router A receives the packet and then has to\nmake a decision: Should it forward the packet to router B, C, or D? The routing proto-\ncols that are being run among the five routers will give A the answer: Forward the\npacket to C over the optimal path to the destination consisting of two Tl lines. Later, if\nrouter C goes out of service, the routing protocols will come into play again, telling A\nthat the new best path is now via the slower-speed lines through router D.\nOf course, the Internet is much, much larger and more complicated than our\nsimple example. Starting with the ARPANET network in 1969 as a network of four",
        "5335ac65-8395-482b-840e-4aa343749499": "Role of Routers in the Internet Chapter 1\nFigure 1.1 Simple routing example. A routing protocol would select the higher-speed path through router C.\nWhen routing protocols detect that router C is out of service, the slower-speed path through router D would\nthen be selected.\npacket-switching computers, today's Internet has tens of thousands of routers, operated\nby various Internet Service Providers (ISPs) and various academic, research, govern-\nment, and commercial organizations. These routers are manufactured by a variety of\nvendors, using varied hardware and software. In this environment, routing becomes not\nonly a technical problem but also a cooperative management problem.\nIn this introductory chapter, we concentrate on the role of the routers in the Internet.\nFirst, we examine how the protocols used by routers fit in with the rest of the Internet's\nprotocols. Routing protocols enable routers to find paths from Internet sources to Inter-\nnet destinations. But how does a router use these paths to forward packets? We explain\nthe forwarding process within a router in great detail, including how routers interact\nwith the packets' sources and destinations. We also explain the organization of Internet\naddresses, which are the instructions carried within the packet to identify the packet's\ndestination.\n1.1 The Internet Protocol Suite\nIn order to achieve the transfer of packets between computers connected to the Internet\nand between the routers making up the Internet itself, certain rules about packet format\nand processing must be followed. These rules are called protocols. The suite of protocols\nused by the Internet is called TCP/IP.",
        "d2e26c86-be2e-4156-931c-db14b7bf4e56": "Section 1.1 The Internet Protocol Suite\nInternet protocols have been separated into layers in an attempt to simplify protocol\ndesign. Ideally, one could replace the protocol at one layer while leaving the other pro-\ntocol layers in place. These layers provide a useful reference but should not be taken as\nhard-and-fast boundaries on protocol design. Internet protocols sometimes blur the\nlayer distinctions or violate them outright for reasons of efficiency. The layering of Inter-\nnet protocols can be viewed in terms of the ubiquitous seven-layer OSI reference model,\nas displayed in Figure 1.2.\n(a) (b)\nFigure 1.2 The seven-layer OSI reference model (a), together with the TCP/IP equivalents (b).\nThe computers communicating over the Internet are sometimes also called hosts, or\nend stations; these computers and the Internet's routers are interconnected using a wide\nvariety of link technologies. Telephone lines, Ethernet segments, packet radio, and satel-\nlite links are some of the traditional Internet link types. Nowadays many other link\ntypes can be found, including Frame Relay, ATM, FDDI, IEEE 802.5 Token Ring, SMDS,\nand AppleTalk segments. Methods for running the TCP/IP protocols over each of these\nlink types have been defined. Indeed, it is a point of pride among Internet protocol\ndesigners that TCP will run over everything, including \"tin cans connected by string.\"\nWhen viewing the layers of a protocol, one commonly speaks of a protocol stack. In\nthe OSI reference model, the lowest layer of the stack consists of the physical protocols;\nthe highest layer, the application protocols. You should think of packetized data from a\nnetwork application being handed down through the layers in the source host, each\nlayer prepending a header of its own. Figure 1.3 shows the headers that would be\nprepended to the Internet's TELNET application's data before the data is transmitted\nonto an Ethernet segment. At the destination host, the headers are then stripped before\nhanding the data to the destination's application entity.",
        "fab4eb76-963a-4612-8425-0d8c1675359e": "Role of Routers in the Internet Chapter 1\nFigure 1.3 Internet headers prepended to TELNET data, from user client to server, before it is transmitted\nonto an Ethernet segment.\nEach layer of the protocol stack usually provides multiplexing services so that mul-\ntiple instances of the next-higher level can be run simultaneously. For example, a link's\ndata-link protocol will allow packet multiplexing based on packet type so that multiple",
        "74096a6d-0fe3-4c4c-8ed0-19bfc017d581": "Section 1.1 The Internet Protocol Suite\nprotocol stacks (for example, both TCP/IP and Novell's IPX protocols) can be supported\non a single link.\nThe OSI reference model is fairly useful in discussing Internet protocols from the\nphysical to the transport layers. However, not all of the Internet's protocols fit into such\nneat layers. For example, the Internet's Address Resolution Protocol (ARP) [192] strad-\ndles the network and data-link layers. ARP is used to map IP addresses into data-link\naddresses so the correct data-link headers can be built as a packet is forwarded hop by\nhop from one link to another. Also, some of the higher layers of the OSI reference model,\nsuch as the session and presentation layers, have little relevance to the Internet protocol\nsuite.\nThe discussion in this chapter relates to point-to-point, or unicast, communication\nover the Internet. The Internet and the TCP/IP protocol suite also support multicast\ncommunication\u2014the ability for a host to send a single packet for delivery to multiple\ndestination hosts. Parts of the unicast TCP/IP stack have multicast equivalents. We\ndefer further discussion of multicast until Chapter 9, Internet Multicast Routing.\nPhysical Layer\nThe physical layer specifies how the bits of the packet are physically encoded when\ntransmitted and received over a given link technology. Bits are typically encoded as\nelectronic or light pulses, organized so that transmission errors can be detected. For\nexample, the physical layer on telephone lines is defined by various modem\nstandards, such as V.34.\nData-Link Layer\nThe data-link layer specifies how packets are transmitted and received over a given link\ntechnology. Services provided at this layer include identification of end stations on the\nlink, specification of maximum packet size supported (the Maximum Transmission\nUnit, or MTU), and, sometimes, transmission-priority schemes. For example, the Point-\nto-Point Protocol (PPP) [232] is the data-link protocol commonly used in the Internet\nover telephone lines. Often the data-link protocols are specified together with physical\nprotocols, as in Ethernet. The 14-byte Ethernet data-link header provides a 6-byte source\naddress (IEEE MAC address), a 6-byte destination address, and a 2-byte Ethernet type\nfor packet multiplexing.\nNetwork Layer\nThe network layer is responsible for forwarding packets across multiple links (that is,\nthrough one or more routers) when a packet's source and destination are on different",
        "1e1fffdd-90da-418c-914c-cff4281d7231": "8 Role of Routers in the Internet Chapter 1\nlinks, or network segments. Since this book is about Internet routing, most of the discus-\nsion in this book is limited to issues within the Internet's network layer.\nUsually a network-layer addressing scheme is provided, enabling the routers to\nfigure out which network segment the destination host belongs to. Sometimes a\nfragmentation-and-reassembly capability is provided, allowing the network layer\nto accommodate, transparently, links supporting different maximum packet sizes.\nDynamic routing protocols, which allow the routers to automatically find paths to\nnetwork-layer destinations, are also usually considered part of the network layer, as are\nprotocols controlling the interaction between hosts and routers.\nThe Internet's network layer is called the Internet Protocol (IP) [195]. Network-layer\npackets are called IP packets, or IP datagrams. The IP addresses contained in IP packets\nare 32 bits long (see Section 1.2.1). Each network segment is assigned a range of IP\naddresses, represented as an address prefix. Internet routers route packets to these\nprefixes instead of to individual hosts (see Section 2.1). When a host is attached to a\nnetwork segment, or has an interface to the segment, it is given a unique IP address\nin that segment's address range. Hosts with multiple interfaces have multiple IP\naddresses. IP has many routing protocols, including OSPF, RIP, and BGP, which are\ndiscussed later in this book. The Internet Control Message Protocol (ICMP) ([57], [165],\n[194]) allows hosts to find the routers attached to their segments and provides certain\ndiagnostic capabilities to the hosts when the routers are unable to deliver packets to\naddressed destinations.\nTransport Layer\nThe transport layer provides an end-to-end connection between applications running in\nthe source and destination hosts. Services in this layer often include error detection,\nerror correction, and data sequencing. The TCP/IP protocol suite has two transport\nprotocols. The Transmission Control Protocol (TCP) [197] provides a reliable byte stream\nbetween applications. Major advances in TCP's congestion avoidance and control [115]\nhave allowed the Internet to continue to prosper in recent years. The User Datagram\nProtocol (UDP) [198] provides connection without reliability guarantees and is normally\nused by relatively stateless applications, such as Sun's Network File System (NFS) [29].\nHigher Layers\nThe session layer provides mechanisms for starting and stopping transport connections.\nThe presentation layer provides standard ways for encoding and representing an ap-\nplication's data types. By and large, the Internet does not have explicit session- and\npresentation-layer protocols; instead these functions are usually built directly into\nInternet applications. There are, however, some exceptions. The Internet's Remote\nProcedure Call (RFC) protocol [234] fits into the session layer, and some Internet",
        "d900cea1-a30d-419d-823d-4525d30a5c1f": "Section 1.2 Forwarding IP Datagrams\napplications use the ASN.l [113] or External Data Representation (XDR) [235] protocols,\nwhich fit into the presentation layer.\nThe application layer can be thought of as the protocols that implement the kinds of\nnetwork services that you would expect from any computer's operating system. In the\nInternet, application protocols include the Simple Mail Transfer Protocol (SMTP) [196];\nfile-transfer protocols, such as FTP [199] and TFTP [233]; and the protocol for remote\nlogin, TELNET [200].\nThe Internet's Domain Name System (DNS) [163] also probably fits into the applica-\ntion layer. It is the DNS that converts human-friendly host names, such as\nwww. altavista. com, into destination IP addresses that can be routed by the Internet's\nrouters at the network layer.\n1.2 Forwarding IP Datagrams\nThe various network segments making up the Internet are interconnected by routers.\nA router receives an IP packet on one of its interfaces and then forwards the packet out\nanother of its interfaces (or possibly more than one, if the packet is a multicast packet),\nbased on the contents of the IP header. As the packet is forwarded hop by hop, the\npacket's network-layer header (IP header) remains relatively unchanged, containing the\ncomplete set of instructions on how to forward the packet. However, the data-link head-\ners and physical-transmission schemes may change radically at each hop in order to\nmatch the changing media types. Let's use an example to examine the IP forwarding\nprocess in more detail.\nSuppose that the router receives a packet from one of its attached Ethernet seg-\nments. The router's Ethernet adapter has indicated the size of the packet received; the\npacket may look like the packet pictured in Figure 1.3. The router first looks at the\npacket's data-link header, which in this case is Ethernet. If the Ethernet type is set to\n0x800, indicating an IP packet, the Ethernet header is stripped from the packet, and the\nIP header is examined. Before discarding the Ethernet header, the router notes the\nlength of the Ethernet packet and whether the packet had been multicast/broadcast on\nthe Ethernet segment (by checking a particular bit in the Destination MAC address). In\nsome cases, routers will refuse to forward data-link multicasts/broadcasts, as described\nlater.\nThe router then verifies the contents of the IP header by checking the Version, Inter-\nnet Header Length (IHL), Length, and Header Checksum fields. The Version must be\nequal to 4 (in this book, we mean IPv4 when we say IP; a new version of IP, IPv6, is\nbeing developed, however, and is discussed in Section 1.3). The Header Length must be\ngreater than or equal to the minimum IP header size (five 32-bit words). The length of\nthe IP packet (Length), expressed in bytes, must also be larger than the minimum\nheader size. In addition, the router should check that the entire packet has been\nreceived, by checking the IP length against the size of the received Ethernet packet.",
        "3881bb5f-cafe-41fa-8037-f77679a69672": "10 Role of Routers in the Internet Chapter 1\nFinally, to verify that none of the fields of the header have been corrupted, the 16-bit\nones-complement checksum of the entire IP header is calculated and verified to be equal\nto Oxffff. If any of these basic checks fail, the packet is deemed so malformed that it is\ndiscarded without even sending an error indication back to the packet's originator.\nNext, the router verifies that the TTL field is greater than 1. The purpose of the TTL\nfield is to make sure that packets do not circulate forever when there are routing loops.\nThe host sets the packet's TTL field to be greater than or equal to the maximum number\nof router hops expected on the way to the destination. Each router decrements the TTL\nfield by 1 when forwarding; when the TTL field is decremented to 0, the packet is dis-\ncarded, and an ICMP TTL Exceeded message is sent back to the host. On decrementing\nthe TTL, the router must adjust the packet's Header Checksum.\nThe router then looks at the Destination IP address. The address indicates a single\ndestination host (unicast), a group of destination hosts (multicast), or all hosts on a\ngiven network segment (broadcast). Multicast and broadcast forwarding are discussed\nin Chapter 9, Internet Multicast Routing.\nUnicast packets are discarded if they were received as data-link broadcasts or as\nmulticasts; otherwise, multiple routers may attempt to forward the packet, possibly\ncontributing to a packet proliferation called a broadcast storm. In unicast forwarding, the\nDestination IP address is used as a key for the routing table lookup (Section 2.1). The\nbest-matching routing table entry is returned, indicating whether to forward the packet\nand, if so, the interface to forward the packet out of and the IP address of the next IP\nrouter (if any) in the packet's path.\nIf the unicast packet is too large to be sent out the outgoing interface in one piece\n(that is, Length is greater than the outgoing interface's Maximum Transmission Unit, or\nMTU), the router attempts to split the packet into smaller pieces, called fragments. Frag-\nmentation can affect performance adversely [125]. Hosts may instead wish to prevent\nfragmentation by setting the Don't Fragment (DF) bit in the Fragmentation field. In this\ncase, the router does not fragment but instead drops the packet and sends an ICMP Des-\ntination Unreachable (subtype Fragmentation Needed and DF Set) message back to the\nhost. The host uses this message to calculate the minimum MTU along the packet's path\n[165], which is in turn used to size future packets.\nThe router then prepends the appropriate data-link header for the outgoing inter-\nface. The IP address of the next hop is converted to a data-link address, usually using\nARP [192] or a variant of ARP, such as Inverse ARP [25] for Frame Relay subnets. The\nrouter then sends the packet to the next hop, where the process is repeated.\nModification of Forwarding\nThe basic IP forwarding process described earlier can be modified in a number of ways,\nresulting in data packets' taking different paths through the network. First, a router may\nhave multiple paths to a destination. These paths can be used to spread out traffic to a\ndestination prefix across alternative links, called multipath routing, or load balancing. The",
        "0337ffbd-c0c1-4b24-9db0-f766de60a037": "Section 1.2 Forwarding IP Datagrams 11\nend result of multipath routing is that more bandwidth is available for traffic to the\ndestination. When there are multiple paths to a destination prefix, the router's routing\ntable lookup will return multiple next hops. Which of these next hops is used for a par-\nticular packet depends on the implementation. Routing table entries represent the route\nto a given address prefix; the same routing table entry may be used by many TCP con-\nnections. Routers generally want to guarantee that packets belonging to a given TCP\nconnection always travel over the same path; if they were sent over multiple paths,\nreordering of the TCP packets is likely leading to reduced TCP performance. For this\nreason, routers typically use a hash function of some of the TCP connection identifiers\n(source and destination IP addresses) to choose among the multiple next hops.\nThe Type of Service (TOS) field in the packet's IP header can also affect the packet's\npath. Five TOS values have been defined for IP: normal service, minimize monetary\ncost, maximize reliability, maximize throughput, and minimize delay [3]. A packet's\nTOS designation would help the router choose an appropriate path for a given packet.\nFor example, packets requesting to maximize throughput might be transmitted over\nhigh-bandwidth satellite links, whereas these very same links would be avoided by\npackets requesting to minimize delay. To implement TOS routing, a router would keep\nseparate routing tables for each TOS value. When forwarding a packet, the router would\nfirst choose a routing table, based on the packet's TOS, and would then perform the nor-\nmal routing table lookup.\nThe TOS bits in the IP header should not be confused with the IP precedence bits,\nwhich are collocated in the same byte of the IP header with the TOS bits. A packet's IP\nprecedence label does not affect the path of a packet but instead specifies transmission\npriority at each router hop. The precedence bits remain in IPv6 (see Section 1.3), recast\nas packet priority.\nTOS routing has rarely been used in the Internet. Only two Internet routing proto-\ncols, OSPF and IS-IS (Section 13.5), have ever supported calculation of separate paths for\neach TOS value. Because there has been very little deployment of TOS routing, TOS has\nrecently been removed from the OSPF specification [178]. For the same reason, TOS has\nalso been omitted from IPv6.\nAn application can also modify the handling of its packets by extending the IP\nheaders of its packets with one or more IP options. IP options are used infrequently for\nregular data packets, because most Internet routers are heavily optimized for forward-\ning packets having no options. It is not uncommon for a router's performance to\ndegrade by an order of magnitude when forwarding packets with IP options. Most IP\noptions (such as the record-route and timestamp options) are used to aid in statistics col-\nlection but do not affect a packet's path. However, the strict-source route and the loose-\nsource route options can be used by an application to control the path its packets take.\nThe strict-source route option is used to specify the exact path that the packet will\ntake, router by router. The utility of strict-source route is limited by the maximum size of\nthe IP header (60 bytes), which limits to 9 the number of hops specified by the strict-\nsource route option. The loose-source route is used to specify a set of intermediate",
        "55c9fffc-8c90-4af5-b320-5709b3ec99da": "12 Role of Routers in the Internet Chapter 1\nrouters (again, up to 9) through which the packet must go on the way to its destination.\nLoose-source routing is used mainly for diagnostic purposes, such as an aid to debug-\nging Internet routing problems (see Sections 12.4 and 12.5). Loose-source routing also\nhas been used in the past as a tunneling (see Section 1.2.3) mechanism.\nSome network operators consider IP source routing a security hole. If security is\nbeing provided through address filtering, the problem with source routing is that the\nultimate destination of the packet is buried within the IP options field. For this reason,\nsome network operators configure their routers to drop packets containing the source\nrouting options.\nSending ICMP Errors\nTCP/IP hosts get information from routers via the Internet Control Message Protocol\n(ICMP) [194]. There are ICMP messages to discover routers (ICMP Router Discovery\nmessages), the best router to use for a particular destination (ICMP Redirect messages),\nand whether a router and/or host is reachable (ICMP Echo and Echo Reply messages).\nThere are also ICMP error messages that a router uses to inform a host that something is\nwrong with a particular packet the host has sent. The router drops the packet with the\nerror, and the ICMP error message returned contains the beginning of the packet caus-\ning the error (at least through the TCP or UDP header), giving the host (or the person\nbehind the host) a chance to fix the problem.\nIf the IP header of the packet is malformed, the router sends an ICMP Parameter\nProblem message back to the host. If the packet's IP destination is unreachable, an ICMP\nDestination Unreachable message is returned. The common cause for this message is\nthat there is no path to the destination host, but Destination Unreachable messages also\nare used to indicate that the peer application is not available in the destination host\n(subtype Protocol or Port Unreachable) or that the source host has prevented fragmenta-\ntion and the packet is too big to be sent over the next link (subtype Fragmentation\nNeeded and DF Set). If the packet has already traveled the maximum number of hops as\noriginally specified by the host in the packet's TTL field, an ICMP TTL Exceeded mes-\nsage is returned.\nRouters must be careful that the sending of ICMP errors does not adversely affect\nthe network. For this reason, ICMP errors are never sent in response to IP broadcast or\nmulticast packets or to packets that were received as data-link multicast/broadcasts; in\nall these cases, to send an error would risk having one packet generate many ICMP\nerrors in response. In order to avoid an unending stream of ICMP errors, routers never\nsend ICMP error messages in response to ICMP messages themselves; the one exception\nis that ICMP errors are sent in response to ICMP Echo or Echo Reply packets that have\nproblems. Also, routers no longer send ICMP Source Quench messages. These messages\nwere originally intended to indicate network congestion to hosts but were found to do\nmore harm than good by adding more packets to an already congested network.",
        "1d54a7c3-ea6a-4663-bf91-ea98ae7c007b": "Section 1.2 Forwarding IP Datagrams 13\nICMP errors are intended to be for diagnostic purposes only and are generally not\nsupposed to cause the host to take specific actions. For example, receipt of a Destination\nUnreachable message should not cause a host to reset TCP connections [22]. However,\nICMP error messages sometimes are used to implement network functionality, or diag-\nnostic tools. Hosts can discover the MTU available to a destination via the reception of\nICMP Destination Unreachable messages (subtype Fragmentation Needed and DF Set)\n(see [165]). The network utility most commonly used to track down network routing\nproblems, traceroute (Section 12.5), is implemented through clever manipulation of\nICMP TTL Exceeded messages. It has even been suggested that ICMP Source Quench\nmessages be reenabled in the Internet's routers to enhance congestion-control algo-\nrithms [75].\nAdd-Ons\nBesides dynamically finding the paths for datagrams to take toward their destinations,\nrouters also implement other functions. For example, routers play an important role in\nTCP/IP congestion-control algorithms. When a TCP/IP network is congested, routers\ncannot forward all the packets they receive. Simply by discarding some of their received\npackets, routers provide feedback to TCP congestion algorithms, such as the TCP slow-\nstart algorithm [115], [239]. Early Internet routers simply started discarding excess pack-\nets instead of queuing them onto already full transmit queues; these routers were\neventually termed drop-tail gateways. However, this discard behavior was found to be\nunfair, favoring applications that send larger and more bursty data streams. Modern\nInternet routers employ more sophisticated, and fairer, drop algorithms, such as Random\nEarly Detection (RED) [77].\nAlgorithms also have been developed that allow routers to organize their transmit\nqueues so as to give resource guarantees to certain classes of traffic or to specific appli-\ncations. For example, a router may be configured to dedicate half of its link bandwidth\nto interactive traffic or to reserve 5 kilobits/sec on certain links for an Internet video\nconference. These algorithms, called queuing, or link scheduling, algorithms, include\nWeighted Fair Queuing (WFQ) [64] and Class Based Queuing (CBQ) [76]. A protocol called\nRSVP [266] has been developed that allows hosts to dynamically signal to routers which\napplications should get special queuing treatment. However, RSVP has not yet been\ndeployed, with some people arguing that queuing preference could more simply be\nindicated by using the precedence bits in the IP header [45].\nOften other functions, less directly related to packet forwarding, get incorporated\ninto TCP/IP routers. The reason for modifying the routers is usually that there are fewer\nrouters than hosts, and router software is typically much easier to upgrade. Examples of\nthese nonforwarding functions include\n\u2022 Security functions. Companies often put a router between their company net-\nwork and the Internet and then configure the router to prevent unauthorized",
        "7cb101e1-000e-41ec-85ac-b42e2bf55e93": "14 Role of Routers in the Internet Chapter 1\naccess to the company's resources from the Internet. This configuration may\nconsist of certain patterns (for example, source and destination address and\nTCP port) whose matching packets should not be forwarded or of more com-\nplex rules to deal with protocols that vary their port numbers over time, such as\nthe File Transfer Protocol (FTP) [199]. Such routers are called firewalls [41]. Simi-\nlarly, Internet Service Providers often configure their routers to verify the source\naddress in all packets received from the ISP's customers. This foils certain\nsecurity attacks and makes other attacks easier to trace back to their source.\nSimilarly, ISPs providing dial-in access to their routers typically use Remote\nAuthentication Dial-In User Service (RADIUS) [214] to verify the identity of the\nperson dialing in.\n\u2022 Packet tracing. People often use their routers to collect packet traces, in order to\ndiagnose network problems. With an implementation of the Remote Monitoring\nMIB (RMON) [256], a router can be turned into a network analyzer, although\nusually one with considerably less function and performance than a dedicated\nanalyzer, such as a Network General Sniffer (see Section 12.8).\n\u2022 Statistics collection. Some people collect traffic statistics on their routers: how\nmany packets and bytes are forwarded per each IP source and destination com-\nbination. This may be too fine a granularity, and statistics may be kept instead\nper source and destination Autonomous System (AS, the administrative group-\nings of routers within the Internet, as described in Section 2.2) or simply per\nreceiving and transmitting interface on the router. These statistics are used for\nfuture capacity planning. However, in the future, such statistics may be used by\nISPs to implement usage-based charging schemes for their customers or as a\nway to implement settlement schemes between the ISPs themselves.\nFinding the First-Hop Router\nWe have described how routers forward IP packets. However, to get the ball rolling, the\nsource host must find a router to send the packet to in the first place. This has always\nbeen a weak spot in the IP protocol suite. IP does not have a good way to find the best\nfirst-hop router to use for a particular destination and for a long time had no way to\ndynamically find any router.\nLet us first step back a bit. How does a host determine whether a router has to get\ninvolved at all? The host checks to see whether the destination belongs to one of its\ndirectly attached network segments. For example, suppose that a host has a single inter-\nface onto a network segment with address of 128.186.1/24 (see Section 1.2.1). This\nmeans that all hosts with addresses 128.186.1.x also are directly attached to the segment.\nPackets can be sent directly to these hosts without using a router. However, if the host\nwants to send a packet to 192.9.32.1, it must first send the packet to a router attached to\nthe 128.186.1/24 segment.",
        "28cae7fb-c59a-4b93-b782-3796ef679e0c": "Section 1.2 Forwarding IP Datagrams 15\nTraditionally a host would have a configured set of one or more default gateways\n(gateway being the previous term for what we now call a router) to send the packet to.\nOut-of-service default gateways would be pruned from the list by periodically sending\nICMP Echoes to the list and checking for ICMP Echo Replies (that is, pinging the list). In\n1991 ICMP Router Discovery [57] was developed, allowing hosts to dynamically find\nrouters by listening for ICMP Router Discovery messages.\nHowever, the configured default, or discovered, router may not be the best router to\nuse for the given destination. For example, in Figure 1.4, the router 128.186.1.254 is on\nthe best path to the destination 192.9.32.1. If the host's default router is 128.186.1.253, the\npacket will transit the network segment twice, first to the default router and then to\n128.186.1.254 on the way to the destination. IP removes this extra hop via ICMP. The\ndefault router, realizing that it is forwarding the packet back onto the segment where\nit originated, sends an ICMP Redirect message back to the host (128.186.1.1), informing\nthe host that future packets to 192.9.32.1 should be sent directly to the first-hop router\n128.186.1.254. The host then stores this information in its routing table. Such redirect\ninformation must be timed out and refreshed periodically lest the disappearance of the\nfirst-hop router (which possibly could be detected by ICMP router discovery, or ping)\ncause the destination to be permanently unreachable.\nFigure 1.4 ICMP Redirect messages remove extra router hops. (1) Host sends packet to suboptimal first-hop\nrouter; (2) that router forwards the packet on to the real next hop, and (3) sends an ICMP Redirect back to the\nhost so that future packets will be sent directly to best next hop (.254).\nUnfortunately redirect timeouts are often quite long, causing transport connections\nto fail before old redirect information is removed. For this reason, router vendors have\ndeveloped protocols whereby another router can take the place of the failed router\n(assuming its IP and MAC addresses) without the host's knowledge. One such example\nis Cisco Systems' \"hot standby router protocol\" [136]. Another example is the Virtual\nRouter Redundancy Protocol [100] being developed within the Internet Engineering\nTask Force (IETF). This protocol introduces the concept of a \"virtual IP address.\" This",
        "57e9bd9a-6c56-4713-8486-6557fb6e158e": "16 Role of Routers in the Internet Chapter 1\nvirtual IP address can be used as a next hop for a segment's hosts, and the responsibility\nfor the virtual IP address is dynamically allocated to one of the segment's routers via an\nelection algorithm.\nAnother common method for finding the best router for a particular destination is\nto have the host participate in the IP routing protocols (sometimes referred to as wire-\ntapping, since the host is really only eavesdropping on the routers' routing protocols),\nalthough this solution is discouraged by IP purists. RIP (Section 13.1) is commonly used\nfor this purpose, with most UNIX systems shipped running the routed program [222],\nan implementation of RIP. The OSPF implementation included in the companion to this\nbook (OSPF Complete Implementation) allows hosts to wiretap the OSPF protocol.\n1.2.1 IP Addresses\nAn IP packet is routed on the basis of the 32-bit destination IP address found in the\npacket's IP header. IP addresses are generally represented in dotted decimal notation: the\ndecimal value of each byte of the address, separated by periods. For example, the IP\naddress whose hexadecimal value is Oxc0090102 is written as 192.9.1.2.\nBy looking at the IP address, a router can determine quickly whether it is a unicast,\nbroadcast, or multicast address, as shown in Table 1.1. The address space is broken into\nthree chunks: the majority used for unicast, a range of multicast addresses (see Chap-\nter 9, Internet Multicast Routing), and a small portion at the top of the address space\nthat is reserved for future applications. There are also some special-purpose addresses.\nA host uses 0.0.0.0 as the IP source in its packets when the host is attempting to learn its\nIP address through the BOOTP [53] or DHCP [67] protocols, for example. Packets sent\nonto a network segment with IP destination set to the broadcast address 255.255.255.255\nwill be received by all other IP hosts and routers on the segment; this feature is used by\nsuch routing protocols as RIP to disseminate routing updates (Section 13.1).\nTable 1.1 Division of IP Address Space by Function\nA TCP/IP network segment (for example, an Ethernet segment, FDDI ring, or\nFrame Relay subnet) is assigned a set of globally unique unicast addresses by assign-\ning a unicast address prefix to the segment. Hosts and router interfaces attaching toAddress Range Address Functionality\n1.0.0.0-223.255.255.255 IP unicast addresses\n224.0.0.0-239.255.255.255 IP multicast addresses\n240.0.0.0-255.255.255.254 Reserved for future use\n0.0.0.0 Specifies unknown IP address\n255.255.255.255 Local segment broadcast",
        "594898f4-07a3-4374-a961-7f7de139c313": "Section 1.2 Forwarding IP Datagrams 17\nthe segment are then assigned unicast addresses from the set. For example, the\nnetwork segment in Figure 1.4 has been assigned the range of addresses 128.186.1.0-\n128.186.1.255, which is also represented as the address prefix 128.186.1.0/24; the 24\nindicates that all addresses in the segment agree in their first 24 bits. This is also\nsometimes written as the address, mask pair [128.186.1.0,255.255.255.0], with the\n1 bits in the mask representing those bits in the address that stay constant over the\nsegment's addresses. The host and two routers in Figure 1.4 have been assigned ad-\ndresses from the prefix for their interfaces to the segment (128.186.1.1,128.186.1.253,\nand 128.186.1.254, respectively).\nThe highest address in the prefix is assigned as the broadcast address for the seg-\nment. For example, 128.186.1.255 is the broadcast address for the network segment in\nFigure 1.4. A packet sent to this address will be delivered to all hosts and routers\nattached to the segment.\nAs mentioned earlier, TCP/IP routers route to segments. When forwarding a\npacket, a router looks in its routing table (see Section 2.1) to find the segment to which\nthe packet's destination address belongs and then forwards the packet toward the\nmatching segment. However, it is more correct to say that routers route to prefixes.\nRouters cannot possibly keep track of every segment in the Internet. Instead a segment's\naddressing information is aggregated into shorter prefixes at points in the Internet. It is\nroutes to these shorter prefixes, which may have been aggregated up to three or four\ntimes from the original segment prefixes, that are kept in the router's routing table.\nAn example of aggregation is shown in Figure 1.5. Router G is aggregating the\naddresses of the four segments on its right (128.1.1/24,128.1.3/24,128.1.4/24, and\n128.1.62/24), advertising instead a single prefix of 128.1/16 to the routers to its left. This\nmeans that routers A-F are not aware of the four segments to G's right but instead have\na single routing table entry for 128.1/16 pointing (eventually) to router G.\nPrior to 1993, prefixes were forced into a small number of fixed-sized lengths, based\non address class (see Section 1.2.2). When this restriction was lifted, allowing arbitrary\nprefix lengths, much more aggressive aggregation became possible, allowing for greater\nconservation of IP address space and a slowing of the growth rate of the Internet core\nrouters' routing tables (see Section 2.1). Routing on arbitrary prefix length became\nknown as Classless Inter-Domain Routing, or CIDR [81]. The prefix/length notation, such\nas 128.186.1.0/24, became known as CIDR notation.\nA hierarchy of Internet Registries is responsible for assigning the globally unique\nInternet TCP/IP address space [102]. At the top of the hierarchy is the Internet Assigned\nNumber Authority (IANA), which allocates pieces of the Internet address space to\nregional Internet Registries. To date, three regional Internet Registries have been estab-\nlished: InterNIC for North America, RIPE NCC for Europe, and APNIC for Asia Pacific.\nISPs apply to these regional Internet Registries for blocks of IP addresses. The ISPs in\nturn assign parts of these address blocks to their customers (businesses, individuals, or\nsmaller ISPs). Termed provider addressing, this procedure encourages address aggrega-\ntion; the ISP can aggregate its customer's addresses and advertise only the larger",
        "3786ca3d-19a2-4054-8852-63b8f22d6bde": "18 Role of Routers in the Internet Chapter 1\n128.3.7/24 128.2.2/24\n128.2.4/24 128.1.3/24\n128.5.6/24 128.1.4/24\nFigure 1.5 Sample TCP/IP network showing prefix aggregation.\naddress blocks to other ISPs. A side effect of provider addressing occurs when a\ncustomer wants to change ISPs. To maintain address aggregation, the customer is\nencouraged to give back its old addresses and to renumber its network segments into\none of its new ISP's address blocks [209]. Hence the assignment of addresses from ISPs\nto their customers is termed address lending. Renumbering TCP/IP network segments\ncan be quite difficult however [19], [74].\nTable 1.2 Special-Purpose IP Unicast Addresses\nPrefix\n10/8\n127/8\n172.16/12\n192.168/16Address Range\n10.0.0.0-10.255.255.255\n127.0.0.0-127.255.255.255\n172.16.0.0-172.31.255.255\n192.168.0.0-192.168.255.255Reserved Purpose\nPrivate Internet addresses\nLoopback addresses\nPrivate Internet addresses\nPrivate Internet addresses\nOver time, certain IP unicast addresses have accrued special meaning, as shown in\nTable 1.2. The development of BSD UNIX and the TCP/IP protocol suite proceeded\nhand in hand for many years. In particular, many BSD UNIX TCP/IP conventions and\nprotocols have been adopted by the TCP/IP community at large. As one example, the",
        "a1ff3bd1-6900-47f9-af2b-d200047a4a3c": "Section 1.2 Forwarding IP Datagrams 19\nloopback address 127.0.0.1 is used by a BSD system to send IP packets to itself. This led\nto the entire prefix 127/8 being officially reserved as loopback addresses. Certain other\naddress prefixes have been allocated for use by private TCP/IP internets and are not\nroutable (since they cannot be ensured to be unique) on the public Internet. For private\nTCP/IP internets that are not attached to the public Internet, the fact that the addresses\nare not globally routable is of little issue. However, even when using these private,\nnonunique addresses, private internets may be attached to the public Internet through\nNetwork Address Translation (NAT) [79] devices. These devices convert the addresses\nin packets destined for the public Internet, substituting dynamically assigned globally\nunique addresses for all private addresses appearing within the packet.\n1.2.2 A Short History of Internet Addressing\nInternet unicast addresses were not always assigned as arbitrary-length prefixes. In the\nbeginning, the Internet address space was carved up into fixed networks of three sizes:\nClass A, B, and C networks. Class A networks, which we would now call a CIDR prefix of\nlength 8, could contain more than 16 million hosts. Similarly each Class B network was\na CIDR prefix of length 16 containing more than 65,000 hosts, and each Class C network\nwas a CIDR prefix of length 24 containing up to 254 hosts. Whether any particular\naddress belonged to a Class A, B, or C network could be determined quickly by looking\nat the address's first byte, as shown in Table 1.3. Class D addresses were later assigned\nfor IP multicast, with Class E remaining reserved for future use.\nTable 1.3 Historical Class Division of IP Address Space\nFirst Byte\n0-127\n128-191\n192-223\n224-239\n240-255Class\nA\nB\nC\nD\nEExample\n16/8\n128.186/16\n192.9.1/24\n224.1.1.1 (multicast)\nreserved\nIt soon became clear that assigning an entire Class A or B network number to a sin-\ngle physical network segment was wasteful. How often would several thousand hosts\nbe attached to a single Ethernet segment? Also, assigning each physical network seg-\nment a separate network number would force the Internet's routing table to grow lin-\nearly with the number of segments. To avoid these problems, subnetting was invented\n[166], adding another level of hierarchy to the Internet's routing and addressing. With\nsubnetting, each Class A, B, or C network number could be broken up into fixed-sized\npieces called subnets, with each subnet assigned to a different physical segment.",
        "06697d20-1264-4677-905b-023f109814ae": "20 Role of Routers in the Internet Chapter 1\nTake, for example, the Class B network 128.186/16; some number of the lower 16\nbits reserved for host addressing could be used to indicate a subnet number. If the third\nbyte were used for this purpose, 128.186/16 could be divided into 254 subnets (subnets\n0 and 255 being reserved), each containing 254 hosts; this practice was also called using\na subnet mask of 255.255.255.0. In this way, a single Class B network could be used to\naddress hundreds of segments, a Class A network thousands. Outside of the subnetted\nnetwork, all of the segments would be covered by a single Class A, B, or C routing table\nentry.\nIn the presence of subnets, additional broadcast addresses were defined in RFC 922\n[164]. Setting all of a subnet's host bits to 1 resulted in the subnet's directed-broadcast\naddress. This address could be used to send a packet to all hosts on the subnet, even\nwhen the packet was originated from a distant segment. For the subnetted network,\nsetting both the subnet and the host bits to 1 resulted in the all-subnets-broadcast address.\nAlthough never widely implemented, a packet sent to this address was supposed\nto be delivered to all hosts on all subnets of the given Class A, B, or C network.\nUsing the earlier example of the Class B network 128.186/16 subnetted on the\nthird byte, 128.186.10.255 would be the directed-broadcast address for subnet 10\nand 128.186.255.255 the all-subnets-broadcast address for the entire Class B net-\nwork. Forwarding of IP broadcasts is described in Section 9.3.\nUnfortunately the BSD UNIX project used the setting of the host bits to 0 to indicate\nbroadcast addresses. So in the previous example, 128.186.10.0 would be the BSD\ndirected-broadcast address for subnet 10 and 128.186.0.0 the all-subnets-broadcast\naddress for 128.186/16. For a long time, routers would have to support both the RFC\n922 broadcast addresses and the BSD broadcast addresses.\nEventually the restriction that all subnets be the same size was found too limiting.\nSubnet size was driven by the segment having the largest number of hosts, wasting\naddresses on the smaller segments. In our example, if the 128.186/16 subnetted network\nhad one segment with 1,000 hosts, you would be limited to 62 subnets (again avoiding\nsubnets of all Os and all Is) of 1,022 hosts each. To solve this problem, people began\ndividing their Class A, B, and C networks into subnets of varying sizes; this has been\ncalled variable-length subnet masks, or VLSMs. As just one combination, 128.186/16 could\nnow be divided into three subnets capable of holding 254 hosts (128.186.1-3/24), one\nsubnet with 1,022 hosts (128.186.4/22), and 3,966 subnets of 14 hosts each.\nWith VLSMs, schemes were developed allowing subnet masks to be adjusted as the\nhost population of segments changed, without renumbering hosts [250]. The Fuzzball\nrouters in the original NSFNET were the first routers to allow VLSMs [161]. Newer rout-\ning protocols, such as OSPF, were designed with VLSM support.\nSubnet numbers usually were assigned to immediately follow the network prefix. If\nthere was a gap between the network prefix and the subnet number, the subnet mask\nwas termed discontiguous. An example of a discontiguous subnet mask is using the\nfourth byte of a Class B network to indicate the subnet number, resulting in a subnet\nmask of 255.255.0.255. The combination of VLSMs and discontiguous subnet masks was",
        "0b64b757-92e2-4892-b789-f712c15c3ee7": "Section 1.2 Forwarding IP Datagrams 21\na bad one, for two reasons. First, certain assignments of discontiguous subnet masks\ncould result in multiple subnets matching the same number of bits, making the concept\nof best match ambiguous! Second, common routing table lookup algorithms, such as\nPatricia (see Section 2.1), could not handle discontiguous masks efficiently. With discon-\ntiguous subnet masks already discouraged by RFC 922, the introduction of VLSMs\nmade them virtually unsupported. Discontiguous subnet masks are now prohibited by\nthe latest router-requirements RFC [12].\nIn 1993, concern grew over the possibility of the Internet address space becoming\nexhausted. A good percentage of the Class B addresses had already been assigned, and\nthe Internet number authorities wanted to start assigning multiple Class C networks\ninstead. However, since each Class A, B, and C network appeared as individual entries\nin the Internet core routers, assigning multiple Class Cs ran the risk of exhausting the\ntable space of the Internet's routers. The idea of using a single routing table entry to rep-\nresent routes to a collection of class C networks led to CIDR and the current prefix-\nbased, classless Internet routing paradigm. For example, the prefix 192.24.16/20, which\nformerly was represented by the 16 separate Class C networks 192.24.16.0 through\n192.24.31.0, could now be a single routing table entry. Such an entry is sometimes\nreferred to as a supernet.\nWith CIDR, the restriction on all Os and all Is subnets was also removed; with CIDR,\neven the idea of a subnet loses most of its meaning. Internet routing protocols that\nencoded their routes based on the now defunct Class A, B, and C network divisions\nwere either discarded (for example, BGP) or updated to new versions customized for\nCIDR, advertising arbitrary address prefixes (for example, BGP-3 to BGP-4, RIP to\nRIPv2, and IGRP to EIGRP).\n1.2.3 Tunneling\nSuppose that routers A and B know how to forward datagrams addressed to the IP des-\ntination X but that the intervening routers between A and B do not. In order to deliver\npackets to X, a tunnel is configured between routers A and B: When A receives a packet\ndestined for X, it alters that packet to look as though the destination is really router B, in\nessence tricking the intervening routers to forward the packet. When B receives the\npacket, it returns the packet to its original state (possibly altering its TTL; see [188]) and\nforwards it on toward X.\nWhy would the intervening routers between routers A and B not know how to for-\nward to X? The most common example in the Internet is the Internet's Multicast Back-\nbone (MBONE); see Section 9.4. The MBONE consists mostly of a collection of UNIX\nworkstations running the DVMRP routing protocol. DVMRP calculates paths for multi-\ncast datagrams. However, most of the Internet's routers do not run DVMRP and so are\nnot aware of these multicast paths. This forces the MBONE routers to be interconnected\nby tunnels.\ni",
        "da1b96d5-b98f-467e-90ee-ecbc0cdf85fb": "22 Role of Routers in the Internet Chapter 1\nAs another example, in many regions of the Internet, only those routers partici-\npating in BGP (see Section 13.3) obtain routing information for the full set of Internet\ndestinations. In order to forward data traffic to certain destinations, tunnels must be\nconfigured between BGP routers.\nTwo separate mechanisms may be used to implement such a tunnel. The first is\nthe source route option. When forwarding datagrams addressed to X, router A puts\nrouter B's address into the IP header as destination address and moves address X into\na loose source route option. The second mechanism is to encapsulate the packet by a\ncomplete extra IP header. This IP header is again addressed to router B, and the protocol\nnumber in this header is set to 4, telling B that it should strip the IP header and forward\nthe encapsulated packet [188]. The second mechanism is usually preferred, due to the\nsignificant performance degradation seen in most Internet routers when IP options are\nemployed.\nAlthough tunnels are sometimes necessary, they are usually to be avoided. The pro-\ncess of adding and stripping information (be it source routes or extra IP headers) at the\ntunnel end points (routers A and B) decreases forwarding performance in those routers.\nThe additional information also makes it more likely that fragmentation will be neces-\nsary, although hosts can avoid fragmentation by using the Path MTU discovery algo-\nrithm [165], which can take tunneling into account. Worst of all, tunneling can subvert\nfirewalls and in general make traffic monitoring more difficult; the real destination is\nburied in the options field or in additional IP headers. In particular, many ISPs get\nannoyed when people configure MBONE tunnels through the ISP's network, in the pro-\ncess masking high-bandwidth video feeds as innocuous unicast data.\n1.3 IPv6\nPrompted by the fear of exhausting the Internet's address space, designers began work\nin 1993 on a new version of IP with larger addresses. This culminated in 1996 with the\npublication of a full set of network-layer protocol specifications (the other layers of the\nprotocol stack remaining unchanged) for IPv6 [49], [61], [99], [181], with the Internet's\ncurrently deployed IP being referred to in comparison as IPv4.\nWe touch only briefly on IPv6 in this book. Why? Mainly because IPv6 is not all that\nmuch different from IPv4. IPv6 has made a number of incremental improvements over\nIPv4 yet can be summarized roughly as \"IPv4 with 128-bit addresses.\" In particular, the\nIP routing and addressing architecture remains largely unchanged. An IPv6 router\nmakes its forwarding decisions on the basis of a routing table of CIDR-like address pre-\nfixes; address assignment is likely to be provider based; and IPv4's existing routing pro-\ntocols\u2014OSPF [46], RIP [151], and BGP [208]\u2014are being modified to carry IPv6's larger\naddresses.\nIPv6 also has not been widely deployed, probably for several reasons. First,\nthe original fear that IPv4's address space soon may be exhausted now seems an",
        "0e179d24-5ad9-42db-b276-851190177cc7": "Section 1.3 IPv6 23\noverreaction. The deployment of CIDR has improved the efficiency of address usage,\nand fear has now shifted to the routing tables' expanding beyond the capacity of the\nInternet's core routers\u2014a problem that IPv6 does not solve. The possibility of organiza-\ntions using the private Internet address space (see Section 1.2.1) and connecting to the\nInternet through Network Address Translation (NAT) [79] boxes has also lessened the\ndemand for Internet addresses. Since IPv6 does not enable any new classes of network\napplications, conversion of the large base of routers and hosts running IPv4 is likely to\nbe delayed until IPv4 address exhaustion again seems imminent.\nIPv6 can be thought of as an attempt to capture current IPv4 usage in protocol spec-\nifications. Those IPv4 features that are either unused (for example, TOS-based routing)\nor discouraged (such as fragmentation by intermediate routers) have been deleted from\nthe IPv6 protocol specifications. IPv6 has made mandatory several IPv4 features that are\ndesirable but have yet to see widespread deployment: IP multicast and security. In addi-\ntion, address scoping has been made an initial part of the IPv6 addressing architecture\n[99], building on IPv4 experience with private internet addresses [210] and proposals for\nIPv4 multicast address scope [158]. Address scoping is a way of dropping the global-\nuniqueness requirement for certain addresses. IPv6 supports link-local (unique only on\na given segment) and site-local (unique only within a certain \"site\") address scopes, as\nwell as the usual globally unique addresses.\nDifferences from IPv4\nAs mentioned earlier, the major difference between IPv6 and IPv4 is the size of\naddresses: 128 bits for IPv6 versus IPv4's 32-bit address. In IPv6, addresses are no longer\nwritten in dotted decimal notation. Instead the IPv6 address is broken into eight 16-bit\npieces, and each piece is then expressed in hexadecimal, with the pieces separated by\ncolons. An example of an IPv6 address is 4722:Oc62:0:0:2:1298:OCC:A096. As a shortcut,\nthe longest string of 16-bit Os within an address can be abbreviated as :: (but only one\nstring within an address, to avoid ambiguities); our example address can also be written\nas 4722:Oc62::2:1298:OCC:A096. IPv6's notation for CIDR prefixes is similar to IPv4's,\nwith the prefix defined by the first four bytes of our address written as 4722:Oc62/32.\nBecause of the increase in address size, the IPv6 packet header is somewhat larger\nthan IPv4's header, with the minimum size IPv6 header twice the size of the minimum\nIPv4 header. The IPv6 network layer header is depicted in Figure 1.6.\nAll of the fields in the IPv6 header were also present in IPv4, with the exception of\nthe Flow Label, although some fields have been renamed. The Version field is, of course,\nset to 6. The Priority field carries similar semantics to IPv4's precedence field, carrying\nan indication of a packet's transmission queuing priority, although IPv6 allows this field\nto be rewritten at each router hop. The Payload Length is simply the length of the packet\nin bytes. The Next Header field is the same as IPv4's Protocol field, even going so far as\nto use the same encodings. For example, a Next Header field of 6 (see Figure 1.3) indi-\ncates that TCP data is encapsulated. The Hop Limit field is IPv4's TTL field renamed, an",
        "a3d09338-8c62-496d-8d8a-7f3bd23fd432": "24 Role of Routers in the Internet Chapter 1\nFigure 1.6 The IPv6 network-layer packet header.\nadmission of the TTL field's real function in IPv4. Use of the Flow Label in IPv6 has not\nyet been completely determined, although the general idea is to provide a forwarding\nhint to routers for particular packet streams.\nIPv6 uses different data-link encapsulations than IPv4 does. Although the Version\nfield would in theory allow both IPv4 and IPv6 to use the same data-link encapsula-\ntions, experience with the ST2 protocol (an experimental flow-oriented network-layer\nprotocol that was assigned IP version number 5; see [63]) indicated that many IPv4\nimplementations do not bother to check the Version field and would get very confused\non receiving an IPv6 packet. Defining new data-link encapsulations is mostly an admin-\nistrative task; for example, IPv6 has been assigned the Ethernet type of Ox86DD [52], as\nopposed to IPv4's Ethernet types 0x800. Still, there are plenty of new RFCs describing\nhow IPv6 works over the various data links in use in the Internet.\nIPv6 has distilled and simplified IPv4's packet-forwarding process. IPv6 has no TOS\nfield, which had gone pretty much unused in IPv4. The Header Checksum field has also\ndisappeared; those applications that include the IPv6 source and destination addresses",
        "457a56fb-a69f-427f-a896-cf6eea32f23c": "Section 1.3 IPv6 25\nas part of their connection identifier must include part of the IPv6 header in an applica-\ntion checksum (much as is done for TCP in IPv4) or risk having corrupted packets asso-\nciated with the wrong connections. Routers also do not fragment packets, something\nalways thought best avoided in IPv4. Instead they simply send an error back to the\nsource when they are unable to fit the packet onto the next data link.\nIPv6 supports header options as IPv4 does, such as source routing. In IPv6, how-\never, options are encoded as a separate header between the IPv6 header and application\ndata. Additional headers may also be inserted before the application data, to implement\nauthentication, security, and source-packet fragmentation. Each header indicates the\nfunction of the next-in-line encapsulated header by proper setting of the Next Header\nfield.\nIPv6 also has an ICMP [49] that is very similar to its IPv4 counterpart; in IPv6, the\nInternet Group Membership Protocol (IGMP, see Section 9.2.1) has been absorbed into\nICMP as well. IPv6 does not use ARP. Instead the ARP function has been incorporated\ninto the IPv6 Neighbor Discovery protocol [181], which is also part of IPv6 ICMP. In addi-\ntion to implementing the ARP function, IPv6 neighbor discovery encompasses IPv4's\nICMP router discovery and redirect functions. In addition, IPv6 neighbor discovery\nimplements two functions not present in IPv4: address autoconfiguration and\nduplicate-address detection.\nFurther Reading\nMany good books and papers detail the history of the ARPANET network and the Inter-\nnet. See, for example, the papers by Leiner et al. [135] and Clark [44].\nThis book assumes that you have a basic knowledge of the TCP/IP protocol suite\nand data communications in general. The books by Comer [48] and Stevens [240] pro-\nvide an excellent introduction to TCP/IP. Bertsekas and Gallagher's text Data Networks\n[20] is a thorough introduction to data communications for the theoretically inclined.\nAnyone looking just for a survey of networking protocols may be more comfortable\nwith Tanenbaum [242].\nThe router-requirements RFC [12] is necessary reading for anyone designing or\nimplementing an IP router. The RFC provides many years of collected wisdom on what\none should and should not do when building a router.\nBooks on IPv6 are just starting to come out. The collection of essays edited by Brad-\nner and Mankin [26] provides insight into the requirements and design decisions that\nresulted in the IPv6 protocols. For general information on IPv6 protocols, see Huitema's\nbook [103].\n.",
        "0bd7f6e8-a3cc-4298-8b7d-c85418e69762": "2\nInternet Routing Protocols\nIn this chapter, we explore the Internet's dynamic routing protocols. TCP/IP has\nmany routing protocols, with OSPF, BGP, RIP, IGRP, and Integrated IS-IS all in use in\ntoday's Internet. Before getting to the routing protocols themselves, we first discuss the\ndatabase that all routing protocols produce: the router's routing table. An examination\nof the Internet's routing architecture introduces the concept of Autonomous Systems\nand Interior and Exterior Gateway Protocols (IGPs and BGPs). We end the chapter with\na description of the two main routing technologies in use today: Distance Vector and\nlink state.\n2.1 Routing Tables\nAll TCP/IP routing protocols have ways of discovering the reachable IP address pre-\nfixes and, for each prefix, the next-hop router to use to forward data traffic to the prefix.\nAs the network changes\u2014leased lines fail, new leased lines are provisioned, routers\ncrash, and so on\u2014the routing protocols continually reevaluate prefix reachability and\nthe next hop to use for each prefix. The process of finding the new next hop after the net-\nwork changes is called convergence. We prefer routing protocols that find the new next\nhop quickly, that is, protocols having a short convergence time. However, for any routing\nprotocol, as the size and complexity of the network increase, so does convergence time.\nA router's routing table instructs the router how to forward packets. Given a packet,\nthe router performs a routing table lookup, using the packet's IP destination address as\n27",
        "54e76777-78e6-4bde-ace0-442410e0c2e2": "28 Internet Routing Protocols Chapter 2\nkey. This lookup returns the best-matching routing table entry, which tells the router\nwhich interface to forward the packet out of and the IP address of the packet's next hop.\nThere is a separate routing table entry for each address prefix that the router knows\nabout. Entries in the routing table are also commonly referred to as routes. For example,\nFigure 1.5's router C would have the routing table listed in Table 2.1. The next hop of\n\"self\" for prefix 128.5.2/24 indicates that that segment is directly connected to router C;\nC will deliver packets destined to that prefix directly to their destination. Note that\nalthough there is a network segment with the prefix 128.2.2/24, that prefix is hidden\nfrom C by the aggregate 128.2/16 advertised by router D. Similarly router G on the right\nof Figure 1.5 hides a number of more specific prefixes from C by advertising the single\naggregate 128.1/16.\nTable 2.1 The Routing Table of Figure 1.5's Router C\nPrefix\n128.1/16\n128.2/16\n128.2.4/24\n128.3.7/24\n128.5.2/24\n128.5.6/24Next Hop\nRouter G\nRouter D\nRouter A\nRouter D\nSelf\nRouter B\nIf a packet's IP destination falls into the range of addresses described by a particular\nrouting table entry's prefix, we say that the entry is a match. In our example, the entry\nfor 128.3.7/24 in Table 2.1 matches all destinations of the form 128.3.7.x. In our example,\nmany destinations do not have a matching entry\u201428.4.56.77,192.9.1.3,11.11.11.11 are a\nfew examples. If router C receives a packet addressed to any of these destinations, it\nsimply throws the packet away and attempts to send an ICMP Destination Unreachable\nmessage back to the packet's source to inform it about the error.\nIn Table 2.1, the destination 128.2.4.5 matches two routing table entries: 128.2/16\nand 128.2.4/24. This is not at all uncommon. In these cases, the entry with the longest\nprefix, 128.2.4/24, is selected as the best match (sometimes also referred to as longest\nmatch); we also say that 128.2.4/24 is more specific than 128.2/16. One way that multiple\nmatches can occur is when the provider addressing model is being used. An organiza-\ntion takes a range of addresses from its Internet Service Provider and later on changes\nproviders but does not wish to change addresses. The new ISP then ends up advertising\na more specific route for a piece of the old provider's address space (this is now offi-\ncially discouraged by the address lending policy, which would instead force the organi-\nzation to renumber when changing providers; see [209]).",
        "5ef1b8a6-d6dd-4545-abed-f9027c9cdc3c": "Section 2.1 Routing Tables 29\nMany routers have a default route in their routing table. This is a routing table entry\nfor the zero-length prefix 0/0. The default route matches every destination, although it\nis overridden by all more specific prefixes. For example, suppose that an organization's\nintranet has one router attaching itself to the public Internet. All of the organization's\nother routers can then use a default route pointing to the Internet connection rather than\nknowing about all of the public Internet's routes.\nEach router has a different routing table, reflecting its unique position within the\nInternet. From router to router, not only do the next hops of routing table entries change,\nbut even the prefixes that each router knows can be different, as addresses are aggre-\ngated into large prefixes. In Figure 1.5, routers D, E, and F are aware of the prefix\n128.2.2/24, but all other routers see only the aggregate 128.2/16. Routers at the edge of\nthe Internet may rely heavily on the default routing table entry, with only a few hun-\ndred or more specific entries in their routing table. Core routers in the Internet, however,\nhave upwards of 45,000 entries. These routers, which do not use a default route, are said\nto hold the full Internet routing table. The size trend of the full Internet routing table is\nshown in Figure 2.1. The contents of a router's routing table can be viewed through\nSNMP and the IP forwarding-table MIB of RFC 2096 (see Section 12.6).\nFigure 2.1 Size increases in the Internet's routing tables (logarithmic scale).\nIn our example, we have been assuming that router C is building its routing table\nthrough the use of dynamic routing protocols\u2014the aggregates 128.1/16 and 128.2/16\nare being advertised to C (by routers G and D, respectively) through some protocol, as\nare the paths to other remote segments. Dynamic routing protocols are certainly the\nnorm, although they do not need to be used. Instead routing table entries can be explic-\nitly configured, called static routing, by a network operator. For example, to install the",
        "e56d886a-c173-4e08-9fbd-b3b809e3cc5e": "30 Internet Routing Protocols Chapter 2\nroute to 128.3.7/24 in router C, a network operator may type the command add route\n128.3.7/24 address-of-router-D. Running an entire network via static routing is too diffi-\ncult to manage, requiring modification of static routes as the network changes or even\nduring network failures. In our example, if the link between routers C and D fails, the\noperator would have to tell router C to route packets destined to 128.3.7/24 through G\ninstead, something that a dynamic routing protocol would do automatically. However,\nstatic routes are still used today in the Internet to augment dynamic routing. For exam-\nple, two organizations may not trust each other enough to run dynamic routing at the\ninterorganization boundary, relying instead on a set of configured static routes.\nImplementation of Routing Tables\nForwarding performance, usually expressed in packets/second, is the most valued\ncommodity in a router. Therefore makers of routers try to arrange their routers' routing\ntables so that the best match operation can be performed as quickly as possible.\nA common routing table arrangement is a Patricia tree (see [129] and [230])\u2014a spe-\ncial kind of radix tree that minimizes bit comparisons and, when used as a routing table,\nrequires only a single mask-and-match operation. These trees are binary trees, whereby\nthe tree traversal depends on a sequence of single-bit comparisons in the key, the desti-\nnation IP address.\nA Patricia tree that might be used to implement the lookup for the routing table in\nTable 2.1 is shown in Figure 2.2. Suppose that the router is trying to route a packet to the\ndestination 128.2.5.6. The router starts at the top of the Patricia tree, testing bit 13 in\nthe destination address (bits are numbered starting at 0 for the most significant bit of\nthe address). Since this bit is 0, the router branches left, testing in sequence bits 14\n(which is a 1), 15 (a 0) and 21 (a 1). This ends up at the entry specifying no bit compari-\nson, so the tree traversal stops; traversal would also stop if the new bit to test were less\nthan or equal to the last bit tested. When the traversal stops, the destination is com-\npared to the prefix in the entry to see whether there is a match. In our example,\n128.2.5.6 does not match 128.2.4/24. The router must then check for matches against\nshorter prefixes of 128.2.4/24; following the prefix pointer back to 128.2/16 yields\nthe best-matching routing table entry.\nWith a routing table containing 45,000 entries, the router will perform on average 16\nbit comparisons for each lookup. However, the performance of Patricia is somewhat\ndata dependent. With a particularly unfortunate collection of prefixes in the routing\ntable, the lookup of certain addresses can take as many as 32 bit comparisons, one for\neach bit of the destination IP address.\nAlthough radix tree variants such as Patricia are most common, other routing table\nlookup algorithms are also employed in TCP/IP routers. For example, the OSPF imple-\nmentation in the companion book to this book uses a balanced binary tree (see [129]).\nAnother way to speed up the routing table lookup is to try to avoid it entirely. The\nrouting table lookup provides the next hop for a given IP destination. Some routers",
        "c78aac73-f86d-4dbc-9e6b-2aaa79545870": "Section 2.1 Routing Tables 31\nFigure 2.2 Patricia-tree implementation of routing table lookup.\ncache this IP destination-to-next-hop association in a separate database that is consulted\nbefore the routing table lookup (one might say as the front end to the routing table).\nFinding a particular destination in this database is easier because you are doing an exact\nmatch instead of the more expensive best-match operation of the routing table. As a\nconcrete example, this front-end database might be organized as a hash table (see [129]).\nIf the hash function were the sum of the third and fourth bytes of the IP destination, a\ncouple of buckets within the hash table might look as in Figure 2.3 after the router had\nforwarded several packets. Now if the router sees any of these destinations again (a\ncache hit), their lookup will be very quick. Packets to new destinations will be slower,\nhowever, because the cost of a failed hash lookup will have to be added to the normal\nrouting table lookup.\nFront-end caches to the routing table can work well at the edge of the Internet or\nwithin organizations. However, cache schemes do not seem to work well in the\nInternet's core. The large number of packet destinations seen by the core routers can\ncause caches to overflow or for their lookup to become slower than the routing table\nlookup itself. For example, cache schemes are not really a win when the hash bucket\nJ",
        "aa6b6dc0-ee2b-417a-9231-f7333c440c81": "32 Internet Routing Protocols Chapter 2\nFigure 2.3 Hash-table front end to a routing table.\nsize\u2014the number of destinations that hash to the same value\u2014starts getting large. Also,\nthe frequent routing changes seen in the core routers can force them to invalidate their\ncaches frequently, leading to a small number of cache hits.\nAlthough IP addressing has been around for more than 20 years, new routing table\nlookup algorithms are still being developed in attempts to build ever faster routers. The\ntwo papers on routing table design presented at SIGCOMM '97, [27] and [257], are\nrecent examples.\n2.2 Internet Routing Architecture\nThe Internet is organized into regions called Autonomous Systems (ASs). Each AS con-\nsists of a collection of routers under the control of a single administrative entity\u2014for\nexample, all the routers belonging to a particular Internet Service Provider, corporation,\nor university.\nThe collection of ASs is organized in a rough hierarchical fashion. The closer to the\ntop of the hierarchy\u2014the core of the Internet\u2014the more routes appear in the AS. At the\nsame time, the individual prefixes within the routers' routing tables get shorter. The ASs\nat the core of the Internet carry the complete routing table, currently 45,000 routes, and\ndo not use a default route (they are in the so-called default-free zone). All other ASs use\na default route, pointing up the hierarchy, enabling them to carry only a subset of the\nInternet's routes. This arrangement of ASs is pictured in Figure 2.4.\nASs that are in the business of providing Internet connectivity are called Internet\nService Providers (ISPs). The network operators that configure and manage the intercon-\nnection of ISPs have a language all their own. When two providers connect, they usu-\nally establish a peering agreement. If the two providers are at the same level of the\nhierarchy, this is simply an agreement to exchange routing information. However, when\none AS is lower in the hierarchy (downstream), this AS is sometimes entering into a",
        "c7fdad92-9924-40b3-bc3f-43af4d713fcc": "Section 2.2 Internet Routing Architecture 33\nRoute Server\nInternet ExchangeRoute Server\nFigure 2.4 Organization of the Internet into Autonomous Systems. Solid lines indicate peering relationships.\nThe arrows indicate the direction of the default route.\ncustomer relationship with the upstream provider. This means that the upstream provider\nwill advertise the downstream's addresses to the rest of the Internet and will forward\nthe downstream's packets to other providers and their customers as appropriate\u2014that\nis, the upstream provider provides transit for the downstream provider. Interprovider\noperational issues are discussed in various forums, such as the North American Net-\nwork Operators Group (NANOG) [183]; peering issues are a major topic.\nInternet prefixes are now assigned to achieve the best aggregation under CIDR. Pro-\nviders that are large enough can get assigned their own address prefixes, also referred to\nas CIDR blocks. Other smaller providers and their customers must use addresses from\nthe CIDR blocks of their upstream provider(s). However, many companies are still\nusing addresses assigned before the advent of CIDR and its address conservation poli-\ncies: large corporations and universities, such as DEC, Xerox, and MIT, have their own\nClass A addresses, and many individual Class C addresses in the range 192/8 still\nappear in the routing tables (these Class C addresses are sometimes derisively referred\nto by the network operators as the swamp).\nThe identity of the ASs at the Internet's core has changed over the years. Originally\nthe ARPANET network [146], [147] was at the Internet's core. Then, in 1985, the\nNational Science Foundation funded a new Internet core, called the NSFNET. The\nNSFNET began as a collection of LSI-11-based routers, affectionately called Fuzzballs,\ninterconnected by 56Kb leased lines [161]. In 1987, the NSFNET was upgraded to\nIBM RT-based routers interconnected with Tl lines, and in 1992, the line speed was up-\ngraded to T3. The NSFNET was decommissioned in 1995 [93]. Today the Internet's core\nconsists of around half a dozen commercial Internet providers, including UUNET, MCI,\nand Sprint.",
        "ecc8e331-0557-4427-8c4c-b2690b3d2547": "34 Internet Routing Protocols Chapter 2\nIn a variety of facilities around the world, an ISP can place a router and peer with\nother ISPs. These facilities are commonly given names such as Network Access Points\n(NAPs), Metropolitan Area Ethernets (MAEs), or Commercial Internet Exchanges (CIXs).\nPhysically these exchanges are usually implemented as bridged FDDI/Ethernet combi-\nnations or as ATM subnets. Dozens of providers may connect at a single exchange point.\nThe ISPs connecting to the exchange, and those they are peering with, is often public\nknowledge. See, for example, [148] for the ISPs connected to MAE East. Some exchanges\nalso supply a specially instrumented router to ease the distribution of routing informa-\ntion between connected providers. These routers are called Route Servers, and were\ndeveloped by the NSF-funded Routing Arbiter project [223]. Instead of each provider\nestablishing a routing protocol session with every other, a provider instead establishes a\nsingle session with the Route Server. The Route Server then redistributes the informa-\ntion learned to the other providers at the exchange.\nTwo providers may also peer directly over a private connection, such as a high-\nspeed leased line or an ATM circuit. This kind of private peering is becoming common\nbetween the top-level ISPs making up the Internet core.\nAs originally designed, routers within an AS exchanged routing information via a\ncommon routing protocol (called an Interior Gateway Protocol, or IGP), whereas a differ-\nent routing protocol (called an Exterior Gateway Protocol, or BGP) was used to exchange\nrouting information between ASs. The single-IGP rule was soon broken, however,\nwith many ASs running multiple IGPs concurrently\u2014for example, both RIP (see\nSection 13.1) and OSPF. A collection of routers running a common IGP is often called\na routing domain; in this case, an AS may consist of multiple routing domains.\nThe first EGP was also called the Exterior Gateway Protocol [162]. It did a poor job\nof loop detection and so forced a strict hierarchy of ASs. EGP was eventually replaced\nby the Border Gateway Protocol, or BGP (see Section 13.3), which is the EGP in use in the\nInternet today. With BGP, ASs no longer need to be organized in a strict hierarchy. BGP\nis run between providers or between providers and the Route Servers at the various\nInternet exchanges. A peering agreement almost always includes a commitment to\nexchange some amount of BGP routing information. To facilitate configuration and\nmanagement of the BGP protocol exchanges, each AS is assigned a unique 16-bit AS\nnumber. For example, BBN Planet has been assigned AS 1, UUNET AS 284, and Sprint\nAS 1239.\nYou might ask why there is a distinction between IGPs and EGPs. Some people\nthink that the EGP/IGP split is simply a historical accident. However, I believe that the\nrequirements for an IGP differ from those for an EGP, which drives different protocol\ndesigns. In an IGP, one wants a protocol that can calculate efficient routes and that recal-\nculates quickly when the network changes. In an EGP, one is more interested in the abil-\nity to express particular routing policies and to aggregate routing information. As we\nshall see in the next section, these differing requirements often lead to using link-state\nrouting technology in the IGP, whereas EGPs are invariably based on Distance Vector\nrouting technology.",
        "26c9bb27-e420-4c01-955b-91b1acd0a8d3": "Section 2.3 Distance Vector Algorithms 35\n2.3 Distance Vector Algorithms\nIn a Distance Vector protocol, the routers cooperate in performing a distributed computa-\ntion. Distance Vector algorithms calculate the best path to each destination prefix sepa-\nrately, usually trying to find paths that minimize a simple metric, such as the number\nof router hops to the destination. At each intermediate step in the algorithm, each\nrouter has its current best path to the destination prefix. The router then notifies all of\nits neighbors of its current path; concurrently the router's neighbors are also notifying\nthe router of their path choices. The router, seeing the paths being used by all of its\nneighbors, may find a better (that is, lower-cost) path through one of its neighbors. If so,\nthe router updates its next hop and cost for the destination and notifies its neighbors of\nits new choice of route, and the procedure iterates. After some number of iterations,\nthe choice of route will stabilize, with each router having found the best path to the\ndestination.\nThe main advantage of Distance Vector algorithms is their simplicity. These algo-\nrithms are also amenable to route aggregation, and relatively simple routing policies\n(for example, the router should route certain prefixes through a given neighbor but not\nothers) are easy to implement.\nThe canonical example of a Distance Vector protocol is the Internet's Routing Infor-\nmation Protocol (RIP). Using RIP and the network in Figure 2.5 as a concrete example,\nwe'll examine a Distance Vector algorithm's distributed computation in a little more\ndetail.\nDistance Vector Convergence\nRIP routers augment each destination's routing table entry (see Section 2.1) with a met-\nric field. This metric indicates the minimum number of router hops required to reach the\ndestination; the prefixes for directly attached network segments always have their met-\nric set to 1. Every 30 seconds, each RIP router broadcasts RIP updates to its neighboring\nRIP routers; these updates list the prefixes in the router's routing table, together with\ntheir current metrics. When a RIP router receives a RIP update from its neighbor X, the\nrouter examines all the prefixes within the update. If the number of hops to reach a\ngiven prefix through X (obtained by adding 1 to the metric advertised by X for the pre-\nfix) is better than the metric the router has for the prefix, the router updates its routing\ntable. The updated routing table entry has its next hop set to X and its metric set to one\nmore than the metric advertised by X.\nThe example shown in Table 2.2 assumes that at time Tl the interface on router I to\n192.1.4/24 in Figure 2.5 has just become operational and that at times T1-T4, each of the\nrouters A-I sends routing updates simultaneously to its neighbors. The column under A\nshows the routing table entry for 192.1.4/24 in router A as time progresses. After time\nT4, the routing table entries remain stable, and RIP has converged.",
        "2a17ef30-76be-46f9-a036-76ace23d8a90": "36 Internet Routing Protocols Chapter 2\n192.3.7/24 192.2.2/24\n192.2.4/24 192.1.3/24\n192.5.6/24 192.1.4/24\nFigure 2.5 Sample network topology to illustrate Distance Vector protocol behavior.\nTable 2.2 RIP Convergence When Subnet 192.1.4/24 Is Added to Figure 2.5.\n(Routing table changes appear in bold, with each metric printed as a cost, next-hop pair.)\nTime\nTl\nT2\nT3\nT4ABC\noo oo oo\noo oo oo\n3,G\n4,C 4,C 3,GD\noo\nOO\n3,G\n3,GE F G\n00\n2,1\n3,H 2,1\n4,D 3,H 2,1H\nOO\n2,1\n2,1\n2,1I\n1\n1\n1\n1\nDistance Vector protocols get their name from the form their routing updates\ntake: a list (or vector) of metrics (or distances), one for each advertised prefix. If you look\nat the distributed calculation that a Distance Vector algorithm is performing over the\nnetwork as a whole, as illustrated in Table 2.2, you see that it is a distributed application\nof the Bellman-Ford algorithm for finding shortest paths [18]. For this reason, Distance\nVector algorithms are also sometimes called Bellman-Ford algorithms (although this is\nsomewhat confusing, since link-state algorithms can also use the Bellman-Ford algo-\nrithm to perform their routing calculations; see [86]).",
        "9bd8f278-a0d3-4f45-bab5-cf69a5351ec2": "Section 2.3 Distance Vector Algorithms 37\nTable 2.2 shows what happens when a new, shorter path to a destination prefix\nis discovered. However, sometimes the current shortest path is no longer available,\nbecause of link or router failures, and routing must revert to a longer path. A router dis-\ncovers this failure in two ways. Sometimes the router's current best hop will merely\nsend an update saying that the best path just got longer. Other times, the lack of updates\nreceived from the current next hop tells the router that the next hop is probably no\nlonger operational, and so the router selects a new next-hop router advertising an equal\nor longer path. A Distance Vector protocol's convergence behavior in these failure con-\nditions is a little more interesting, and we talk about this in the next section.\nCounting to Infinity\nA Distance Vector protocol's distributed calculation is quite robust, converging after\nnetwork changes even if the updates from the various routers are not synchronized (in\nfact, synchronization of updates can cause problems; see [78]) or if the routers use vary-\ning update intervals [20], [241]. However, Distance Vector protocols can take a long time\nto converge in the face of certain network failures. Suppose, for example, that the inter-\nface from router I to 192.1.4/24 in Figure 2.5 becomes inoperational. Table 2.3 shows the\nbehavior of RIP, again making the artificial assumption that each of the routers A-I\nsends updates synchronously at the time intervals T1-T15.\nTable 2.3 Distance Vector Convergence When Subnet 192.1.4/24 Is Deleted from Figure 2.5.\n(Routing table changes are printed in bold, with each metric printed as a cost, next-hop pair.)\nAs you can see, it takes quite a while before the routers decide that the prefix\n192.1.4/24 is unreachable. During this time, forwarding loops may very well form; in\nour example, there is a forwarding loop between routers G and H from time T2 until\ntime T14. Notice that in any given router, the cost of prefix 192.1.4/24 continuallyTime\nTl\nT2\nT3\nT4\nT5\nT6A\n4,C\n4,C\n4,C\n5,C\n6,C\n7,CB\n4,C\n4,C\n4,C\n5,C\n6,C\n7,Cc\n3,G\n3,G\n4,G\n5,G\n6,G\n7,GD\n3,G\n3,G\n4,G\n5,G\n6,G\n7,GE\n4,D\n4,D\n4,D\n5,D\n6,D\n7,DF\n3,H\n3,H\n4,H\n5,H\n6,H\n7,HG\n2,1\n3,H\n4,H\n5,H\n6,H\n7,HH\n2,1\n3,G\n4,G\n5,G\n6,G\n7,GI\noo\n3,G\n4,G\n5,G\n6,G\n7,G\n...T7-T13...\nT14\nT1515,C\n<\u00bb15,C\n0015,G\nOO15,G\noo15,D\n0015,H\nOO15,H\n0015,G\n0015,G\n00",
        "b987f623-fe8f-4734-ac85-a5887ade048c": "38 Internet Routing Protocols Chapter 2\nincreases until it reaches the RIP infinity of 16. This behavior is called counting to infinity\nand is the reason that the maximum path cost is generally set to a small value in Dis-\ntance Vector protocols: The larger the maximum path cost, the longer counting to infin-\nity can last, consuming network and router CPU bandwidth in the process. Distance\nVector protocols, such as RIP, exhibit similar properties when a network failure simply\nlengthens the path to a destination. The general convergence behavior in this case can\nbe characterized as follows: On the way to its new metric value, the router's routing\ntable entry assumes the lengths of all possible paths (to the destination) existing in the\nrouting domain before the failure [120].\nImproving Convergence\nIn order to improve Distance Vector protocol convergence, many modifications to Dis-\ntance Vector protocols have been implemented at one time or another.\n\u2022 In order to reduce convergence time, many routers running Distance Vector\nprotocols send updates immediately when their routing tables change instead\nof waiting for the next 30-second interval. These updates are called triggered\nupdates.\n\u2022 To help prevent forwarding loops during convergence, Distance Vector proto-\ncols usually employ a procedure called split horizon. In split horizon, when a\nrouter sends a routing update out its interface X, the router omits all routes from\nthe update whose outgoing interface is equal to X. For example, at time Tl in\nTable 2.3, router G would not be broadcasting an update for 192.1.4/24 to rout-\ners H and I. In a modification to split horizon, called infinite split horizon, or split\nhorizon with poison reverse, updates sent out interface X advertise routes with\noutgoing interface X as being unreachable (that is, with a cost of 16). Infinite\nsplit horizon is more effective than split horizon in reducing forwarding loops,\nin fact completely doing away with loops consisting of only two routers. How-\never, since infinite split horizon makes updates larger, split horizon is more\ncommon.\n\u2022 In another modification, called hold down, a router refuses to accept updates\nfor a route for some period of time after the route has initially been declared\nunreachable. For example, if router I in Table 2.3 had been performing hold\ndown, it would refuse to accept routing updates from its neighbors for several\ntime periods after time Tl. Hold down can inhibit the forming of forwarding\nloops in certain situations, although it lengthens convergence time in others.\nFor that reason, it is not often employed by protocols such as RIP but is still\nused in other Distance Vector protocols, such as IGRP (see Section 13.4) and\nDVMRP (Section 14.2).",
        "1ce4bd60-c58e-4d40-9455-dbfdc9c6e829": "Section 2.4 Link-State Algorithms 39\nThese modifications can improve a Distance Vector protocol's convergence proper-\nties but cannot completely eliminate the formation of routing loops during convergence\nor the counting-to-infinity behavior. There are two known ways to solve these problems\nin a Distance Vector protocol. The first method, employed by the Internet's BGP, is to\nadvertise the complete path (that is, sequence of routers) to each destination prefix\nrather than just the prefix's metric (see Section 13.3). The second method, described in\nvarious papers ([82], [119], [157]) and implemented by EIGRP (Section 13.4), is to strictly\ncontrol the order of routing updates between nodes. These latter methods can guarantee\nloop-free routing but generally complicate the protocol significantly and can in fact\nincrease convergence time.\n2.4 Link-State Algorithms\nInstead of the incremental, distributed calculation used by a Distance Vector algorithm,\nlink-state routing algorithms employ a replicated distributed database approach. Each router\nin a link-state algorithm contributes pieces to this database by describing the router's\nlocal environment: the set of active links to local IP network segments and neighboring\nrouters, with each link assigned a cost. This is where link-state algorithms get their\nname: Instead of advertising a list of distances to each known destination, a router run-\nning a link-state algorithm advertises the states of its local network links. These link-\nstate advertisements are then distributed to all other routers. The end result is that all\nrouters obtain the same database of collected advertisements, together describing the\ncurrent map of the network. The cost of a path in the network is assigned as the sum of\nthe costs of the links comprising the path. From the network map, each router then runs\na shortest-path calculation, typically the Dijkstra algorithm, although other algorithms,\nsuch as Bellman-Ford, are also sometimes used, producing the shortest path to each des-\ntination prefix.\nPart II of this book is dedicated to the detailed description of a particular link-state\nrouting protocol: OSPF. We defer explanation of many link-state mechanisms until then.\nLink-state algorithms were originally designed to get around performance problems in\nDistance Vector protocols [146]; however, arguments about the relative merits of Dis-\ntance Vector and link-state protocols persist (see Section 3.2). Link-state algorithms are\ngenerally considered to have good convergence properties: When the network changes,\nnew routes are found quickly and with a minimum of routing protocol overhead. Since\nlink-state database protocols have more data at their disposal (namely, a complete\ndescription of the network) than do Distance Vector protocols, they can easily calculate\npaths with more sophisticated characteristics than simply paths with least cost. For\nexample, link-state protocols have been designed for the Internet to calculate separate\npaths for each IP Type of Service (see Section 7.1), calculate paths obeying a wide range\nof policy constraints (IDPR, in Section 13.6), or calculate paths that can deliver certain\nquality-of-service guarantees [86].",
        "5347c18d-096e-4b67-956b-237974fe5030": "40 Internet Routing Protocols Chapter 2\nLink-state routing protocols are definitely more complicated to specify than are\nDistance Vector protocols, as you can tell by comparing the size of the OSPF and RIP\nspecifications. However, once you modify a Distance Vector algorithm to obtain some of\nthe standard link-state properties (resistance to routing loops, transmit only routing\nchanges instead of frequent refresh of routing data), you end up with a protocol that is\njust as difficult to implement as a link-state protocol. For example, writing good OSPF\nand BGP implementations are roughly equivalent tasks.\nThe EGP/IGP split allows the Internet to get the best features of both routing proto-\ncol technologies. For example, using OSPF as the IGP enables fast local convergence,\nwhereas BGP between ASs facilitates route aggregation and policy-based routing. Of\ncourse, these two technologies can also be mixed within a single protocol\u2014the two-level\nhierarchy within OSPF, a link-state protocol, uses Distance Vector mechanisms (see\nChapter 6, Hierarchical Routing in OSPF).\nFurther Reading\nPart II of this book covers the OSPF protocol in detail. Chapter 13, Unicast Routing Pro-\ntocols, compares and contrasts the unicast routing protocols in use in the Internet today:\nRIP, OSPF, BGP, IGRP, and Integrated IS-IS.\nRouting in the Internet by Huitema [104] does a good job of explaining the motiva-\ntion and theory behind the Internet's routing protocols.",
        "6931094d-3451-4b08-8324-e63e852e4a75": "Part II\nThe OSPF Protocol\nIn Part II, we discuss the OSPF protocol. We start in Chapter 3, Developing the OSPF\nProtocol, by discussing why OSPF was developed in the first place and the original\nrequirements and design decisions. We also discuss how OSPF has evolved, first as the\nresult of interoperability testing and Internet deployments and then in reaction to evolu-\ntion of the Internet itself.\nChapter 4, OSPF Basics, discusses the basic protocol mechanisms of OSPF. Link-\nstate routing was originally designed for networks whose packet-switching computers\nwere interconnected by point-to-point links, and so we restrict ourselves to those topol-\nogies. At the core of a link-state protocol is the link-state database, and in Chapter 4, we\ndiscuss the contents of individual pieces of the database, how the database is distrib-\nuted and synchronized between routers, and the routing calculations that produce a\nrouting table from the link-state database.\nIn Chapter 5, OSPF Network Types, we discuss how OSPF runs differently over seg-\nments other than point-to-point links. OSPF contains special support for broadcast seg-\nments, such as Ethernets, and for nonbroadcast yet multiaccess network segments, such\nas Frame Relay and ATM subnets. We discuss how OSPF performs neighbor discovery\nand database synchronization over these segment types and how these segments are\nrepresented within the link-state database. OSPF can run in two distinct modes over\nnonbroadcast subnets: Point-to-MultiPoint and NBMA. We compare and contrast these\ntwo modes of operation.\nThe implementation of hierarchical routing using OSPF is the subject of Chapter 6,\nHierarchical Routing in OSPF. We describe how an OSPF routing domain can be split\n41",
        "b503ed5a-cac0-48cc-8059-33d228c7e259": "42 The OSPF Protocol Part II\ninto areas and discuss the rules covering area organization, including when and where\nvirtual links must be deployed. We then describe how routing information learned from\nother protocols, called external routes, can be advertised by OSPF. The chapter ends\nwith a discussion of the interaction between external routes and areas. This includes a\ndescription of the two area types, stub areas and NSSAs, that can be used to control the\nspread of external routing information.\nOSPF has been extended in various ways over the years. These optional extensions\nare described in Chapter 7, OSPF Extensions. Stub areas and NSSAs are described in\nmore detail. The Demand Circuit extensions are a way of running OSPF efficiently over\ndial-up and low-speed links. The Database Overflow extensions enable a router to\ngracefully degrade when the size of the link-state database exceeds the router's capaci-\nties. The proposed external-attributes-LSA would enable OSPF to be used to propagate\nBGP path information across an OSPF routing domain, as an alternative to IBGP. We\nalso describe an extension that has recently been removed from the OSPF specification:\nthe ability to route packets differently, based on their specified TOS. A discussion of\nMOSPF, an extension enabling the forwarding of multicast datagrams, is deferred until\nChapter 10, MOSPF.\nPart II ends with Chapter 8, An OSPF FAQ. This chapter provides a list of frequently\nasked questions about OSPF and their answers.",
        "c3a05cc5-dd76-4e94-ac4b-283522045418": "3\nDeveloping the OSPF Protocol\nThe development of the OSPF routing protocol began in 1987. OSPF was one of the first\nprotocols to be developed completely within the Internet Engineering Task Force (IETF).\nA decade later, the lETF's OSPF Working Group still exists, and the OSPF protocol con-\ntinues to be extended, although the basic OSPF protocol was established with the first\npublication of the OSPF Version 2 (OSPFv2) specification in 1991.\nTracing OSPF development allows us to introduce the features of OSPF\u2014not just\nwhat they are but also why they were considered important. Like the Internet, OSPF has\nevolved over time. Some current features of OSPF, such as the Point-to-MultiPoint inter-\nface, were never envisioned in the original OSPF design. Other features, such as TOS-\nbased routing, were included in the design but never deployed. A timeline showing the\nmajor milestones in the development of OSPF is shown in Figure 3.1.\nIn this chapter, we describe the features of OSPF and the basic design decisions that\nformed the OSPF protocol. We begin with the first meeting of the OSPF Working Group,\nat the November 1987 IETF meeting in Boulder, Colorado.\n3.1 Functional Requirements\nTo understand the initial goals of the OSPF Working Group, you need to consider what\nthe Internet of 1987 looked like. It was largely an academic and research network,\nfunded by the U.S. government. At the core of the Internet, the ARPANET had been\nreplaced by the NSFNET backbone and its regional networks. Much of the Internet used\n43",
        "994f1f2a-f9bd-424f-8ab3-6dad1667b2ad": "44 Developing the OSPF Protocol Chapter 3\nFigure 3.1 Timeline of OSPF development.\nstatic routing; those Autonomous Systems employing dynamic routing used the\nRouting Information Protocol (RIP), while the Exterior Gateway Protocol (EGP) was\nused between Autonomous Systems.\nBoth of these protocols were having problems. As the size of Autonomous Systems\ngrew and as the size of the Internet routing tables increased, the amount of network\nbandwidth consumed by RIP updates was increasing, and route-convergence times\nwere becoming unacceptable as the number of routing changes also increased. BGP's\nupdate sizes were also increasing, and the topological restrictions imposed by EGP\n(which technically required a tree topology, coining the term \"reachability protocol\"\ninstead of a routing protocol) were rapidly becoming unmanageable.\nWe decided to tackle the problem of producing a RIP replacement. The reasons\nfor trying to solve the RIP problem instead of the EGP problem were twofold. First, the\nRIP problem seemed easier\u2014being of local-scale scope\u2014than a protocol that has to run\nover the entire Internet as EGP did. Second, a RIP replacement would have wider appli-\ncability, being of use both in the Internet and in commercial TCP/IP networks (what",
        "df467158-7a5d-4a8d-ad42-d2f783bc48f9": "Section 3.1 Functional Requirements 45\npeople today call intranets). Tackling the EGP problem was left to the designers of BGP\n[208].\nThus the major requirement was to produce an intra-AS routing protocol (also\ncalled an Interior Gateway Protocol, or IGP) that was more efficient than RIP. We\nwanted a protocol that both consumed fewer network resources than RIP and con-\nverged faster than RIP when the network changed. Examples of network changes are\nwhen communication links, router interfaces, or entire routers fail. After the failure, the\nbest paths to certain destinations change. It takes some time for any routing protocol to\nfind the new best paths, and the paths used in the meantime are sometimes suboptimal\nor even nonfunctional. The process of finding the new path is called convergence.\nOther initial functional requirements for the OSPF protocol included the following.\n\u2022 A more descriptive routing metric. RIP uses hop count as its routing metric, and\npath cost is allowed to range from 1 to 15 only. This created two problems for\nnetwork administrators. First, it limited the diameters of their networks to 15\nrouter hops. Second, administrators could not take into account such factors as\nbandwidth and/or delay when configuring their routing systems. For OSPF, we\nsettled on a configurable link metric whose value ranges between 1 and 65,535,\nwith no limitation on total-path cost. This design decision removes network-\ndiameter limitations and allows for configurations such as that in Figure 3.2,\nwhere a two-hop terrestrial path (OSPF cost of 200) can be preferred over a\ndirect satellite connection (OSPF cost of 1,000). See Section 4.8 for more details\non OSPF's routing metric.\nFigure 3.2 Configuring metrics to avoid links with high delay.\nEqual-cost multipath. We wanted OSPF to be able to discover multiple best paths\nto a given destination, when they exist. However, we did not mandate how\nrouters should use these multiple best paths for forwarding data packets. It\ndid not seem necessary to standardize the choice of which of the multiple\npaths to use for a given packet. There are many strategies: round-robin on a",
        "3fbb2af9-9a9d-4932-bed2-32b3d3028dd5": "46 Developing the OSPF Protocol Chapter 3\npacket-by-packet basis, a hash on the source address, and so on. However,\nrouters with different strategies can be mixed together freely, and a working\nnetwork will still result.\nRouting hierarchy. We wanted to be able to build very large routing domains, on\nthe order of many thousands of routers. The only known way to scale routing to\nsuch a size is by introducing hierarchy. The OSPF hierarchy was implemented\nvia a two-level area routing scheme, as described in Section 6.1.\nSeparate internal and external routes. Autonomous Systems running RIP were\nhaving trouble knowing which information to trust. You always want to trust\ninformation gained first hand about your own internal routing domain over\nexternal routing information that has been injected into your domain. RIP did\nnot distinguish between the two types of information. In OSPF, external routing\ninformation is labeled and is explicitly overridden by any internal routing infor-\nmation; see Section 6.2.\nSupport of more flexible subnetting schemes. When OSPF was first being designed,\nthe Internet was still using Class A, B, and C addresses. IP subnetting did exist,\nbut subnets were always allocated by dividing a given Class A, B, and C\naddress into equal-sized pieces [166]. However, we felt that people were going\nto want to make more efficient use of the address space, so we made it a require-\nment that OSPF be able to route to arbitrary [address, mask] combinations. In\nparticular, we wanted to be able to accommodate so-called variable-length sub-\nnet masks (VLSMs), whereby a Class A, B, or C address could be carved into\nunequal-sized subnets.\nThis requirement pretty much anticipated classless Internet routing (CIDR).\nHowever, it would have to be adjusted slightly to accommodate CIDR com-\npletely (see Section 3.7).\nSecurity. We wanted to be able to administratively control which routers joined\nan OSPF domain. A common problem with RIP is that anyone can bring up a\nbogus RIP router advertising the default route (or any other route, for that mat-\nter), disrupting routing. By authenticating received OSPF packets, a router\nwould have to be given the correct key before it could join the OSPF routing\ndomain.\nThis requirement led us to reserve space in OSPF packets for authentication\ndata. But the development of nontrivial authentication algorithms for OSPF\nwould have to wait for several years (see Section 3.7).\nType of Service routing. We wanted to be able to calculate separate routes for IP\nType of Service (TOS). TCP/IP supports five classes of TOS: normal service, mini-\nmize monetary cost, maximize reliability, maximize throughput, and minimize delay.\nThe idea behind TOS is that IP packets can be labeled with a particular TOS,\nwhich would then influence the handling of the packets, including possibly the",
        "0ad6e2b7-64d8-4791-9484-94aa7669a3e9": "Section 3.2 Design Decisions 47\nroute that the packet would take through the Internet (called TOS-based\nrouting).\nOSPF supported TOS-based routing from the beginning, allowing the\nassignment of separate link metrics and building separate routing tables for\neach TOS. For example, in Figure 3.2, a second metric can be assigned for the\nmaximize-bandwidth TOS, allowing the satellite link to be preferred for file-\ntransfer traffic at the same time that the link is avoided by all other traffic types.\nTOS support was made optional, giving rise to many arguments about what\nshould happen to a packet designated with, for example, minimize monetary\ncost when a path minimizing monetary cost does not exist but a normal service\npath does: Should the packet be discarded, or should it be forwarded along the\nnormal service path instead?\nAll these design efforts and arguments were really for naught. Although\nseveral implementations of OSPF TOS-based routing were developed, TOS-\nbased routing has never been deployed in the Internet. This is probably for lack\nof a real need for TOS and also because of a chicken-and-egg problem: The hosts\ndo not label packets with TOS because the routers do not act on TOS, and the\nrouters do not act on TOS because the packets are not labeled.\n3.2 Design Decisions\nAfter establishing the requirements for the new protocol, the design could begin. This\nsection describes some of the major design decisions made during initial development\nof OSPF. Some of the decisions were controversial; others were not.\nOne noncontroversial design decision was the formatting of the OSPF packet. As is\ndone for most TCP/IP protocols, we wanted OSPF packets to be aligned so that they\ncould be processed easily within common computer architectures: 4-byte fields starting\nat offsets of a multiple of 4 bytes, 2-byte fields starting at even offsets, and so on. Nicely\naligned packets also allow protocol implementors in languages such as C to use data\nstructures as \"packet templates,\" simplifying the implementation of packet reception\nand transmission.\nThe most major design decision, and also the most controversial one, was choosing\nthe underlying routing protocol technology. At the time, there were two major technolo-\ngies, which are the same two choices one would have if designing a routing protocol\ntoday: link-state and Distance Vector.\nLink-State versus Distance Vector\nDistance Vector protocols were in common use in the Internet, with RIP being the major\nexample. Distance Vector protocols employ a distributed-processing model. Each router\nparticipating in a Distance Vector algorithm performs a routing calculation based on the",
        "c60668c4-89b6-4394-84e3-294b970f1461": "48 Developing the OSPF Protocol Chapter 3\ncurrent information received from the router's neighbors. The router then sends the\nintermediate results of this calculation (which is typically the router's current routing\ntable) to all of its neighbors, causing them to redo their calculations based on this\nupdated information. The neighbors in turn send their updated routing tables to their\nneighbors, and so on. This process then iterates until all routers converge on the best\npaths to the destination networks. (For a more detailed description of the Distance\nVector algorithm, see Section 2.3.)\nLink-state protocols (also called shortest-path first, or SPF, protocols because they\ncommonly use Dijkstra's Shortest Path First algorithm in their routing calculations)\nemploy a distributed database model. Each router running a link-state algorithm describes\nits local environment in link-state advertisements, or LSAs. Local environment includes\nthe router's operational interfaces, the cost to send user data traffic out the interface,\nand to what the interface connects. These LSAs are distributed to all other routers by\na procedure called flooding. All routers end up with the same set of LSAs, called the\nlink-state database. From this database, the routers calculate their routing tables, using\nshortest-paths algorithms, such as Dijkstra's algorithm. (For a more detailed descrip-\ntion of link-state algorithms, see Chapter 4, OSPF Basics.)\nAs mentioned earlier, RIP was having trouble in some of the Internet's larger\nAutonomous Systems. RIP was taking a long time to converge and was consuming con-\nsiderable network bandwidth in the process. In addition, RIP is slow to flush unreach-\nable destinations from the network, going through a procedure called counting to\ninfinity (see Section 2.3). Indeed, as shown in [20] and [120], when a network change\ncauses the best path to a destination to lengthen, the routing table entry for the des-\ntination in a Distance Vector algorithm will, under some circumstances, take all inter-\nmediate values between the old and new costs before finally converging to the new\nvalue.\nBBN saw similar behavior in the original ARPANET routing algorithm, which\nwas based on Distance Vector. That algorithm's deficiencies included slow response\nto topological changes, large update packets that interfered with data traffic, and a\ntendency to form loops that would persist for seconds at a time [147]. In response to\nthese problems, BBN had developed the first link-state routing algorithm, which had\nperformed well in replacement of the original ARPANET routing algorithm ([146],\n[147], and [220]).\nAfter observing BBN's success in the first link-state algorithm, we decided to\ndevelop a link-state routing algorithm for TCP/IP. There was considerable dissent on\nthis issue, however. Link-state routing protocols are more complicated to specify and\nimplement than are Distance Vector protocols. And although link-state routing looked\npromising to many people, a multivendor link-state routing protocol had never been\ndeveloped\u2014and some people believed that it could not be done.\nIn fact, there was enough dissent that we were forced to change the name of the\nworking group from its original Open Interior Gateway Protocol (OIGP) Working\nGroup to the Open Shortest Path First Interior Gateway Protocol (OSPFIGP, later",
        "596861a6-b8ce-492f-aa86-8d2353246142": "Section 3.2 Design Decisions 49\nmercifully shortened to OSPF) Working Group, and a short-lived Open Distance\nVector Working Group was formed in direct competition.\nIn retrospect, the industry trend has been toward link-state routing algorithms.\nBesides OSPF for TCP/IP, link-state routing protocols have been developed for all other\nmajor protocol suites: IS-IS for OSI, NetWare Link Services Protocol (NLSP) for Novell\nNetware, Advanced Peer-to-Peer Networking (APPN) for IBM's SNA, and Private\nNetwork-to-Network Interface (PNNI) for ATM. However, the debate about link state\nversus Distance Vector does continue in a more muted form. Research continues in\nremoving the deficiencies of Distance Vector algorithms [82], with some of these\nimprovements being fielded in an enhancement to Cisco's proprietary Distance Vector\nalgorithm IGRP [96]. RIP, the quintessential Distance Vector algorithm, has been\nextended to carry CIDR routes [149] and remains widely used in the Internet. The\nInternet's BGP [208] is also Distance Vector based.\nLink-State Basis\nHaving chosen to create a link-state TCP/IP routing protocol, we found quite a bit\nof existing technology to draw on. BBN had pioneered link-state routing, having de-\nployed the first link-state routing protocol in May 1979 in the ARPANET network. The\nARPANET was both a simple and challenging environment for a routing protocol.\nThe ARPANET was a packet-switching network that provided services at level two of\nthe OSI reference model, similar to an X.25 Public Data Network (PDN). The ARPANET\nenvironment was simple because of its uniformity: All switches were manufactured by\nthe same vendor, were running the same software, and were interconnected by serial\nlines with line rates between 9.6Kb and 56Kb. However, routing within the ARPANET\nwas tasked with a job that no TCP/IP routing protocol has ever taken on: Not only did\nARPANET routing route around network failures, but it also detected and routed\naround network congestion (see Chapter 8, An OSPF FAQ).\nThe ARPANET link-state protocol had established all of the basic mechanisms of a\nlink-state routing protocol: the link-state database, distribution of the database via a\nflooding algorithm, and shortest-path routing calculations. An area routing scheme had\nalso been developed for the ARPANET, although it had never been deployed [231].\nHowever, the ARPANET protocol still had room for improvement. For example, the\nbackground level of routing traffic was fairly high, since in the ARPANET algorithm,\nthe refresh rate of the link-state database was inversely proportional to the time it took\nto bring up a new serial line between switches. And in a famous network outage, a vul-\nnerability in the ARPANET flooding algorithm caused a failure of the entire network\nthat could be reversed only by power cycling all the switches concurrently (see Sec-\ntion 4.2.2). Corrective measures for these problems were proposed in a 1983 paper by\nPerlman [189].",
        "ab839713-dfe7-4a7a-bf56-4460a4f1d30f": "50 Developing the OSPF Protocol Chapter 3\nBBN also had converted the ARPANET link-state protocol to a TCP/IP routing\nprotocol [152]. However, this protocol was too inefficient over link technologies com-\nmon in the Internet, such as Ethernet, because this protocol simulated the ARPANET\nenvironment by treating a collection of routers connected to an Ethernet as if they were\npairwise-connected by serial lines.\nAt the same time that we were developing OSPF for TCP/IP, the ISO standards\norganizations were developing a link-state routing protocol called IS-IS for the OSI pro-\ntocol stack [112]. The emerging IS-IS protocol had already developed an efficient mecha-\nnism for running link-state protocols over broadcast links, such as Ethernet LANs,\nelecting a Designated Router to control flooding and to perform information reduction\nfor each LAN.\nThese were the link-state routing experiences that we could use as a basis for our\nprotocol design. At the time, some people posed the question, \"Why not simply adopt\nthe IS-IS OSI routing protocol as your new routing protocol?\" IS-IS was being devel-\noped at the same time that we were undertaking development of OSPF. Looking at the\nemerging IS-IS protocol, we saw a number of barriers to its becoming a TCP/IP routing\nprotocol. We mention a few of these problems by way of example. First, IS-IS ran\ndirectly over the link layer, which we thought was the wrong choice for a TCP/IP rout-\ning protocol, as explained next. At the time, IS-IS had no way to fragment LSAs, with a\nrouter having to originate all of its routing data within a single LSA. In some TCP/IP\nenvironments in which routers import many external routes, such a design would be\nunworkable. IS-IS had an area routing scheme, but one that did not allow any shortcuts\nbetween areas that we thought were necessary for an Internet routing protocol. Also,\nIS-IS made no attempt to align fields in their packet formats, making life more difficult\nfor protocol implementors.\nGiven these and other technical issues, we considered it simpler to design a new\nprotocol rather than to attempt to modify a protocol such as IS-IS. There were also non-\ntechnical considerations. Many people felt that it was better that the IETF have complete\ncontrol over the OSPF protocol design rather than depend on an ISO committee whose\ngoals, namely, to produce a routing protocol for the OSI protocol stack, were somewhat\ndifferent. Equally as controversial as the decision about link state versus Distance Vec-\ntor, the decision to design a brand-new routing protocol would remain a bone of conten-\ntion for years, until 1992, when OSPF was selected as the Internet's recommended IGP\n(see Section 3.6).\nEncapsulation\nWhen designing a TCP/IP routing protocol, you have three choices for encapsulation of\nyour new protocol's packets: They can run directly over the link layer, directly over the\nIP network layer, or over IP's transport protocols UDP or TCP.\nRunning directly over the link layer is problematic, for the following reasons. Most\nlink layers do not provide fragmentation and reassembly services, so your routing",
        "46b8411d-04ec-4326-a040-5e3156793d06": "Section 3.2 Design Decisions 51\nprotocol would have to implement its own fragmentation. You would also have to get\ncode points assigned for all of the various link layers that your protocol runs over, for\nexample an Ethernet type for running over Ethernet.\nRunning over IP allows your protocol to use all of IP's network-layer services. You\ncan use IP fragmentation and reassembly instead of creating your own. IP runs over\nvirtually any link type; so if your protocol runs over IP, you do not have to worry about\nallocation of code points for the various link layers. If you want to send your routing\nprotocol packets more than one hop and if you are careful, you can even use the for-\nwarding services of the IP layer (OSPF does this for its virtual links; see Section 6.1.1).\nYou have to be careful, though, that you do not enter into a chicken-and-egg situation,\nwhereby your routing protocol depends on the forwarding, which in turn depends on\nthe data supplied by your routing protocol.\nUsing UDP gives you a couple of additional benefits. It provides you with an\noptional checksum to verify integrity of your protocol packets. Each UDP protocol is\nassigned a UDP port for multiplexing over the UDP layer, and these UDP ports are\nmuch more abundant than IP protocol numbers, coming from a 16-bit rather than an\n8-bit space. Also, UDP protocols are easier to deploy on many operating systems: Often,\nsending or receiving packets directly over IP requires special privileges (for example,\nbeing \"superuser\" on a UNIX system), whereas the UDP interface is usually available to\nall users and their applications. If running over TCP, an additional benefit is running\nover a reliable byte stream (for example, BGP [208]).\nWe did not need the reliability of TCP; link-state routing protocols have their own\nreliability built into their flooding algorithms, and TCP would just get in the way. Also,\nthe ease of applications in UNIX and other operating systems to send and receive UDP\npackets was seen by some as a disadvantage; the necessity of gaining OS privileges was\nseen as providing some small amount of security. The additional small benefits of UDP\nencapsulation were outweighed by the extra 8 bytes of UDP header overhead that\nwould appear in every protocol packet. So we decided to run OSPF directly over the IP\nnetwork layer, and we received an assignment of IP protocol number 89 from the IANA\n[212].\nOne other issue involving encapsulation appeared when running over broadcast\nsubnets, such as Ethernet LANs. Existing TCP/IP routing protocols, such as RIP, trans-\nmitted routing protocol packets as IP broadcasts on these networks. However, this\nmeant that all hosts on the LAN would receive the RIP packets, even if they were\nnot running RIP (or even if they were not running the TCP/IP stack). An emerging\ntechnology\u2014IP multicast\u2014solved this problem by allowing a single IP packet to be\nsent and then received only by those hosts interested in the packet. The problem with\nIP multicast was that it was not supported in most operating systems. For example, if\nyou wanted to use IP multicast on a UNIX workstation, you would have to build your\nown UNIX kernel with the multicast additions. But multicast was clearly a better solu-\ntion than broadcast, and so we bit the bullet and requested a pair of IP multicast ad-\ndresses for use by OSPF over Ethernet and other broadcast subnets (see Section 5.2).",
        "dc4ad265-b452-4ad9-bf6f-d699d0aa77e4": "52 Developing the OSPF Protocol Chapter 3\nLSA Fragmentation\nSwitches running a link-state routing protocol advertise their routing information in\nlink-state advertisements, or LSAs. If a switch advertises all of its information in a single\nLSA, that LSA could get very large indeed. For example, an IP router may want to\nadvertise many thousands of routes about destinations elsewhere in the Internet.\nInstead of advertising a single large LSA, most link-state protocols allow the switches\nto originate multiple smaller LSAs. We call this behavior LSA fragmentation.\nIn OSPF, we could have made the LSAs quite large; since OSPF has access to the IP\nnetwork layer's fragmentation and reassembly services, OSPF LSAs could have been up\nto 65,000 bytes long. However, IP fragmentation should usually be avoided [125]. So we\ndefinitely wanted to make OSPF LSAs smaller than common link MTUs found in the\nInternet. The smallest common MTU is Ethernet's 1,500 bytes [165].\nMaking LSAs as large as possible minimizes the static size of the link-state database,\nbecause the bookkeeping portion of the LSA header is amortized over more data. How-\never, we opted to keep OSPF LSAs as small as possible, advertising each separable piece\nof routing data in a distinct LSA. Making the link-state database somewhat larger in fact\nminimizes the total amount of routing traffic; when something in the OSPF routing\ndomain changes, only the changed routing information gets reflooded.\nKeeping the data within LSAs small and of fixed format also made LSAs easy to\nbuild and parse. This was important to those of us who had spent a lot of time writing\ncode to build packets in those routing protocols, such as BGP [162], with complicated\npacket formats.\nNote that we did not make the LSA format flexible and open-ended, as is done in\nother link-state protocols. Although flexible formats allow some implementations to\nexperiment with efficient packing algorithms, they make the development of packet\nreception code and interoperability testing more difficult by increasing the number of\ntest cases. Worse, flexible formats leave the network vulnerable to bad packing algo-\nrithms in other implementations.\nCommon Mechanisms over Disparate Link Layers\nMany kinds of link-level technologies, with different properties, are in use in the\nInternet. Some connect only two routers, such as synchronous serial lines. Others may\nconnect many routers, such as a large Frame Relay public-data network. Some may\nallow packets to be broadcast or multicast, such as Ethernet. Others may not, such as an\nATM subnet. Link technologies also have different MTUs, transmission speeds, and\nerror rates. Link-state routing as originally developed for the ARPANET was designed\nfor switches interconnected via leased serial lines (called point-to-point links in OSPF).\nHowever, we wanted OSPF to work over all of the Internet's link technologies and to\nwork the same way over each link technology, or at least to minimize any link-specific\nfunctionality. A few examples follow.",
        "6a155254-9020-4f76-979a-4c08cf444dd9": "Section 3.2 Design Decisions 53\nThe first example was the flooding of LSAs over broadcast LANs. We could have\nmodeled a collection of n routers attached to a broadcast LAN asn* (n-l) / 2 point-to-\npoint connections (one for each pair of routers) and then run the point-to-point flooding\nalgorithm over each connection. Although simple, this approach costs too much in\nterms of the amount of flooding traffic that would be sent over the LAN. Instead we\nadded a level of indirection: We modeled the LAN connectivity, from the flooding algo-\nrithm's point of view, as a star network of n point-to-point connections. A special router,\ncalled the Designated Router, on the LAN is elected, and all other routers on the LAN\nneed to flood LSAs to/from the Designated Router only. Running a slight variant of the\npoint-to-point flooding algorithm over these n connections then does a nice job of mini-\nmizing flooding traffic on the LAN (see Section 5.2.2).\nAnother example is the operation of OSPF over X.25 PDNs. Except for the missing\nbroadcast/multicast capability, as far as the operation of a link-state protocol was con-\ncerned, an X.25 subnet had the same properties as an Ethernet: many routers connected\nto a common medium, each pair of which can communicate directly. We coined the term\nNBMA (nonbroadcast multiaccess) for these subnets. Operation of OSPF over NBMAs\nis almost identical to operation of OSPF over broadcast LANs: Flooding uses the\nDesignated Router, and both subnets are represented identically within the OSPF link-\nstate database by network-LSAs (see Section 5.2.3). The only real difference between\nbroadcast subnets and NBMA subnets is in the discovery of neighboring routers. On\nbroadcast networks, a router can discover its neighbors dynamically by sending multi-\ncast probes (called Hello packets in OSPF); on NBMA networks, a router's neighbors\nmay have to be configured (see Section 5.3.1).\nUnfortunately not all link technologies could be mapped directly to leased serial\nlines or Ethernets. For example, to support OSPF over dial-up telephone lines, a collec-\ntion of significantly different mechanisms had to be developed (see Section 7.3).\nBackup Designated Router\nWhen running over broadcast and NBMA segments, OSPF relies on the Designated\nRouter. All LSAs flooded over a broadcast or NBMA subnet go through the subnet's\nDesignated Router, which is responsible for reporting the subnet's local topology within\na network-LSA. This behavior, however, leads to a robustness problem. When the\nDesignated Router fails, neither LSAs nor user data can be forwarded over the subnet\nuntil after a new Designated Router is established.\nEven inadvertently replacing the current Designated Router with another causes\nsome disruption, as all routers must synchronize with the new Designated Router and a\nnew network-LSA is flooded to all OSPF routers, causing all routers to rerun their rout-\ning calculations. To make sure that a switch of Designated Router happens only on fail-\nures, we designed the Designated Router election so that routers newly added to the\nsubnet always defer to the existing Designated Router.",
        "0eb4d343-1adc-4091-ba8a-2d36186fd63d": "54 Developing the OSPF Protocol Chapter 3\nThen, to ensure that the switchover occurs as quickly as possible on failures, we\nintroduced the concept of a Backup Designated Router. The Backup Designated Router\nalso is elected and then prequalified to take over as Designated Router, all while the cur-\nrent Designated Router is operating normally. If the Designated Router fails, the Backup\nDesignated Router keeps the flooding over the subnet going, even before the Desig-\nnated Router's failure is detected (see Section 5.2.2). As soon as the failure is discovered,\nthe Backup Designated Router is promoted to Designated Router; since all other routers\non the subnet have already synchronized with the Backup Designated Router, the\nswitchover is relatively painless.\nExternal Route Tag\nWe had designed a way to import external routes into an OSPF routing domain. Exter-\nnal routes are those routes learned from other sources: routes learned from routing pro-\ntocols, such as RIP or BGP, or static information configured by network managers. Each\nexternal route is imported in its own LSA. At the urging of one of the OSPF Working\nGroup's members, Milo Medin, we also imported each route with a 32-bit tag called the\nexternal route tag. This tag is not used by the OSPF protocol itself but instead was to be\nused to convey information, transparently to OSPF, across an OSPF routing domain.\nAlthough when OSPF was initially designed, we did not know exactly what the tag\nwould be used for, it has proved to be very useful over the years.\nThe first use for the tag was to convey policy information between routers on the\nboundary of the OSPF domain. In the Internet, a single router may import thousands of\nexternal routes into an OSPF routing domain. Other routers on the boundary of the\nOSPF domain must decide, after learning of the routes, whether to readvertise them to\nother routing domains. A router usually makes this decision by scanning manually con-\nfigured lists of routing filters. The tag simplifies the configuration of routing filters by\nallowing routes to be grouped together by policy when imported into the OSPF domain.\nThen a routing policy can simply say, \"Readvertise routes with tag X,\" rather than\n\"Readvertise routes Xlr X2,..., Xn.\" The same sort of functionality is provided in BGP\nwhen using BGP communities [39].\nRules were written on how to exchange routing information between the OSPF and\nBGP routing protocols (see Section 11.6.1). Use of the external route tag allows OSPF\nrouters to import routes (namely, RIP routes, statically configured routes, or BGP-\nlearned routes with short AS paths) with enough additional information to construct\ncorrect BGP attributes at the other side of the OSPF routing domain. This ability\nremoves the necessity to also advertise such routes across the OSPF routing domain in\nIBGP. Although not yet implemented, use of the tag also allows complete replacement\nof IBGP by an alternative OSPF mechanism (see Section 7.6).",
        "dd165495-17e1-479c-8a95-72e2b0fdb101": "Section 3.2 Design Decisions 55\nHierarchical Abstraction\nIn order to be able to build large OSPF networks, we allowed an OSPF routing domain\nto be split into regions, or areas. Details of any particular area were to be hidden from\nall other areas, and addressing information would be aggregated when advertised\nacross area boundaries. Both of these functions would reduce the size of a router's\nrouting table and link-state database, thereby enabling the size of the overall rout-\ning domain to grow larger. Splitting an OSPF routing domain into areas could also be\nconsidered to be a two-level hierarchical routing scheme (see Chapter 6, Hierarchical\nRouting in OSPF).\nSeveral design decisions needed to be made about the area organization. First,\nwhat would be on the area boundary\u2014routers, network segments, or both? As dis-\ncussed in Chapter 2, Internet Routing Protocols, the Internet is split into Autonomous\nSystems, the boundaries of which are composed of network segments. For OSPF areas,\nhowever, we took the opposite tack, choosing routers as the area boundaries. This deci-\nsion meant that each network segment would belong to one and only one area, a prop-\nerty that we thought would make the aggregation of addresses across area boundaries\neasier.\nSecond, how would we describe an area to other areas? In order to achieve the scal-\ning properties we desired, we had to reduce the information associated with an area\nbefore advertising it to other areas. This information reduction is called abstraction.\nAbstraction in a link-state routing algorithm is a difficult problem. We considered\nan analog of the OSPF network-LSA, which abstracts the OSPF connectivity across\na given broadcast subnet (see Section 5.2.3); however, that kind of abstraction has a\ntendency to distort metric information. Instead we decided to simply summarize a\nlist of addresses reachable within the area. These addresses are then passed from area\nto area, just as routes are advertised from router to router within a Distance Vector\nprotocol (see Section 2.3). For other link-state routing abstraction schemes, see [9]\nand [38].\nAlthough we were using Distance Vector mechanisms between areas, we wanted to\navoid the common pitfalls of Distance Vector algorithms. So we required that all areas\nbe directly connected to a special area, called the backbone area. By forcing all of an area's\nrouting information to go through the backbone area on the way to other areas, we thus\nmandated a simple hub-and-spoke area organization that standard Distance Vector\nmechanisms could handle without problems.\nYet forcing all areas to be physically connected to a single backbone area seemed to\nbe too onerous. To get around this restriction, we enabled the logical extension of the\nbackbone area through the configuration of what we called virtual links. Virtual links\nallowed us to tunnel routing information through areas, creating a logical hub-and-\nspoke topology on any arbitrary physical area topology (see Section 6.1.2).",
        "8d995c96-1077-4e51-8210-f0886b30a10e": "56 Developing the OSPF Protocol Chapter 3\n3.3 OSPFvl: A False Start\nThe OSPF protocol specification was first published in October 1989, as RFC 1131 [174].\nLike most Internet protocols, OSPF has a version number. RFC 1131 documented ver-\nsion 1 of the OSPF protocol.\nThe lETF's motto is rough consensus and running code. Completing the OSPF design\nwas the first part of the OSPF Working Group's job; now we had to prove that the proto-\ncol worked by implementing it.\nTwo implementations of OSPFvl were written, one to run on Proteon's routers, and\nanother, written by Rob Coltun at the University of Maryland, to run on UNIX worksta-\ntions. The latter implementation was made available in source code form for a very\nnominal fee. This implementation later became quite widespread and is now available\nas part of the GATED distribution [83].\nThe implementation of a new protocol invariably uncovers problems, and OSPFvl\nwas no exception. The first problem we noticed was that OSPFvl had trouble deleting\ninformation from the routing system. Information is deleted in OSPF through the use of\nso-called MaxAge LSAs (see Section 4.7.2). However, in OSPFvl, MaxAge LSAs often\ncirculated through the routing system long after they had served their function. Besides\nbeing somewhat disconcerting, this behavior could prevent new information from being\nintroduced. Although we fixed this problem in the next version of OSPF, problems with\ndeleting MaxAge LSAs persisted in many implementations for years.\nAnother problem was more hypothetical. The original ARPANET link-state routing\nprotocol had a flaw that could cause an entire network to \"melt down\" as routing\nupdates would continue to circulate at great speeds throughout the network until the\nnetwork itself was shut down as a corrective action [221]. At the root of this problem\nwas the way in which the ARPANET protocol detected whether an LSA was being\nupdated. In all link-state algorithms, LSAs have sequence numbers: When a router\nreceives two copies of the same LSA, the copy with the \"higher\" sequence number is an\nupdate of the other copy. Just what \"higher\" means depends on how the sequence space\nis organized. In the original ARPANET algorithm, the sequence number space was\ncircular, and data corruption could confuse the determination of which LSA was the\nupdate. In OSPFvl, we had made the corrections suggested in [189] to avoid this prob-\nlem, but these corrections were not quite foolproof. To patch the last vulnerability, we\nneeded to change the LSA sequence space to a simple linear space, as described in\nSection 4.2.2.\nImplementation of OSPFvl uncovered several places where OSPF could be opti-\nmized. For example, OSPFvl specified that after a router interface became operational,\nthe router had to wait a fixed time interval before establishing OSPF neighbor relation-\nships over the interface. However, it turned out that information contained in OSPF\npackets received over the interface could make this interval much smaller. As another\nexample, OSPF requires that you exchange information about the full link-state data-\nbase with a newly discovered OSPF neighbor. OSPFvl specified that you had to send a",
        "f18ebf19-1411-4044-b70c-3b48dea821b9": "Section 3.4 Interoperability Testing 57\ndescription of your full database before requesting to receive pieces of your neighbor's\ndatabase. However, it turned out to be much more efficient for OSPF routers to mix\ndatabase descriptions and requests.\nIt also became clear that a number of points in the OSPFvl specification were not\ncompletely specified. For example, OSPFvl gave a detailed description of how to build\nan OSPF router's routing table but did not explain how a router performs a routing\ntable lookup: choosing the \"best-matching\" routing table entry for a given IP destina-\ntion. In fact, up until this point, no IP routing protocol had a completely specified rout-\ning table lookup.\nAll of these issues led us to revise the OSPFvl specification. A fix to the LSA\nsequence space could not be backward compatible; any change to the LSA sequence\nspace would lead to LSA sequence-number confusion between routers running the old\nand new versions of the specification, which is what we were trying to avoid in the first\nplace. Hence we incremented the OSPF version number, producing a specification for\nOSPFv2, which was eventually published as RFC 1247 in July 1991 [176].\nThe failure of OSPFvl and OSPFv2 to interoperate was not an issue, since OSPFvl\nwas never deployed. Since we did not have to worry about backward compatibility, we\ntook this opportunity to simplify the OSPF packet formats. It also had become clear that\nthere were some OSPF features, such as the ability of OSPF routing to take into account\nan IP packet's Type of Service label, which were not going to be implemented by every-\none. In order to make such features optional, we introduced a way for routers to\nnegotiate capabilities, by adding an Options field to OSPF packets and LSAs (see\nChapter 7, OSPF Extensions).\nGoing from OSPFvl to OSPFv2 was the last time that we could make sweeping\nchanges to OSPF. OSPFv2 would soon be deployed in the Internet, and all future\nchanges would have to be made with an eye toward keeping the installed base of OSPF\nrouters running. Although the OSPF specification has been reissued several times since\nthe publication of RFC 1247, the current specification still has the OSPF version number\nset to 2 and still interoperates with implementations of the original RFC 1247.\n3.4 Interoperability Testing\nMaking sure that multiple independent implementations of a protocol can interoperate\nis essential to the creation of a good protocol. Until interoperability is demonstrated,\none can never be sure that the protocol specification is clear and unambiguous. Often\ninteroperability testing will uncover holes in the protocol specification; unwritten\nassumptions made by protocol designers are not always apparent to implementors\nwhen they read the specification for the first time. Interoperability testing is especially\nimportant for routing protocols, which are distributed algorithms that require the con-\ncerted interaction of many routers (instead of just the interoperability of two hosts, as,\nfor example, with transport algorithms such as TCP). For this reason, interoperability of",
        "7afa8c85-c920-4893-84fb-2dc99a9898fc": "58 Developing the OSPF Protocol Chapter 3\nindependent implementations is one of the requirements for advancement of routing\nprotocols in the lETF's standard process [98].\nSix organized interoperability sessions were held during the initial development of\nthe OSPF protocol, in the years 1990 through 1994. These sessions were really more like\nthe bake-offs held periodically for various Internet protocols. One company would vol-\nunteer to host an interoperability session, and then OSPF developers from other compa-\nnies would arrive with their routers for several days of testing. The first session was\nheld at Proteon, Inc., and involved three router vendors. Then came sessions hosted\nby SURANet (an NSF regional network, since purchased by BBN Planet), 3Com, FTP\nSoftware, and Xyplex. A final session, held by the Corporation for Open Systems' lab in\nReston, Va., attracted 12 router vendors.\nThese tests were loosely organized, with a collegial atmosphere. Much of the first\nday was typically spent stringing Ethernet and serial cables. We would then agree on\nseveral network topologies and failure scenarios to try. Along the way, we would find\nbugs, usually in the implementations, although sometimes in the OSPF protocol itself.\nSometimes several developers would examine a packet trace to try to isolate a problem.\nAfter having found a bug, developers would typically change their code (some had\nbrought their complete development environments on portable PCs, whereas others tel-\nnetted back to their companies' development systems), reload their routers, and try the\ntests again. It was a common occurrence at these sessions to see developers from several\ncompanies all leaning over a competitor's shoulder, trying to fix a bug!\nTest topologies were typically small, since each router vendor could bring only a\ncouple of routers. For example, one of the network topologies used during the test-\ning session at 3Com is pictured in Figure 3.3. In this testing session and others, a live\nInternet connection (this time to BARRNet, the Bay Area NSF Regional Network, which\nhas since been purchased by BBN Planet) was used in order to import some Internet\nroutes into the testing environment.\nOSPF bake-offs are no longer scheduled today. Nonetheless, there are still places\nthat vendors can take their OSPF implementations for testing, such as University of\nNew Hampshire's Interoperability Lab [251].\nTools\nTo determine how well OSPF was working and to track down problems when they\narose, we needed some tools. To discover whether OSPF was building the correct routes,\nwe used standard Internet tools, such as traceroute and ping (see Chapter 12, Debug-\nging Routing Problems). But in order to monitor OSPF protocol performance, new tools\nhad to be created.\nFirst, we needed a way to see the OSPF packets that were being sent and received\nduring the testing. Network analyzers, such as the Network General Sniffer, were\nattached to our test network in order to perform packet collection (see Section 12.8).\nHowever, these analyzers did not know how to decode OSPF packets, and manually",
        "f5ace1c7-6725-4a29-90e8-3ef44837dfa2": "Section 3.4 Interoperability Testing 59\nEthernet Area A\nFigure 3.3 One configuration tested during the 3Com testing session in February 1991. As an additional test,\n400 external routes were imported from BARRNet.\ndecoding hexadecimal packet dumps was cumbersome. So we modified the analyzers'\nsoftware to decode OSPF packets and to be able to filter out non-OSPF packets, in order\nto make analysis of the remaining OSPF packets easier.\nMost of the job of a link-state protocol such as OSPF is to keep the database of LSAs\nsynchronized between routers. But determining whether the database was synchro-\nnized proved difficult. Having each router list its complete set of LSAs and then com-\nparing the list was very time consuming and error prone\u2014even in our small test setups,\nthe OSPF database often had hundreds of LSAs. Having each router print how many\nLSAs were in its database was useful, but just because each router had the same number\nof LSAs did not mean that the databases were synchronized. For example, one router\nmight have more up-to-date copies of particular LSAs than another router. To detect",
        "1e829879-5017-439a-ad7f-1f400c07556a": "60 Developing the OSPF Protocol Chapter 3\nthese situations, we had each router report a 32-bit checksum of its database, which\nproved a reliable indication of database synchronization.\nThe database checksum and other statistics that we found useful during testing\nwere eventually added to the OSPF Management Information Base (see Section 11.2), so\nthat the information could be extracted via SNMP.\nMost of the interoperability testing was limited to small networks. However, at\nthe 1994 COS testing, Rob Coltun modified his OSPF implementation so that a UNIX\nworkstation could both participate in the testing as an OSPF router and simulate an\nadditional number of OSPF routers. This modified implementation allowed us to test\nhow other OSPF implementations behaved in relatively large networks, by increasing\nthe OSPF area size to 240 routers and importing a number of external routes equal to the\nfull Internet routing table at that time (10,000 entries).\nProblems Found\nMost problems found during interoperability testing were implementation problems.\nDevelopers participating in interoperability tests quickly learn to bulletproof their\nimplementations. Interoperability tests produce all kinds of behavior, some of which is\ncounter to the protocol specifications. Malformed protocol packets are the most com-\nmon violation. A robust protocol implementation detects these violations and responds\ngracefully.\nHowever, quite a few errors in the OSPF specification were also found during the\ntesting. Some representative examples follow.\nThe most common problem was incomplete specification, usually in the OSPF\npacket and LSA formats. For example, in the first round of testing, there was a disagree-\nment on how to represent the default route in OSPF. Routes are represented in OSPF as\n[network, mask] pairs. However, the OSPF specification defined the default route as a\nroute with network equal to 0.0.0.0, without specifying the associated mask value. Dur-\ning testing, one implementation originated a route with network equal to 0.0.0.0 and a\nnonzero mask. Some implementations interpreted this as a default route, but others did\nnot, because they were expecting a mask of 0.0.0.0.\nTesting often produced a rapidly changing environment, with routers being contin-\nually rebooted, interfaces going up and down, addresses changing, and so on. These\nrapid changes stressed the OSPF protocol mechanisms. For example, after discovering\neach other, neighboring OSPF routers synchronize their OSPF databases by a procedure\ncalled Database Exchange (see Section 4.7.1). This procedure assumed that the sequence\nnumber in LSAs always progressed. But in a rapidly changing network, we saw that\nthis was not necessarily the case. It was possible that during Database Exchange, an LSA\ncould be deleted and then reoriginated with the initial (smallest) sequence number, giv-\ning the appearance that the LSA's sequence number was going backward! The specifica-\ntion of Database Exchange had to be modified accordingly; for more details on this",
        "54b1cd73-c451-425e-9f42-7c74dede07f0": "Section 3.5 Field Trials 61\nissue, see the FAQ entitled \"Why install MaxAge LSAs in the link-state database when\nthere are no previous instances?\" in Chapter 8.\nSelection of the network configurations to test was fairly random, with several peo-\nple drawing on the whiteboard at once. This sometimes yielded situations not antici-\npated when OSPF was designed. For example, in the fifth round of testing, a virtual-link\nconfiguration was constructed that caused the OSPF routing calculation to fail. As a\nresult, the calculation of OSPF routes when virtual links are in use was significantly\nchanged when the OSPF specification was republished in March 1994 [177].\nINTEROP Demo\nIn October 1991, we performed interoperability testing of a different type: We held an\ninteroperability demonstration at the INTEROP 91 Fall trade show. Unlike previous\nOSPF tests, the OSPF routers this time were being used in a production environment,\ncomprising INTEROP's ShowNet. The ShowNet provided TCP/IP connectivity be-\ntween the trade show booths and the Internet, providing Ethernet and/or Token Ring\ndrops to each booth. FDDI rings connected the Ethernet and Token Ring segments, and\na router running BGP was connected via a Tl connection to the Internet. A diagram of\nthe INTEROP 91 ShowNet is shown in Figure 3.4. All routers pictured ran OSPF, and\nthere were additional OSPF routers in the booths of the 11 vendors supplying OSPF\nrouters.\nIt is difficult to create a flashy demonstration of a routing protocol. When the rout-\ning protocol is working, one does not really notice that it is there at all. We did have an\nHP Openview Network Management Station, modified to display the OSPF routers'\ndatabase checksums. Looking at the display, one could tell when new OSPF information\nwas being flooded. We also had an Excelan LANalyzer network analyzer modified to\nshow the level of OSPF protocol traffic, separated by OSPF packet type (see Section 4.5).\nThe INTEROP 91 OSPF demonstration was a one-time event. Succeeding INTEROP\nShowNets ran OSPF not as a demo but as an integral part of their operational\nenvironments.\n3.5 Field Trials\nInteroperability testing is very valuable when developing a routing protocol, but there\nis no substitute for seeing how well the protocol works in a production environment.\nFor that reason, concurrent with the interoperability test sessions, we started looking for\nplaces in the Internet to deploy OSPF.\nBut first we had to start using it ourselves. The best way to get a superior product is\nto have the people who are developing the product use it on a day-to-day basis. In 1990,\nwhen I was working at Proteon, Inc., we had an in-house router network that was used",
        "f4ce4e33-65f3-411b-ba7b-dc0e5fdd5f7b": "62 Developing the OSPF Protocol Chapter 3\nFigure 3.4 Running OSPF on the INTEROP 91 ShowNet.\nto carry on the business of the company. If the network failed, you knew it instantly,\nas the workstation or PC on your desk would pretty much cease to function. This net-\nwork consisted of about 20 routers running RIP, interconnecting Ethernet and 802.5\nToken Ring LANs with a high-speed proprietary LAN technology called Pronet-80. One\nevening in 1990, after the Proteon OSPF implementation was well tested in a lab envi-\nronment, I started converting the Proteon network from RIP to OSPF. After about the\nsixth router was converted, the routers began crashing. So I turned OSPF off and tried\nagain the next night after making appropriate changes to the software. This scenario\ncontinued for several nights in a row, until the network ran smoothly. At that point, I left\nthe network running OSPF. Over time, Proteon's operational network grew to more\nthan 60 routers, and it was always an important proving ground for new releases of\nOSPF software. In time, the Proteon network also ran OSPF extensions, such as MOSPF\nand the OSPF database-overflow mechanisms.",
        "684f19ee-ff44-40b5-b1ce-6568d6033ede": "Section 3.5 Field Trials 63\nAt this point, we knew that OSPF could be run in an operational network, but we\nwere not sure that OSPF could be managed by people other than the OSPF software\ndevelopers. We began looking for other networks to run OSPF. The NSF regional net-\nworks seemed likely candidates. These networks were the largest and most demanding\nof all the TCP/IP networks that existed at the time, and it was these networks that drove\nthe design of the OSPF protocol in the first place (see Section 3.1).\nThe first network that we attempted to convert to OSPF was the NSF regional net-\nwork SURANet, in 1990. At that time, SURANet had about 60 routers, all running RIP.\nWe decided to convert the network incrementally, converting one router at a time from\nRIP to OSPF. In order to do an incremental conversion, one has to have routers running\nboth protocols simultaneously, converting RIP routes to OSPF routes and vice versa; this\ncan be dangerous if not handled correctly (see Section 11.6). In addition, two other\nrequirements were imposed on the transition. First, the routing tables in the routers\nwere to look the same regardless of whether the router was running OSPF, RIP, or both\nprotocols simultaneously (see Section 11.6.2). Second, during the transition, we had to\nmanage all routers through the in-band mechanisms of TELNET consoles and SNMP.\nWith these restrictions, conversion of SURANet was abandoned after several attempts.\nSuch a conversion today would be easy, but then it was too difficult to monitor the con-\nversion using in-band management, and the mechanisms for running OSPF and RIP\nsimultaneously had not been adequately designed, producing instead an overabun-\ndance of routing traffic.\nThe first deployment of OSPF in the Internet was in April 1990. Milo Medin and Jeff\nBurgan converted the NASA Science Internet network from RIP to OSPF, and a day later\nVince Fuller started running OSPF on the NSF regional network BARRNet [170]. In both\ncases, all routers were converted at one time. In the NASA Science Internet network, this\nwas made easier because all routers could be managed out-of-band via modem connec-\ntions to the routers' consoles.\nFeature Requests\nDeployment of a protocol often reveals places where it can be improved. The Internet\nstandards process recognizes the importance of deployment, emphasizing protocol\nimplementation and operational experience as a protocol advances up the Internet stan-\ndards ladder [98]. Deployment of OSPF led to a number of protocol modifications to\nincrease the protocol's usefulness in the Internet.\nPeople who manage Internet networks are very concerned about optimizing the\npaths that data takes across their networks. They do not like packets taking extra hops.\nAs soon as OSPF was deployed in the Internet, it was found that OSPF could produce\nextra hops at the boundary between the OSPF routing domain and another Autono-\nmous System. At the time, these boundaries were called DMZs, borrowing military\nterminology, and were typically implemented as shared Ethernets where routers\nfrom two or more ASs would connect and exchange routing information via the BGP",
        "9a57fb0f-5b88-46cc-8d7a-c8f960573ccf": "64 Developing the OSPF Protocol Chapter 3\nprotocol. (Today the boundaries are called Network Access Points or NAPs, and are\ntypically implemented as FDDI rings, ATM subnets, and so on, and BGP is used instead\nof BGP, but otherwise the same ideas apply.) An example of the extra hop is shown in\nFigure 3.5.\nFigure 3.5 Use of OSPF's forwarding address.\nThe OSPF routing domain in AS 1 has placed two routers on the DMZ Ethernet, but\nonly one of these routers, router A, is exchanging routing information with the router\nfrom AS 2, router C. Router A would then import the routes into the OSPF routing\ndomain. However, in importing these routes, router A was saying, \"Send me traffic for\ndestinations in AS 2.\" This meant that router B would send such traffic first to router A\ninstead of directly to router C. To get rid of this extra hop, we introduced the concept of\na forwarding address into OSPF. This concept allows router A to say, \"Send traffic des-\ntined for AS 2 directly to router C.\" The EGP routing protocol also had a forwarding-\naddress concept, called third-party EGP, and forwarding addresses were later added to\nthe BGP and RIP-II routing protocols.\nPeople who deployed OSPF also wanted to run OSPF on as many of their routers as\npossible so as to minimize the number of routing protocols they had to deal with.\nHowever, some of their routers had only minimal resources, especially when it came\nto available memory. So OSPF stub areas were invented\u2014regions at the edge of the\nAutonomous System whose routers would rely mainly on a default route (see Sec-\ntion 7.2). Routers within stub areas would as a result have only small routing tables but\nwould still be able to participate in OSPF routing.",
        "7191bb72-0ab9-46d6-a975-a5edb15796b7": "Section 3.5 Field Trials 65\nProduction environments often require more flexibility than anticipated by protocol\ndesigners. For example, OSPF includes an area routing scheme. At the edge of an area,\nIP addresses can be aggregated before being advertised further, allowing a reduction in\nrouting table size. Originally it was required that all such aggregations be nonoverlap-\nping. However, the following scenario was common in practice: A range of addresses\nwas assigned to one area, but then later on, some of these addresses were reassigned\nto other areas. (This is similar to what happens in today's provider-based address-\ning model when someone changes Internet providers; see Section 2.2.) You then\nwant one area to advertise the original aggregate and other areas to advertise more\nspecific parts of the aggregate. The OSPF specification was amended to allow such a\nconfiguration.\nProblems Found\nProduction environments can also often be more demanding than interoperability tests.\nThe most obvious example is network size; it is impractical to put together very large\ntestbeds, and even if you could do so, you would never replicate completely the traffic\npatterns that you would see in a real network. Thus production networks often reveal\nprotocol problems that have not been seen before. A couple of examples taken from\nexperience with OSPF in real networks follow.\nPeople tried using OSPF on very slow links. Requests to delete OSPF routing infor-\nmation, called MaxAge LSAs, could get queued on these slow links for many seconds\nduring periods of congestion. This in turn could inhibit the origination of new OSPF\ninformation, spreading congestion even further. To fix this problem, OSPF's flooding\nmechanism was altered. Not surprisingly, this flooding alteration was also required\nto operate OSPF over dial-up links (OSPF's so-called Demand Circuit extensions, as\ndescribed in Section 7.3).\nWhen OSPF was originally designed, only a few different common link technolo-\ngies were running IP: Ethernet and point-to-point serial lines running proprietary\ndata-link encapsulations. PPP and FDDI were just being developed. Later on,\ndata-link technologies that had a rather ill-defined IP MTU (maximum transmission\nunit) came into use\u2014802.5 Token Ring and Frame Relay are two examples. Over\nthese data links, it is possible that two neighboring routers will disagree on the largest\npacket that can be sent over the link, which causes problems in forwarding. As one\nrouter sends a packet that is too big for the other to receive, it becomes impossible\nto deliver large packets over certain paths. (One might think that IP fragmentation\nwould deal with this situation, but although fragmentation nicely handles links with\ndiffering MTUs, it assumes that all routers attached to a given link agree on that\nlink's MTU.) As a result, OSPF was modified to detect and avoid links having MTU\nmismatches.",
        "f59604d1-6dbc-4d76-9a61-43b03efbcda6": "66 Developing the OSPF Protocol Chapter 3\n3.6 On Becoming a Standard\nStarting in 1992, the IETF began the process of selecting a common IGP for the Internet.\nThe de facto common IGP, RIP, was no longer viewed as adequate. Two candidates for\nthe common IGP emerged: OSPF and Integrated IS-IS [30].\nBoth OSPF and the OSI routing protocol IS-IS are link-state protocols. There are, of\ncourse, technical differences between them. Integrated IS-IS was an enhancement to\nIS-IS, allowing both IP and OSI routes to be calculated by a single routing protocol. The\nOSPF developers thought that their original reasons for not choosing IS-IS as a base (see\nSection 3.2) were still valid, making OSPF a better choice. The IS-IS developers had their\nown technical reasons for preferring IS-IS. These technical issues were debated on mail-\ning lists and other technical forums ([156] and [191]).\nHowever, instead of the technical details, two other issues dominated the debate.\nFirst, the decision between OSPF and Integrated IS-IS was a continuation of the tension\nbetween the TCP/IP and OSI protocol suites, similar to the SNMP versus CMIP debates\nin previous years and the debate over the various IPv6 choices in later years. Many of\nthe OSPF supporters believed that it was important to have an Internet routing protocol\nover which the IETF had change control. On the other hand, some Integrated IS-IS sup-\nporters viewed the choice of common IGP as an opportunity for significant deployment\nof the OSI protocol suite within the Internet.\nAnother issue was over integrated routing itself. If you wanted to simultaneously\nsupport two separate protocol suites, such as TCP/IP and OSI, should you do this with\na single integrated instance of a routing protocol, or should each protocol suite have its\nown routing protocol? Supporters of integrated routing argued that it was more effi-\ncient and easier for software developers. Opponents of integrated routing, labeled\nadherents of a Ships-in-the-Night, or SIN approach, argued that only separate routing\nprotocols provided the needed flexibility for deployment of multiple protocols. The\nintegrated-routing debate, just as with the Bellman-Ford versus link-state routing\ndebate, continues today as people consider deploying IPv6 into the existing Internet.\nThe IETF\u2014whose motto is rough consensus and running code\u2014is not set up to make\nquick decisions when confronted with multiple competing protocols. In the end, the\nIETF chose OSPF as the common IGP [85], [109]. At that point, however, the choice was\nanticlimactic, since the market had already made the decision, with all the major routing\nmanufacturers opting to implement OSPF.\nAt the same time as the choice for the Internet's common IGP was being made,\ncriteria for the standardization of routing protocols were also being determined. Rout-\ning protocols typically involve the interoperation of many routers instead of simply\na pair of hosts for a transport protocol such as TCP. For this reason, more stringent\ncriteria involving testing, deployment, and multiple independently developed imple-\nmentations were required [98]. Each Internet routing protocol must document\nhow it meets these criteria; for OSPF, these documents can be found in [170], [173],\nand [175].",
        "ed197c58-4b28-4204-9c30-02d749f37c1b": "Section 3.7 The Internet Evolves 67\n3.7 The Internet Evolves\nThe basic OSPF design was completed in 1989 and 1990. However, the Internet changes\ncontinually, and Internet protocols must adapt to these changes or become obsolete. In\nthis section, we examine how changes in the Internet have led to changes in OSPF.\nCIDR\nIn 1993, it became apparent that the growth in the Internet was going to soon cause the\nrouters at the core of the Internet to run out of routing table space. To keep the Internet\nrunning, the previous procedure of chopping the Internet address into fixed-length\npieces (called Class A, B, and C addresses and their fixed-length subnets; see Sec-\ntion 1.2.2) was abandoned. Instead Internet routing would be based on address pre-\nfixes. Each routing protocol would have to advertise the size of prefixes by advertising\nthe number of significant bits or, alternatively, a mask, with each prefix. This new\naddressing method was called Classless Inter-Domain Routing (CIDR) [81].\nOlder Internet routing protocols whose packet formats were based on Class A, B,\nand C addressing were either discarded or updated. BGP and earlier versions of BGP\nwere rapidly replaced by BGP-4 [208]. RIP and IGRP were updated to become\nRIP-II and EIGRP, respectively.\nOSPF had always advertised each prefix together with its mask and did not depend\non Class A, B, and C addressing. As CIDR was deployed, however, one problem became\napparent. OSPF imported external routes (for example, routes learned from BGP) into\nthe OSPF routing domain in AS-external-LSAs. When imported by a single router, mul-\ntiple AS-external-LSAs were distinguished by their Link State ID; the Link State ID was\nsupposed to be set to the address prefix of the imported route. However, sometimes a\nrouter might want to import the same prefix with two different lengths\u2014for example,\n192.9.0.0/16 and 192.9.0.0/24\u2014and this was impossible, since both would use the\nLink State ID of 192.9.0.0. As it looked as though such situations might become\ncommonplace\u2014with, for example, an organization shifting Internet providers\nyet keeping its IP addresses\u2014the rules for setting Link State IDs in AS-external-LSAs\nhad to be modified.\nFrame Relay Subnets\nOSPF was designed to run over various types of links, including point-to-point links;\nbroadcast subnets, such as Ethernet; and nonbroadcast subnets supporting many rout-\ners (see Chapter 5, OSPF Network Types). These nonbroadcast subnets were called non-\nbroadcast multiaccess networks (NBMAs). When running over NBMAs, OSPF assumes\nthat each router attached to the NBMA can communicate directly. This assumption was\nvalid for X.25 PDNS using SVCs, the original model for an OSPF NBMA.",
        "3250ede7-36be-43e8-84b7-b22eda9f8a4f": "68 Developing the OSPF Protocol Chapter 3\nLater Frame Relay subnets implemented out of PVCs became common in the Inter-\nnet. Application of NBMAs to Frame Relay subnets met with only partial success. Often\nPVCs were not configured in a full mesh, or even if they were, individual PVCs were\nsubject to failure; either condition violated the NBMA assumption of direct communica-\ntion. Configuration guidelines were established to ameliorate these problems by config-\nuring a single Frame Relay subnet as multiple NBMAs [65]. Unfortunately such a\nconfiguration is often confusing and error prone.\nTo solve these problems running OSPF over Frame Relay, the Point-to-MultiPoint\nsubnet was eventually developed as an alternative to OSPF's NBMA support (see\nSection 5.4). Although not as efficient as OSPF's NBMA support, Point-to-MultiPoint\nsubnets can autoconfigure and are robust against PVC failures.\nMulticast\nWork began in the 1980s on extending multicast\u2014the ability to send a single packet\nand have it delivered to multiple recipients\u2014from a single LAN to Internetwide. The\nseminal work on this subject was done by Steve Deering when he was at Stanford [59],\nas he developed the receiver-oriented Internet multicast model and the Internet Group\nMembership Protocol (IGMP), which communicated multicast group membership\nbetween hosts and routers [56].\nMulticast routing protocols compute the path of a multicast datagram from its\nsender to its multiple recipients. The first Internet multicast routing protocol was the\nDistance Vector Multicast Routing Protocol (DVMRP) [202]. DVMRP is implemented for\nUNIX workstations in the mrouted program.\nIn 1992, the Multicast Backbone, or MBONE, was formed. The MBONE provides\nmulticast routing services to the Internet and is overlaid on the Internet\u2014mainly UNIX\nworkstations running DVMRP interconnected via tunnels. The MBONE broadcasts\naudio and video from IETF meetings to interested participants around the world and is\na breeding ground for multicast applications, such as interactive whiteboards [140];\nteleconferencing tools [139], [228]; video conferencing [80], [246]; and large-scale image\ndistribution [55].\nAs a Distance Vector multicast routing protocol, DVMRP suffers from the same con-\nvergence problems as RIP (see Section 3.1). In the hope of getting a more stable and effi-\ncient multicast routing protocol and in deploying multicast routing directly in the\nInternet's routers, the Multicast Extensions to OSPF (MOSPF) were developed in 1992\n(see Chapter 10, MOSPF).\nEnhanced Security\nThe first Internet security incident to achieve widespread attention was the Internet\nworm in 1988. In November of that year, Robert Morris, a graduate student at Cornell\nUniversity, wrote a computer virus that replicated itself over the Internet, infecting",
        "c17329ac-cd10-4813-b900-da1d7f32dcf8": "Section 3.7 The Internet Evolves 69\nthousands of UNIX workstations by exploiting security flaws in the UNIX operating\nsystem [87], [211].\nSecurity firewalls soon became big business as a way of protecting Internet sites\nfrom unlawful entry. People also came to believe that the Internet's infrastructure,\nincluding its routing protocols, needed to be protected. All new Internet protocol speci-\nfications are now required to have a section discussing security concerns, when the pro-\ntocol is published as an RFC [193]. Proposals were made to secure the Internet's existing\nprotocols [111].\nThe OSPF protocol had been designed with security in mind. Fields were included\nin OSPF protocol packets so that the packets could be authenticated. The idea is to vali-\ndate a set of routers by giving them a key and then to use data contained within a\nreceived OSPF packet to verify that it was generated by a router holding the key and\nthat the packet had not been altered. However, no real security mechanism had been\nimplemented for OSPF, only a clear password mechanism akin to TELNET passwords\nbefore the advent of Kerberos [238] and one-time passwords [90], which can be broken\ntrivially by anyone watching the packet exchanges on the network. To provide nontriv-\nial authentication in OSPF, cryptographic hash algorithms were eventually developed,\nas described in Section 11.7.\nIPv6\nBesides the danger imposed by routing table growth to the Internet's routers, the Inter-\nnet will sometime run out of addresses (when, precisely, this will happen is a matter of\nsome conjecture; see [1]). To prepare for this eventuality, development of the next gener-\nation of the Internet Protocol, IPv6, was started in 1995. IPv6 is an evolution of the IPv4\narchitecture; the routing architecture stays the same, but the size of the address increases\nfrom 32 to 128 bits ([49], [61], [99], [181]).\nTo be able to provide routing services for IPv6, the OSPF protocol was also updated.\nSince backward compatibility was not an issue, the packet and LSA formats were\nredone in OSPF for IPv6 [46]. All addressing semantics were removed from packet and\nLSA headers, allowing OSPF for IPv6 to be used by any protocol stack. All basic OSPF\nmechanisms, such as flooding, area organization, and routing calculations, were kept\nthe same so that most of the software for OSPFv2 could be reused.\nFurther Reading\nA succession of OSPF protocol specifications have been published as RFCs over the\nyears, each one obsoleting the previous ([174], [176], [177], and [178]). Each specification\nhas an appendix listing changes from the previous, allowing one to track the changes\nin the OSPF protocol. OSPF features, properties, and performance characteristics are\ndescribed in [173]. Results of OSPF interoperability testing and OSPF deployments are\ndescribed in [168] and [175].",
        "ad046186-2182-4899-930a-e07af48e36a0": "OSPF Basics\nOSPF belongs to the general category of routing protocols called link-state protocols. In\nthe last 10 to 15 years, link-state protocols have become popular alternatives to more\ntraditional Distance Vector algorithms. In addition to the development of OSPF for\nTCP/IP, link-state routing protocols have been implemented for many other protocol\nstacks, including the IS-IS protocol for OSI [112], NLSP for Novell's NetWare [184],\nIBM's APPN network-node routing [84], and the ATM Forum's PNNI routing pro-\ntocol [9].\nThe first link-state algorithm was developed by Bolt, Beranek and Newman in 1979\nfor the ARPANET [147], a packet-switching network that provided data-link services to\nattached hosts. These hosts used either the X.25 or 1822 protocols to interface with the\nARPANET packet switches. Between hosts, the Network Control Protocol (NCP) pro-\nvided transport services. In 1983, all the hosts were converted to the TCP/IP protocol\nstack, and routers were attached to the ARPANET, giving birth to today's Internet. The\nARPANET remained at the core of the Internet for many years, until it was finally\nretired in 1989.\nThe ARPANET'S link-state routing algorithm replaced a Distance Vector algorithm\nthat was starting to show signs of wear and tear. The goal of ARPANET routing\nwas to find the least-delay paths through the network. The previous Distance Vector\nalgorithm was taking a long time to converge on correct paths when the network\ntopology changed, and it was generating a lot of control traffic in the process. The new\nlink-state routing protocol was extensively instrumented and monitored, and it was\n71",
        "f35406df-a018-43ee-b4e7-89381bd155a6": "72 OSPF Basics Chapter 4\nfound to meet quite stringent performance goals, consuming less than 1 percent of link\nbandwidth for control traffic and less than 2 percent of switch CPU for routing calcula-\ntions, while responding to network changes in less than 100 milliseconds.\nAt the core of every link-state routing protocol is a distributed, replicated database.\nThis database describes the routing topology\u2014the collection of routers in the routing\ndomain and how they are interconnected. Each router in the routing domain is responsi-\nble for describing its local piece of the routing topology in link-state advertisements, or\nLSAs. These LSAs are then reliably distributed to all the other routers in the routing\ndomain in a process called reliable flooding. Taken together, the collection of LSAs\ngenerated by all of the routers is called the link-state database. The link-state routing\nprotocol's flooding algorithm ensures that each router has an identical link-state data-\nbase, except during brief periods of convergence. Using the link-state database as in-\nput, each router calculates its IP routing table, enabling the correct forwarding of IP data\ntraffic.\nIn this chapter, we will examine the basic features of a link-state protocol. These\ninclude LSAs, the link-state database, reliable flooding, and routing calculations. We\nwill look at the OSPF protocol in detail.\n4.1 An OSPF Example\nThe ARPANET switches were interconnected via point-to-point leased lines. To this day,\nall link-state protocols run in a very similar fashion, given such an environment. For this\nreason, we illustrate the basic concepts of OSPF, using a collection of routers intercon-\nnected by point-to-point links. A specific example network topology, shown in Fig-\nure 4.1, is used throughout this chapter.\nFigure 4.1 Point-to-point network topology.",
        "6204fcae-41ec-446a-9853-1f50082dfae5": "Section 4.1 An OSPF Example 73\nSuppose that this network has been up and running for some time. All of the six\nrouters pictured will then have identical link-state databases that describe a complete\nmap of the network. Looking at this database, any of the six routers can tell how many\nother routers are in the network (5), how many interfaces router 10.1.1.4 has (3), whether\na link connects 10.1.1.2 and 10.1.1.4 (yes), and so on. The database also gives a cost for\neach link. Although this cost is not shown in Figure 4.1, let us assume that the cost of\neach link is 1.\nFrom the database, each router has calculated the shortest paths to all others. For\nexample, router 10.1.1.1 calculates that it has two equal-cost shortest paths to 10.1.1.6,\none through 10.1.1.2 and 10.1.1.4 and the other through 10.1.1.3 and 10.1.1.5. (It is inter-\nesting to note that since they all have the same database, any router can calculate the\nrouting table of any other; this useful property is taken advantage of by the Multicast\nExtensions to OSPF, as explained in Chapter 10, MOSPF.)\nWhen the network is in a steady state\u2014that is, no routers or links are going in or\nout of service\u2014the only OSPF routing traffic is periodic Hello packets between neigh-\nboring OSPF routers and the occasional refresh of pieces of the link-state database.\nHello packets are usually sent every 10 seconds, and failure to receive Helios from a\nneighbor tells the router of a problem in its connected link or neighboring router. Every\n30 minutes, a router refloods the pieces of the link-state database that it is responsible\nfor, just in case those pieces have been lost from or corrupted in one of the other rout-\ners' databases.\nNow suppose that the link between routers 10.1.1.2 and 10.1.1.4 fails. The physical\nor data-link protocols in router 10.1.1.2 will probably detect this failure in a small num-\nber of seconds; as a last resort, the failure to receive OSPF Helios over the link will indi-\ncate the failure in 40 seconds. As soon as it detects the failure, router 10.1.1.2 will update\nthe link-state database by reoriginating its router-LSA. This new router-LSA will say\nthat router 10.1.1.2 has links to routers 10.1.1.1 and 10.1.1.3 but that it no longer has a\nlink to 10.1.1.4. Router 10.1.1.2 will start the flooding of its new router-LSA by sending\nthe LSA to routers 10.1.1.1 and 10.1.1.3. Router 10.1.1.3 will then continue the flooding\nprocess by sending the LSA to router 10.1.1.5, and so on.\nAs soon as each router receives router 10.1.1.2's new router-LSA, the router recalcu-\nlates its shortest paths. For example, router 10.1.1.1 will now calculate that it has only a\nsingle shortest path to 10.1.1.6, the one going through 10.1.1.3 and 10.1.1.5.\nIn this example, we have identified each router by an IP address, and this is also\nhow OSPF routers commonly identify one another. Each OSPF router has an OSPF\nRouter ID. The Router ID is a 32-bit number that uniquely identifies the router within\nthe OSPF routing domain. Although not required by the OSPF specification, the OSPF\nRouter ID in practice is assigned to be one of the router's IP addresses.",
        "53922f0f-01ba-4da7-bb52-f4f37ac28e0f": "74 OSPF Basics Chapter 4\n4.2 Link State Advertisements (LSAs)\nEach OSPF router originates one or more LSAs to describe its local part of the routing\ndomain. Taken together, the LSAs form the link-state database, which is used as input to\nthe routing calculations. In order to provide organization to the database and to enable\nthe orderly updating and removal of LSAs, each LSA must provide some bookkeeping\ninformation, as well as topological information. All OSPF LSAs start with a 20-byte\ncommon header, shown in Figure 4,2, which carries this bookkeeping information.\nThese bookkeeping functions are described in the following sections.\n4.2.1 Identifying LSAs\nAn OSPF link-state database might consist of many thousands of LSAs. Individual LSAs\nmust be distinguished during flooding and the various routing calculations. OSPF LSAs\nare identified by three fields found in the common LSA header: LS Type, Link State ID,\nand Advertising Router.\nLS Type Field\nThe LS Type (link-state type) field broadly classifies LSAs according to their functions.\nFive LS Types are defined by the base OSPF specification. LSAs with LS Type equal to 1\nare called router-LSAs. Each router originates a single router-LSA to describe its set of\nactive interfaces and neighbors. In a routing domain consisting solely of routers inter-\nconnected by point-to-point links, the link-state database consists only of router-LSAs.\nFor this reason, we concentrate on router-LSAs in this chapter.LS Age\nOptions LS Type\nLink State ID\n- Advertising Router -\n\u2014 LS Sequence Number \u2014\nLS Checksum\nLength\nFigure 4.2 The LSA header.",
        "c12764fb-6749-4df1-a15f-22f55ebd0f37": "Section 4.2 Link State Advertisements (LSAs) 75\nLSAs with LS Type equal to 2 are called network-LSAs. Each network-LSA describes\na network segment, such as a broadcast or NBMA network, along with the identity of\nthe network's currently attached routers. The use of network-LSAs is described further\nin Chapter 5, OSPF Network Types.\nLSAs with LS Type equal to 3 (network-summary-LSAs), 4 (ASBR-summary-LSAs),\nand 5 (AS-external-LSAs) are used to implement hierarchical routing within OSPF. These\nare discussed further in Chapter 6, Hierarchical Routing in OSPF.\nOne way of extending the OSPF protocol is to add new LS Types. Two LS Types\nhave been added to those defined by the base specification. LSAs with LS Type equal to\n6 are called group-membership-LSAs and are used to indicate the location of multicast\ngroup members in MOSPF (see Chapter 10, MOSPF). LSAs with LS Type equal to 7\nare used in OSPF NSSA areas to import a limited set of external information (see Sec-\ntion 7.4). In addition, an LS Type of 8 has been proposed, the external-attributes-LSAs,\nto carry BGP path information across an OSPF routing domain in lieu of Internal BGP\n(see Section 7.6).\nOSPF routers are not required to store or forward LSAs with unknown LS Type.\nWhen OSPF is extended by adding new LS Types, this rule is maintained through use of\nthe Options field. Options bits are added, saying, \"I understand this new LS Type,\" and\nare exchanged between routers in Database Description packets (see Section 4,7.1).\nLooking at the Options field advertised by its neighbor, a router then knows which\nLSAs to forward and which LSAs to keep to itself.\nLink State ID Field\nThe Link State ID field uniquely distinguishes an LSA that a router originates from all\nother self-originated LSAs of the same LS Type. For compactness and convenience, the\nLink State ID also often carries addressing information. For example, the Link State ID\nof an AS-external-LSA is equal to the IP address of the externally reachable IP network\nbeing imported into the OSPF routing domain (see Section 6.2).\nAdvertising Router Field\nThe Advertising Router field is set to the originating router's OSPF Router ID. A router\ncan easily identify its self-originated LSAs as those LSAs whose Advertising Router is\nset to the router's own Router ID. Routers are allowed to update or to delete only self-\noriginated LSAs.\nKnowing which router has originated a particular LSA tells the calculating router\nwhether the LSA should be used in the routing calculation and, if so, how it should\nbe used. For example, network-summary-LSAs are used in the routing calculation\nonly when their Advertising Router is reachable. When they are used, the cost to the",
        "86adcd82-4c68-4c63-b4bb-206ff06ad96f": "76 OSPF Basics Chapter 4\ndestination network is the sum of the cost to the Advertising Router and the cost adver-\ntised in the LSA.\n4.2.2 Identifying LSA Instances\nWhen a router wishes to update one of the LSAs it is originating (called self-originated\nLSAs), it must have some way to indicate to the other routers that this new LSA instance\nis more up to date and therefore should replace any existing instances of the LSA. In\nOSPF LSAs, the LS Sequence Number in the common LSA header is incremented when\na new LSA instance is originated. The LSA instance having the larger LS Sequence\nNumber is considered to be more recent. If the LS Sequence Numbers are the same, the\nLS Age and LS Checksum fields of the LSA are compared by the router before it declares\nthat the two instances are identical.\nLS Sequence Number Field\nWhen a router has two instances of a particular LSA, it detects which instance is more\nrecent by comparing the instances' LS Sequence Numbers. The instance with the larger\nLS Sequence Number is the more recent. Of course, the meaning of larger depends on\nthe organization of the sequence number space (see Figure 4.3).\nFigure 4.3 Various LS Sequence Number space organizations.\nThe original ARPANET link-state algorithm used a circular sequence number space.\nBy carefully controlling the rate at which new LSA instances were generated, all possi-\nble sequence numbers for a given LSA were constrained at any one time to lie in a half-\ncircle (that is, a semicircle). The largest sequence number was then the sequence number\nappearing on the counterclockwise edge of the semicircle. However, this scheme was",
        "d1f82766-acd6-4b7a-858c-fabe503485c5": "Section 4.2 Link State Advertisements (LSAs) 77\nnot robust in the face of errors. In a now famous network failure, bit errors in switch\nmemory caused the accidental introduction of three instances of an LSA having\nsequence numbers (Sl7 S2, and S3 in Figure 4.3) that were not constrained to a semicircle.\nThe switches could no longer determine which LSA instance was most recent, since\nSj < S2 < S3 < Si. As a result, the three LSA instances were continually flooded through-\nout the network, each instance replacing the others in turn. This continued until the\nentire network was power cycled (see [221]). Some people have likened such problems\nto a virus. Once introduced by a switch, such bad data spreads to all other switches and\nbecomes extremely difficult to eradicate.\nTo help avoid this network failure (called herein the ARPANET sequence bug),\na lollipop-shaped sequence number space was proposed [189]. Each LSA is initially\noriginated with the smallest sequence number S0, which is part of the lollipop's\nhandle. The sequence space then increments until it enters the circular part of the\nspace. Version 1 of the OSPF protocol used the lollipop-shaped sequence space.\nAlthough the lollipop-shaped organization provides better protection against the\nARPANET sequence bug, since sequence numbers falling into the lollipop handle\nnever create ambiguities, the three sequence numbers Slr S2, and S3 still cause a\nproblem.\nOSPFv2 uses a linear sequence space, which completely prevents the ARPANET\nsequence bug. OSPF LS Sequence Numbers are signed 32-bit values. The first time an\nOSPF router originates a given LSA, it sets the LSA's LS Sequence Number to the small-\nest negative value (S0, called InitialSequenceNumber and having the value 0x80000001).\nSubsequently each time the router updates the LSA, it increments the LSA's LS\nSequence Number by 1. An LSA's LS Sequence Number monotonically increases\nuntil the maximum positive value is reached (Sf^ax, called MaxSequenceNumber\nand with the value Ox7fffffff). At this point, when the router wishes to update the\nLSA, it must start again with the initial sequence value of S0, rolling over the se-\nquence space. However, to get the other routers to accept this new LSA instance as\nthe most recent, the router must first delete the LSA instance with sequence number\n$Max from the routing domain (see Section 4.7.2) before flooding the new instance\nwith sequence number S0.\nOne should note that, since OSPF routers are not allowed to update their self-\noriginated LSAs more than once every 5 seconds, in the absence of errors (in either\nhardware or software implementations), a 32-bit sequence space, such as OSPF's, will\ntake more than 600 years to roll over! However, as we saw in the ARPANET bug, errors\ncan and do happen. Besides using a linear sequence space irt its LSAs, OSPF has other\nfeatures that guard against problems similar to the ARPANET sequence bug. First, all\nOSPF LSAs contain a checksum, so that data corruption within an LSA is detected.\nSecond, OSPF requires the LS Age field of all LSAs to be incremented at each hop dur-\ning flooding, which eventually breaks any flooding loop by causing a looping LSA's LS\nAge field to reach the value MaxAge.",
        "3aeb8028-603b-4db9-8d3e-2a7c189de7aa": "78 OSPF Basics Chapter 4\n4.2.3 Verifying LSA Contents\nAn LSA may become corrupted during flooding or while being held in a router's mem-\nory. Corrupted LSAs can create havoc, possibly leading to incorrect routing calculations,\nblack holes, or looping data packets. To detect data corruption, redundant information\nis added to the LSA as a checksum or parity check. In OSPF, this function is provided by\nthe LS Checksum field in the LSA header.\nLS Checksum Field\nEach OSPF LSA is checksummed to detect data corruption within the LSA header and\ncontents. The checksum is calculated originally by the router that originates the LSA\nand then is carried with the LSA as it is flooded throughout the routing domain and\nstored within the link-state database. A router verifies the checksum of an LSA received\nfrom a neighboring router during flooding; corrupted LSAs will be discarded by the\nrouter, in hopes that the retransmitted LSA from the neighbor will be uncorrupted. A\nrouter also periodically verifies the checksums of all the LSAs in its link-state database,\nguarding against its own hardware and software errors. Detection of such internal\nerrors will generally cause the router's OSPF processing to reinitialize.\nAfter an LSA instance is originated, its checksum is never altered. For this reason,\nthe checksum excludes the LSA's LS Age field, which is modified in flooding. This\nmeans that OSPF does not detect corruption of the LS Age field; corruption of the LS\nAge field will in general cause no more harm than speeding up the rate of LSA origina-\ntions. A proposal to safeguard the LS Age field (along with other security-related con-\ncerns) is given in [179].\nThe checksum is implemented by using the Fletcher checksum algorithm, which\nis used in the OSI network and transport layers (see [145]). The reason for using the\nFletcher checksum in LSAs is that it is easy to calculate yet catches patterns of data cor-\nruption different from the standard Internet ones-complement checksum used by\nOSPF's protocol packets. During flooding, LSAs are carried in OSPF Link State Update\npackets. If for some reason data corruption fails to be detected by the Update packet's\nones-complement checksum, Fletcher may still detect the corruption within individual\nLSAs.\nThe OSPF protocol also uses the LSA checksum as an efficient way to determine\nwhether two instances of the same LSA, both having the same LS Checksum fields and\nrelatively the same age, also have the same contents (and so should be considered the\nsame instance). This is a probabilistic comparison\u2014there is no absolute assurance that\nwhen the checksums are equal, so are the contents, although it seems to be highly likely\nin this context (same LSA, same LS sequence number, and relatively the same LS age).\nNote that even if the assumption were wrong, OSPF would recover automatically\nwhenever the LSA was refreshed (that is to say, within 30 minutes).",
        "76fa883a-28e2-467c-89cd-2bcadf701ef9": "Section 4.2 Link State Advertisements (LSAs) 79\n4.2.4 Removing LSAs from the Distributed Database\nUnder normal circumstances, every LSA in the link-state database is updated at least\nonce every 30 minutes. If an LSA has not been updated after an hour, the LSA is\nassumed to be no longer valid and is removed from the database. The LS Age field in\nthe LSA header indicates the length of time since the LSA was last updated.\nLS Age Field\nThe LS Age field indicates the number of seconds since the LSA was originated. Under\nnormal circumstances, the LS Age field ranges from 0 to 30 minutes; if the age of an\nLSA reaches 30 minutes, the originating router will refresh the LSA by flooding a new\ninstance of the LSA, incrementing the LS sequence number and setting the LS age to 0\nagain.\nIf the originating router has failed, the age of the LSA continues to increase until\nthe value of MaxAge (1 hour) is reached. At that time, the LSA is deleted from the\ndatabase\u20141 hour is the maximum value that the LS Age field can ever attain. To en-\nsure that all routers remove the LSA more or less at the same time, without depending\non a synchronized clock, the LSA is reflooded at that time. All other routers will then\nremove their database copies on seeing the MaxAge LSA being flooded.\nAfter an LSA's originating router has failed, it can therefore take as long as an hour\nfor the LSA to be removed from other routers' link-state databases. Such an LSA is cer-\ntainly advertising out-of-date information; however, OSPF guarantees that the LSA will\nnot interfere with the routing table calculation. How? By requiring that a link be adver-\ntised by the routers at both ends of the link before using the link in the routing calcula-\ntion (see Section 4.8).\nOSPF also has a procedure, called premature aging, for deleting an LSA from the\nrouting domain without waiting for its LS Age to reach MaxAge. Sometimes a router\nwishes to delete an LSA instead of updating its contents. Using premature aging, the\nrouter deletes the LSA from the distributed database by setting the LSA's LS Age field\nto MaxAge and reflooding the LSA. In order to avoid possible thrashing situations\nwhereby one router continually originates an LSA while another continually deletes\nit, a router is allowed to prematurely age only those LSAs that the router itself origi-\nnated. If a router crashes or is removed from service without prematurely aging its self-\noriginated LSAs, said LSAs will remain in other routers' link-state database for up\nto an hour while they age out naturally.\nThe age of an LSA is also examined in order to implement other OSPF functions,\nsuch as rate limiting the amount of OSPF flooding (see Section 4.7.3). The uses of the LS\nAge field are shown in Table 4.1.",
        "aaaa60cc-dd29-4166-b312-b4e0b0590b13": "80 OSPF Basics Chapter 4\nTable 4.1 Actions Taken by OSPF Router, Based on LS Age Fields\n4.2.5 Other LSA Header Fields\nOptions\nThe Options field in the OSPF LSA header can indicate that an LSA deserves special\nhandling during flooding or routing calculations. In addition to the LSA header, the\nOptions field can appear in OSPF Hello and Database Description packets. The Options\nfield is 1 byte in length. In the base OSPF protocol specification, only two Options bits\nwere denned. With the addition of OSPF protocol extensions, such as MOSPF, NSSA\nareas, and the Demand Circuit extensions, five of the eight Option bits now have\ndefined meanings.\nLength\nThe Length field contains the length, in bytes, of the LSA, counting both LSA header\nand contents. Because the Length field is 16 bits long, an LSA can range in size from 20\nbytes (the size of the LSA header) to over 65,000 bytes; note that one cannot go all the\nway to 65,535 bytes, since the LSA must eventually be transported within an IP packet\nthat is itself restricted to 65,535 bytes in length. However, note that all OSPF LSAs are\nsmall, with the only LSA type that is likely to exceed a few hundred bytes being the\nrouter-LSA. Router-LSAs can be large when a router has many different interfaces, but\nare still unlikely to exceed a few thousand bytes in length.\n,Constant Value Action of OSPF Router\nMinLSArrival 1 second Maximum rate at which a router will accept updates of any given\nLSA via flooding.\nMinLSInterval 5 seconds Maximum rate at which a router can update an LSA.\nCheckAge 5 minutes Rate at which a router verifies the checksum of an LSA contained in\nits database.\nMaxAgeDiff 15 minutes When two LSA instances differ by more than 15 minutes, they are\nconsidered to be separate instances, and the one with the smaller LS\nAge field is accepted as more recent.\nLSRefreshTime 30 minutes A router must refresh any self-originated LSA whose age reaches\nthe value of 30 minutes.\nMaxAge 1 hour When the age of an LSA reaches 1 hour, the LSA is removed from\nthe database.",
        "3e55558a-214b-4235-99c3-a12466d93265": "Section 4.3 A Sample LSA: The Router-LSA 81\n4.3 A Sample LSA: The Router-LSA\nIn the network environment of routers interconnected via serial lines, OSPF uses only\na single LSA type: the router-LSA. Each OSPF router originates a single router-LSA,\nwhich reports the router's active interfaces, IP addresses, and neighbors.\nLet's examine the router-LSA originated by router 10.1.1.1 in Figure 4.4. First, a little\nmore explanation of Figure 4.4 is in order. All serial lines in the figure are unnumbered:\nThe routers' serial line interfaces have not been assigned IP addresses; nor have IP sub-\nnets been assigned to the serial lines. Each router has been assigned an IP address that is\nnot attached to any particular interface; the routers are labeled with these addresses.\nFollowing the usual convention, OSPF Router IDs have been assigned equal to the rout-\ners' IP addresses, although this is not strictly required by the OSPF specification. Finally,\neach interface is labeled with a pair of numbers. The first number is the interface's\nMIB-II Iflndex value, and the second is the OSPF output cost that has been assigned to\nthe interface. Figure 4.5 displays the router-LSA that router 10.1.1.1 would originate\nafter full OSPF relationships to its neighbors have been established.\n(2,10)\n(1,5) (3,10)\nFigure 4.4 Point-to-point network topology, with interface IFIndexes and costs labeled.\nLet us first consider the setting of the fields in the standard LSA header. All LSAs\nare originated with LS Age set to 0. The Options field describes various optional capa-\nbilities supported by the router; see Chapter 7, OSPF Extensions. The Link State ID of\na router-LSA is set to the router's OSPF Router ID. The LS sequence number of the LSA\nis 0x80000006, indicating that five instances of the router-LSA have previously been\noriginated.\nNext in the router-LSA comes a byte (labeled Router Type in Figure 4.5) describing\nthe router's role in hierarchical routing, as well as any special roles that router might\nhave in multicast routing. (See Sections 6.1, 6.2, and 10.4.)",
        "ea73d67b-08bf-47c9-b845-82fa3dff9036": "82 OSPF Basics Chapter 4\nFigure 4.5 Router 10.1.1.1's router-LSA.\nThe router-LSA then indicates that three connections (or links) are being reported.\nThe first two links are point-to-point connections to neighboring routers, as indicated\nby the Link Type field. The Link ID of a point-to-point connection is the neighboring\nrouter's OSPF Router ID. Since these connections are unnumbered, the Link Data field\nindicates the corresponding router interface's MIB-II Iflndex.",
        "c523b970-24cb-4163-9c07-fdc26d89a706": "Section 4.4 The Link-State Database 83\nEach link also contains a Metric field. This field, ranging from 1 to 65,535, indicates\nthe relative cost of sending data packets over the link. The larger the cost, the less likely\nthat data will be routed over the link. Metrics are configured by the person setting up\nthe network. The metric can mean anything\u2014delay, dollar cost of sending traffic over\nthe link, and so on. The only thing to note is that adding the metrics should be meaning-\nful, since OSPF calculates the cost of the path to be the sum of the cost of the path's com-\nponent links. This means that delay would be a fine metric. So would transmission time\nfor the link (which is the default value for the metric in the OSPF MIB; see Section 11.2).\nHowever, link bandwidth would probably not be a good metric, since adding band-\nwidth along a path is not very meaningful. Figure 4.4 uses the metric I call weighted hop\ncount. One starts by assigning each link a metric of 1 and then increases the cost of the\nless preferred links until the least-cost paths flow over the more desirable links.\nNote that metrics can be asymmetric; one does not have to assign equal metrics to\nboth sides of a link. However, assigning equal metrics to both sides of a link is the norm,\nas has been done in Figure 4.4. In the original OSPF specification, separate metrics could\nbe assigned for each TOS, although this feature was removed due to lack of deployment\nof TOS-based routing. For backward compatibility, the router-LSA still has space for\nTOS metrics, even though in practice the # TOS metrics for each link is always set to 0.\nThe last link in router 10.1.1.1's router-LSA advertises the router's own IP address.\nThe address is advertised as a stub network connection. Stub networks are allowed to\nsource or sink IP packets, but do not carry transit traffic. The Link ID field of a stub net-\nwork connection is advertised as the network's IP address, the Link Data field as its IP\nmask. Connections to stub networks are allowed to advertise a Metric of 0.\nAs mentioned earlier, the router-LSA is the one type of LSA that can get quite large.\nAll of a router's interfaces must be advertised in a single router-LSA. The fixed part of a\nrouter-LSA is 24 bytes in length, with each advertised connection adding an additional\n12 bytes. The router-LSA in Figure 4.5 is only 24 + 3 * 12 = 60 bytes long, but a router-\nLSA for a router with 100 interfaces would be 1,224 bytes in length.\n4.4 The Link-State Database\nThe collection of all OSPF LSAs is called the link-state database. Each OSPF router has an\nidentical link-state database. Link-state databases are exchanged between neighboring\nrouters soon after the routers have discovered each other; after that, the link-state data-\nbase is synchronized through a procedure called reliable flooding (see Section 4.7.2).\nThe link-state database gives a complete description of the network: the routers and\nnetwork segments and how they are interconnected. Starting with a link-state database,\none can draw a complete map of the network. This property can serve as a powerful\ndebugging tool. By examining a single router's database, one immediately observes the\nstate of all other routers in the network.",
        "19ea4a41-bfa2-44df-9268-c2485a317633": "84 OSPF Basics Chapter 4\nOf course, OSPF is not a network-monitoring protocol; it is a routing protocol. In\nperformance of the routing function, a router uses the link-state database as the input to\nthe router's routing calculation (see Section 4.8).\nTable 4.2 shows the link-state database for the network in Figure 4.4. Each row in\nthe table represents a single LSA. As mentioned earlier, each LSA is identified by the\ncontents of the table's first three columns; the second three columns identify the LSA's\ninstance.\nTable 4.2 Link-State Database for Sample Network\nLSType\nRouter-LSA\nRouter-LSA\nRouter-LSA\nRouter-LSA\nRouter-LSA\nRouter-LSALink State ID\n10.1.1.1\n10.1.1.2\n10.1.1.3\n10.1.1.4\n10.1.1.5\n10.1.1.6Adv. Router\n10.1.1.1\n10.1.1.2\n10.1.1.3\n10.1.1.4\n10.1.1.5\n10.1.1.6LS Checksum\nOx9b47\nOx219e\nOx6b53\nOxe39a\nOxd2a6\nOx05c3LS Sequence No.\n0x80000006\n0x80000007\n0x80000003\nOx8000003a\n0x80000038\n0x80000005LSAge\n0\n1,618\n1,712\n20\n18\n1,680\nOne can quickly determine in OSPF whether two routers do indeed have syn-\nchronized databases. First, determine that the two routers have the same number of\nLSAs in their link-state databases; second, that the sums of their LSAs' LS Checksum\nfields are equal. These values are represented in the OSPF MIB by the variables\nospfExternLsaCount, ospfExternLsaCksumSum, ospfAreaLsaCount,and\nospf AreaLsaCksumSum. As with using the LS Checksum field to compare LSA contents,\ncomparing the sum of the LS Checksums to determine link-state database synchroniza-\ntion is probabilistic in nature but useful in practice. For example, according to the data-\nbase in Table 4.2, all routers should have six LSAs in their link-state database, and the\nsum of the LSAs' LS Checksums should be Ox2e43b.\nLooking at the OSPF database, one can also immediately tell which parts of the net-\nwork are changing the most\u2014namely, the parts that are described by LSAs whose LS\nSequence Numbers are changing the most and whose LS Age field never gets very\nlarge. In Table 4.2, for example, you can see that the router-LSAs originated by routers\n10.1.1.4 and 10.1.1.5 are changing much more rapidly than LSAs originated by other\nrouters. Looking at the network diagram in Figure 4.4, one would guess that is because\nthe point-to-point connection between 10.1.1.4 and 10.1.1.5 goes up and down fre-\nquently. Note that this information can be determined by looking at any router's link-\nstate database, since all routers have exactly the same information.\nIn our sample network of routers connected via serial lines, the link-state database\nis very simple and uniform, consisting only of router-LSAs. However, in the presence\nof network segments other than point-to-point links or when hierarchical routing is",
        "22e315a8-1632-4265-954a-040df98f7546": "Section 4.5 Communicating between OSPF Routers: OSPF Packets 85\nemployed or when OSPF extensions, such as MOSPF, are deployed, other LSA types are\nintroduced. These LSAs are explained further in Chapters 5, 6, and 10.\n4.5 Communicating between OSPF Routers: OSPF Packets\nLike most IP protocols, OSPF routers communicate in terms of protocol packets. OSPF\nruns directly over the IP network layer, doing without the services of UDP or TCP\n(which are used by RIP and BGP, respectively). When a router receives an IP packet with\nIP protocol number equal to 89, the router knows that the packet contains OSPF data.\nStripping off the IP header, the router finds an OSPF packet. One particular type of\nOSPF packet, together with its IP encapsulation, is shown in Figure 4.6.\nOSPF uses services of the IP header as follows.\n\u2022 Since most OSPF packets travel only a single hop, namely, between neighboring\nrouters or peers, the TTL in the IP packet is almost always set to 1. This keeps\nbroken or misconfigured routers from mistakenly forwarding OSPF packets.\nThe one exception to setting the TTL to 1 comes in certain configurations of\nOSPF hierarchical routing (see Section 6.1.1).\n\u2022 The Destination IP address in the IP header is always set to the neighbor's IP\naddress or to one of the OSPF multicast addresses AllSPFRouters (224.0.0.5) or\nAllDRouters (224.0.0.6). Use of these two multicast addresses is described in\nSection 5.2.\n\u2022 An OSPF router uses IP fragmentation/reassembly when it has to send a packet\nthat is larger than a network segment's MTU. However, most of the time, a\nrouter can avoid sending such a large packet, sending an equivalent set of\nsmaller OSPF packets instead (this is sometimes called semantic fragmentation).\nFor example, IP fragmentation cannot be avoided when a router is flooding an\nLSA that is itself larger (or close to larger) than the network segment's MTU.\nThat is to say, there is no semantic fragmentation for OSPF LSAs (although this\nhas been introduced in OSPF for IPv6; see Section 3.7). IP fragmentation is also\nunavoidable when the router has so many neighbors on a broadcast segment\nthat the size of the Hello packet exceeds the segment's MTU (Section 5.2.1).\n\u2022 A router sends all OSPF packets with IP precedence of Internetwork Control, in\nhope that this setting will cause OSPF packets to be preferred over data packets\n(although in practice, it seldom does).\nAll OSPF packets begin with a standard 24-byte header, which provides the follow-\ning functions.\n\u2022 An OSPF packet type field. There are five separate types of OSPF protocol pack-\nets: Hello packets (type = 1), used to discover and maintain neighbor relation-\nships and Database Description packets (type = 2), Link State Request packets",
        "d68f466a-7e75-42c1-812b-866d50240e92": "86 OSPF Basics Chapter 4\n(type = 3), Link State Update packets (type = 4), and Link State Acknowledg-\nment packets (type = 5), all used in link-state database synchronization (see\nSection 4.7).\nThe OSPF Router ID of the sender. Thus the receiving router can tell which OSPF\nrouter the packet came from.\nA packet checksum. This allows the receiving router to determine whether the\npacket has been damaged in transit; if so, the packet is discarded.\nAuthentication fields. For security, these fields allow the receiving router to verify\nthat the packet was indeed sent by the OSPF router whose Router ID appears in\nthe header and that the packet's contents have not been modified by a third\nparty. See Section 11.7 for details.\nAn OSPF Area ID. This enables the receiving router to associate the packet to the\nproper level of OSPF hierarchy and to ensure that the OSPF hierarchy has been\nconfigured consistently (see Section 6.1).\n4.6 Neighbor Discovery and Maintenance\nAll routing protocols provide a way for a router to discover and maintain neighbor rela-\ntionships (also sometimes called peer relationships). A router's neighbors, or peers, are\nthose routers with which the router will directly exchange routing information.\nIn OSPF, a router discovers neighbors by periodically sending OSPF Hello packets\nout all of its interfaces. By default, a router sends Helios out an interface every 10 sec-\nonds, although this interval is configurable as the OSPF parameter Hellolnterval. A\nrouter learns the existence of a neighboring router when it receives the neighbor's OSPF\nHello in turn.\nThe part of the OSPF protocol responsible for sending and receiving Hello packets\nis called OSPF's Hello protocol (not to be confused with the old NSFNET routing proto-\ncol of the same name). The transmission and reception of Hello packets also enables a\nrouter to detect the failure of one of its neighbors; if enough time elapses (specified as\nthe OSPF configurable parameter RouterDeadlnterval, whose default value is 40 sec-\nonds) without the router's receiving a Hello from a neighbor, the router stops advertis-\ning the connection to the router and starts routing data packets around the failure. In\nmost cases, however, the failure of the neighbor connection should be noticed much ear-\nlier by the data-link protocol. Detecting neighbor failures in a timely fashion is crucial to\nOSPF protocol performance. The time to detect neighbor failures dominates conver-\ngence time, since the rest of the OSPF protocol machinery (flooding updated LSAs and\nredoing the routing table calculations) required to route packets around the failure takes\nat most a few seconds.\nBesides enabling discovery and maintenance of OSPF neighbors, OSPF's Hello pro-\ntocol also establishes that the neighboring routers are consistent in the following ways.",
        "5430e322-2d68-4dad-9186-04de71bac353": "Section 4.7 Database Synchronization 87\n\u2022 The Hello protocol ensures that each neighbor can send packets to and receive\npackets from the other. In other words, the Hello protocol ensures that the link\nbetween neighbors is bidirectional. Unless the link is bidirectional, OSPF rout-\ners will not forward data packets over the link. This procedure prevents a rout-\ning failure that can be caused by unidirectional links in other protocols, which is\nmost easily demonstrated using RIP (see Section 13.1). Suppose that RIP routers\nA and B are connected and that packets can go from B to A but not vice versa.\nB may then send routing updates for network N to A, causing A to install B as\nthe next hop for N. However, whenever A forwards a packet destined for\nnetwork N, the packet will go into a \"black hole.\"\n\u2022 The Hello protocol ensures that the neighboring routers agree on the Hellolnter-\nval and RouterDeadlnterval parameters. This ensures that each router sends\nHelios quickly enough so that losing an occasional Hello packet will not mistak-\nenly bring the link down.\nThe OSPF Hello protocol performs additional duties on other types of network seg-\nments (see Chapter 5, OSPF Network Types). Also, the OSPF Hello protocol is used to\ndetect and negotiate certain OSPF extensions (see Chapter 7, OSPF Extensions).\nFigure 4.6 shows the Hello packet that router 10.1.1.1 would be sending to router\n10.1.1.2 in Figure 4.1 after the connection has been up some time. By including router\n10.1.1.2 in the list of neighbors recently heard from, router 10.1.1.1 indicates that it is\nreceiving router 10.1.1.2's Helios. On receiving this Hello packet, router 10.1.1.2 will\nthen know that the link is bidirectional. The fields Network Mask, Router Priority,\nDesignated Router, and Backup Designated Router are used only when the neighbors\nare connected by a broadcast or NBMA network segment (see Section 5.2). The Options\nfield is used to negotiate optional behavior between the neighbors and is discussed fur-\nther in Section 7.1.\n4.7 Database Synchronization\nDatabase synchronization in a link-state protocol is crucial. As long as the database\nremains synchronized, a link-state protocol's routing calculations ensure correct and\nloop-free routing. It is no surprise, then, that most of the protocol machinery in a link-\nstate protocol exists simply to ensure and to maintain synchronization of the link-state\ndatabase. Of the 76 pages in the OSPF specification detailing protocol functionality,\n32 deal exclusively with database synchronization. Of the 5 OSPF protocol packet\ntypes, 4 are used for database synchronization.\nDatabase synchronization takes two forms in a link-state protocol. First, when\ntwo neighbors start communicating, they must synchronize their databases before for-\nwarding data traffic over their shared link, or routing loops may ensue (Section 4.7.1).\nSecond, there is the continual database resynchronization that must occur as new LSAs\nare introduced and distributed among routers. The mechanism that achieves this resyn-\nchronization is called reliable flooding (Section 4.7.2).",
        "30621477-8322-46a0-81f1-59e1f6625281": "88 OSPF Basics Chapter 4",
        "eda95720-ac63-4cf4-ad2d-9158b02866da": "Section 4.7 Database Synchronization 89\n4.7.1 Initial Database Synchronization\nWhen the connection between two neighboring routers first comes up, the routers must\nwait for their link-state databases to be synchronized before forwarding data traffic over\nthe connection. Otherwise discrepancies in the neighbors' databases may lead to their\ncalculating incompatible routing tables, resulting in routing loops or black holes.\nIn the original ARPANET link-state protocol, achieving this initial synchronization\nwas done without introducing any additional mechanisms. When the connection first\ncame up, reliable flooding began over the connection, but the connection was not used\nfor data traffic until enough time had elapsed to guarantee that the entire database had\nbeen either updated or refreshed. In the ARPANET protocol, this time interval was 60\nseconds.\nThe ARPANET strategy, although simple, did have a major drawback. It tied the\ntime to bring up a connection to the database refresh interval. In order to reduce the\namount of routing traffic, one would like to increase the database refresh interval; for\nexample, in OSPF, each LSA is refreshed only once every 30 minutes. In the ARPANET\nstrategy, however, this would incur an unacceptable delay in bringing up neighbor con-\nnections. To solve this problem, [189] suggested another strategy: an explicit database\ndownload when neighbor connections first come up. The OSPF protocol uses this sec-\nond strategy.\nInstead of sending the entire database to the neighbor when the connection comes\nup, an OSPF router sends only its LSA headers, and then the neighbor requests those\nLSAs that are more recent. This procedure is more efficient than simply sending the\nentire database; it is called Database Exchange in the OSPF specification.\nDatabase Exchange is what the majority of the OSPF neighbor finite-state machine\nis tasked to do. As soon as the Hello protocol has determined that the connection\nbetween neighbors is bidirectional, the OSPF protocol decides whether databases need\nto be synchronized\u2014over serial lines, databases are always synchronized, although\nover other network segments, databases are synchronized only between certain neigh-\nbor pairs (see Chapter 5, OSPF Network Types). If a decision to synchronize is made,\neach neighbor does two things: sends the link-state headers of all the LSAs currently in\nits database to the other in a sequence of OSPF Database Description packets and starts\nflooding any future LSA updates over the connection. Commencing the flooding pro-\ncedure is necessary to ensure that Database Exchange finishes in a deterministic time\nperiod.\nTransmission and reception of the sequence of Database Description packets by a\nrouter resembles the operation of the TFTP protocol. Only one Database Description\npacket can be outstanding at any one time; the router will send the next Database\nDescription packet only when the previous one is acknowledged through reception\nof a properly sequenced Database Description packet from the neighbor.\nWhen an entire sequence of Database Description packets has been received, a\nrouter knows the link-state headers of all the LSAs in its neighbor's link-state database.",
        "59a0c6f3-5723-46d7-b421-644d76654378": "90 OSPF Basics Chapter 4\nIn particular, the router knows which of the neighbor's LSAs it does not have and which\nof the neighbor's LSAs are more recent. The router then sends Link State Request pack-\nets to the neighbor requesting the desired LSAs, and the neighbor responds by flooding\nthe LSAs in Link State Update packets.\nAfter having sent a full sequence of Database Description packets to the neighbor,\nhaving received a full sequence of Database Description Packets from the neighbor, and\nhaving had all of its Link State Request packets satisfied by Link State Updates received\nfrom the neighbor, the router declares the connection synchronized and advertises it as\nready to be used for data traffic. At this point, the neighbor is said to be fully adjacent to\nthe router (at the beginning of the Database Exchange procedure, the two routers were\nsaid to be merely adjacent).\nFigure 4.7 shows an example of the Database Exchange procedure. Assume that\nall the routers in Figure 4.1 have synchronized on the database displayed in Table 4.2.\nThen suppose that router 10.1.1.6 restarts. This temporarily tears down the connections\nbetween 10.1.1.6 and its neighbors 10.1.1.4 and 10.1.1.5. These two routers will have\nupdated their LSAs, omitting their connections to 10.1.1.6. The initial exchange of Helios\nand the Database Exchange between routers 10.1.1.4 and 10.1.1.6 is then displayed in\nFigure 4.7.\nNote several features of Database Exchange as illustrated in Figure 4.7. The first\nDatabase Description packet sent by router 10.1.1.6 indicates that 10.1.1.6 has seen\n10.1.1.4's Helios, so that 10.1.1.4 does not need to wait for 10.1.1.6's next Hello to\nestablish bidirectionality. This same Database Description packet also establishes the\nsequence number to be used during Database Exchange; the sequence number is incre-\nmented for each pair of Database Description packets and serves as an acknowledgment\nfor the previous pair. The last Database Description packet sent by 10.1.1.4 is empty,\nserving only as an acknowledgment. Examining the Link State Request packet sent by\n10.1.1.6, you see that Link State Request packets do not request particular LSA instances\nbut only the current database copy of each LSA listed. Finally, note that although\n10.1.1.6 really has the most recent router-LSA for itself, both routers act as if the old\nrouter-LSA for 10.1.1.6 in 10.1.1.4 is most recent. After requesting and receiving this old\nLSA from 10.1.1.4, router 10.1.1.6 immediately issues an updated router-LSA with a\nlarger sequence number.\nAn interesting property of the combination of the Hello protocol and Database\nExchange is the following: It uses both small packets and large packets, multicast (on\nthose segments that support multicast) and unicast. As a result, OSPF tends to detect\nlink-level difficulties, such as MTU mismatches between neighbors, or unicast working\nbut multicast not working, by failing to form a full adjacency. This behavior makes the\nlink-level problems easier to find than does the alternative of tracking down strange\nfailures in TCP/IP applications.\nOne last thing to note is that a router may have MaxAge LSAs in its link-state data-\nbase as Database Exchange is begun with a neighbor. Since MaxAge LSAs are in the pro-\ncess of being deleted from the database, the router does not send them in Database",
        "46c5e60c-808f-419a-b630-2448ee207c2b": "Section 4.7 Database Synchronization 91",
        "cc83f5fe-6b59-4f54-b4b8-2e3eba1b8578": "92 OSPF Basics Chapter 4\nDescription packets to the neighbor; the LSAs may be gone by the time the neighbor\ngets around to requesting them. Instead the MaxAge LSAs are flooded to the neighbor\nto make sure that the neighbor also deletes them.\n4.7.2 Reliable Flooding\nAs LSAs are updated with new information, they are sent throughout the routing\ndomain by a procedure called reliable flooding. The flooding procedure starts when a\nrouter wishes to update one of its self-originated LSAs. This may be because the router's\nlocal state has changed\u2014for example, one of the router's interfaces may have become\ninoperational, causing the router to reoriginate its router-LSA. Or the router may wish\nto delete one of its self-originated LSAs, in which case it sets the LSA's LS Age field to\nMaxAge. In any case, the router then floods the LSA, packaging the LSA within a Link\nState Update packet, which may or may not contain other LSAs, and then sending the\nLink State Update packet out all of its interfaces.\nWhen one of the router's neighbors receives the Link State Update packet, the\nneighbor examines each of the LSAs contained within the update. For each LSA that is\nuncorrupted, of known LS type, and more recent than the neighbor's own database\ncopy (if any), the neighbor installs that LSA in its link-state database, sends an acknowl-\nedgment back to the router, repackages the LSA within a new Link State Update packet,\nand sends it out all interfaces except the one that received the LSA in the first place. This\nprocedure then iterates until all routers have the updated LSA.\nIn order to achieve reliability, a router will periodically retransmit an LSA sent to a\nneighbor until the neighbor acknowledges receipt of the LSA by sending a Link State\nAcknowledgment packet listing the updated LSA's link-state header.\nFigure 4.8 shows an example of OSPF's flooding. The example starts with router\n10.1.1.3 updating its router-LSA and flooding the LSA to its neighbors at time Tl. The\nexample then makes the simplifying assumptions that each router spends an equal time\nprocessing the update, that transmission time of the update is equal on all links, and\nthat all of the updates are received intact. Note, then, that after a number of iterations\nless than or equal to the diameter of the network (in this example, 3), all routers have the\nupdated LSA. Some further explanation of the example is in order. At time T2, router\n10.1.1.4 seems to receive the update from both 10.1.1.2 and 10.1.1.5 simultaneously.\nWe assume that the update from 10.1.1.5 is processed first, and so at time T3,10.1.1.4\nsends an update to 10.1.1.2 only. After time T3, acknowledgments are sent. In OSPF,\nrouters generally delay acknowledgment of received LSAs, in hope that they can fit\nmore LSA acknowledgments into a single Link State Acknowledgment packet, which\nreduces routing protocol processing and bandwidth consumption. Note also that\nnot all updates require explicit acknowledgment. When updates cross, with each\nneighbor sending the other the same update (as in the case of routers 10.1.1.1 and\n10.1.1.2 at time T2), the received update is taken as an implicit acknowledgment, and",
        "621593db-de87-4dda-9a91-4fc838def3ae": "Section 4.7 Database Synchronization 93\nno corresponding Link State Acknowledgment packet is required to be sent. In fact,\nas a result of this property, in any link direction, one update or acknowledgment is\nsent but never both.\nFigure 4.8 Reliable flooding, starting at 10.1.1.3, where M is a Link State Update packet and ack is a Link State\nAcknowledgment packet.\nThe preceding example has described flooding in a network of routers connected\nvia serial lines. When different network segment types, such as broadcast networks, are\npresent or when some routers run optional extensions to the OSPF protocol, flooding\ncan get more complicated, as illustrated in Chapters 5 and 7.",
        "fcb989c9-8bf7-45b2-b0cf-7a3a83bf0e1c": "94 OSPF Basics Chapter 4\n4.7.3 Flooding Robustness\nOSPF's reliable-flooding scheme is robust in the face of errors. Just what do we mean by\nrobust in this case? Even when transmission errors, link and/or router failures occur,\nthe network continues to function correctly; link-state databases continue to be synchro-\nnized, and the amount of routing traffic remains at an acceptable level. OSPF's flooding\nachieves this robustness because of the following features.\n\u2022 Flooding could be restricted to a minimal collection of links interconnecting\nall routers (called a spanning tree). As long as the links in the spanning tree\nremain operational, router databases would remain synchronized. However,\nOSPF does not use a spanning tree; it floods over all links. As a result, the\nfailure of any link does not significantly disrupt database synchronization,\nas LSA updates simultaneously flow on alternate paths around the link\nfailure.\n\u2022 Because of software errors, a router might accidentally delete one or more\nLSAs from its database. To ensure that the router eventually regains database\nsynchronization with the rest of the OSPF routing domain, OSPF mandates\nthat all originators of LSAs refresh their LSAs every 30 minutes, incrementing\nthe LSAs' sequence numbers and reflooding them throughout the routing\ndomain.\n\u2022 To detect corruption of LSAs as they are flooded, each LSA contains a checksum\nfield. An LSA's checksum is originally calculated by the LSA's originator and\nthen becomes a permanent part of the LSA. When a router receives an LSA dur-\ning flooding, it verifies the LSA's checksum. A checksum failure indicates that\nthe LSA has been corrupted. Corrupted LSAs are discarded and not acknowl-\nedged, in hope that the retransmitted LSA will be valid.\n\u2022 Errors in implementation might lead to situations in which the routers disagree\non which LSA instance is more recent, possibly causing flooding loops. An\nexample of this is the problem caused by the ARPANET routing protocol's cir-\ncular sequence space (see Section 4.2.2). To guard against this kind of problem,\nan OSPF router increments an LSA's LS Age field when placing the LSA into a\nLink State Update packet. This behavior eventually breaks flooding loops, as a\nlooping LSA's LS Age field will eventually hit the value MaxAge, at which time\nthe LSA will be discarded. This behavior is similar to the breaking of IP for-\nwarding loops through the use of the IP header's TTL field.\n\u2022 To guard against a rapidly changing network element (for example, a link\nbetween routers that is continually going up and down) causing an excessive\namount of control traffic, OSPF imposes rate limits on LSA origination; any par-\nticular LSA can be updated at most once in every 5 seconds (MinLSInterval).",
        "5bd27c87-c93a-4208-b5c0-00786c678d24": "96 OSPF Basics Chapter 4\ncosts, since the cost of a path is set equal to the sum of the cost of its constituent links.\nFor example, link delay makes a perfectly good metric. So does hop count: If you set the\ncost of each link to 1, the cost of a path is the number of links in the path.\nThe link-state database for the network of Figure 4.1 is shown in Figure 4.9. The\nmetrics used in this example are what some people call weighted hop count. Small inte-\ngers are assigned to each link, with more preferred links getting smaller values than oth-\ners. Link costs have been assigned symmetrically in this example, although they do not\nhave to be. Each router can advertise a different cost for the router's own link direction.\nIf costs are assigned asymmetrically, paths will in general be asymmetric, with packets\nin one direction taking a given path and responses traveling a different path. IP works\nfine in the face of such asymmetric paths, although many network administrators dis-\nlike asymmetry, because it makes routing problems more difficult to debug.\nFigure 4.9 Link-state database as directed graph.\nNote that each link is advertised by two routers, namely, those at either end of the\nlink. For example, the link between 10.1.1.2 and 10.1.1.4 is advertised by both routers in\ntheir router-LSAs, each with a cost of 1. In order to avoid using stale information in the\nrouting calculation, OSPF requires that both routers advertise the link before it can be\nused by the routing calculation. For example, suppose that router 10.1.1.4 in Figure 4.9\nfails. Router 10.1.1.4's router-LSA, advertising the now inoperational links to routers\n10.1.1.2,10.1.1.5, and 10.1.1.6, will persist in the link-state database for up to an hour.\nBut since these routers will no longer be advertising their halves of the links to 10.1.1.4,\ndata traffic will be successfully rerouted around the failure.\nThe link-state database in Figure 4.9 reconstitutes the network map, in the form of a\ndirected graph. The cost of a path in this graph is the sum of the path's component link\ncosts. For example, there is a path of cost 4 from router 10.1.1.3 to 10.1.1.4, going through\nrouter 10.1.1.5. On the graph, a router can run any algorithm that calculates shortest\npaths. An OSPF router typically uses Dijkstra's Shortest Path First (SPF) algorithm [230]\nfor this purpose.\nDijkstra's algorithm is a simple algorithm that efficiently calculates all at once the\nshortest paths to all destinations. The algorithm incrementally calculates a tree of short-\nest paths. It begins with the calculating router adding itself to the tree. All of the router's",
        "ca94c742-4363-4a75-ae7a-d363f3061389": "Section 4.8 Routing Calculations 97\nneighbors are then added to a candidate list, with costs equal to the cost of the links from\nthe router to the neighbors. The router on the candidate list with the smallest cost is then\nadded to the shortest-path tree, and that router's neighbors are then examined for\ninclusion in (or modification of) the candidate list. The algorithm then iterates until the\ncandidate list is empty.\nAs an example, Table 4.3 shows Dijkstra's algorithm as run by router 10.1.1.3 in Fig-\nure 4.9. At each iteration, another router is added to the tree of shortest paths. While on\nthe candidate list, each destination is listed with its current cost and next hops. These\nvalues are then copied to the routing table when the destination is moved from the can-\ndidate list to the shortest-path tree. The boldface type in Table 4.3 indicates those places\nwhere a destination is first added to the candidate list or when its values on the candi-\ndate list are modified. For example, in iteration 4, destination 10.1.1.6's entry on the\ncandidate list is modified when a shorter path is discovered by going through router\n10.1.1.4.\nTable 4.3 Dijkstra Calculation Performed by Router 10.1.1.3\nAs you can see by going through the example, Dijkstra's algorithm ends up\nexamining each link in the network once. When examining the link, the algorithm may\nplace a destination onto the candidate list or modify a destination's entry on the candi-\ndate list. This operation also requires a sort of the candidate list, because we always\nwant to know which destination on the candidate list has the smallest cost. Since the\nsort is an O(log(n)) operation and the size of the candidate list never exceeds the number\nof destinations, the performance of Dijkstra's algorithm is O(/ * log(n)), where / is theDestination Added Candidate List\nto Shortest-Path Tree Destination (cost, next hops)\n1 10.1.1.3\n2 10.1.1.5\n3 10.1.1.2\n4 10.1.1.4\n5 10.1.1.1\n6 10.1.1.610.1.1.5 (1, 10.1.1.5)\n10.1.1.2 (3, 10.1.1.2)\n10.1.1.1 (5, 10.1.1.1)\n10.1.1.2 (3, 10.1.1.2)\n10.1.1.4 (4, 10.1.1.5)\n10.1.1.1 (5, 10.1.1.1)\n10.1.1.6 (11, 10.1.1.5)\n10.1.1.4 (4, 10.1.1.5, 10.1.1.2)\n10.1.1.1 (5, 10.1.1.1)\n10.1.1.6(11,10.1.1.5)\n10.1.1.1(5,10.1.1.1)\n10.1.1.6 (10, 10.1.1.5, 10.1\n10.1.1.6(10,10.1.1.5,10.1\nEmpty1.2)\n1.2)",
        "d5cca10e-ff13-4cd5-b3f6-a27cd9e10309": "98 OSPF Basics Chapter 4\nnumber of links in the network and n is the number of destinations (in our example,\nequal to the number of routers). In some books on data structures, Dijkstra's algorithm\nis stated somewhat differently for fully mesh-connected networks (every router directly\nconnected to every other router); for these networks, the algorithm's performance can\nbe seen to be O(rt2).\nThe resulting shortest paths calculated by router 10.1.1.3 in our sample network are\ndisplayed in Figure 4.10. Multiple shortest paths have been found to 10.1.1.4, allowing\nload balancing of traffic to that destination (called equal-cost multipath). An OSPF\nrouter knows the entire path to each destination. However, in IP's hop-by-hop routing\nparadigm, only the first hop is needed for each destination. Extracting this infor-\nmation from the collection of shortest paths yields the IP routing table, as displayed in\nTable 4.4.\n10.1.1.3 10.1.1.5\nFigure 4.10 Shortest paths, as calculated by router 10.1.1.3.\nTable 4.4 Router 10.1.1.3's IP Routing Table\nDestination\n10.1.1.1\n10.1.1.2\n10.1.1.4\n10.1.1.5\n10.1.1.6Next Hop(s)\n10.1.1.1\n10.1.1.2\n10.1.1.2\n10.1.1.5\n10.1.1.5\n10.1.1.2\n10.1.1.5Cost\n5\n3\n4\n1\n10\nThe routing calculation is the simplest part of OSPF. However, in the presence of\nnetwork segments other than point-to-point links or when OSPF hierarchical routing or\nsome of the OSPF extensions are used, the routing calculations get a little more compli-\ncated, as we will see later.",
        "289ba189-5aff-45fe-b350-70946517f908": "Section 4.8 Routing Calculations 99\nFurther Reading\nThe ARPANET'S link-state routing algorithm is described in [147]. The problem caused\nby the ARPANET'S circular sequence space is described in [221]. Suggestions for fixes to\nprevent future occurrences of the ARPANET'S sequence are given in [189].\nThe OSPF specification can be found in [177]. The first three chapters give an over-\nview of the OSPF protocol, although the rest of the specification is really geared to pro-\ntocol implementers.\nFor descriptions of other link-state protocols, see [237].\nExercise\n4.1 Calculate the size in bytes of each of the LSAs in Table 4.2.",
        "dd56fdfa-5f78-4ee1-a26c-29dd997a8db9": "OSPF Network Types\nUntil now, we have addressed how the OSPF protocol runs in network topologies con-\nsisting of routers interconnected with serial lines. Such topologies are where link-state\nprotocols were originally developed (namely, the ARPANET network), and they dem-\nonstrate all the basic elements of a link-state protocol. The bulk of the routing literature\nalso concentrates on point-to-point network topologies.\nHowever, the Internet contains many other subnet (that is, data-link) technologies,\nall capable of joining more than two routers to a single medium: Ethernets, 802.5 Token\nRings, FDDI rings, Frame Relay subnets, ATM, SMDS, packet radio, and so on. OSPF\nruns over these subnet technologies, although somewhat differently from the way it\nruns over point-to-point links. In the OSI reference model, these differences would be\ncalled subnetwork-dependent convergence functions.\nThe differences in the way that OSPF runs over the various subnet technologies can\nbe grouped as follows.\n\u2022 Neighbor discovery and maintenance. OSPF always accomplishes this task through\nits Hello protocol, but the Hello protocol runs differently on different subnet\ntypes.\n\u2022 Database synchronization. How does one synchronize the link-state database over\nthe subnet? Which routers become adjacent, and how does reliable flooding\ntake advantage of any special properties that the subnet might provide?\n101",
        "42762868-e9d7-4774-ac88-4f231c5cd459": "102 OSPF Network Types Chapter 5\n\u2022 Abstraction. In the OSPF link-state database, how does one represent the subnet\nand router connectivity over the subnet?\nOSPF divides the various subnet technologies into the following classes: point-to-\npoint subnets, broadcast subnets, nonbroadcast multiaccess (NBMA) subnets, and\nPoint-to-MultiPoint subnets. The point-to-point subnet case has already been discussed.\nBefore exploring these other subnet technologies in Sections 5.2,5.3, and 5.4, we must\nfirst understand how OSPF uses the IP subnet model.\n5.1 The IP Subnet Model\nIn TCP/IP, every link (or physical subnet) is assigned one or more address prefixes.\nEach address prefix is called an IP subnet. For example, suppose that an Ethernet seg-\nment was assigned the set of addresses beginning with the first 24 bits of 10.3.2.0. This is\nusually written as the prefix 10.3.2.0/24. Sometimes it is also said that the Ethernet seg-\nment's subnet number is 10.3.2.0 and that its subnet mask is 255.255.255.0. The subnet\nmask may also be written as the hexadecimal OxffffffOO. In any case, it means that all\nrouters and hosts connected to the Ethernet segment have IP addresses in the range\n10.3.2.0 to 10.3.2.255.\nIP routes to subnets, not to individual hosts. IP routing protocols advertise routes to\naddress prefixes, and each entry in an IP routing table is an address prefix.\nThe IP subnet model generally contains the following rules.\n\u2022 Two hosts on different IP subnets cannot send IP packets directly to each other\n(or, as we say, cannot talk directly) but instead must go through one or more IP\nrouters.\n\u2022 In the converse of the preceding rule, it is assumed that two hosts/routers on a\ncommon subnet can send packets directly to each other.\n\u2022 Two routers cannot exchange routing information directly unless they have one\nor more IP subnets in common. (This is true only for routers exchanging infor-\nmation via Interior Gateway Protocols. When running Exterior Gateway Proto-\ncols, such as BGP, two routers generally need either a common IP subnet or to\nbelong to the same Autonomous System.)\nMultiple subnets (in other words, IP prefixes) can be assigned to a physical link. In\nthis case, the IP subnetting rules say that two hosts on separate subnets cannot talk\ndirectly, even if they are on the same physical link. Figure 5.1 gives an example of an\nEthernet segment that has been assigned two IP subnets: 10.3.2.0/24 and 10.3.3.0/24.\nEach subnet has two hosts, and a router has addresses on both. The physical connectiv-\nity shows all hosts and the router on a common link, and the IP connectivity shows two\nseparate segments connected by an IP router (see Figure 5.2).",
        "ded747b5-0b63-4413-a4cc-6c6647298677": "Section 5.1 The IP Subnet Model 103\nFigure 5.2 Resulting IP connectivity.\nOf course, rules in IP are made to be broken, or at least bent, and the IP subnet\nmodel is no exception. For example, [24] proposes removing the restriction that two IP\nentities must share a common IP prefix in order to talk directly. The Next Hop Resolu-\ntion Protocol (NHRP) [123] actively tries to find shortcuts between routers on different\nsubnets. In IPv6, two nodes can talk directly whenever they are connected to the same\nphysical media, regardless of their addresses. Even OSPF's Point-to-MultiPoint network\nmodel breaks the rule that two routers on the same subnet must be able to talk directly.",
        "5fd5568d-5686-4275-92fc-79475717248a": "104 OSPF Network Types Chapter 5\nIP multicast does not use the IP subnet model either. When a multicast datagram is\nsent onto a physical link, usually as a data-link multicast, all IP multicast routers on the\nlink get it, regardless of IP subnet boundaries. IGMP ignores IP subnets also.\nHowever, OSPF in general enforces the IP subnet model. Two OSPF routers will\nnever form a neighbor relationship and hence will never forward packets directly\nbetween each other unless they share a common prefix. This behavior is accomplished\nvia OSPF's Hello protocol. An OSPF router creates a separate OSPF interface for each IP\nsubnet that the router connects to (that is to say, has addresses in). When an OSPF router\nsends a Hello packet out an interface, the router sets the IP source address in the Hello\nto the router's IP address on the subnet and includes the subnet mask in the body of the\nHello. Routers receiving the Hello will accept it only if (a) both routers agree on the sub-\nnet mask and (b) both router interfaces (sender and receiver) attach to the same subnet.\nFor example, suppose that all the hosts and routers in Figure 5.1 were OSPF routers.\nThen the router with two addresses would have two OSPF interfaces and would be\nsending Helios out both interfaces, even though the Helios in either case would appear\non the same Ethernet segment. The Hello sent out the router's 10.3.2.1 interface would\nbe accepted by both routers 10.3.2.2 and 10.3.2.3 but would be rejected by routers\n10.3.3.2 and 10.3.3.3 for being associated with the wrong IP subnet. The Hello sent out\nthe router's 10.3.3.1 interface would be handled similarly, with the result being the\nOSPF neighbor relationships as shown in Figure 5.2.\nA number of problems have been caused by the fact that MOSPF is built on top of a\nprotocol that respects that IP subnet model (namely OSPF), whereas IP multicast does\nnot. These problems will be considered in Chapter 10, MOSPF.\n5.2 Broadcast Subnets\nA broadcast subnet is a data link whereby an attached node can send a single packet that\nwill be received by all other nodes attached to the subnet. The canonical example is an\nEthernet. When a station on an Ethernet sends an Ethernet packet, all other stations hear\nthe packet, but their Ethernet adapters discard the packet unless it is addressed to either\nthe adapter's own unique 48-bit Ethernet MAC address or to the Ethernet broadcast\naddress Oxffffffffffff. The latter type of packet is termed a broadcast packet. Broadcast is\nvery useful for (a) autoconfiguration and (b) replicating information, as we will see.\nOther examples of broadcast subnets are 802.5 Token Rings, FDDI rings, and SMDS\nsubnets.\nAn additional useful capability of some broadcast networks is multicast. Multicast is\nthe ability of a node to send onto the subnet a single packet that will be accepted by\nsome subset of nodes on the subnet. Again using Ethernet as an example, Ethernet mul-\nticast addresses are those 48-bit Ethernet addresses having the least significant bit of the\nmost significant byte set to 1 (namely, OxOlxxxxxxxxxx). A node typically can program\nits Ethernet adapter to accept one or more specific multicast addresses. Then, when",
        "73f0476e-8265-4f2b-ac51-461db997c4c3": "Section 5.2 Broadcast Subnets 105\npackets are sent to a given multicast address, only those nodes interested in the multi-\ncast address will accept the packet. This behavior allows a subset of nodes on the Ether-\nnet to converse, without adversely affecting the other nodes on the Ethernet. Some\nsubnet technologies, such as Ethernet and FDDI (Fiber Distributed Data Interface), offer\nvery good multicast capabilities. Other broadcast subnets offer no multicast capabilities,\nor their multicast is of such limited scope (such as Token Ring and SMDS) as to be of no\nuse to TCP/IP applications such as OSPF.\n5.2.1 Neighbor Discovery and Maintenance\nConsider the five OSPF routers connected to an Ethernet segment in Figure 5.3, all\nattached to the IP subnet 10.4.7.0/24. Each OSPF router joins the IP multicast group\nAllSPFRouters (224.0.0.5). On Ethernets, IP multicast addresses map algorithmically to\nEthernet multicast addresses: The last 23 bits of the IP multicast address are appended\nto the multicast block OxOlOOSexxxxxx. So the OSPF routers end up programming their\nEthernet adapters to accept Ethernet multicasts to Ox01005e000005.\nEach OSPF router then periodically multicasts its Hello packets (once every\nHellolnterval seconds, just as on point-to-point links) to the IP address 224.0.0.5. When\nrouter 10.4.7.1 multicasts its Hello packet, routers 10.4.7.2-10.4.7.5 all receive the Hello.\nRouter 10.4.7.1 also indicates that it can hear the other routers' Helios, by listing all of\ntheir OSPF Router IDs in the body of the single Hello (see Section 4.6). In this way,\nrouter 10.4.7.1 maintains its relationships with all other OSPF routers by sending a sin-\ngle packet instead of sending a separate packet to each neighbor on the Ethernet.\nFigure 5.3 Ethernet segment with five OSPF routers attached.",
        "35ba7061-6a45-49e0-8bd8-0b54fbd93310": "106 OSPF Network Types Chapter 5\nThe advantages of OSPF's Hello protocol over broadcast subnets are as follows.\n\u2022 Automatic discovery of neighbors. By multicasting to a well-known address, neigh-\nboring routers discover each other without needing any configuration.\n\u2022 Efficiency. When n OSPF routers are on a broadcast segment, there are\nn * (n - 1) / 2 neighbor relationships. However, these neighbor relationships are\nmaintained by sending only n Helios, one by each router, every Hellolnterval\nseconds.\n\u2022 Isolation. If the broadcast subnet has sufficient multicast capability, such as\nEthernet, the Hello protocol operates without disturbing non-OSPF nodes on\nthe broadcast segment. If multicast is not supported, OSPF's AllSPFRouters\naddress gets mapped into the data-link broadcast address. The disadvantage of\nusing the data-link broadcast address is that all nodes on the Ethernet, whether\nthey are OSPF routers or not, will receive the OSPF Hello packets. Nodes other\nthan OSPF routers would discard the packets, of course, but the act of discard-\ning them still consumes valuable processing time.\n5.2.2 Database Synchronization\nOn a broadcast subnet with n OSPF routers, there are n * (n - 1) / 2 neighbor pairs. If\nyou try to synchronize databases between every pair of routers, you end up with a large\nnumber of Link State Updates and Acknowledgments being sent over the subnet.\nOSPF solves this problem by electing a Designated Router for the broadcast sub-\nnet. All other routers keep their databases synchronized with the Designated Router,\nusing the normal procedures of Database Exchange and reliable flooding (see Sec-\ntion 4.7). Instead of n * (n - 1) / 2 adjacencies over the broadcast subnet, there are now\nonly n.\nUsing a Designated Router is more efficient than synchronizing between every pair\nof routers attached to the broadcast subnet, but it is less robust. If the Designated Router\nfails, so does database synchronization over the broadcast subnet. OSPF deals with this\nproblem by electing a Backup Designated Router for the broadcast subnet. All routers\nnow synchronize with both the Designated Router and the Backup Designated Router,\nand the Backup Designated Router acts as a hot standby in case the Designated Router\nfails. In fact, even before the failure of the Designated Router is noticed, the Backup\nDesignated Router keeps reliable flooding running smoothly over the broadcast subnet.\nWith the advent of the Backup Designated Router, there are now 2n -1 adjacencies over\nthe broadcast subnet.\nFor example, suppose that in Figure 5.3, router 10.4.7.3 has been elected Designated\nRouter and 10.4.7.2 Backup Designated Router. The set of adjacencies formed over the\nEthernet segment are then indicated in Figure 5.4.",
        "cb906cf2-dadf-4ae6-803e-9f7c66a5f4cd": "Section 5.2 Broadcast Subnets 107\n10.4.7.1\n10.4.7.4 10.4.7.5\nFigure 5.4 Flooding adjacencies when 10.4.7.3 and 10.4.7.2 are Designated Router and Backup Designated\nRouter, respectively.\nTo see how reliable flooding works over a broadcast subnet, suppose that, in Fig-\nure 5.4, Router 10.4.7.5 receives a new LSA from one of its other links. The router then\ninstalls the LSA in its link-state database and then wants to flood it to both 10.4.7.3 and\n10.4.7.2 (the Designated Router and Backup Designated Router, respectively). To do\nso, router 10.4.7.5 sends a Link State Update to the IP multicast address AllDRouters\n(224.0.0.6), which only the Designated Router and the Backup Designated Router listen\nto. Both the Designated Router and the Backup Designated Router then receive the LSA;\nthe Designated Router sends the LSA back onto the Ethernet segment in a Link State\nUpdate addressed to AllSPFRouters, updating the rest of the routers on the Ethernet.\nThe Backup Designated Router has deferred its flooding responsibilities on the Ethernet\nto the Designated Router; however, if the Backup Designated Router does not see the\nLink State Update from the Designated Router within the LSA retransmission interval\n(typically 5 seconds), it will step in and flood the LSA back onto the Ethernet in order to\nkeep the database synchronization going.\nDesignated Router Election\nThe Designated Router election process works as follows, using data transmitted in\nHello packets. The first OSPF router on an IP subnet always becomes Designated\nRouter. When a second router is added, it becomes Backup Designated Router.\nAdditional routers added to the segment defer to the existing Designated Router\nand Backup Designated Router; the only time the identity of the Designated Router or\nBackup Designated Router changes is when the existing Designated Router or Backup\nDesignated Router fails.\nIn the event of the failure of a Designated Router or Backup Designated Router,\nthere is an orderly changeover. Each OSPF router has a configured Router Priority\nvalue, a value between 0 and 127 inclusive. When, for example, the Designated Router\nfails, the Backup Designated Router is promoted to Designated Router, and the remain-\ning router having the highest Router Priority becomes the Backup Designated Router,\nusing the routers' OSPF Router ID to break ties. Then the new Backup Designated",
        "a94f3cf8-8025-4b7a-b6f7-bb1a5ec993e1": "108 OSPF Network Types Chapter 5\nRouter has to start the time-consuming procedure of initial database synchronization or\nDatabase Exchange with all other routers on the subnet.\nSince being Designated Router or Backup Designated on a subnet consumes addi-\ntional resources, you may want to prevent certain routers from assuming these roles.\nThis is done by assigning those routers a Router Priority of 0.\nOne other time that Router Priority comes into play is in partitioned subnets. When\na subnet is partitioned into two pieces, two Designated Routers are elected, one for each\npartition. When the partition heals, the Designated Router with the higher Router Prior-\nity assumes the role of Designated Router for the healed subnet.\n5.2.3 Abstraction\nThe common theme in running OSPF over broadcast subnets is reducing an O(n ) prob-\nlem to O(n). Representation of broadcast subnets in the link-state database is no excep-\ntion. We want to capture the fact that each of the routers connected to the broadcast\nsubnet can talk to each other directly. The obvious way to do this is for each router to\ninclude links to all other routers in its router-LSA. But this would introduce n* (n-l)\nlinks into the OSPF database. So instead, OSPF creates a new LSA type, called the\nnetwork-LSA, to represent the broadcast subnet. Each router-LSA then has a link to\nthe broadcast subnet's network-LSA, and the network-LSA has links to each of the\nrouter-LSAs, reducing the number of links from n * (n - 1) to n * 2. These two alterna-\ntives are shown in Figures 5.5 and 5.6.\nFigure 5.5 One possible representation of router connectivity of a broadcast subnet.",
        "5d565405-3b0a-4a41-adc6-e2abc90e180d": "Section 5.2 Broadcast Subnets 109\nFigure 5.6 OSPF's representation of a broadcast subnet, using a network-LSA.\nOf course, most broadcast subnets do not have a computer processor, and so\nthe subnet cannot originate the network-LSA itself. Instead the Designated Router\noriginates the network-LSA on the subnet's behalf. OSPF also uses the network-LSA to\nindicate the state of database synchronization. The Link State ID of the network-LSA\nis the IP address of the Designated Router; when a router-LSA includes a link to the\nnetwork-LSA, the originating router is saying, \"I have an interface on this subnet and\nmy database is synchronized with the Designated Router.\" Likewise the network-LSA\nlists those routers whose databases have been synchronized with the Designated\nRouter. As in the point-to-point network case, this synchronization property ensures\nthat routers will calculate shortest-path trees containing only those routers that are able\nto make consistent routing calculations, which in turn ensures loop-free forwarding (see\nSection 4.8).\nThis synchronization guarantee provides another example of why OSPF uses a\nBackup Designated Router. When a Designated Router fails, a new network-LSA\nmust be originated by the new Designated Router. Timely promotion of the Backup\nDesignated Router, which is already synchronized with the other routers, ensures that\nthis new network-LSA will immediately list all the subnet's routers and hence that for-\nwarding of data traffic over the subnet will continue uninterrupted.\nThe network-LSA for the subnet in Figure 5.3, assuming that 10.4.7.3 has been\nelected Designated Router, is shown in Figure 5.7. This figure assumes that 10.1.1.3 is\nthe Designated Router's OSPF Router ID, which is probably an address assigned to\nanother of the router's OSPF interfaces.",
        "2694cc1a-59dd-4609-9b9d-fa7a7d1af825": "110 OSPF Network Types Chapter 5\nFigure 5.7 Network-LSA for subnet 10.4.7.0/24, assuming that router 10.4.7.3 has been elected Designated\nRouter.\n5.2.4 Problems\nWhen OSPF runs over broadcast networks, it assumes transitive connectivity: If router\nA can talk to the Designated Router and if the Designated Router can talk to router C,\nthen routers A and C can also talk directly. This assumption underlies the network-LSA\nabstraction in the previous section; using the network-LSA generated by the Designated\nRouter, A will calculate routes with router C as next hop, possibly without ever having\nexchanged any packets (including Helios) with router C directly.\nFortunately the transitivity assumption is valid for most common broadcast subnet\ntechnologies, such as Ethernet. However, it is not always valid for subnet technologies\nthat are themselves composed of data-link switches, such as SMDS (we also call these\ncloud subnets). These subnets may sometimes be better candidates for the Point-to-\nMultiPoint subnets (see Section 5.4).LS Age\nOptions LS Type\nLink State ID -\n- Advertising Router \u2014\n- LS Sequence Number \u2014\nLS Checksum\nLength\n\u2014 Network Mask \u2014\n\u2014 Attached router 1 \u2014\n\u2014 Attached router 2 \u2014\n\u2014 Attached router 3 \u2014\n\u2014 Attached router 4 \u2014\n\u2014 Attached router 5 \u20140 seconds\nE-bit, LS Type 2 (network-LSA)\n10.4.7.3\n10.1.1.3\n0x80000010\nOx7c23\n44 bytes\n255.255.255.0\n10.4.7.3\n10.4.7.1\n10.4.7.5\n10.4.7.4\n10.4.7.2",
        "57521df6-21f8-425f-ad01-8ac51f1edceb": "Section 5.3 NBMA Subnets 111\nPacket-radio subnets also fail the transitivity assumption, due to line-of-sight prob-\nlems. Packet radio subnets are good candidates for treatment as Point-to-MultiPoint\nsubnets, with the OSPF Demand Circuit extensions enabled to reduce routing traffic to a\nminimum because of packet radio's bandwidth limitations (see Section 7.3).\n5.3 NBMA Subnets\nNonbroadcast multiaccess (NBMA) segments support more than two routers and allow\nany two routers to communicate directly over them but do not support a data-link\nbroadcast capability. Examples include X.25, Frame Relay, or asynchronous transfer\nmode (ATM) subnets that support either (a) switched virtual circuits (SVCs) or (b) a full\nmesh of PVCs connecting each pair of routers.\nAny NBMA subnet can also be modeled as a Point-to-MultiPoint segment (see Sec-\ntion 5.4). NBMA segments are efficient in terms of neighbor maintenance, database syn-\nchronization, and database representation, reducing O(n2) relationships to O(n) by using\nsimilar mechanisms to those used for broadcast subnets. However, NBMA segments\nhave weird failure modes when two attached routers cannot communicate directly\n(see Section 5.3.4), sometimes making the Point-to-MultiPoint model the more robust,\nalthough less efficient, choice.\nAn example of an NBMA segment is shown in Figure 5.8. A collection of six routers\nis attached to a Frame Relay subnet, with each router connected to every other router\nvia a Frame Relay PVC. A single IP subnet will be assigned to the NBMA segment, with\nall routers having IP interface addresses on the segment.\n5.3.1 Neighbor Discovery and Maintenance\nSince there is no broadcast capability on an NBMA subnet, OSPF neighbors must be dis-\ncovered initially through configuration. Configuration is restricted to routers eligible to\nbecome Designated Router (that is, those whose Router Priority on the NBMA subnet is\nnonzero). To make administration easier and to reduce the amount of Hello traffic, most\nrouters attached to the NBMA subnet should be assigned a Router Priority of 0. In rout-\ners eligible to become Designated Router, the identity of all other routers attached to the\nNBMA subnet must be configured, as well as whether those routers themselves are eli-\ngible to become Designated Router.\nIn order to implement Designated Router election, routers that are eligible to\nbecome Designated Router send one another Helios every Hellolnterval (typically 10)\nseconds. Additionally the routers that have been elected Designated Router and Backup\nDesignated Router send Helios to all other routers on the NBMA subnet. These Helios\nare initially sent also every Hellolnterval seconds, but since typical NBMA networks\nhave a habit of charging per packet, the rate of sending Helios when the other router",
        "353e98ea-9433-4c5c-8ba5-39147764aafd": "112 OSPF Network Types Chapter 5\nFrame Relay\nsubnet\n10.5.5.0/24\nFigure 5.8 Sample NBMA subnet: a Frame Relay subnet, with a full mesh of PVCs shown as dashed lines.\ndoes not respond slows eventually to Polllnterval seconds (typically 120). In contrast,\nrouters with Router Priority of 0 simply send Helios to the current Designated Router\nand Backup Designated Router every Hellolnterval seconds.\nFor example, in Figure 5.8, assume that routers A and B have been elected\nDesignated Router and Backup Designated Router, respectively; that router F has a\nRouter Priority of 1; and that all other routers have a Router Priority of 0. Assume fur-\nther that router C has been inoperational for some time. Then routers A and B will be\nsending separate Helios to each of D, E, and F every 10 seconds and will be polling\nrouter C every 2 minutes to see whether it has come up. Also, D, E, and F will be\nresponding to A and B with Helios of their own every 10 seconds.\n5.3.2 Database Synchronization\nDatabase synchronization on NBMA networks works the same as on broadcast net-\nworks. A Designated Router and Backup Designated Router are elected; all other rout-\ners initially perform Database Exchange with the Designated Router and Backup\nDesignated Router, and flooding over the NBMA always goes through the Designated\nRouter on the way to the other routers attached to the NBMA subnet. The only differ-\nence is that, where on broadcast subnets one would be sending Link State Updates to",
        "f78b8519-6943-4440-9ede-3808c5df507a": "Section 5.3 NBMA Subnets 113\nthe multicast addresses AllSPFRouters and AllDRouters, on NBMA subnets, Link State\nUpdates must be replicated and sent to each adjacent router separately.\n5.3.3 Abstraction\nRepresentation of an NBMA subnet within the OSPF link-state database is indistin-\nguishable from the representation of a broadcast subnet. A network-LSA is originated\nfor the NBMA subnet by the Designated Router, and all router-LSAs originated by the\nsubnet's routers contain links to the network-LSA.\n5.3.4 Problems\nMany nonbroadcast subnets cannot support a large number of routers, with each router\npair being able to communicate directly. In a subnet providing only a PVC service, the\ncost of this many PVCs may be prohibitive. For example, to connect 100 routers in a full\nmesh over a Frame Relay subnet would require 4,950 PVCs. Even when SVCs are used,\ncapacity limitations may prohibit pairwise connectivity. Unless each router on the\nsubnet can communicate directly with every other router, the NBMA model cannot\nbe used.\nHowever, a partial mesh can be turned into multiple NBMA networks, although the\nconfiguration can get quite complicated (see [65]). Consider, for example, the Frame\nRelay subnet in Figure 5.9. Although PVCs do not interconnect every pair of routers,\nthree- overlapping router subsets can be found, each of which is full-mesh connected:\n{F,A,B}, (B,C,D), and {D,E,F}. Each of these subsets is assigned its own IP subnet. Those\nrouters attached to more than one subnet then end up with multiple IP addresses and\nOSPF interfaces, each attaching to a different IP subnet.\nNBMA networks are only as robust and reliable as the underlying data-link service.\nIf, for example, a PVC fails or is misconfigured or if an SVC cannot be established, due\nto capacity or policy reasons, routing over the NBMA subnet will fail. And, unfortu-\nnately, often the reason for the failure will not be immediately obvious to the network\noperator.\nTake, for example, the network in Figure 5.8. Suppose that router A has been elected\nDesignated Router. If then the PVC between routers E and B fails, all routing tables\nwould look correct in the routers, but any packets that B was supposed to forward to E,\nor vice versa, would fall into a black hole. If instead the PVC between A and F fails,\nrouting between routers A through E would continue to work, but F would be isolated\nfrom all other routers on the NBMA subnet, even from those with which it continues to\nmaintain PVCs.\nThe Point-to-MultiPoint model can always be applied to rectify these problems,\nalthough at some loss of efficiency. This model is described next.",
        "02b8ebc4-7be1-4a94-84a7-7385fe051bb4": "114 OSPF Network Types Chapter 5\n10.5.6.4 Frame Relay\n10.5.7.4 subnet\nFigure 5.9 Frame Relay network with partial PVC mesh, implemented as multiple NBMA subnets.\n5.4 Point-to-MultiPoint Subnets\nThe Point-to-MultiPoint model can be used on any data-link technology that the NBMA\nmodel can be used on. Usually these subnets are connection-oriented subnets, such as\nFrame Relay and ATM. In addition, the Point-to-MultiPoint model drops the require-\nment that all routers on the subnet be able to communicate directly, making it possible\nto model partial PVC meshes as single Point-to-MultiPoint networks. Dropping the full-\nmesh requirement also allows the modeling of more exotic data-link technologies, such\nas packet radio, as Point-to-MultiPoint networks.\nFor example, the partial PVC mesh in Figure 5.9 can be turned into the single OSPF\nPoint-to-MultiPoint subnet with prefix 10.6.6.0/24 as pictured in Figure 5.10. Each OSPF\nrouter would have a single IP address on the subnet: Router A would be assigned the IP\naddress 10.6.6.1, and so on. Each router would have a single OSPF interface to the sub-\nnet, although multiple OSPF neighbor relationships would form over that interface:\nRouter A would form neighbor relationships with F and B; B with A, C, D, and F; and\nso on.\nWhen the Point-to-MultiPoint model is used on a subnet built out of PVCs, the\noperation of OSPF is very similar to treating each PVC as if it were a serial line, as we\nshall see in the following sections. The advantage of using the Point-to-MultiPoint",
        "90565d20-e301-49a6-8424-3c3e5453cfc1": "Section 5.4 Point-to-MultiPoint Subnets 115\nFigure 5.10 Turning the partial mesh of Figure 5.9 into a Point-to-MultiPoint subnet.\nmodel is in the possibility of autoconfiguration and the model's robustness. Since the\nPoint-to-MultiPoint model deals well with partial connectivity between attached rout-\ners, the failure of an occasional PVC or SVC causes no problems. In addition, the Point-\nto-MultiPoint model plays well with the Demand Circuit extensions to OSPF (see\nSection 7.3).\n5.4.1 Neighbor Discovery and Maintenance\nThere are no Designated Routers or Backup Designated Routers on Point-to-MultiPoint\nsubnets. On these subnets, the job of the Hello protocol is simply to detect active OSPF\nneighbors and to detect when communication between neighbors is bidirectional.\nBecause Point-to-MultiPoint networks do not have a broadcast capability, it is some-\ntimes necessary to configure the identity of OSPF neighbors in an OSPF router. How-\never, sometimes a router can detect its neighbors dynamically. For example, on a Frame\nRelay subnet using PVCs, a router could use the Link Management Interface (LMI) pro-\ntocol to learn the identity of the PVCs provisioned on the Point-to-MultiPoint interface\nand could then use Inverse ARP (see [25]) to discover the IP addresses of the neighbors\non the other end of the PVC.",
        "5cbf8552-aed8-4230-94dd-810dc1dcc83d": "116 OSPF Network Types Chapter 5\nA router on a Point-to-MultiPoint subnet periodically sends OSPF Helios to all\nother routers on the subnet with which the router can converse directly. For example, in\nFigure 5.10, router A would send separate Helios to routers F and B every 10 seconds;\nrouter B would send separate Helios to routers A, C, D, and F; and so on.\n5.4.2 Database Synchronization\nOn a Point-to-MultiPoint subnet, each router becomes adjacent to all other routers\nwith which it can communicate directly, performing initial database synchronization\nthrough Database Exchange, then participating in reliable flooding with its neighbors.\nFor example, in Figure 5.10, each PVC is an OSPF adjacency. In order to flood an LSA\nfrom router A to router D, the LSA first goes to router B (or one of several alternative\npaths).\n5.4.3 Abstraction\nA router on a Point-to-MultiPoint subnet includes the following links in its router-LSA:\na point-to-point connection for each of its neighbors on the Point-to-MultiPoint subnet\nand a single stub network connection to its own IP interface address (see Section 4.3).\nFor example, router D in Figure 5.10 would include four point-to-point connections in\nits router-LSA (one each to routers B, C, E, and F) and a single stub network connection\nfor its address of 10.6.6.4. Note, then, that to route from 10.6.6.4 to 10.6.6.1, the OSPF\nrouting calculation will calculate a next hop of 10.6.6.2. Even to go between two routers\non the same IP subnet, an intermediate router must be traversed.\n5.4.4 Problems\nWhat the Point-to-MultiPoint model gains in autoconfiguration and robustness, it\nloses in efficiency. The closer the underlying physical subnet comes to providing\nfull-mesh connectivity, the less efficient Point-to-MultiPoint becomes. In fact, a\nfull-mesh Frame Relay or ATM subnet can be configured as a Point-to-MultiPoint\nnetwork, and you may even have to configure it so, if the underlying data-link service\nis unreliable. However, when operating a full-mesh Frame Relay or ATM network\nin Point-to-MultiPoint mode, the work involved in neighbor maintenance, flooding,\nand database representation increases as O(n2), where n is the number of OSPF rout-\ners attached to the subnet, instead of the O(\u00ab) behavior that can be achieved with the\nNBMA model.",
        "1e6272ff-4de0-434a-8394-acb70dfb88dc": "Section 5.4 Point-to-MultiPoint Subnets 117\nFurther Reading\nSee [24] for a description of the enhancements that have been proposed to the IP subnet\nmodel, mainly to support the connection of a large number of routers to connection-\noriented subnets, such as Frame Relay and ATM. One of the technology pieces used in\nthese extensions is NHRP, the protocol described in [123]. Splitting up a partial-mesh\nFrame Relay or ATM subnet into multiple OSPF NBMA subnets is explained in [65].\nExercises\n5.1 In Figure 5.8, when the circuit between router A, the Designated Router, and\nrouter F fails, why is router F isolated from all other routers on the NBMA subnet?\n5.2 In Figure 5.10, what are all the possible paths that an LSA might take as it is\nflooded from router A to router D? Assuming that transmission times on all PVCs\nare equivalent and that router-handling times in all routers are equivalent, how\nmany copies of the LSA is router D likely to receive?\n5.3 Give the router-LSA that will be produced by router A in Figure 5.10.",
        "07627eaf-90ab-47b8-af0a-a40f63db1927": "6\nHierarchical Routing in OSPF\nHierarchical routing is a technique commonly used when building large networks. As a\nnetwork grows, so do the resource requirements for the network's management and\ncontrol functions. In a TCP/IP network, resource consumption includes\n\u2022 Router memory consumed by routing tables and other routing protocol data. In\nan OSPF network, this other data would include the OSPF link-state database.\n\u2022 Router computing resources, used in calculating routing tables and other rout-\ning protocol functions. In an OSPF network, these resources include the CPU\nrequired to calculate shortest-path trees.\n\u2022 Link bandwidth, used in distributing routing data. In an OSPF network, this\nincludes the bandwidth consumed by OSPF's database synchronization pro-\ncedures.\nIt is inevitable that resource requirements grow as the network grows. But the ques-\ntion is, How quickly do resource requirements need to grow? Let's take routing table\nsize as an example. Employing the OSPF protocol as described in Chapter 4, one sees\nthat routing table size increases linearly (specifically, one for one) as the number of\nTCP/IP segments grows. We call this flat routing; each router in the network is aware of\nthe existence and specific addresses belonging to each and every network segment.\nHowever, by employing hierarchical routing, we can slow the rate of routing table\ngrowth to the order of the logarithm of the number of segments, written as O(log(n)),\n119",
        "935cdc02-6664-4d96-8deb-426d769bb3bc": "120 Hierarchical Routing in OSPF Chapter 6\nwhere n is the number of network segments. Figure 6.1 illustrates the difference\nbetween linear and logarithmic routing table growth.\nNumber of network segments\nFigure 6.1 Linear versus logarithmic growth.\nIn hierarchical routing, an internet is partitioned into pieces, which in turn are\ngrouped recursively into levels. At the lowest level, inside one of the lowest-level parti-\ntions, routing is flat, with all routers knowing about all network segments within the\npartition. But the routers have only sketchy information about other partitions. When\nforwarding a packet addressed to a remote destination, the routers rely on the higher\nlevels of hierarchical routing to navigate the internet, eventually locating the partition\ncontaining the destination address.\nFigure 6.2 shows an internet organized into a three-level hierarchy. All addresses\ncome from the address range 10.0.0.0/8. There are three second-level partitions, with\nthe lower left containing the 10.1.0.0/16 addresses, the lower right 10.2.0.0/16, and the\nupper partition 10.3.0.0/16. The nine first-level partitions contain even more specific\naddresses, with the lower-left first-level partition containing the addresses 10.1.1.0/24,\nand so on.\nSuppose that an IP packet is sent by host 10.1.1.6 to the destination 10.3.3.5. The\npacket first appears in the first-level partition 10.1.1.0/24. Since the destination is not in\nthe range 10.1.1.0/24, it is handed to second-level routing in the 10.1.0.0/16 partition\nand then similarly handed to third-level routing. At this point, the packet is forwarded\nto the correct second-level partition (10.3.0.0/16) and then by second-level routing to\nthe correct first-level partition (10.3.3.0/24), whereupon first-level routing delivers the\npacket to the destination. This pattern of forwarding the packet up the hierarchy\u2014first",
        "be81b602-0e1e-4762-bab9-522e34414dbb": "Chapter 6 Hierarchical Routing in OSPF 121\nlevel to second to third and then back down again\u2014is what gives hierarchical routing\nits name.\nFigure 6.2 An internet employing hierarchical routing.\nHierarchical routing reduces routing table size. Suppose that 16 network segments\nare in every first-level partition in Figure 6.2. Let us look at routing from the perspec-\ntive of a router in the first-level partition labeled 10.1.1. If flat routing were deployed\nthroughout the figure, the router would have a routing table consisting of 9 * 16 = 144\nentries, one for every network segment. However, because of the three-level hierarchy,\nthe router has 16 entries for the local segments within 10.1.1.0/24 and additional entries\nfor 10.1.2.0/24,10.1.3.0/24,10.2.0.0/16, and 10.1.0.0/16, for a total of 20 routing table\nentries, a marked reduction from 144.\nThere is often a trade-off involved in the routing table size reduction (and reduction\nin other resources) that can be accomplished with hierarchical routing. Namely, the\ninformation reduction can lead to suboptimal forwarding. Although packets are still\nforwarded to their destinations, the packets may take a longer path than can be found in\na flat routing system. This is illustrated further in Section 6.1.1.",
        "b539c14b-c87a-4fce-bd80-c83f11f0796a": "122 Hierarchical Routing in OSPF Chapter 6\nTo keep the routing table sizes, and therefore the memory and CPU demands, on its\nrouters to a manageable level, the worldwide Internet employs hierarchical routing.\nIP subnetting and CIDR addressing (see Chapter 2) are tools used to implement the\nInternet's routing hierarchy. IP's 32-bit address generally limits the number of hierarchi-\ncal levels to around four, although with IPv6's 128-bit addresses (see Section 1.3), more\nlevels of hierarchy may be possible in the future.\nOSPF implements a two-level hierarchical routing scheme through the deployment\nof OSPF areas, as described in Section 6.1. Furthermore, OSPF allows an internet to be\nsplit into additional levels by incorporating two levels of external routing information\ninto the OSPF routing domain, as explained in Section 6.2.\nHierarchical routing protocols are difficult to design. Most of the protocol bugs\nfound in OSPF over the years have been in the area routing support, some of which\nhave been discovered only recently. See Section 3.5 for a description of the various hier-\narchical routing bugs that have been encountered and repaired in OSPF since its original\ndesign.\n6.1 OSPF Areas\nOSPF supports a two-level hierarchical routing scheme through the use of OSPF areas.\nEach OSPF area is identified by a 32-bit Area ID and consists of a collection of network\nsegments interconnected by routers.\nInside any given OSPF area, OSPF runs as described in Chapters 4 and 5. Each area\nhas its own link-state database, consisting of router-LSAs and network-LSAs describing\nhow the area's routers and network segments are interconnected. Routing within the\narea is flat, with each router knowing exactly which network segments are contained\nwithin the area. However, detailed knowledge of the area's topology is hidden from all\nother areas; the area's router-LSAs and network-LSAs are not flooded beyond the area's\nborders.\nRouters attached to two or more areas are called area border routers, or ABRs. Area\nborder routers leak IP addressing information from one area to another in OSPF sum-\nmary-LSAs. This enables routers in the interior of an area to dynamically discover desti-\nnations in other areas (the so-called inter-area destinations) and to pick the best area\nborder router when forwarding data packets to these destinations.\nFigure 6.3 shows a sample OSPF area configuration having four OSPF areas. Area\n0.0.0.0's link-state database consists of four router-LSAs. Area 0.0.0.1's link-state data-\nbase has four router-LSAs. Area 0.0.0.2's link-state database has three router-LSAs and a\nnetwork-LSA. Area 0.0.0.3's link-state database has three router-LSAs. Since all of area\n0.0.0.1's addresses fall into the range 10.2.0.0/16, routers B and C can be configured to\naggregate area 0.0.0.1's addresses by originating a single summary-LSA with destina-\ntion of 10.2.0.0/16. Likewise router A can be configured to aggregate area 0.0.0.2's\naddresses by advertising a single summary-LSA with destination equal to 10.1.0.0/16.",
        "09753125-ff11-4f85-868c-caf3627506fe": "Section 6.1 OSPF Areas 123\nArea 0,0.0.1\n10.2.1.0/24 10.2.2.0/24\nFigure 6.3 A sample area configuration.\nHowever, area 0.0.0.3's addresses do not aggregate, so router D will end up originating\ntwo summary-LSAs, one for 10.3.7.0/24 and one for 10.8.2.0/24.\nFigure 6.4 displays in detail the summary-LSA that router B uses to leak area\n0.0.0.1's addressing information into area 0.0.0.0. Router B has been configured to aggre-\ngate all of area 0.0.0.1's addresses into a single advertisement for the prefix 10.2.0.0/16.\nThe Link State ID for the summary-LSA is the prefix address 10.2.0.0. The prefix\nmask, 255.255.0.0, is included in the body of the summary-LSA. Also included in the\nsummary-LSA is the cost from the advertising router (router B) to the prefix. Since\n10.2.0.0/16 is an aggregation, the cost in this case is set to the cost from router B to the\nmost distant component of 10.2.0.0 (in this case, 10.2.2.0/24, at a cost of 7).\nArea 0.0.0.1's addresses are distributed throughout area 0.0.0.0 as the summary-LSA\nis flooded throughout area 0.0.0.0. From area 0.0.0.0, the addresses are advertised into\nthe other areas, as described in Section 6.1.1.\nSplitting an OSPF routing domain into areas reduces OSPF's demands for router\nand network resources. Since the area's link-state database contains only router-LSAs\nand network-LSAs for the area's own routers and networks, the size of the link-state\ndatabase is reduced, along with the amount of flooding traffic necessary to synchronize",
        "a368d172-d9ba-4349-abca-37c13bbe3ba8": "124 Hierarchical Routing in OSPF Chapter 6\nFigure 6.4 Summary-LSA advertised by router B into area 0.0.0.0.\nthe database. If aggregation is employed at area boundaries, routing table size is also\nreduced. The cost of the shortest-path calculation is O(z * log(n)), where i is the number\nof router interfaces, and n is the number of routers (see Section 4.8); so as the routing\ndomain is split into areas, the cost of the shortest-path calculation also decreases.\nOf course, splitting the routing domain adds some amount of summary-LSAs to the\ndatabase and routing calculations. However, summary-LSAs are smaller than router-\nLSAs, and the routing calculations involving summary-LSAs are cheaper than the\nshortest-path calculation. In fact, the routing calculation for all summary-LSAs in an\narea is like the processing of a single RIP packet (see Section 6.1.1).\nIn 1991, [173] recommended that the size of an OSPF area be limited to 200 routers,\nbased solely on the cost of the shortest-path calculation. However, this estimate is prob-\nably dated, as router CPU speeds have increased considerably since then. In reality,\nmaximum area size is implementation specific. Some vendors of OSPF routers are build-\ning areas of 500 routers, whereas others recommend that the number of routers in an\narea be limited to 50.\nIn addition to allowing one to build much larger OSPF networks, OSPF areas pro-\nvide the following functionality.\n\u2022 Increased robustness. The effects of router and/or link failures within a single\narea are dampened external to the area. At most, a small number of summary-\nLSAs are modified in the other areas, and, when aggregation is employed, pos-\nsibly nothing will change in the other areas at all.LSAge\nOptions | LS Type\nLink State ID -\n- Advertising Router \u2014\n\u2014 LS Sequence Number \u2014\nLS Checksum\nLength\n\u2014 Network Mask \u2014\nIOS |\nMetric0\n0x2, Type 3 (summary-LSA)\n10.2.0.0\nRouter B's Router ID\n0x80000001\n28 bytes\n255.255.0.0\nIOS 0 (normal service)\nCost of 7",
        "95b3d21b-3101-44c7-99c3-f2711c16a1a5": "Section 6.1 OSPF Areas 125\n\u2022 Routing protection. OSPF always prefers paths within an area (intra-area paths),\nover paths that cross area boundaries. This means that routing within an area is\nprotected from routing instabilities or misconfiguration in other areas. For\nexample, suppose that a corporation runs OSPF and assigns the engineering\ndepartment as one area and the marketing department as another. Then, even\nif the marketing department mistakenly uses some of the engineering ad-\ndress prefixes, communication within engineering will continue to function\ncorrectly.\n\u2022 Hidden prefixes. One can configure prefixes so that they will not be advertised to\nother areas. This capability allows one to hide one or more subnets from the rest\nof the routing domain, which may be wanted for policy reasons: The subnets\nmay contain servers that should be accessed only by clients within the same\narea.\n6.1.1 Area Organization\nWhen an OSPF routing domain is split into areas, all areas are required to attach directly\nto a special area called the OSPF backbone area. The backbone area always has Area ID\n0.0.0.0. In the sample area configuration of Figure 6.3, areas 0.0.0.1,0.0.0.2, and 0.0.0.3\nattach directly to area 0.0.0.0 via the area border routers A, B, C, and D.\nThe exchange of routing information between areas is essentially a Distance Vector\nalgorithm (see Section 2.3 for a discussion of Distance Vector algorithms). Let us use\nrouter D in Figure 6.3 as an example. The exchange of routing information includes the\nfollowing steps.\n1. The area border routers A through D advertise the addresses of their directly\nconnected areas by originating summary-LSAs into the backbone.\n2. Router D receives all the summary-LSAs through flooding.\n3. For any given destination, router D examines all summary-LSAs advertising\nthat destination, using the best summary-LSA to create a routing table entry for\nthe destination, and then readvertises the destination into its attached area\n0.0.0.3 in summary-LSAs of its own.\nIn particular, for the destination 10.2.0.0/16, router D sees two summary-LSAs, one\nfrom router C and one from router B, each advertising a cost of 7. Router D then selects\nthe summary-LSA from C as better because the total cost through C is smaller. Router D\nthen installs a routing table entry for 10.2.0.0/16 with a cost of 8: the cost advertised in\nrouter C's summary-LSA plus the cost from D to C. Finally, router D originates a\nsummary-LSA for 10.2.0.0/16, with a cost of 8, into area 0.0.0.3 so that area 0.0.0.3's rout-\ners will know how to reach 10.2.0.0/16.",
        "9130d4c4-8c0d-425e-9c0b-77d6188b785c": "126 Hierarchical Routing in OSPF Chapter 6\nThe similarities between the distribution of area routing information in OSPF and\nthe operation of the canonical Distance Vector algorithm, RIP, is given in Table 6.1.\nTable 6.1 Distribution of Area Routing Information, Using Distance Vector Mechanisms\nThe use of Distance Vector mechanisms for exchanging routing information\nbetween areas is the reason for requiring all areas to attach directly to the OSPF back-\nbone. The larger the number of redundant paths in a network, the worse a Distance Vec-\ntor algorithm's convergence properties (see Section 2.3). Requiring all areas to attach\ndirectly to the backbone limits the topology for inter-area routing exchange to a simple\nhub-and-spoke topology (see Figure 6.5), which eliminates redundant paths and is not\nsubject to Distance Vector convergence problems, such as counting to infinity. However,\nrequiring direct connection of all areas to the OSPF backbone does not mean requiring\nphysical connectivity to the backbone, as we shall see in the discussion of virtual links\nlater on in this section.\nFigure 6.5 Inter-area routing exchange in the sample OSPF network of Figure 6.3.\nThe example at the beginning of this section also illustrates that the loss of informa-\ntion that enables OSPF area routing to scale also can lead to the selection of less efficient\npaths. If router D forwards a packet to the IP destination 10.2.1.20, it will forward the\npacket to router C instead of along the shorter path through router B. This behavior is\ndue to the fact that router D does not even realize the existence, much less the location,Area Routing Function\nOriginate surnrnary-LSAs for directly\nattached areas into backbone.\nReceive summary-LSAs via flooding.\nAdd cost in summary-LSA to distance to\nsummary-LSA's originator.\nChoose best summary-LSA.\nOriginate own summary-LSAs into directly\nattached areas.Analogous RIP Function\nSend directly attached nets in RIP packets.\nReceive RIP packets from neighbors.\nAdd 1 to cost of each received route.\nChoose best route advertised by neighbor.\nAdvertise updated routing table in RIP\npackets sent to neighbors.",
        "f34b1abb-36c2-4092-830f-b80b9d20ef30": "Section 6.2 Incorporating External Routing Information 127\nof the network segment 10.2.1.0/24 and so forwards using the aggregated routing table\nentry of 10.2.0.0/16 instead.\n6.1.2 Virtual Links\nOSPF requires that all areas attach directly to the backbone area but not that the attach-\nment be physical. Indeed, one can take any physical arrangement of areas and attach\nthem logically to the backbone through the use of OSPF virtual links.\nFor example, suppose that the organization whose network is pictured in Figure 6.3\npurchases two smaller companies and adds their networks as separate OSPF areas, as\npictured in Figure 6.6. The two new areas do not attach physically to the backbone, so\ntwo virtual links are configured through area 0.0.0.3, the first having as end points\nrouters D and E, the second having as end points routers D and F. Virtual links allow\nsummary-LSAs to be tunneled across nonbackbone areas, maintaining the desired hub-\nand-spoke topology for inter-area routing exchange. In Figure 6.6, router A receives\nthe summary-LSA from router E, after the summary-LSA has been tunneled across\narea 0.0.0.3. In order to evaluate the relative cost of the summary-LSA, router A sums\nthe cost of the backbone path to router D, the cost of the virtual link to router E, and the\ncost advertised in router E's summary-LSA. In this fashion, the virtual link acts like a\npoint-to-point link that has been added to the backbone.\nHowever, although the exchange of routing topology continues to follow a simple\nhub-and-spoke topology, the forwarding of data packets does not. The OSPF routing\ncalculations for virtual links have a built-in shortcut calculation, allowing data packets\nto avoid the backbone area when the backbone is not on the shortest path. Using Fig-\nure 6.6 again as an example, routing information from area 0.0.0.4 goes to the backbone\nbefore being redistributed to area 0.0.0.5, but data traffic from area 0.0.0.4 to 0.0.0.5 sim-\nply traverses area 0.0.0.3, avoiding the backbone altogether.\nUnfortunately many people find it difficult to decide when and where to configure\nvirtual links. It is possible to design algorithms so that the routers themselves can\ndynamically establish virtual links; an example of such an algorithm can be found in\n[267]. In the future, these algorithms may relieve network operators of the burden of\nconfiguring virtual links.\n6.2 Incorporating External Routing Information\nOf course, the entire Internet is not run as a single OSPF domain. Many routing proto-\ncols are in use in the Internet simultaneously: OSPF, RIP, BGP, IGRP, and IS-IS, to name a\nfew of the most common (see Chapter 2). On the edge of an OSPF routing domain, gen-\nerally you will find routers that run one or more of these routing protocols, in addition\nto OSPF. It is the job of these routers, called AS boundary routers (ASBRs), to import the",
        "183f7d89-9e6d-4565-8249-12f87bbfad75": "128 Hierarchical Routing in OSPF Chapter 6\nThe Internet\nFigure 6.6 Virtual links incorporate new networks. External routing information is imported by the routing\ndomain's AS boundary routers.\nrouting information learned from these other routing protocols into the OSPF routing\ndomain. This behavior allows routers internal to the routing domain to pick the best-\nexit router when routing to destinations outside the OSPF routing domain, just as sum-\nmary-LSAs allow routers within an OSPF area to pick the right area exit when forward-\ning to inter-area destinations.\nInformation learned from other routing protocols and for destinations outside of\nthe OSPF routing domain is called external routing information, or external routes. External\nroutes are imported into the OSPF routing domain in AS-external-LSAs originated by\nthe AS boundary routers. Each AS-external-LSA advertises a single prefix.",
        "e7eb56fa-c5cf-478a-9eb9-d55164bfa018": "Section 6.2 Incorporating External Routing Information 129\nConsider, for example, the network in Figure 6.6. Routers B and G are running BGP\nsessions to learn of destinations in the Internet at large. Tens of thousands of routes may\nbe learned in this way; to date, the default-free core of the Internet carries more than\n40,000 routes. However, probably not all of these routes would be imported into the\nOSPF domain. Routers B and G would import only those routes where the choice of B\nor G was important; when either exit would do, default routes imported by B and G\nwould suffice. Still it would not be unusual for B and G to originate several thousand\nAS-external-LSAs into the routing domain. In addition, router H is exchanging RIP\ninformation with an isolated collection of RIP routers. Router H then imports each pre-\nfix that it learns from the RIP routers in an AS-external-LSA.\nPaths internal to the OSPF routing domain are always preferred over external\nroutes. External routes also can be imported into the OSPF domain at two separate lev-\nels, depending on metric type. This gives a four-level routing hierarchy, as shown in\nTable 6.2. Paths that stay within one level are always preferred over paths that must\ntraverse the next level.\nTable 6.2 OSPF's Four-Level Routing Hierarchy\nLevel\n1\n2\n3\n4Description\nIntra-area routing\nInter-area routing\nExternal Type 1 metrics\nExternal Type 2 metrics\nFor example, in the network of Figure 6.6, router H may import its RIP routes into\nOSPF as external Type 1 metrics, and routers B and G import their routing information\nas external Type 2 metrics. Then the routing preferences introduced by OSPF hierarchy\nin Figure 6.6 are as follows, from most preferred to least preferred: (1) routing within\nany given OSPF area, (2) routing within the OSPF routing domain itself, (3) routing\nwithin the OSPF domain and RIP cloud, taken together, and (4) routing within the Inter-\nnet as a whole.\nBesides establishing two different routing levels, external Type 1 and Type 2 metrics\nhave different semantics. The use of external Type 1 metrics assumes that in the path\nfrom OSPF router to destination, the internal component (path to the ASBR advertising\nthe AS-external-LSA) and external component (cost described by external Type 1 met-\nric) are of the same order. For example, if the OSPF routing domain used hop count as\nits metric (namely, setting each interface cost to 1) and RIP routes were imported as\nexternal Type 1 metrics, the combined OSPF and RIP system would operate more or less\nseamlessly, selecting paths based on minimum hop count even when they cross the\nOSPF-to-RIP boundary.",
        "b51ed3cb-5576-4524-890f-b54382c225a3": "130 Hierarchical Routing in OSPF Chapter 6\nIn contrast, external Type 2 metrics assume that the external part of the path (cost\ngiven by the external Type 2 metric) is always more significant than the internal cost to\nthe AS boundary router. This would be the case when BGP routes were imported as\nexternal Type 2 metrics, with metric set equal to the BGP route's AS path length\u2014no\nmatter what the cost to the advertising AS boundary router, the whole OSPF routing\ndomain is still only a single AS.\nFigure 6.7 displays an AS-external-LSA. This AS-external-LSA assumes that\nrouter B has learned the prefix 8.0.0.0/8 through BGP, with an AS path length of 12,\nand that AS path length is being used as the OSPF external Type 2 metric. Note that the\nformat of the AS-external-LSA is very similar to the summary-LSA: The Link State ID\nfor both is the address prefix of the route being advertised, and both LSAs contain the\nnetwork mask and route cost in the body of the LSA.\nFigure 6.7 An AS-external-LSA.\nThere are two fields in the AS-external-LSA of Figure 6.7 that have not been men-\ntioned so far. The Forwarding Address field in this particular AS-external-LSA has\nbeen set to 0.0.0.0 to indicate that traffic destined for 8.0.0.0/8 should be forwarded to\nrouter B, the originator of the AS-external-LSA. However, by specifying another rout-\ner's IP address in the Forwarding Address field, router B can have traffic forwarded to\nanother router instead. This feature is used to prevent extra hops at the edge of theLS Age\nOptions LS Type\nLink State ID -\n\u2014 Advertising Router \u2014\n- LS Sequence Number \u2014\nLS Checksum\nLength\n- Network Mask -\nE IOS |\nMetric\n- Forwarding Address \u2014\n\u2014 External Route Tag -0\n0x2, Type 5 (AS-external-LSA)\n8.0.0.0\nRouter B's Router ID\n0x80000003\n36 bytes\n255.0.0.0\nE = 1 (Type 2 metric)\nCost of 12\n0.0.0.0 (none)\n0TOS 0 (normal)",
        "f995bc47-75b4-4081-afff-c49e8ab2222f": "Section 6.2 Incorporating External Routing Information 131\nrouting domain and would be done automatically by router B when necessary. See\nSection 3.5 for further information.\nThe External Route Tag field is not used by OSPF itself but instead is used to convey\ninformation between the routing protocols being run at the edge of the OSPF routing\ndomain (BGP and RIP in Figure 6.6). For example, in the BGP-OSPF interaction speci-\nfied in [252], the External Route Tag is set when importing external routes on one edge\nof the routing domain, to give routers on the other side of the routing domain informa-\ntion as to whether, and if so how, they should export this routing information to other\nAutonomous Systems (see Section 11.6.1). The External Route Tag is also used by the\nexternal-attributes-LSA, proposed in [73] as an alternative to IBGP (see Sections 7.6\nand 13.3).\n6.2.1 Interaction with Areas\nHow is external routing information conveyed across area borders in OSPF? One way\nthis could have been done in OSPF was to reoriginate the AS-external-LSAs at area\nborders, just as OSPF does with summary-LSAs for inter-area routes. However, this\nwould have been expensive in terms of database size. When there are multiple area\nborder routers for a given area, multiple AS-external-LSAs would be originated for\neach original AS-external-LSA: one origination per area border router. And within\nthe area border routers, the situation would have been even worse, with each area bor-\nder router holding a slightly different version of each AS-external-LSA for each at-\ntached area.\nSo OSPF takes a different tack, simply flooding AS-external-LSAs across area bor-\nders. For example, the AS-external-LSA in Figure 6.7 is flooded throughout all areas in\nFigure 6.6; all routers in the network then hold this exact AS-external-LSA in their link-\nstate databases.\nIn particular, router H in area 0.0.0.5 has the AS-external-LSA in its link-state data-\nbase. However, in order to make use of this information, router H must know the loca-\ntion of the originator of the AS-external-LSA\u2014in this case, the ASBR router B. For\nthis reason, OSPF advertises the location of ASBRs from area to area, using Type 4\nsummary-LSAs (also called ASBR-summary-LSAs). The ASBR-summary-LSA that the\narea border router F originates into the area 0.0.0.5 in order to advertise the location of\nASBR B is shown in Figure 6.8. The Link State ID of the ASBR-summary-LSA is the\nOSPF Router ID of the ASBR whose location is being advertised. Other than that, the\nformat, origination, and processing of ASBR-summary-LSAs is identical to that of\nsummary-LSAs.\nThe AS-external-LSA is the only type of OSPF LSA, other than the proposed\nexternal-attributes-LSA of Section 7.6, that is flooded throughout the entire OSPF rout-\ning domain. We say that OSPF AS-external-LSAs have AS flooding scope, whereas",
        "b1354fff-e257-4b2d-88f2-15b7271e9b49": "132 Hierarchical Routing in OSPF Chapter 6\nFigure 6.8 ASBR-summary originated by router F into area 0.0.0.5.\nrouter-LSAs, network-LSAs, and summary-LSAs, which are not flooded across area\nborders, have area flooding scope.\nThere can be thousands of external routes imported into an OSPF routing domain in\nAS-external-LSAs, forming a large part of an OSPF area's link-state database. For this\nreason, additional OSPF area types have been defined that restrict the amount of exter-\nnal routing information within an area, thereby limiting the resources that OSPF con-\nsumes in the area's routers and links, at the expense of reduced functionality. These area\ntypes are the subject of Section 6.3.\n6.3 OSPF Area Types\nNormal OSPF areas have some desirable properties. Normal areas can be placed any-\nwhere within the OSPF routing domain, although possibly requiring configuration of\nvirtual links. Normal areas calculate efficient, although not always optimal, inter-area\nand external routes through the use of summary-LSAs, ASBR-summary-LSAs, and AS-\nexternal-LSAs. And normal areas support ASBRs, directly importing external routing\ninformation from other routing protocols and then distributing this information to other\nareas.\nHowever, this support requires processing and bandwidth resources that may not\nbe available everywhere. To have areas with smaller routers and to have low-bandwidth\nlinks, OSPF forgoes some of these desirable properties and introduces two restricted\narea types: stub areas and NSSAs.LSAge\nOptions LS Type\n- Link State ID -\n\u2014 Advertising Router \u2014\n\u2014 LS Sequence Number \u2014\nLS Checksum\nLength\n\u2014 Network Mask \u2014\nTOS |\nMetric0\n0x2, Type 4 (ASBR-summary-LSA)\nRouter B's Router ID\nRouter F's Router ID\n0x80000002\n28 bytes\n0.0.0.0 (not used)\nTOS 0 (normal)\nCost of 5",
        "f4ecf83a-c527-491b-b2c1-8db85d0271aa": "Section 6.3 OSPF Area Types 133\n6.3.1 Stub Areas\nOf all OSPF area types, stub areas consume the least resources. Stub areas, part of the\noriginal OSPF design, were designed to contain routers that had limited resources, espe-\ncially when it came to router memory.\nTo conserve router memory, the link-state database in stub areas is kept as small as\npossible. AS-external-LSAs are not flooded into stub areas; instead routing to external\ndestinations within stub areas is based simply on default routes originated by a stub\narea's area border routers. As a result, ASBRs cannot be supported within stub areas. To\nfurther reduce the size of the link-state database, origination of summary-LSAs into\nstub areas is optional. Inter-area routing within stub areas can also follow the default\nroute. Without AS-external-LSAs and summary-LSAs, stub areas cannot support virtual\nlinks either and so must lie on the edge of an OSPF routing domain.\nAs a result of these restrictions, not all areas can become stub areas. For example, in\nFigure 6.6, only areas 0.0.0.1 and 0.0.0.4 could be configured as stub areas. The backbone\narea can never be configured as a stub; areas 0.0.0.2 and 0.0.0.5 support ASBRs; and area\n0.0.0.3 needs to support virtual links.\nEven if you can configure an OSPF area as a stub area, you may not want to. The\nlack of AS-external-LSAs (and possibly summary-LSAs) means that routing to external\n(and possibly inter-area) destinations can take less efficient paths than in regular areas.\nThis fits in with the observation made at the end of Section 6.1.1: The trade-off for the\nimproved scaling properties of hierarchical routing is the possibility of suboptimal\nroutes. With the even better scaling properties of stub areas comes the possibility of\neven more suboptimal routes.\n6.3.2 NSSAs\nNSSAs, or not-so-stubby areas, were defined in [47] as an extension to stub areas.\nAlthough most of the stub area restrictions, such as preventing the flooding of AS-\nexternal-LSAs into the area and not allowing configuration of virtual links through the\narea, were deemed acceptable by the NSSA designers, they wanted the ability to im-\nport a small amount of external routing information into the NSSA for later distribution\ninto the rest of the OSPF routing domain.\nA typical example of an NSSA is area 0.0.0.5 in Figure 6.6. You want to import\nroutes learned from the RIP cloud into area 0.0.0.5 and then to distribute these routes\nthroughout the rest of the OSPF routing domain. However, area 0.0.0.5 does not need\nthe collection of AS-external-LSAs imported by routers B and G as a result of their BGP\nsessions. Instead routing in area 0.0.0.5 to these BGP-learned destinations can be han-\ndled by a single default route pointing at router F.\nExternal routing information is imported into an NSSA by using Type-7-LSAs (LS\nType = 7). These LSAs have area flooding scope and are translated at the NSSA",
        "52f52946-5510-4699-b5cc-954211bbdfd8": "134 Hierarchical Routing in OSPF Chapter 6\nboundary into AS-external-LSAs that allow the external routing information to be\nflooded to other areas. The NSSA border serves as a one-way filter for external informa-\ntion, with external information flowing from NSSA to other areas, but not vice versa.\nFor further information on NSSAs, see Section 7.4.\nFurther Reading\nThe seminal paper on hierarchical routing is [128]. Scaling properties of hierarchical\nrouting are analyzed in [88]. An interesting proposal to add area routing to the original\nARPANET link-state routing algorithm, although never implemented, is presented\nin [231].\nThe interaction between BGP and OSPF, defining what information should be\nleaked between the two routing protocols and how it should be leaked, is defined in\n[252]. The specification for NSSAs is provided in [47].\nExercises\n6.1 Calculate routing table for routers A through D in Figure 6.3.\n6.2 Calculate the routing table for router A in Figure 6.6.\n6.3 In Figure 6.6, how many summary-LSAs does router E originate into area 0.0.0.4?\nHow many ASBR-summary-LSAs? What are their associated costs?\n6.4 By combining two areas in Figure 6.6, how could one avoid the need for any\nvirtual links?",
        "b38f5e4f-0086-439d-8d9c-ff3c30586ec1": "7\nOSPF Extensions\nThe base OSPF protocol has changed only slightly since the OSPF Version 2 specification\nwas first published in [176] in 1991. The OSPF version number is still 2, and today's\nOSPF implementations still interoperate with those written in 1991. However, this is\nnot to say that nothing has changed in OSPF since 1991. There have been a number\nof bug fixes and optimizations made to the specification as a result of field experi-\nence and an increasing number of independent OSPF implementations, as documented\nin Chapter 3. Also, there have been a steady stream of optional extensions to OSPF,\nranging from multicast routing to protocol extensions enabling efficient use of dial-up\ncircuits, such as ISDN. These optional extensions\u2014their content and the OSPF mecha-\nnisms that enable their addition in a backward-compatible way\u2014are the subject of this\nchapter.\nIt was fortunate that there were two optional capabilities built into the OSPF Ver-\nsion 2 specification at the very beginning, namely, TOS-based routing and stub area sup-\nport. These capabilities caused extension mechanisms to be built into OSPF from the\nstart. One usually goes about extending OSPF by employing one or more of the follow-\ning methods.\n\u2022 Enrich the network description as implemented by the OSPF link-state data-\nbase by adding either data to existing LSA types or new LSA types. For exam-\nple, the multicast routing extensions to OSPF, referred to as MOSPF, add\ngroup-membership-LSAs (LS Type 6) to indicate the location of multicast group\nmembers.\n135",
        "ead97d8a-4153-45bc-b4e6-65d4ea31f00a": "136 OSPF Extensions Chapter 7\n\u2022 Add new routing calculations to accommodate more sophisticated forwarding\nrules. For example, OSPF's optional TOS-based routing performs separate rout-\ning calculations for each of the five IP Type of Service values [3]. This behavior\nallows routers to forward IP packets based on the packet's TOS designation, as\nwell as on the packet's IP destination address.\n\u2022 Alter OSPF database synchronization to achieve different performance points.\nFor example, the Demand Circuit extensions to OSPF remove the periodic refresh\nof OSPF LSAs in order to make more efficient use of dial-up link technology.\nOf course, OSPF extensions must be defined in such a way that they are backwardly\ncompatible with existing OSPF routers. Since one cannot expect to deploy an OSPF\nextension in all routers at once, one needs to ensure that a mix of new and old OSPF\nrouters (a) continues to forward IP data traffic successfully and (b) does not exhibit any\nanomalous behavior, such as continual retransmissions of LSAs. To enable backward\ncompatibility, OSPF includes an 8-bit Options field in OSPF Hello packets, Database\nDescription packets, and OSPF LSAs. The Options field allows automatic discovery of\nwhich routers support a given extension and what routing information the extension\ncan use.\nThe Options field is displayed in Figure 7.1. In general, one bit of the Options field\nhas been allocated to each OSPF extension. As a result, the OSPF Options field is almost\nused up, which has led to an increase in size to 24 bits in OSPF for IPv6 (see Section 3.7).\nExplanation of the current use of the Options bits can be found in Table 7.1 and else-\nwhere in this chapter.\nDC-bit EA-bit N/P-bit MC-bit E-bit T-bit\nFigure 7.1 The OSPF Options field.\nMismatches in router capabilities in an OSPF routing domain, with some routers\nsupporting an option and others not, can trigger the following OSPF mechanisms in\norder to retain backward compatibility.\n\u2022 Routers may refuse to become adjacent. For example, two routers that disagree\non whether an OSPF area has been configured as a stub will refuse to become\nadjacent, because otherwise routing loops might occur (see Section 7.2).\n\u2022 An OSPF router will not flood an extension's new LSA type to a neighbor\nunless the neighbor implements the extension. In other words, routers are\nrequired to store and flood only those LSAs that they understand. For example,\ngroup-membership-LSAs are sent only to those routers supporting MOSPF.\n\u2022 Certain router-LSAs and other LSA types may be ignored during routing calcu-\nlations. For example, in OSPF TOS-based routing, paths are calculated around\nthose routers that do not support TOS.",
        "d6abc09f-38d1-4923-b834-6815d454253f": "Section 7.1 IOS-Based Routing 137\nTable 7.1 summarizes the current OSPF extensions and how they are implemented.\nThe remainder of this chapter discusses each extension in more detail. Detailed discus-\nsion of MOSPF, the largest extension, is postponed until Chapter 10, MOSPF.\nTable 7.1 Summary of OSPF Extensions\nExtension\nTOS-based routing\nStub areas\nDemand Circuit extensions\nNSSA areas\nDatabase overflow\nExternal-attributes-LSAs\nMulticast routing extensions to\nOSPF (MOSPF)Option Bits\nUsed\nT-bit\nE-bit\nDC-bit\nN/P-bit\nNone\nEA-bit\nMC-bitAdditional LSA Types\nAdditional data in router-LSAs\nNone\nNone\nType-7-LSAs (LS Type 7)\nNone\nExternal-attributes-LSA\n(LS Type 8)\nGroup-membership-LSA\n(LSType6)Updates\nRouting\nCalculations?\nYes\nNo\nNo\nYes\nNo\nNo\nYes\n7.1 IOS-Based Routing\nIP supports five different Types of Service (TOS) for datagram delivery: normal service,\nminimize monetary cost, maximize reliability, maximize throughput, and minimize\ndelay. An application indicates which TOS it wishes to be applied to the application's\ndatagrams by setting the TOS field in its datagrams' IP headers. The routers may then\nroute both on the datagrams' IP destination and on their TOS, forwarding datagrams\nrequesting normal service one way, datagrams requesting to minimize monetary cost\nanother way, and so on.\nConsider the network in Figure 7.2. Link costs have been configured symmetrically,\nwith the cost of a link for normal service pictured. As a result, router 10.9.0.6 will deliver\ndatagrams destined for 10.9.0.4 over the path of cost 8 through 10.9.0.1. However, if the\nlink between 10.9.0.3 and 10.9.0.4 is a satellite link, router 10.9.0.6 may send datagrams\nrequesting to minimize delay over the alternative path through 10.9.0.5.\nTOS-based routing has recently been omitted from the OSPF specification [178], due\nto lack of deployment experience. TOS-based routing has seen limited deployment\nwithin TCP/IP networks and for this reason, has also been omitted from the IPv6 speci-\nfications (see Section 1.3). Lack of TOS-based routing has been a chicken-and-egg prob-\nlem: Host vendors have not changed their applications to request TOS, because the",
        "dd00f6b4-e8bf-430e-8f58-3fca15d49531": "138 OSPF Extensions Chapter 7\nFigure 7.2 Sample network implementing TOS-based routing.\nrouters do not forward based on TOS; the routers do not forward based on TOS, because\nfew applications request TOS. There are, however, a few TCP/IP hosts (such as Cray\nsupercomputers) that can be configured to request maximize throughput TOS for FTP\nsessions, and so on. Although there are no commercially available router implementa-\ntions of TOS-based routing, there have been two separate implementations of OSPF\nTOS-based routing in the past, one done for the Research Internet Gateway project [105]\nand the other by 3Com. In the rest of this section, we describe how TOS routing was\nimplemented within the original OSPFv2 specification [176].\nEach link within a router-LSA (see Section 4.3) could advertise separate costs for\neach TOS value; if the router-LSA failed to list a cost for a TOS value, the cost defaulted\nto that specified for normal service, which was always present. An OSPF router imple-\nmenting TOS-based routing then ran separate routing calculations for each TOS, each\ntime using the costs specified for the given TOS. In Figure 7.2, the costs pictured are\nfor the TOS value of normal service. In order to get router 10.9.0.6 to forward traffic\nrequesting minimize-delay service toward 10.9.0.5, router 10.9.0.3 simply advertised\nthe cost of its attached satellite link as greater than 10 for the TOS value of minimize\ndelay.",
        "80880a8e-87b8-45e0-800d-46df68370cc8": "Section 7.2 Stub Areas 139\nBackward-Compatibility Provisions\nThe preceding discussion assumed that all routers within the routing domain were\ncapable of routing based on TOS. However, it is more likely that certain routers would\nsupport TOS and that others would not.\nOSPF allowed a mix of TOS capability within a routing domain through the use of\nthe T-bit in the Options field of router-LSAs, summary-LSAs, and AS-external-LSAs. By\nsetting the T-bit in its router-LSA, a router indicated that it was performing TOS-based\nrouting. Summary-LSAs and AS-external-LSAs with the T-bit set indicated that they\nwere describing TOS-capable paths all the way to their advertised destinations. An\nOSPF router performing TOS-based routing then performed its routing calculations, for\nall TOS other than normal service, on the subset of the link-state database having the\nT-bit set.\nAs a result of these procedures, an OSPF router supporting TOS may have had a\nnormal service path to a destination but not paths for other TOS values. In this case,\nwhen a router forwarded datagrams that requested other than normal service to the\ndestination, the normal-service path was used anyway. In this way, the datagram was\nforwarded on the best-effort path until a path for the specific TOS value was encoun-\ntered, and then the datagram used the path for the specific TOS the rest of the way to the\ndestination, resulting in loop-free routing.\nFor example, suppose in Figure 7.2 that routers 10.9.0.1,10.9.0.3,10.9.0.4, and\n10.9.0.5 supported TOS routing, yet the others did not. In that case, a datagram with\ndestination 10.9.0.4 and requesting to minimize delay would be forwarded by router\n10.9.0.1 along the normal-service path through 10.9.0.2 to 10.9.0.3, whereupon it would\ntake the shortest minimize-delay path through 10.9.0.5 on its way to 10.9.0.4.\n7.2 Stub Areas\nStub areas arose from the desire to deploy routers having limited memory and process-\ning resources, even within a large OSPF routing domain. To support such limited rout-\ners, an OSPF routing domain is split into areas, and the resource-limited routers are\nassigned to special areas, called stub areas, at the edge of the OSPF routing domain.\nAS-external-LSAs are not flooded into stub areas, relying instead on default routing in\nthe stub areas to forward traffic addressed to external destinations. The default route\nalso can be used for inter-area destinations, removing the need for summary-LSAs\nwithin stub areas.\nRemoving AS-external-LSAs and summary-LSAs can significantly reduce the link-\nstate database size, and hence the memory and processor consumption, of routers\nwithin a stub area. To give a numerical example, suppose that, on average, router-LSAs\nconsume 192 bytes of router memory and that AS-external-LSAs consume another 64\nbytes. In an OSPF router domain consisting of 200 routers and 10,000 AS-external-LSAs,",
        "a1a48333-69bd-41da-9746-bb94c3c50509": "140 OSPF Extensions Chapter 7\nthe link-state database would consume approximately 678K of router memory. How-\never, if in this same routing domain, a particular router was isolated within a stub area\nof 10 routers, the router's link-state database would be a meager 2K in size.\nStub areas are a part of the base OSPF specification [177]. For further information on\nstub areas, see Section 6.3.1.\nBackward-Compatibility Provisions\nIt is important for all routers within a stub area to agree that the area is a stub area. If\ncertain routers treated the area as a stub area and others did not, two problems might\nensue. First, there might be continual retransmissions of LSAs, with those routers\nbelieving that the area was not a stub trying unsuccessfully to flood AS-external-\nLSAs to those routers believing that the area was a stub. Worse yet, disagreements\non a stub- area status might cause routing loops, with some routers in the area using\nAS-external-LSAs in their routing calculations and others simply using default routes.\nTo prevent these problems, OSPF mechanisms ensure that all routers agree on\nwhether the area is a stub. When an OSPF router's interface connects to a stub area, the\nrouter sends Helios out onto the associated network segment, with the E-bit clear in the\nHello packets' Options field. Other OSPF routers receiving the Hello will accept it for\nfurther processing only if they too agree that the associated segment belongs to a stub\narea. This means that two routers disagreeing on stub-area status will never achieve\nbidirectional communication, and so will never start database synchronization (thereby\navoiding potential flooding problems), and will not become fully adjacent (thereby\navoiding using each other for forwarding).\n7.3 Demand Circuit Extensions\nThe OSPF Demand Circuit extensions are specified in [169]. Demand circuits are point-\nto-point or Point-to-MultiPoint links (see Chapter 5) that incur usage-based costs. An\nexample is an ISDN basic-rate service, whereby you might pay for your connect time\nand also pay a per packet or per bit rate for the data you transmit or receive. Other\nexamples include standard dial-up links and router-to-router links implemented\nthrough X.25, Frame Relay, or ATM switched virtual circuits (SVCs). In all these circum-\nstances, to save money, you want to send the bare minimum of routing protocol traffic\nover the demand circuit, ideally establishing the underlying data-link connection only\nwhen there is user-data traffic to transmit. These are the goals of OSPF's Demand\nCircuit extensions.\nOSPF routing protocol traffic is of two types. First, there are the periodic Hello pack-\nets that are sent over each link for neighbor discovery and maintenance (see Section 4.6).\nSecond, there is the OSPF protocol traffic to achieve and maintain link-state database\nsynchronization between routers. The Demand Circuit extensions remove the periodic",
        "a8730c09-e1e3-472f-afb6-67d736100291": "Section 7.3 Demand Circuit Extensions 141\nnature of both traffic types. These extensions reduce the amount of OSPF routing traffic,\nremoving all OSPF protocol traffic from a demand circuit when the routing domain is in\na steady state (in other words, in the absence of link and router failures).\nOver a demand circuit, OSPF Helios are sent only until initial link-state database\nsynchronization is achieved. Then Helios are suppressed, depending completely on the\ndata-link protocol to indicate link failures. For example, when the demand circuit is\nimplemented as an X.25 SVC, the router will receive an X.25 Clear message with an\nappropriate diagnostic code when the link is no longer usable.\nTo remove the periodic nature of OSPF database synchronization, simple refreshes\nof LSAs are not flooded over demand circuits. When a router receives a new LSA\ninstance, the router compares the contents of the new LSA instance to the current LSA\ncopy in the router's database. If the contents have not changed, the new LSA is not\nflooded over the router's attached demand circuits. Therefore the last copy of the LSA to\nbe flooded over the demand circuit reflected some change in the OSPF routing domain.\nTo prevent the routers on the other side of the demand circuit from aging out this LSA,\nthe router indicates that the LSA should not be aged, by setting the LSA's DoNotAge bit\nwhen flooding the LSA over the demand circuit.\nAs an example of the Demand Circuit extensions, suppose that in Figure 7.2, the\nlink between routers 10.9.0.6 and 10.9.0.7 is a demand circuit, implemented as a dial-up\nlink. When router 10.9.0.7 is first booted, the dial-up connection to 10.9.0.6 is estab-\nlished, Helios are exchanged, and then link-state database synchronization is performed\nbetween 10.9.0.6 and 10.9.0.7. During database synchronization, each LSA flooded by\n10.9.0.6 to 10.9.0.7 (and vice versa) has the DoNotAge bit set, so they will not have to be\nrefreshed. Then, after some period of time without network changes and/or user-data\ntraffic, the dial-up connection between 10.9.0.6 and 10.9.0.7 is torn down, to be reestab-\nlished when necessary: A refresh of 10.9.0.2's router-LSA would not cause a new dial-up\nconnection, but if the link between 10.9.0.2 and 10.9.0.3 fails, the dial-up connection\nwould be reestablished in order to flood updated router-LSAs from 10.9.0.2 and 10.9.0.3.\nThe OSPF Demand Circuit extensions can be used to good effect even when\ndemand circuits are not in use. On low-bandwidth broadcast links and permanent\npoint-to-point links, such as packet radio, the Demand Circuit extensions can reduce\nrouting protocol traffic, making more of the link bandwidth available for user-data traf-\nfic. The Demand Circuit extensions typically avoid LSA refreshes over links labeled as\ndemand circuits, but in OSPF networks with large databases, LSAs can even be origi-\nnated with the DoNotAge bit set in order to avoid LSA refreshes on all links.\nThe DoNotAge Bit\nThe DoNotAge bit is defined as the most significant bit of the LS Age field. LSAs having\nthe DoNotAge bit set are not aged as they are held in an OSPF router's link-state\ndatabase. This means that these LSAs do not have to be refreshed every 30 minutes.\nHowever, stale LSAs with the DoNotAge bit set are still eventually removed from the",
        "3c104931-855b-4075-b563-6226b20aaf88": "142 OSPF Extensions Chapter 7\nlink-state database. The rule is that these LSAs can be removed from the database\nwhen both (a) they have been in the database for at least an hour and (b) the LSAs'\noriginator has also been unreachable for at least that period of time. The time constant\nof 1 hour was chosen to prevent temporary unreachability conditions from causing\nLSA thrashing\u2014the flushing of LSAs only to see them immediately originated again.\nIn all other link-state database operations\u2014comparing two instances of the same\nLSA, deciding whether an LSA is to be updated or deleted, and so on\u2014an LSA with an\nage of DoNotAge + x is treated identically to an LSA with an age of x. In particular, to\nprotect against flooding loops, the LS Age of a DoNotAge LSA is incremented at each\nflooding hop. Should the LSA's LS Age reach DoNotAge + Max Age, the LSA is\nremoved from the routing domain.\nCaveats\nSince the Demand Circuit extensions remove all OSPF protocol traffic when the routing\ndomain is in a steady state, the data-link connection underlying the demand circuit can\nbe closed when not being used for user-data traffic. This behavior saves money but can\ndelay notification of link failures: If the underlying data-link connection is closed due to\nlack of traffic, the inability to establish a new data-link connection (in other words, a link\nfailure) will not be noticed until there is new user-data traffic to send. As a result, longer\nrerouting times may occur.\nAlso, the Demand Circuit extensions remove some of OSPF's robustness. The\nremoval of periodic Helios means that the method of last resort to detect neighbor fail-\nures is no longer available. Further, the removal of LSA refreshes over demand circuits\nmeans that the automatic correction for link-state database corruption does not take\nplace across demand circuits.\nWhen there is a real change in an OSPF routing domain, for example, when a link\nbecomes inoperational or a new piece of external routing information is imported,\nupdated LSAs are flooded over demand circuits. In a large routing domain, these\nchanges may be frequent enough to keep a demand circuit's underlying data-link con-\nnection continuously open. One way to isolate a demand circuit from these changes is to\nassign the demand circuit to an OSPF stub area or NSSA (see Section 6.3).\nBackward-Compatibility Provisions\nIn order to suppress Helios on demand circuits, an OSPF router must establish that the\nOSPF router on the other end of the link also is going to treat the link as a demand cir-\ncuit. Otherwise, suppressing Helios will just cause the neighbor to declare the link inop-\nerational. Therefore a link's demand-circuit status is negotiated. A router wanting to\ntreat a link as a demand circuit sends its first Hello on the link with the DC-bit set in the\nHello's Options field (see Figure 7.1). If the router on the other end of the link is able and",
        "c5561581-1da4-4fb4-b668-9056165ea6fc": "Section 7.4 NSSA Areas 143\nwilling to treat the link as a demand circuit, it responds with a Hello also having the\nDC-bit set.\nUse of the DoNotAge bit also must be negotiated, although this negotiation is\nnetworkwide instead of just between the end points of a demand circuit. All routers in\nan OSPF routing domain must be capable of understanding the DoNotAge bit before\nany one router starts setting the DoNotAge bit in LSAs. The reason is that the reaction of\nan unmodified OSPF router to the DoNotAge bit is unpredictable; at best, an unmodi-\nfied router will treat an LSA with DoNotAge set as a MaxAge LSA, causing the unmod-\nified router to ignore the LSA.\nA router indicates that it is capable of understanding the DoNotAge bit by setting\nthe DC-bit in the Options field of the LSAs that the router itself originates. Routers can\nthen set the DoNotAge field in LSAs if, and only if, all LSAs in the link-state database\nhave the DC-bit set.\nThe presence of routers that do not understand DoNotAge must be indicated across\narea boundaries, to prevent the flooding of AS-external-LSAs with DoNotAge set. This\nis accomplished by area border routers. Noticing routers incapable of DoNotAge pro-\ncessing in one area, an area border router floods a dummy ASBR-summary-LSA (see\nSection 6.2.1, and Section 2.5.1 of [169]) with DC-bit clear into its other attached areas.\n7.4 NSSA Areas\nDefined in [47], not-so-stubby areas (NSSAs) are an extension of OSPF stub areas. Like\nstub areas, NSSAs enable routers with limited resources to participate in OSPF routing.\nLike stub areas, NSSAs limit resource consumption by preventing the flooding of AS-\nexternal-LSAs into NSSAs, relying instead on default routing to external destinations.\nAs a result, both stub areas and NSSAs must be placed at the edge of an OSPF routing\ndomain.\nHowever, NSSAs are more flexible than stub areas. An NSSA can import a selected\nnumber of external routes into the OSPF routing domain, enabling the NSSA to provide\ntransit service to small stub routing domains that themselves are not part of the OSPF\nrouting domain. For example, in Figure 6.6, area 0.0.0.5 can be configured as an NSSA,\nprotecting its internal routers from all the AS-external-LSAs imported by the OSPF\nrouting domain's BGP routers (routers B and G), but allowing attachment of the isolated\nRIP cloud.\nExternal routing information is imported into an NSSA in Type-7-LSAs. Type-7-\nLSAs are identical in format to AS-external-LSAs. However, unlike AS-external-LSAs,\nType-7-LSAs have only area flooding scope. In order to further distribute the NSSA's\nexternal routing information, Type-7-LSAs are selectively translated into AS-external-\nLSAs at the NSSA border.\nTranslation is performed by the area border router with the highest OSPF router ID.\nAggregation is also possible at translation time through the configuration of address",
        "3a651b56-6e31-4b8f-91a4-942c7843771c": "144 OSPF Extensions Chapter 7\nranges within the area border router. The N/P-bit in a Type-7-LSA's Options field indi-\ncates whether the Type-7-LSA should be translated: Only those LSAs with the N/P-bit\n(where the P in this case stands for propagate) are translated. There are several reasons\nwhy you might not want a Type-7-LSA translated.\n\u2022 For policy reasons. The Type-7-LSA may describe a private external route that\nshould be used only by the routers within the NSSA area.\n\u2022 For protocol reasons. Default routing within an NSSA, which is necessary because\nthe NSSA does not receive the OSPF domain's AS-external-LSAs, is imple-\nmented by the NSSA's area border routers originating Type-7-LSAs advertising\nthe default route. These Type-7-LSAs must not be translated into a default for\nthe entire OSPF routing domain.\n\u2022 When an area border router is also an AS boundary router. In this case, proper AS-\nexternal-LSAs exist without having to translate Type-7-LSAs.\nGoing back to the example in Figure 6.6, suppose that router H learns a route to\n192.9.1.0/24 via RIP with a cost of 3. Router H may then import into area 0.0.0.5 the\nType-7-LSA pictured in Figure 7.3, which would then be translated into an AS-external-\nLSA by router F for distribution to other OSPF areas.\nFigure 7.3 An example Type-7-LSA.LSAge\nOptions LS Type\nLink State ID -\n- Advertising Router \u2014\n- LS Sequence Number \u2014\nLS Checksum\nLength\n- Network Mask \u2014\nE TOS |\nMetric\n\u2014 Forwarding Address \u2014\n- External Route Tag \u20140\nN/P-bit (Type-7-LSA)\n192.9.1.0\nRouter H's Router ID\n0x80000001\n36 bytes\n255.255.255.0\nE = 0 (Type 1 metric), TOS 0 (normal)\nCost of 3\n0.0.0.0 (none)\n0",
        "36f006b9-e882-4094-bff1-08602fb14904": "Section 7.5 Database Overflow Support 145\nBackward-Compatibility Provisions\nJust as for stub areas, all routers in an NSSA area must agree that the area is an NSSA, to\nprevent continual retransmissions of LSAs or, even worse, routing loops. This agree-\nment is ensured in a similar fashion to that for stub areas. A router will set the N/P-bit\nin the Options field of Hello packets that it transmits out its interfaces connecting to\nNSSA areas. On these interfaces, the router will not accept Hello packets unless their\nN/P-bit is also set. In this way, two OSPF routers that disagree on whether an area is an\nNSSA will never attempt database synchronization; nor will they use each other in\nrouting calculations.\n7.5 Database Overflow Support\nThe OSPF Database Overflow extensions are designed to deal with resource shortages\nin OSPF routers. When such shortages are known ahead of time, the routers with lim-\nited resources may be consigned to OSPF stub areas or NSSAs. It is the job of OSPF's\ndatabase-overflow support to deal with unexpected shortages.\nThe Database Overflow extensions work by limiting the size of the link-state data-\nbase. Only the number of nondefault AS-external-LSAs is restricted. The decision to\nlimit only these LSA types was based on the following considerations.\n\u2022 Nondefault AS-external-LSAs often comprise the lion's share of the link-state\ndatabase, as discussed in [173].\n\u2022 The number of these LSAs that will be present day to day is most unpredictable.\nThe Internet is always growing, causing more external routes to be imported\nin each OSPF domain. Also, a configuration error in an AS boundary router\nimporting BGP-learned routes easily can lead to thousands of extra external\nroutes being imported by mistake.\n\u2022 These LSAs are, in some sense, optional. If removed from the link-state data-\nbase, routing within the OSPF routing domain will continue to function. In par-\nticular, the OSPF routers still should be manageable; thus if the reason for the\ndatabase overflow was a configuration error, the error can be corrected. In addi-\ntion, without these LSAs, any default routing in the AS will continue to work,\nideally meaning that the majority of external destinations will still be reachable.\nTo enforce this limit, the maximum allowed number of nondefault AS-external-\nLSAs, ospf ExtLsdbLimit, is configured in each router. The ospf ExtLsdbLimit\nmust be set identically in each router; its value can be calculated as a function of\nthe smallest router's memory size. At no time will any OSPF router accept more\nthan ospf ExtLsdbLimit nondefault AS-external-LSAs; excess LSAs are silently dis-\ncarded without being acknowledged. In addition, when a router reaches its limit of\nospf ExtLsdbLimit LSAs, it goes into database-overflow state, In database-overflow state,",
        "5c7eeea4-9d09-4662-b470-9bfa6456e207": "146 OSPF Extensions Chapter 7\na router deletes its self-originated nondefault AS-external-LSAs from the routing\ndomain and refuses to originate any more.\nWhen the number of nondefault AS-external-LSAs exceeds ospf ExtLsdbLimit,\nsome number of Link State Update retransmissions will occur. However, since all\nrouters agree on the value of ospf ExtLsdbLimit, it is guaranteed that within a\nshort period of time, enough routers will enter database-overflow state and flush\ntheir self-originated LSAs that the database will converge to a state having less than\nospf ExtLsdbLimit nondefault AS-external-LSAs. Convergence on a common link-state\ndatabase is crucial, as this is the only guarantee that loop-free routing will continue.\nAlthough ospfExtLsdbLimit should be set the same in each router, there is no pro-\ntocol mechanism guaranteeing an equal setting. Instead ospfExtLsdbLimit is set in\neach router via SNMP (see Section 11.1).\nThe database-overflow condition may be transitory. To return the routing domain to\ncomplete operation without human intervention, a timer may be configured in each\nrouter so that it automatically transitions out of database-overflow state after some\nperiod of time, reoriginating its nondefault AS-external-LSAs in the process. This timer\nneed not be the same length in all routers. Indeed, you may want to configure a shorter\ntimer in the routers that originate the more critical AS-external-LSAs.\nThe database-overflow support limits only AS-external-LSAs. Similar techniques\ncan be applied to control the number of other LSA types, such as summary-LSAs and\ngroup-membership-LSAs.\nBackward-Compatibility Provisions\nThe OSPF database-overflow support has no explicit support for backward compatibil-\nity with unmodified OSPF routers. In the same routing domain, you can mix routers\nsupporting the Database Overflow extensions with unmodified routers, just as you can\nmix routers having ospfExtLsdbLimit set to differing values. In these cases, however,\nthe only routers guaranteed to detect the database-overflow condition are those having\nthe smallest ospfExtLsdbLimit value. Unless this subset of routers can bring the link-\nstate database size under their ospfExtLsdbLimit by themselves, the routers in the\nOSPF domain may fail to synchronize on a common link-state database. This failure, in\nturn, can lead to continual retransmissions of Link State Updates and to routing loops\nwhen sending to external destinations.\n7.6 The External-Attributes-LSA\nThe Internet is split up into Autonomous Systems (ASs). Routers within an AS run an\nInterior Gateway Protocol (IGP) in order to forward traffic within the AS. Examples of\nIGPs include OSPF and RIP. Routers at the edge of an AS exchange routing information",
        "8bfd1b07-487a-4b69-b411-4fb73ffb41bf": "Section 7.6 The External-Attributes-LSA 147\nwith other ASs using an Exterior Gateway Protocol (EGP). The Border Gateway Proto-\ncol (BGP; see Section 13.3) is the EGP used in the Internet.\nWhen an AS is providing transit service for other ASs, routers on one side of\nthe AS must transmit the BGP information across the AS where other routers will in\nturn readvertise the information to their BGP peers. The original mechanism to propa-\ngate BGP information across an AS was called Internal BGP, or IBGP. In IBGP, each BGP\nrouter on the edge of a given AS must form an IGBP peering session with every other\nBGP router in the AS. The problem with this scheme is that the number of IBGP ses-\nsions rapidly becomes intractable, growing as n , where n is the number of BGP rout-\ners in the AS.\nMethods for distributing BGP information across an AS have been proposed that\nprovide better scaling than IBGP: BGP confederations [248], BGP route reflectors [17],\nand BGP route servers [94]. The first two methods have seen significant deployment in\nthe Internet.\nWhen an AS runs OSPF as its routing protocol, the external-attributes-LSA (LS\nType 8) provides another alternative to IBGP. The BGP information that needs to be\ncommunicated consists of a set of BGP attributes for each BGP destination, the fore-\nmost attribute being the path of ASs (the so-called AS path), which must be traversed to\nreach the destination. The AS path is necessary to provide loop detection within the\nBGP protocol and also is used to implement BGP routing policies (see Section 13.3).\nIn order to use the external-attributes-LSA to replace IBGP, each BGP router at\nthe edge of the OSPF Autonomous System imports its BGP-learned destinations in\nAS-external-LSAs. Each AS-external-LSA has a 4-byte tag field that can be used to carry\nextra information about the external route (see Figure 6.7). If the BGP attributes for the\ndestination can be squeezed into these 4 bytes, an external-attributes-LSA is unneces-\nsary; for example, this is the case when the destination belongs to a neighboring AS (see\nSection 11.6.1 and [252]). However, if the destination's AS path is longer, a separate\nexternal-attributes-LSA is originated with contents equal to the destination's BGP\nattributes. Then, in order to associate the destination's AS-external-LSA with the correct\nBGP attributes, the Tag field in the AS-external-LSA is set equal to the Link State ID of\nthe appropriate external-attributes-LSA.\nAdvertising the BGP attributes separately from the destinations saves space in the\nlink-state database when multiple destinations have the same BGP attributes. This is\ncommonly the case. To date, an example default-free router had 40,000 BGP routes but\nonly 13,000 associated BGP attributes.\nAs an example, suppose that in Figure 6.6, the OSPF Autonomous System is\nassigned AS 33 and provides transit service for several other ASs. Suppose further that\nrouter B has a BGP session with a router in AS 171 and that router G has a BGP session\nwith a router in AS 265. When router B installs in its routing table a BGP route to\n132.166.0.0/16 with an AS path of [AS 171, AS 68, AS 373], router B passes this informa-\ntion along to G by originating an external-attributes-LSA and an AS-external-LSA. The\nexternal-attributes-LSA, having a Link State ID of OxfOOOOOOa, is pictured in Figure 7.4.",
        "924e0483-565c-4a35-87b4-c8061c2081e6": "148 OSPF Extensions Chapter 7\nThe AS-external-LSA would advertise 132.166.0.0/16, inserting OxfOOOOOOa in the\nAS-external-LSA's Tag field. If on receipt of these two LSAs, router G installs the route\ninto its routing table, G would in turn advertise 132.166.0.0/16 to its BGP peer in AS 265,\nwith a new AS path of [AS 33, AS 171, AS 68, AS 373]. The Format ID field in the body of\nthe external-attributes-LSA enables the external-attributes-LSA to transmit data for pro-\ntocols other than BGP.\nFigure 7.4 The external-attributes-LSA.\nUse of the external-attributes-LSA has a clear advantage over IBGP, analogous to\nthe advantage of multicast over multiple unicasts. When a router uses the external-\nattributes-LSA to advertise its BGP information to other routers in its AS, the router is\nguaranteed that each advertised BGP route will traverse each network segment at most\nonce; this is a generic property of OSPF flooding (see Section 4.7.2). In contrast, when\nusing IBGP, the same BGP information may be sent over a network segment many\ntimes, as multiple IBGP peering sessions each may traverse the network segment. The\nexternal-attributes-LSA also has an advantage over other IBGP scaling methods, such as\nroute reflectors and BGP communities, in that the external-attributes-LSA requires noLS Age\nOptions LS Type\nLink State ID\n- Advertising Router \u2014\n\u2014 LS Sequence Number \u2014\nLS Checksum\nLength\nAttribute length\nFormat ID |\n_ External _\nAttributes\nZero padding0\n0x2, Type 8 (external-attributes-LSA)\nOxfOOOOOOa\nRouter B's Router ID\n0x80000004\n40 bytes\n1 8 bytes\nFormat ID 1 = BGP\nBGP Origin = IGP\nAS path = 171,68,373",
        "6c783e3d-52aa-4440-a747-006442707a55": "Section 7.6 The External-Attributes-LSA 149\nadditional configuration. The one potential downside of the external-attributes-LSA is\nthat it requires routers on the interior of the AS (although not all routers) to store BGP\ninformation in the form of external-attribute-LSAs, when before they did not have to.\nAlthough the external-attributes-LSA is an attractive alternative to IBGP, it has\nnever been implemented or deployed. This is probably due to the reluctance of network\noperators to import all of their BGP-learned routes (to date, more than 40,000 in the\ndefault-free networks) into their IGP.\nBackward-Compatibility Provisions\nAs with all optional LSA types, the external-attributes-LSA is flooded only between\nthose routers that understand the LSA. A router conveys its understanding to its neigh-\nbors by setting the EA-bit in the Database Description packets that the router sends dur-\ning initial database synchronization (see Section 4.7.1).\nRestricting external-attributes-LSAs to modified routers is both a feature and a\nbug. On the positive side, it relieves unmodified routers from the burden of stor-\ning the external-attributes-LSAs. On the negative side, however, it can prevent the\nexternal-attributes-LSA from replacing IBGP functionality. If two BGP routers are not\ninterconnected by routers supporting the external-attributes-LSA, the two routers will\nstill be aware of the BGP routes each is trying to exchange with the other through exam-\nination of AS-external-LSAs. But they will not be able to associate BGP path attributes\nwith the routes, since they will not receive each other's external-attributes-LSAs. Worse\nyet, if two BGP routers were, but are no longer, interconnected by routers capable of\nflooding external-attributes-LSAs, the two BGP routers may end up associating incor-\nrect BGP path attributes with the BGP routes. This latter problem is due to the fact that\nthe external-attributes-LSAs that each router holds may in that case be out of date.\nConsidering these problems, it may have been better if all routers were capable of\nflooding external-attributes-LSAs. For this reason, the OSPF for IPv6 specification intro-\nduced a category of LSA types that are stored and flooded even by routers that do not\nunderstand the LSA type (see [46]).\nFurther Reading\nOSPF hierarchical routing, including a discussion of OSPF stub areas and NSSAs, is cov-\nered in Chapter 6. The NSSA protocol specification is given in [47].\nFor a more detailed explanation of Type of Service routing, see the discussions on IP\nforwarding rules in the IP router-requirements document [12].\nThe OSPF Demand Circuit extensions are defined in [169]. These extensions have\nalso been defined for RIP. Defined in [159] and [160], the RIP extensions provide similar\nfunctionality to the OSPF Demand Circuit extensions. However, the mechanisms to pro-\nvide such functionality in a Distance Vector algorithm, such as RIP, are quite different.",
        "fd5a5977-07d7-4f01-8f6f-65238451bf91": "150 OSPF Extensions Chapter 7\nFor further information on BGP, see Section 13.3 and the BGP specification [208].\nBGP extensions addressing ways to more efficiently propagate BGP routing information\nacross an AS are described in [17], [94], and [248].\nExercises\n7.1 Consider the area configuration in Figure 6.6. Assume that router B imports 1,000\nexternal routes into OSPF as AS-external-LSAs and that router G imports another\n1,000. Assume that area 0.0.0.4 is an OSPF stub area and that area 0.0.0.5 is an\nNSSA, with router H originating 100 Type-7-LSAs. What is the size of the link-\nstate database in area 0.0.0.1? In area 0.0.0.4? In area 0.0.0.5?\n7.2 Consider the network in Figure 7.2. Suppose that the link between routers 10.9.0.1\nand 10.9.0.2 incurs a high per packet charge. For that reason, for traffic between\n10.9.0.6 and 10.9.0.4, you want packets that request to minimize monetary cost (IP\nIOS 16) to avoid that link. What is the smallest IOS 16 cost that can be configured\nfor the link in order to achieve this goal?\n7.3 Section 7.3 gave an example of X.25 networks indicating link failures through cer-\ntain diagnostic codes in Call Clear indications. Give other examples of data-link\nprotocols that can indicate link failures. Which common data links do not provide\nlink-failure notifications?\n7.4 Assume the following configuration in Figure 7.2. Only routers 10.9.0.6 and\n10.9.0.2 implement the OSPF Database Overflow extensions, with both setting\ntheir ospf ExtLsdbLimit to 5,000. Suppose that each of the eight routers in the AS\noriginates 1,000 AS-external-LSAs. Does the link-state database reach a synchro-\nnized state in this case? How about if ospf ExtLsdbLimit is set to 6,500 in both\n10.9.0.6 and 10.9.0.2?\n7.5 Assume that the external-attributes-LSA is used to replace IBGP in an AS in which\n40,000 BGP routes must be exchanged between BGP routers, with 14,000 distinct\nAS paths, of average length 6 ASs. What would the size of link-state database be in\nbytes, assuming no overlap of destinations and/or AS paths advertised by the\nBGP routers? Is the latter a reasonable assumption?",
        "379a0d24-d19c-4898-92d9-862492e8d073": "8\nAn OSPF FAQ\nIn this chapter, we answer some frequently asked questions (FAQs) about the OSPF\nprotocol. Many of these questions have been raised on the OSPF Working Group's mail-\ning list. The questions that follow are roughly organized from general to specific.\nQ: Where can I get OSPF software?\nA: The original freely available OSPF implementation was written by Rob Coltun\nwhen he was at the University of Maryland (UMD). That implementation was written\nin C for UNIX systems and for a long time was available via anonymous FTP over the\nInternet.\nAlthough no longer available in its original form, the UMD OSPF implementation\nhas since been incorporated into the GATED program. GATED was originally devel-\noped at Cornell University and is now maintained and enhanced by Merit Network Inc.,\na nonprofit corporation located in Ann Arbor, Michigan. GATED, a routing daemon for\nUNIX platforms, can be used as a replacement for the standard UNIX routed routing\ndaemon. In addition to routed's RIP support, GATED also supports OSPF and BGP.\nGATED is also commonly used as a development platform for routing protocol soft-\nware, so you can often find modified GATEDs supporting other protocols: DVMRP, PIM\nSparse, IS-IS, and so on.\nAlthough freely available for individual use, you must execute a GATED redistribu-\ntion license when incorporating GATED software into commercial products. Software\n151",
        "f59dac1f-87fa-4aaa-ace9-4fb05b9dd3a6": "152 An OSPF FAQ Chapter 8\nsupport for GATED is available through joining the Merit GATED Consortium. For\nmore information on GATED, consult http://www.gated.org.\nIn addition to being incorporated into GATED, the UMD implementation has also\nbeen ported into many commercial routers. As such, it is by far the most common OSPF\nimplementation in use today.\nBesides the UMD OSPF implementation, the only other freely available OSPF\nimplementation is the one contained in the companion book to this book (OSPF\nComplete Implementation), which is covered by the GNU General Public License.\nQ: How can I participate in discussions about OSPF?\nA: Discussions about the OSPF protocol, including possible bugs and enhancements,\nare carried on the OSPF Working Group's mailing list: ospf\u00a9gated.Cornell .edu. To\njoin the mailing list, send a subscription request to ospf-request@gated. Cornell. edu.\nThere are also sometimes interesting OSPF discussions on the various GATED mailing\nlists (see http://www.gated.org).\nThe OSPF Working Group is one of the Internet Engineering Task Force's (IETF)\nmany Working Groups. The IETF is the protocol engineering and development arm\nof the Internet. Anyone is free to participate in the IETF through any of the many\nIETF mailing lists. The IETF also holds three face-to-face meetings a year. Most IETF\nWorking Groups produce documents called Internet Drafts, some of which will even-\ntually be published as RFCs. For information on IETF Working Groups, how to join\nIETF mailing lists, how to receive or submit Internet Drafts, and so on, consult\nhttp: //www. ietf.org. For a general description on how the IETF works, see [108].\nQ:' What units is the OSPF link-state metric measured in?\nA: OSPF does not specify how costs are assigned to links. Assignment of link costs is\nleft up to individual network administrators. Within one OSPF routing domain, link\ncost may be set to the link's fixed delays (propagation), whereas another routing\ndomain may use the monetary cost of transmission over the link, and so on. As far as\nOSPF is concerned, links costs are just numbers subject to the following restrictions.\n\u2022 The cost of any link must lie in the range 1 to 65,535 inclusive. In other words,\nlink cost is a positive 16-bit integer.\n\u2022 The cost of a path is the sum of the cost of the path's constituent links. Paths\nwith smaller cost are shorter and preferred over paths with larger cost. As a\nresult, links with smaller cost are more likely to carry data traffic.\n\u2022 When virtual links are used, the cost of paths within a transit area should be\nkept less than or equal to 65,535. If path cost in a transit area exceeds this value,\nvirtual links may not become operational.",
        "69cc7703-68cc-448a-8e88-db41f62bb1b2": "Chapter 8 An OSPF FAQ 153\nAs an example, when all links are assigned a cost of 1, OSPF routing will always\nchoose minimum-hop paths. The default value for link cost in the OSPF MIB [12] indi-\ncates link-transmission speed. For more information on metric-setting strategies, see\nChapter 11, OSPF Management.\nQ: Does OSPF routing respond to network load?\nA: No, OSPF metrics are static. OSPF dynamically routes around link failures, but it\ndoes not route around network congestion. Changing paths in response to network load\nis difficult to do well in a distributed routing protocol: Routing has a tendency to thrash,\nwith all routers choosing the shortest path initially, then moving en masse to a lightly\nloaded secondary path, and then back again.\nThe only link-state routing protocol to react to network load was the BBN\nARPANET routing algorithm [147], which used a link-state metric that varied with\nthe length of the link's output queue. The ARPANET experienced route thrashing, but\nBBN fixed the problem by limiting the dynamic metric range to reduce the response\nto congestion. The effect of limiting the metric is shown in [127], which contains a great\nfigure that shows graphically that within a limited range, metric changes encourage an\nequilibrium but that large metric changes cause wild oscillations in routes.\nHaving routing respond to network load is easier in virtual-circuit networks than in\ndatagram networks like the Internet. The reason is that virtual-circuit networks natu-\nrally limit the response to congestion: Changes in metric due to congestion levels typi-\ncally affect only new circuits, leaving existing circuits on their old paths (see [20]). For\nthis reason, you do see link-state algorithms in virtual-circuit networks that route cir-\ncuits based in part on network load conditions.\nQ: Why is the representation of point-to-point links in OSPF so strange?\nA: The representation of point-to-point links in OSPF is a little strange. But before\nexplaining why it is so strange, we should describe how point-to-point links are repre-\nsented. Figure 8.1 shows three routers connected by point-to-point links. Each router\nhas assigned an IP address to each of its point-to-point interfaces. These addresses are\ntotally unrelated; the addresses assigned to either end of a point-to-point link need not\nfall into a common subnet. Each router has also independently assigned a cost to each\npoint-to-point interface. In the resulting router-LSAs, which also are pictured in Fig-\nure 8.1, each router advertises a point-to-point connection to the other and a stub link\nto the other router's IP address.\nAdvertising the neighboring router's IP address instead of the router's own address\nis what people find so strange. To make this even more confusing, after the router\nruns its OSPF routing calculation, it finds that the resulting routing table says to for-\nward packets for its own address out the point-to-point interface to the neighboring\nrouter! Although it was always assumed that a router would not forward a datagram",
        "b7f79520-7876-4d27-97bc-b68077bdfd52": "154 An OSPF FAQ Chapter 8\nFigure 8.1 Point-to-point representation in OSPF.\naddressed to one of its own addresses, this property does make routing table dumps\nlook a little weird.\nSo what are the reasons behind this strange representation? First, the noncontrover-\nsial part: Advertising the interface addresses separately instead of advertising a single\nroute for the point-to-point link, as is done in the RIP, frees the network administrator\nfrom assigning separate subnets to each point-to-point link. This allows better conserva-\ntion of the ever scarcer IP address space.\nBut why advertise the neighbor's IP address instead of your own? The following\nobscure reasons explain why.\n\u2022 The neighbor's address is advertised even before an OSPF neighbor relation-\nship is formed. This allows network booting over the point-to-point link.\nAssume in Figure 8.1 that router B is trying to boot a software image that is\nlocated on a server somewhere else in the network. The network boot loader\nrunning in router B is probably a small program without an OSPF application.\nHowever, having router A advertise B's address allows router B's address to be\nroutable anyway.\n\u2022 Advertising the neighbor's address has a tendency to bias routing in a way that\nis useful for diagnostic purposes. You'd like to use ping to determine whether",
        "7b9c34e1-ebb1-4d51-aa6d-9e44cb111727": "Chapter 8 An OSPF FAQ 155\nan interface is operational. So when pinging an interface address, it would be\nuseful if the ping were routed into the addressed interface. This is more likely,\nalthough not guaranteed, when advertising the neighbor's IP address. For\nexample, in Figure 8.1, when router B sends a ping to router A's address\n10.20.9.6, it is in fact routed through router C and then into the correct interface.\n(Of course, to some people, this just looks like suboptimal routing!)\nThe representation of point-to-point links in OSPF is confusing enough that an\noption was added to represent the links in a fashion identical to that used by RIP:\nAssign a subnet to the point-to-point link and have the router at each end of the link\nadvertise a stub link to the subnet. In OSPF for IPv6 (see Section 3.7), in which backward\ncompatibility with the installed base of OSPF routers is not an issue, each end point of\nthe link advertises its own address instead of its neighbor's address.\nQ: Must both sides of a point-to-point link agree whether the link is numbered or unnumbered?\nA: Yes. To see the problems that such a disagreement causes, let us look at an example.\nSuppose that in Figure 8.1 router B thinks that its link to router A is unnumbered but\nthat all other interface addresses are as pictured. In this case, router B, thinking that no\naddresses had been assigned to the link, would fail to advertise A's interface address,\n10.19.1.1. As a result, that address would become unreachable.\nQ: Why is OSPF so difficult to configure?\nA: It isn't, or at least it shouldn't be. A router's OSPF implementation should not be\nany more difficult to configure than its RIP implementation. OSPF does have a large\nnumber of tunable parameters that can make configuration seem complicated. How-\never, most of these parameters should be set to default values in an OSPF implemen-\ntation.\nThe complete set of OSPF configurable parameters can be found in the OSPF MIB\n[12]. The MIB is organized into 12 groups (a thirteenth group, ospfAreaRangeTable, is\nobsolete and is included only for backward compatibility), containing 99 variables in all.\nHowever, more than half (61) of these variables are read-only, used for statistics collec-\ntion, reporting the contents of the link-state database, and so on. The remaining vari-\nables are used to configure not only the base OSPF protocol but also OSPF extensions,\nsuch as MOSPF, NSSA areas, and the Demand Circuit extensions (see Chapter 7).\nTo get OSPF running on a router, all you really need to do is configure the IP\naddresses of the router's OSPF interfaces (variable ospf if ipAddress). The other vari-\nable that is frequently set is the cost of an OSPF interface (ospf ifMetricValue).\nOSPF has a number of configurable per interface timers, whose values should\nalmost always remain at their default settings. The default settings are listed in\nthe OSPF MIB. If running OSPF over satellite links or very low-speed links (for\nexample, 1200-baud modems), you may need to change the values of the timers\nospfIfTransitDelay, ospfIfRetranslnterval, ospfifHelloInterval,and",
        "1148cf71-2212-449a-ac88-aff57b0c80a7": "156 An OSPF FAQ Chapter 8\nospf If RtrDeadinterval. Running OSPF over nonbroadcast networks, such as Frame\nRelay and ATM, may also require some configuration, especially when using NBMA\nmode (see Chapter 5).\nSplitting an OSPF routing domain into areas always requires additional configura-\ntion. First, you must establish area boundaries by configuring the area that each router\ninterface attaches to (ospfifAreaid). Then, to achieve address aggregation at area\nborders, one or more entries in the area border routers' ospf AreaAggregateTable\nmust be configured. In addition, if not all nonbackbone areas attach to a single back-\nbone area, one or more virtual links must be configured between area border routers\n(ospfvirtif Table). For detailed information on configuring OSPF, see Chapter 11,\nOSPF Management.\nQ: What OSPF interface type should I use when running OSPF over a Frame Relay subnet?\nA: Your two options are the OSPF NBMA and Point-to-MultiPoint interface types. The\nNBMA interface type treats the Frame Relay network sort of like a simulated Ethernet\nsegment, whereas Point-to-MultiPoint models Frame Relay PVCs as if they were indi-\nvidual point-to-point links. NBMA is more efficient than Point-to-MultiPoint but is gen-\nerally more difficult to configure and less robust against PVC failures and other failures\nwithin the Frame Relay subnet. See Sections 5.3 and 5.4 for more details.\nQ: How should my routers advertise information between the OSPF and RIP protocols?\nA: Unfortunately there are no standards in this area. Every router vendor has worked\nout its own mechanisms controlling the interactions of OSPF and RIP. So the place to\nstart in answering this question is probably the configuration guide provided by your\nrouter vendor(s). Two simple models for the interaction of OSPF and RIP are given in\nSection 11.6.2.\nQ: I see a lot of \"2-Way\" states in my OSPF router's neighbor statistics. Don't I want the oper-\national states of all my OSPF router's neighbors to be \"Full\"?\nA: No. State \"2-Way\" is often correct for neighbors over broadcast and NBMA seg-\nments. On these segment types, only a small percentage of the neighbors become fully\nadjacent (that is, achieve state \"Full\"). All routers become fully adjacent to the segment's\nDesignated Router and Backup Designated Router but go no further than \"2-Way\" with\nother neighbors on the segment. See Section 5.2 for more details.\nQ: When the Designated Router is operational, is the Backup Designated Router duplicating\nthe work done by the Designated Router?\nA: No. The Backup Designated Router is mainly just waiting to take over Designated\nRouter duties should the present Designated Router fail. The only function that the\nBackup Designated Router will perform until that failure occurs is to help a little in",
        "6f13b03a-f4a6-4156-82b2-dad340473866": "Chapter 8 An OSPF FAQ 157\nflooding. The Designated Router is responsible for maintaining the reliability of flood-\ning over its segment. However, should retransmissions of LSAs become necessary,\nthe Backup Designated Router will step in to perform the necessary retransmissions\neven if the Designated Router is still active. In all other duties, such as origination of\nthe network-LSA for the segment and initial flooding of LSAs over the segments,\nthe Backup Designated Router always defers to the active Designated Router. See Sec-\ntion 5.2 for more details.\nQ: How big can I build my OSPF areas?\nA: Maximum area size really depends on your router vendor (or vendors). In 1991, the\nguideline was at most 200 routers in a single area [173]. The larger an OSPF area gets,\nthe more resources the OSPF protocol consumes in the area's OSPF routers. These\nresources include router memory, CPU cycles, and network bandwidth.\nTo date, some vendors have deployed OSPF areas of up to 350 routers. In contrast,\nother router vendors recommend that areas should be limited to 50 or fewer routers.\nMost vendors will include in their documentation the maximum area size they will\nsupport.\nIn general, you should not make your areas too small. Areas require additional con-\nfiguration (see the previous question) and can create suboptimal routing.\nQ: Where should I put area boundaries?\nA: This is a complicated question, one without a single answer. Placement of area bor-\nders can depend on the following factors.\n\u2022 Addressing structure. In a routing domain in which segments have already been\nassigned address prefixes, you want to configure area boundaries so that OSPF\ncan aggregate prefixes at area borders. For example, in Figure 6.3, area 0.0.0.1\nhas been assigned so that a single aggregate of 10.2.0.0/16 can be advertised to\nother areas for the prefixes 10.2.1.0/24 and 10.2.2.0/24. Aggregation reduces\nrouting table size, lessening the resource requirements.\n\u2022 Area size. As mentioned, vendors usually have a limit to the size of areas they\ncan support. Area size comes into play in another way also. Suppose that you\nhave not yet assigned address prefixes to your routing domain's segments. You\ncan then minimize routing domain size by simultaneously (a) assigning prefixes\nalong area boundaries, (b) assigning equal-sized areas, and (c) making the num-\nber of areas equal to the common area size (see [128]). For example, if you have\n25 network segments in your routing domain, assign 5 areas of 5 segments each,\ntaking the addresses for all segments within a single area from a single aggre-\ngated prefix.\n\u2022 Topology considerations. Area boundaries can induce suboptimal routing. To\nreduce the amount of suboptimal routing, minimize the physical connections",
        "bac754dc-7a4c-4833-8729-658b43964b38": "158 An OSPF FAQ Chapter 8\nbetween areas. Minimizing physical connection between areas also minimizes\nthe number of area border routers, which reduces the number of summary-\nLSAs and hence limits link-state database size.\n\u2022 Policy considerations. OSPF protects routing inside area from outside interfer-\nence. If you are running a single routing domain that consists of multiple orga-\nnizations, each organization may wish to be configured as its own area. Such a\nconfiguration protects against misconfiguration of one organization (for exam-\nple, mistakenly assigning a subnet belonging to another organization) from dis-\nturbing the other organization's internal infrastructure. Also, by using stub\nareas or NSSAs, one organization can be assured that the other organizations\nwill not use its links for transit (that is, all traffic on the organization's links will\neither be originated by, or destined for, the organization itself). In addition,\nwhen configured as separate areas, organizations can hide selected addresses\nfrom each other by configuring \"no-advertise\" aggregates at area boundaries.\nQ: Should I use virtual links ?\nA: Sure, if your area configuration requires them. Virtual links free you from having to\nworry about maintaining physical connectivity of the backbone area. Simply configure\narea boundaries based on addressing, topology, and/or policy considerations and then\nconnect the backbone area (including all area border routers) with virtual links as\nneeded. These days, almost all router vendors support virtual links.\nVirtual links do have some disadvantages, however. They require manual configu-\nration. Also, when using virtual links, you cannot aggregate addresses assigned to net-\nwork segments belonging to the backbone area; if you do, the routers will simply ignore\nthe aggregation directives.\nQ: Is an area border router simply a router that attaches to multiple areas, or does it also have to\nbe attached to the backbone area?\nA: Any router that attaches to multiple areas is called an area border router. Area bor-\nder routers label themselves as such in their router-LSAs, originate summary-LSAs into\ntheir attached areas, and are capable of forwarding datagrams between their attached\nareas.\nHowever, unless an area border router is also attached to the backbone area, either\nphysically or via a configured virtual link, the area border router will not be fully func-\ntional. Without an attachment to the backbone area, the area border router is prohibited\nfrom using summary-LSAs in its routing calculations and so cannot calculate routes to\ndestinations in remote areas.\nConsider, for example, the area configuration in Figure 6.6. Even without the\nvirtual link to router D, router F would still be considered an area border router. With-\nout the virtual link, router F would still be able to forward traffic from area 0.0.0.3 to\ndestinations in area 0.0.0.5, and vice versa. But until the virtual link to router D is",
        "2bdbd844-0c5e-4e63-b90f-e908c455a284": "Chapter 8 An OSPF FAQ 159\nestablished, router F would be unable to forward traffic to destinations in remote areas\n(areas 0.0.0.0, 0.0.0.1,0.0.2, and 0.0.0.4).\nQ: When I create virtual links, does OSPF force the data traffic to flow along the same paths as\nthe virtual links ?\nA: No. OSPF control traffic follows the path of the virtual links, with information con-\ncerning one nonbackbone area being sent to the backbone, where it is then distributed to\nthe other areas. But data traffic can take shortcuts between nonbackbone areas, flowing\nalong paths not described by any virtual link. You can think of virtual links as enabling,\nbut not restricting, transit traffic.\nConsider the area configuration in Figure 6.6. The two virtual links in area 0.0.0.3\nallow that area to carry transit traffic between the rest of the routing domain and areas\n0.0.0.4 and 0.0.0.5. However, data traffic between areas 0.0.0.4 and 0.0.0.5 will flow\nacross the direct link between routers E and F rather than follow the virtual links\nthrough router D. In contrast, the OSPF control traffic does follow the virtual links.\nFor example, routing information about the destinations in area 0.0.0.5 is flooded by\nrouter F along the virtual link to router D, from where it is further distributed along the\nvirtual link to router E and also to routers A, B, and C in area 0.0.0.0.\nQ: Why are LSA instances with larger checksums necessarily more recent?\nA: Obviously just because one instance has a larger checksum does not mean that the\nLSA has been more recently generated. However, assuming that both instances have the\nsame LS Sequence Number and relatively the same age (see Section 4.2.2), OSPF treats\nthe LSA instance having the larger checksum as being more recent. This behavior solves\nthe following problem.\nSuppose that router X has originated a router-LSA with an LS Sequence Number of\n0x80000006. Router X is then taken down to install a new interface card, and is restored\n5 minutes later. Router X has no idea which LS Sequence Numbers it has used in the\npast; suppose that the new router-LSA that router X originates also has an LS Sequence\nNumber of 0x80000006 but different contents to reflect the newly added interface. Now\nthere are two router-LSAs for router X present in the network simultaneously. How are\nall the routers to agree on which LSA has the more recent data?\nOSPF's rule selecting the LSA having the largest checksum is arbitrary but produces\nthe desired result. In the situation of the previous paragraph, there are three cases. In the\nfirst case, the new router-LSA has a larger checksum than the old LSA. In this case, as\nit is flooded throughout the routing domain, the new LSA replaces the old, and every-\nthing is well.\nIn the second case, the new LSA has a smaller checksum and is therefore ignored.\nHowever, in the process of performing initial database synchronization with its neigh-\nbors (see Section 4.7.1), router X will learn about the old LSA instance and, since the old",
        "ac88eac6-f774-4702-a1d3-15395740fc55": "160 An OSPF FAQ Chapter 8\nwould be preferred over router X's current LSA, will increase its router-LSA's sequence\nnumber to 0x80000007 and reflood to overcome the problem.\nIn the most unlikely case, both old and new LSAs will have identical checksums,\neven though they have different contents. In this case, router X's updated LSA will be\nignored. It may then take as long as the LSA refresh interval (30 minutes, at which time\nrouter X will refresh its LSA with an incremented LS Sequence Number) before the\nother routers accept the new information from router X.\nQ: Does OSPF aging require synchronized clocks?\nA: No. OSPF does not even require that routers have time-of-day clocks. OSPF does\nrequire that a router keep track of how long ago each LSA was originated. This require-\nment forces all OSPF routers to have some kind of internal clock so that they can age the\nLSAs within their link-state databases. The age of an LSA is between 0 and 60 minutes.\nAs long as the age of a given LSA does not vary from router to router by more than\n15 minutes (the OSPF architectural constant MaxAgeDiff), OSPF continues to work\ncorrectly. Allowing a variation of 15 minutes out of a maximum of 60 means that one\nrouter's internal clock can be up to 25 percent faster than another's without any adverse\neffects.\nThere is one case in which all routers have to agree more closely on the age of an\nLSA. When an LSA reaches the age of MaxAge (60 minutes), it is removed from con-\nsideration by the OSPF routing calculation. To ensure that this happens roughly at\nthe same time in all routers, when an LSA reaches MaxAge in one router's link-state\ndatabase, that router refloods the LSA to tell the other routers to also remove the\nLSA.\nQ: I've read that OSPF refreshes its link-state database every 30 minutes. Does the whole data-\nbase get reflooded all at one time?\nA: No. LSAs, the individual pieces of the link-state database, get refreshed indepen-\ndently. If an LSA's LS Age reaches 30 minutes, the OSPF router that originated the\nLSA will update the LSA, increasing the LSA's LS Sequence Number, resetting the\nLS Age field to 0, and reflooding the LSA. Since the LS Age fields of the LSAs\nwithin the link-state database usually become fairly randomly distributed, you tend\nto get a constant dribble of LSA refreshes rather than having all the LSAs refresh at\nonce.\nTake, for example, the link-state database pictured in Figure 12.10. The two\nsummary-LSAs originated by router 165.29.1.6 (lines beginning 3 155.29.1.0\nies.29.1.6 and 3 165.29.1.64 165.29.i. 6) are due to be refreshed in 6 seconds.\nAfter that, the next LSA refresh will be for router 170.211.176.12's router-LSA (line\nbeginning l 170.211.176.12 170.211.176.12), which will occur 201 seconds later.",
        "14ccd281-d5dd-4531-ac55-2eb1e4dfcca7": "Chapter 8 An OSPF FAQ 161\nQ: If I import the whole Internet routing table into OSPF, will my OSPF routers be able to keep\nup with the LSA refresh traffic?\nA: Most routers will be able to handle this amount of OSPF control traffic, although it\nshould be mentioned that to date, no Internet Service Provider imports the whole rout-\ning table (around 45,000 entries) into its IGP. Every OSPF LSA gets refreshed every 30\nminutes, so with 45,000 LSAs, you would see on average 25 LSA refreshes a second.\nMultiple LSAs are likely to be packaged within a single OSPF Link State Update packet,\nbut you'd still probably see several Link State Update packets a second, on every link\nin the network (see Section 4.7.2). This amount of processing is within reach of mod-\nern OSPF implementations but of course will continually increase as the size of the\nInternet's routing table increases.\nThere is one way that router vendors can dramatically decrease the amount of\nOSPF control traffic: They can program their OSPF routers to originate LSAs with the\nDoNotAge bit (see Section 7.3) set. This removes the requirement to refresh LSAs,\nresulting in OSPF routers sending only changes, similar to protocols such as BGP.\nHowever, this behavior would reduce the protocol's robustness\u2014if you remove OSPF's\nLSA refreshes, damage to an LSA while in a router's database will not be corrected\nautomatically.\nJust because a router originates its LSAs with the DoNotAge bit set, it doesn't mean\nthat the router is prevented from refreshing its LSAs. By setting the DoNotAge bit, the\nrouter can choose to refresh its LSAs at whatever rate the router chooses\u2014never, once\nevery 3 hours, once a day, or even at a rate that is inversely proportional to the link-state\ndatabase size.\nThere is another possible modification. Just as in the Database Overflow extensions\nto OSPF (Section 7.5), you can rank the LSAs according to their importance. In the Data-\nbase Overflow extensions, when a router's capacity is exceeded, it discards the least cru-\ncial part of its OSPF database, namely, AS-external-LSAs for destinations other than the\ndefault route. These too could be the only LSAs with the DoNotAge bit set, leaving the\nmore important parts of the database to refresh every 30 minutes. Refreshes of these\nmore crucial parts of the database would guarantee that the OSPF routing domain\nwould eventually return to a manageable state automatically, even in the presence of\nhardware and software errors within the routers that were causing LSAs to be lost or\ndamaged.\nQ: If a router detects that another OSPF router has become unreachable, should it delete the\nLSAs that that router had originated from the link-state database?\nA: Absolutely not! The only LSAs that the router is allowed to flush are the LSAs that\nthe router itself has originated. The problem with flushing another router's LSAs when\nthat router has become unreachable is that the unreachability condition may be short\nlived. If so, when that router again becomes reachable, it would have to reoriginate its",
        "a8b1e6df-995d-47dc-aab7-5d183fca4c40": "162 An OSPF FAQ Chapter 8\nLSAs, and all the routers in the network would have gone through the work of flushing\nand then immediately reinstating the LSAs just to get back to the status quo.\nAs an example of a temporary unreachability condition, see the network map in\nFigure 5.3. If there is a Designated Router change on the Ethernet, there may be a\nshort disruption in reachability as a new network-LSA and matching router-LSAs are\nflooded. During this time, you wouldn't want to flush LSAs originated by routers\nbeyond the segment, even if they are momentarily unreachable, because the con-\ntents of these LSAs are going to be the same before and after the Designated Router\nchange.\nAnother reason for a router not flushing LSAs originated by others is the desire to\navoid circular dependencies. The routing table calculation depends on the contents of\nLSAs, so you don't in turn want the existence of the same LSAs to depend on the rout-\ning calculation.\nThere are two obscure exceptions to the rule about not flushing other routers' LSAs.\nThe first comes about when a router has changed its OSPF Router ID. In this case, old\nnetwork-LSAs originated with the router's previous Router ID may still be in the link-\nstate database, and these the router is allowed to (in fact, is required to) flush (see\nSection 13.4 of [178]). The second is when there are LSAs in the database with the\nDoNotAge bit set (Section 7.3). Since these LSAs never age out, a router removes them\nfrom its database when the LSAs' originating router has been unreachable for at least an\nhour. A time constant as large as a hour was chosen to break the circular dependency\ndescribed in the previous paragraph.\nQ: Why install MaxAge LSAs in the link-state database when there are no previous instances?\nA: MaxAge LSAs in OSPF are just instructions to delete a particular LSA from the link-\nstate database. So why store a deletion request itself in the database? Most of the time,\nyou do not, but occasionally you do to deal with possible race conditions in OSPF's\nDatabase Exchange process (Section 4.7.1).\nA router performs Database Exchange with a neighbor as soon as bidirectional com-\nmunication has been established with the neighbor. The idea is for the router to describe\na snapshot of its database to the neighbor and then to let the neighbor pick and choose\nwhich pieces of the database (that is, LSAs) the neighbor needs to become up to date.\nThe connection between the two routers is available to forward data packets as soon as\nDatabase Exchange completes. However, while the database snapshot is being sent to\nthe neighbor, the database is potentially changing as a result of new LSAs received by\nthe router from other neighbors. These database changes create a window where the\nsnapshot sent to the neighbor can itself be out of date. Depending on how an implemen-\ntation chooses a snapshot, this window can be small or rather large.\nIn most cases, having the snapshot go out of date is handled naturally by the\nDatabase Exchange process: As long as LS Sequence Numbers don't go backward, the",
        "e8c467a4-215a-4807-b8c8-b49e08ed511c": "Chapter 8 An OSPF FAQ 163\nprocess works correctly. The only time LS Sequence Numbers can go backward in OSPF\nis when LSAs are deleted. In these cases, having the OSPF routers involved in the\nDatabase Exchange store the MaxAge LSAs prevents LS Sequence Numbers from going\nbackward during the extent of the Database Exchange.\nQ: Why does OSPF go through a separate Database Exchange process on link start-up, instead\nof simply re/loading the entire database over the link?\nA: There are three reasons. First, OSPF wants to know when synchronization has com-\npleted, so that it can then start advertising the link in LSAs. In this way, OSPF prevents\ndata traffic from being forwarded over the link until the two ends of the link have syn-\nchronized databases. The end of the Database Exchange is a clear indication that syn-\nchronization has completed.\nSecond, Database Exchange proceeds at a controlled rate, with one packet outstand-\ning at any one time, similar to TFTP. On the other hand, simply reflooding the database\nat link-up would cause a large blast of update traffic.\nThird, under most circumstances, Database Exchange ends up transmitting some-\nwhat less data, with only the 20-byte LSA header going over the link instead of the\nentire LSA.\nQ: How many router vendors support MOSPF?\nA: To date, you can find MOSPF support in products from five routers vendors: 3Com,\nBay Networks, IBM, Proteon, and Xyplex.\nMOSPF, like the other dense-mode multicast routing protocols DVMRP and PIM\nDense, is effective in commercial internets. These protocols calculate efficient paths, are\nrobust, and are simple to configure. In addition, both MOSPF and DVMRP allow multi-\ncast routing to be deployed incrementally by supporting multicast topologies that are\ndifferent from the unicast routing topology.\nDVMRP is the protocol in use in the majority of the MBONE (see [131]). However,\npieces of the MBONE run MOSPF, as described in Section 10.6.\nMOSPF is the only currently deployed multicast routing protocol that can be config-\nured for hierarchical multicast routing (Section 10.4). MOSPF is also the only multicast\nrouting protocol with explicit support for IP multicast's expanding ring search (Sec-\ntion 10.1.1).\nQ: Why does MOSPF use reverse costs when calculating inter-area and inter-AS multicast\npaths?\nA: Readers interested in the answer to this question will probably have to read Chap-\nter 10, MOSPF, first. Everyone probably agrees that multicast datagram paths are best",
        "53a4527c-1f55-4390-95f5-158841bd365a": "164 An OSPF FAQ Chapter 8\ncalculated using forward costs\u2014that is, the cost of links in the direction from the data-\ngram's source to the group members, or the direction in which the datagram will be\nforwarded. MOSPF does this when the source and group members are within the same\narea. However, when the datagram must cross area or AS boundaries, MOSPF needs\nto use summary-LSAs or AS-external-LSAs to approximate the neighborhood of the\nsource. Unfortunately these two LSAs, used mainly for unicast routing calculations,\nadvertise reverse costs from MOSPF's perspective: toward instead of away from the\nsource.\nOne could still imagine combining the reverse costs advertised by summary-LSAs\nwith forward-link costs in router-LSAs. However, to do so can prevent delivery of data-\ngrams to some group members. Using forward-link costs in these situations could cause\nan area border router's summary-LSA to look much more attractive for multicast than\nit really is. These problems begin showing up only in area configurations with virtual\nlinks, such as the one displayed in Figure 8.2.\nThis network diagram has a single multicast source, labeled SI, and located on seg-\nment 10.15.6.0/24. Three multicast sources, labeled Gl, are located in areas 0.0.0.1,\n0.0.0.2, and 0.0.0.3. Asymmetric link costs have been configured on several links. For\nexample, the cost to forward traffic from router D to router C is 1, whereas the cost to\nforward traffic in the reverse direction is 10. (Links with symmetric costs are displayed\nwith a single cost in the middle of the link, as we have done throughout most of the\nnetwork diagrams in this book.) As a result of these asymmetric costs, router E for-\nwards unicast traffic to SI along the circuitous path of cost 7 through routers F, D, C,\nand A (remember that in OSPF, the cost of the link between a network and a router is\nalways 0).\nTo calculate the path of a multicast datagram originating from SI, the routers use\nthe summary-LSAs generated for 10.15.6.0/24. These summary-LSAs are listed in\nTable 8.1. Note that some possible summary-LSAs have not been advertised, due to\nOSPF's split-horizon rules. For example, router D does not advertise a summary-LSA\nfor 10.15.6.0/24 into area 0.0.0.1, since router D's next hop for that destination is in\narea 0.0.0.1.\nWhen calculating the multicast path for a datagram with source SI and destination\ngroup Gl, router D will be selected as the entry into area 0.0.0.2 and router F as the entry\ninto Area 0.0.0.3. However, if forward costs were used in area 0.0.0.1's multicast routing\ncalculation, router E would be selected erroneously as the entry into area 0.0.0.1, and as\na result, none of the group members in areas 0.0.0.1, 0.0.0.2, or 0.0.0.3 would receive the\nmulticast datagram. But since MOSPF uses reverse costs everywhere in the inter-area\nand inter-AS cases, router C is chosen as the entry point into area 0.0.0.1, and the multi-\ncast datagram is delivered successfully.",
        "f19ef160-306a-48ef-93e0-2cb2b84b09c3": "Chapter 8 An OSPF FAQ 165\nFigure 8.2 An MOSPF example requiring reverse-link costs.",
        "e3025df4-b7f5-4f46-9dbe-dc66c349f38e": "166 An OSPF FAQ Chapter 8\nTable 8.1 Summary-LSAs Generated for Segment 10.15.6.0/24\nOriginating Router\nRouter C\nRouter E\nRouter B\nRouter D\nRouter FArea\n0.0.0.1\n0.0.0.1\n0.0.0.2\n0.0.0.2\n0.0.0.3Cost\n4\n7\n4\n5\n6\nQ: If you could design OSPF again from scratch, what would you do differently?\nA: The Internet is continually evolving, and its protocols must evolve with it. Once you\ndeploy a protocol, you can change it only so much, because you want to remain back-\nwardly compatible with your installed base; once people start using a protocol, you\nno longer have the luxury of starting with a blank slate when sitting down to solve a\nproblem.\nHowever, if we could start again from scratch, these are some of the things that I\nwould do differently.\n\u2022 Representation of point-to-point links. Having the routers at either end of a point-\nto-point link advertise one anothers' addresses has been the single most confus-\ning part of OSPF over the years (see earlier question in this FAQ). Although\nnow ameliorated somewhat by allowing a RIP-style advertisement of point-to-\npoint links, it probably would have been better to have each router advertise its\nown interface address; we have done this in OSPF for IPv6 [46].\n\u2022 Having LS Age field count down instead of up. This would allow a router to lower\nits LSA refresh rates by increasing the initial LS Age values for LSAs. However,\nwith the advent of the demand-circuit support for OSPF (see Section 7.3), lower-\ning the LSA refresh rate can also be accomplished through setting the LSA's\nDoNotAge bit.\n\u2022 Matching two halves of a link within the link-state database. When there are multiple\nlinks between a pair of routers, it is not possible in OSPF to match the link half\nadvertised by one router with the link half advertised by its neighbor. Although\nnot an issue for IP unicast traffic, which is inherently unidirectional, the inabil-\nity to match link halves did cause some problems when MOSPF needed to\nchoose the incoming interface for multicast datagrams (see Section 10.3.1).",
        "540411d4-1283-45ec-9ea3-34cc57561f0d": "Chapter 8 An OSPF FAQ 167\nLooking up network-LSAs during the Dijkstra. In the OSPF routing calculation, you\nmust find a network-LSA knowing only its Link State ID but not its Advertising\nRouter. This has caused some confusion when, for example, the OSPF Router ID\nof the Designated Router changes and there are for a while two network-LSAs\nwith the same Link State ID present in the database. This problem has been\nfixed in OSPF for IPv6 [46].\nConfiguring MOSPF on a per-physical link basis. Instead of configuring MOSPF on\na per IP subnet basis, it makes more sense to configure MOSPF on each physical\nlink. IP multicast forwarding, since it uses data-link multicast services, wants to\nmake sure that only one copy of each datagram is sent onto a link, no matter\nhow many IP subnets are configured on the link. In the current MOSPF specifi-\ncation, all but a single subnet on each link must be disabled for multicast for-\nwarding (see Section 6.3 of [171]).",
        "6522bfe0-d185-47a2-8c02-ef5cf23d0d36": "Part III\nInternet Multicast Routing\nIn Part III, we describe the basics of Internet multicast routing. Chapter 9, Internet\nMulticast Routing, provides an introduction to IP multicast forwarding. The interaction\nbetween multicast hosts and routers is covered, including IGMP. The role of a multicast\nrouter is described in detail. The difference between source-based tree and shared-tree\nprotocols is also explained. The chapter ends with a discussion of the Internet's multi-\ncast service, called the MBONE.\nChapter 10, MOSPF, gives a detailed description of one of the Internet's multicast\nrouting protocols, the Multicast Extensions to OSPF (MOSPF). The interaction of\nMOSPF and IGMP, the MOSPF routing calculations, the operation of MOSPF's two-\nlevel hierarchy, and the interoperation of MOSPF and DVMRP on the MBONE are all\ncovered.\n169",
        "4dc65933-6f66-4312-b238-8699d7e02b90": "9\nInternet Multicast Routing\nThis chapter lays the foundation for a discussion of multicast routing protocols. The\nduties of a multicast router, including the interaction between multicast hosts and\nrouters, are explained. Beginning with a historical examination of broadcast forward-\ning, the two multicast forwarding paradigms, source-based trees and shared trees, are\npresented. We end with a description of the MBONE, the Internet's multicast routing\noverlay.\n9.1 Internet Multicast Model\nA network multicast capability allows an application to send a single datagram\nthat will be delivered to multiple recipients. Applications exhibiting one-to-many and\nmany-to-many communication patterns find multicast extremely useful\u2014the alterna-\ntive, namely, sending multiple copies of each datagram, consumes more network band-\nwidth and incurs additional delay to recipients. These applications include multiperson\nteleconferences and videoconferences, distance learning, and bulk transfer of the same\nset of data to a large number of recipients, such as the distribution of stock quotations to\nstockbrokers.\nMulticast services are available at the data-link layer of many LAN technologies.\nFor example, in Ethernet, all MAC addresses having the least significant bit in their\nfirst byte set to 1 are multicast addresses. A host's Ethernet adapter can usually be\n171",
        "d2826d46-851b-4fc9-8665-3277fef115aa": "172 Internet Multicast Routing Chapter 9\nprogrammed with a set of multicast destinations to accept. For example, ten hosts\nattached to an Ethernet segment may all program their Ethernet adapters to accept the\nEthernet multicast address 01-00-5E-00-00-01. If any host on the Ethernet then sends an\nEthernet packet with destination 01-00-5E-00-00-01, all ten hosts will receive and pro-\ncess the packet accordingly.\nIP multicast is a generalization of these LAN multicast services. The IP multicast\nmodel is defined in [56]. A multicast destination is referred to as a multicast group. Each\ngroup is represented as a single Class D address (224.0.0.0-239.255.255.255). Group\nmembers can be scattered across an IP internet. A sender of a datagram addressed to the\ngroup does not know where the group members are; in fact, the sender does not know\nhow many group members there are or whether there are any group members at all\n(this kind of information may be available from the multicast transport protocol in use,\nbut here we are just talking about the network-layer multicast service). The sender, in\nfact, does not have to be a member of the multicast group itself. To send a datagram to\nthe group, the sending host just sets the IP datagram's destination IP address to the\ngroup's Class D address and then transmits the datagram as a data-link multicast onto\nthe local network segment. From there, it is the job of the multicast routers to forward\nthe datagram to all group members, replicating the datagram when necessary (Sec-\ntion 9.3.1).\nGroup membership is dynamic. A host can join and leave multicast groups at will,\nusing the Internet Group Membership Protocol to keep the multicast routers informed of\nthe host's current membership status. There are no limits to the size of a multicast\ngroup, and a host can belong to multiple groups at the same time.\nMulticast routers use multicast routing protocols to determine the path of the multi-\ncast datagram from sending host to group members. A number of multicast routing pro-\ntocols have been developed for the Internet; these protocols are discussed in Chapter 14,\nMulticast Routing Protocols.\nThroughout this chapter, we will use the network in Figure 9.1 to demonstrate vari-\nous IP multicast principles. That figure shows three members of multicast group Gl,\nlocated on network segments 192.5.1/24,192.5.2/24, and 192.7.1/24. These group mem-\nbers would use IGMP to convey their group membership to their local routers (routers\nR5, R6, and RIO and Rll, respectively). We assume that all routers R1-R11 are participat-\ning in multicast routing. The senders to group Gl, marked by circles with an inscribed S,\nare located on segments 192.6.1/24,192.5.2/24, and 128.4.1/24. As mentioned earlier,\nthe sender on segment 128.4.1/24 is not aware of the number or location of group Gl\nmembers; in fact, the sender need not even be aware of the existence of its local multi-\ncast router R8. Two workstations, Wl and W2, have also been included to illustrate\nMBONE functions in Section 9.4.",
        "35487a84-1e61-4266-80e2-4a0610da7820": "Section 9.2 The Multicast Protocol Stack 173\n192.5.1/24 192.5.2/24\n128.4.1/24\n192.6.1/24\n128.4.2/24\nFigure 9.1 Network diagram illustrating IP multicasting principles.\n9.2 The Multicast Protocol Stack\nThe IP protocol stack differs somewhat for multicast and unicast (Section 1.1). From the\nphysical through the network layers, the two stacks coincide, albeit with some modifica-\ntions made for multicast.\nAt the data-link layer, multicast makes use of the data-link multicast services, when\nthey exist. When a multicast datagram is transmitted over a data link supporting multi-\ncast, by either the sending host or an intermediate multicast router, the data-link desti-\nnation is set to a multicast address. The mapping of IP Class D address to data-link\nmulticast address is always algorithmic; address resolution protocols, such as ARP, are\nnot required. For example, when transmitting an IP multicast datagram over an Ether-\nnet segment, the low-order 23 bits of the IP destination Class D address are placed into\nthe Ethernet multicast address 01-00-5E-00-00-00 to produce the destination Ethernet\naddress [56]; thus an IP datagram addressed to 224.1.1.1 will always be transmitted on\nEthernet segments using the Ethernet destination 01-00-5E-01-01-01. (Why not 24 bits,",
        "20fbbf82-4928-4c0e-bcc1-9c07634e1115": "174 Internet Multicast Routing Chapter 9\nyou ask? The Internet's Assigned Number Authority, IANA, always likes to reserve part\nof each address space for further use, as you can also see in the encoding of Classes A-E\naddresses in [212].) If a data link supports broadcast but not multicast, the multicast\ndatagram is transmitted as a data-link broadcast. Although IP hosts wishing to receive\nmulticast datagrams cannot attach to network segments supporting neither multicast\nnor broadcast, multicast routers (and indeed hosts wishing to send only multicasts) can;\nover these nonbroadcast network segments, multicast datagrams are transmitted identi-\ncally to unicasts (see Section 10.3.1).\nAt the network layer, multicast datagrams have their IP destinations set to Class D\naddresses. Class D addresses are restricted to appear only as destination addresses; they\ncannot be used as IP source addresses; nor can they appear in IP source routes (Sec-\ntion 1.2).\nAlso at the network layer, multicast hosts and routers use IGMP, instead of ICMP, to\nexchange control information necessary for multicast datagram delivery. The only\nICMP packets used for multicast are the ICMP Echo and Echo Reply\u2014you can ping a\nmulticast address (see Section 12.4). However, ICMP errors are never sent in response to\nIP multicast datagrams; as a result, there is no multicast equivalent of Path MTU discov-\nery, and multicast traceroute employs a completely different mechanism than its unicast\ninspiration (Sections 12.5 and 12.11). Also, since senders of IP multicast datagrams do\nnot need to know about the local multicast router(s), multicast does not need ICMP\nrouter discovery or ICMP redirects.\nAt the transport layer, the multicast and unicast stacks diverge. The standard uni-\ncast transport protocol, TCP, does not work with multicast. In fact, there is no standard\nIP multicast transport protocol (many IP multicast protocols employ UDP for its multi-\nplexing service but use additional transport mechanisms as well). Many of the initial IP\nmulticast applications, developed on the MBONE (Section 9.4), invented their own\ntransport mechanisms. Applications such as teleconferencing do not need completely\nreliable delivery of packets but instead want to flag out-of-order packets and to provide\na mechanism to detect variations in delay so that the application can adjust its playback\nbuffer. Experience with such MBONE applications as vat [139], nevot [228], and nv [80]\nhas led to the development of a standard multicast transport, called Real-Time Transport\nProtocol (RTP) [229], for these kinds of applications. Numerous other proposals have\nbeen made for multicast transport protocols, including [5] and [167].\nA large number of applications have been developed for the MBONE, including\nteleconferencing (vat, nevot), videoconferencing (nv, ivs [246]), interactive white-\nboards (wb [140]), large-scale distribution of imaging data such as weather maps (imm\n[55]), experiments with the multicast delivery of Net news, and so on. The conferencing\napplications typically need some kind of session control to specify how people can join\nand leave conferences, as well as monitoring conference quality. Session control can be\nprovided by RTP or by other applications, such as the session directory (sd [138]) and\nmultimedia conference control (mmcc [227]) tools. The sd tool is used to dynamically",
        "00695278-6d4b-4ddc-bd3e-734f4c23d26c": "Section 9.2 The Multicast Protocol Stack 175\nallocate multicast addresses to new conferences as they start up on the MBONE; the pro-\ntocol that sd implements is described in [91].\nIP Multicast Addresses\nParts of IP multicast address space have been allocated for specific purposes, as shown\nin Table 9.1. The all-systems address of 224.0.0.1 contains all the IP multicast hosts and\nrouters on a given network segment. This address is used by multicast routers to query\nthe segment for group membership. The all-routers address contains all the multicast\nrouters on a given network segment and again is used by IGMP.\nTable 9.1 IP Multicast Address Assignments\nMulticast addresses of the form 224.0.0.x are always local to a given network seg-\nment and are never forwarded by multicast routers. These addresses are typically used\nby routing protocols that wish to exchange routing updates over the segment\u2014for\nexample, OSPF uses 224.0.0.5 and 224.0.0.6, RIPv2 uses 224.0.0.9, and so on.\nThe document [158] proposes that a range of IP multicast addresses be reserved for\nadministrative scoping, along the lines of IPv6's administrative scoping [99]. The idea\nbehind administrative scoping is that these addresses can be locally assigned and that\npeople do not have to worry about their being unique across the entire Internet or\neven across organizations. For example, the network in Figure 9.1 could be a single\norganization attached to the Internet. The network's Internet connection would then\nbe its \"organization local scope boundary\"; inside the organization, a group, such as\n239.192.0.1, could be used by an application without fear of interfering with (or interfer-\nence from) another multicast application running in the Internet at large. The \"local\nscope\" range allows the organization itself to be divided into smaller pieces, each\nwith its own private multicast address space. Administratively scoped addressing is\nintended to replace the TTL-based scoping that is currently deployed in the MBONE.\nOther IP addresses have been reserved for certain applications, as documented in\n[212]. For example, IP multicast addresses in the range 224.252.0.0-224.255.255.255 have\nbeen reserved for the Distributed Interactive Simulation (DIS) [106] applications.",
        "2379da91-057c-4fe3-b79c-0e1d40ddefe1": "176 Internet Multicast Routing Chapter 9\n9.2.1 IGMP\nThe Internet Group Management Protocol (IGMP) [56] is the multicast equivalent of ICMP,\nimplementing the necessary communication between hosts and multicast routers for the\nsuccessful delivery of multicast datagrams. As we have seen, no communication is nec-\nessary between the sender of multicast datagrams and its first-hop router. However, a\nhost wishing to receive multicast datagrams sent to a particular multicast group must\ninform its local routers of its group membership by sending IGMP Host Membership\nReports.\nA host sends a Host Membership Report when (a) it first joins a particular multicast\ngroup and (b) in response to an IGMP Host Membership Query received from a router.\nA separate Host Membership Report is sent for each group that the host belongs to.\nOn each network segment, one of the multicast routers becomes the Querier, respon-\nsible for periodically sending Host Membership Queries onto the segment in order to\ndynamically keep track of the segment's group membership. In the original IGMP,\nwhich we now call IGMPvl, the Querier was elected by the multicast routing protocol\nin use. In the second version of IGMP, the Querier is elected by IGMP itself (see the dis-\ncussion of IGMPv2 that follows). Host Membership Queries are sent to the all-systems\nmulticast address 224.0.0.1. If after some time Host Membership Reports for a given\ngroup cease to be heard in response to Host Membership Queries, it is assumed that\nthere are no members of that group on the segment.\nRouters are interested in knowing whether they need to forward multicast data-\ngrams addressed to a particular group Gl onto the network segment. To make that deci-\nsion, they need to know whether there are any members of Gl on the segment, but they\ndo not need to know which hosts belong to Gl or even how many hosts. This fact allows\nIGMP to employ an interesting algorithm to minimize the number of Host Membership\nReports sent: When a host receives a Host Membership Query, it randomly delays\nbefore sending Reports on its groups. If it hears a report for one of its groups before\nsending its own report, it then simply cancels the pending report transmission. As a fur-\nther optimization, reports are addressed to the group address being reported (with a\nTTL of 1 so that they are not forwarded off the local network segment), so that only\ngroup members and multicast routers, which receive all multicasts, will hear the report.\nFigure 9.2 shows a report sent for the group 224.1.1.1.\nIGMP operates only on segments having data-link multicast or broadcast capabili-\nties. Nonbroadcast segments must simulate a data-link multicast capability in order to\nrun IGMP. Examples of simulated data-link multicast include LAN emulation [8] and\nMARS [4], both developed for ATM subnets.\nWhen a host attaches to multiple network segments, it must join groups separately\non each segment. The host may belong to a group on one segment but not another, or it\nmay join the group on both segments. In the latter case, the host will likely get two cop-\nies of each datagram.",
        "14afcb92-7a29-481f-974b-06a1dfba841a": "Section 9.2 The Multicast Protocol Stack 177\nFigure 9.2 IGMP Host Membership Report.\nIGMP runs over IP, as IP protocol number 2. All versions of the IGMP protocol use\nthe same packet format, with a Type field indicating the packet function. This Type field\nis a combination of the Version and Type fields present in the original IGMP specifica-\ntion. To make things a little more confusing, some of the multicast routing protocols,\nsuch as DVMRP, and some diagnostics, such as multicast traceroute, also use IGMP\npacket types. The resulting list of IGMP packets by type is shown in Table 9.2.\nTable 9.2 IGMP Packet Types\nIGMPv2\nThe second version of IGMP, IGMPv2, is being deployed to replace IGMPvl. The two\nversions have two main differences.\nFirst, IGMPv2 improves the so-called leave latency, the time it takes a router to notice\nthat no more members of a given group are on the network segment. This improvement\nis important for applications that send a lot of data or for when many groups come and\ngo. In either case, taking a long time to notice that a group has gone away means thatType Code\n(hexadecimal) Packet Function\nOxll Host Membership Query\n0x12 Host Membership Report\n0x13 DVMRP packets (Secdon 14.2)\n0x16 IGMPv2 Membership Report\n0x17 IGMPv2 Leave Group message\nOxle Multicast traceroute response (Section 12.11)\nOxlf Multicast traceroute query/request (Section 12.11)\n0x22 IGMPvS Membership Report",
        "4b44d7c5-9050-4399-8efb-1c2ba24daacb": "178 Internet Multicast Routing Chapter 9\nunnecessary bandwidth has been consumed forwarding multicast datagrams to a place\nwhere nobody is listening.\nTo decrease the leave latency, a new IGMP packet is added: the IGMP Leave Group\nmessage. When a host leaves a group, it immediately multicasts a Leave Group message\nto the all-routers address of 224.0.0.2. On receiving the Leave Group, the Querier for the\nnetwork is not sure whether any group members are left on the segment. To find out,\nthe Querier then multicasts a Membership Query for the specific group in question;\nthis query is addressed to the group and has a TTL of 1. If no hosts respond with\nMembership Reports, it is assumed that group members are no longer present.\nSecond, IGMPv2 elects the Querier on each segment rather than leaving election up\nto the multicast routing protocol. When a multicast router first attaches to a network\nsegment, it assumes that it will be the Querier. However, if the router receives a\nMembership Query on the segment from a router with a lower IP address, the router\nrelinquishes its Querier duty. If, at some point in the future, the router ceases to hear\nthese Membership Queries, the router will again become Querier.\nIGMPvS\nA third revision of the IGMP is under development [28]. In this version of IGMP, group\nmembers will be able to request source filtering, using a new Membership Report\n(Table 9.2). When joining a group, a host can request that it wants to receive multicast\ndatagrams only from a particular set of sources (called source-specific joins) or, alterna-\ntively, that it wants to exclude a set of sources (called source-specific leaves). One applica-\ntion of such a mechanism would be if you were participating in a teleconference and\none of the other participants were playing a radio so loudly that you could not hear any-\none else talking. Using IGMPvS's source-specific leave mechanism, you could simply\nblock that participant's packets.\n9.3 Broadcast Forwarding\nWith the advent of IP multicast, Internet broadcast addresses (Section 1.2.2) have\nbecome less and less used, especially directed and all-subnets-broadcast addresses.\nIn addition, with the removal of the Class A, B, and C addresses in favor of CIDR,\nall-subnets broadcast addresses are no longer well defined. However, we discuss broad-\ncast forwarding in this section, using the network in Figure 9.1, which provides a good\nintroduction to IP multicasting mechanisms.\nSuppose first that router R7 wants to send a RIPvl update message to both routers\nR8 and R9. Router R7 can set the IP destination address of the update to the local seg-\nment or local-wire broadcast address of 255.255.255.255 and then send the packet as a\ndata-link broadcast onto the segment 128.4.3/24. Both R8 and R9 will then receive the",
        "373b0a59-2390-4a9f-a035-0d5b87c54255": "Section 9.3 Broadcast Forwarding 179\nupdate and process it accordingly. Packets addressed to 255.255.255.255 are never\nforwarded.\nSuppose instead that SI wishes to send a packet that will be received by all hosts on\na particular remote segment, say, 128.4.2/24. For example, the packet might be a ping,\nallowing the sending host to detect which hosts are currently attached to 128.4.2/24.\nThe ping would then be addressed to the directed-broadcast address of 128.4.2.255. The\nping would then be forwarded exactly as if it were to a unicast address on 128.4.2/24,\ngoing through routers Rl, R2, R4, and R7 until it reached router R9. At this point, router\nR9 would send the packet onto 128.4.2/24 as a data-link broadcast, so that it would be\nreceived and processed by all attached hosts. Directed broadcasts such as these are also\nsometimes humorously referred to as letter bombs.\nFinally, suppose that SI wants to send a ping to every host attached to a subnet of\n128.4/16 (whether this is a good idea is left as an exercise for the reader). The ping is\nthen addressed to the all-subnets-broadcast address of 128.4.255.255 and is forwarded as\na data-link unicast until it reaches router R7. At this point, in order to be received by all\nhosts on all 128.4/16 subnets, the packet will be forwarded instead as a data-link broad-\ncast. However, to avoid disastrous forwarding loops, a procedure called reverse-path\nbroadcasting [54] must be employed (similar precautions are used by IP multicast rout-\ning). The reverse-path broadcasting inhibits forwarding in certain circumstances: When\na router receives the data-link broadcast, it checks to see whether the interface it\nreceived the packet on would be used to forward unicast traffic back to the packet\nsource. If so, the packet is accepted and forwarded out all other interfaces belonging to\nthe subnetted network. If not, the packet is dropped.\nIn our example, the entry router to the subnetted network 128.4/16, router R7, will\nbroadcast the ping onto subnet 3, where it will be received by routers R8 and R9 and\nbroadcast onto subnets 1 and 2, respectively. R7 will also send a copy of the ping over its\npoint-to-point connection to router R9. R9, however, will discard the ping received over\nthe point-to-point link, since its route back to the ping's source, SI, goes over the LAN\nsegment 128.4.3/24 instead of the point-to-point link to R7. By discarding the ping\nreceived over the point-to-point link, router R9 avoids forwarding duplicate pings onto\nsubnet 2.\n9.3.1 Multicast Forwarding\nThe path that a multicast datagram takes, from source host to group members, depends\non the type of multicast routing protocol in use. In all cases, the datagram's path forms a\ntree.\nIn the case of source-based multicast routing protocols (DVMRP, MOSPF, PIM Dense),\na separate tree is calculated for each combination of multicast source and destination\ngroup. Assuming that the LAN segments in Figure 9.1 have cost 1 and that the costs\nof the point-to-point links are as labeled, the three source-based trees that would be",
        "10414561-9108-4a2d-a6c6-f77fdd7bd2f1": "180 Internet Multicast Routing Chapter 9\ncalculated for group Gl are as shown in Figure 9.3. \"Tree\" means that there is exactly\none path from the source to each group member, illustrated by the path from source S2\nto the group Gl member on 192.7.1/24. There are two possible equal-cost paths to the\ngroup member, one through Rll and the other through RIO. If both paths were used,\ntwo copies of each datagram would be received by the group member; therefore the\npath through RIO is pruned, leaving only the path through Rll. All source-based multi-\ncast routing protocols have ways to prune these equal-cost paths.\nIn the shared-tree protocols (PIM Sparse, CBT) a single tree is built for each group,\nregardless of source. A router is selected as the root for the group's tree, with the group\nmembers added as leaves. In PIM, this router is called the Rendezvous Point (RP); in CBT,\nthis router is called the core. In our example, if router R4 is selected as the RP, the shared\ntree that would result for group Gl is as shown in Figure 9.4.\nThe shared tree consists of routers R3, R4, R5, R6, and Rll. Multicast datagrams\nfrom sources that are not on the shared tree (SI and S3 in our example) are encapsulated\nby the first-hop routers (Rl and R8, respectively) and then forwarded to the Rendez-\nvous Point, R4, as unicasts (shown in Figure 9.4 as directed dashed lines). At that point,\nR4 decapsulates the datagram and multicasts the datagram down the shared tree\ntoward the group members. In both PIM Sparse and CBT, an optimization is made if the\nfirst-hop router is already on the shared tree (as would be the case when the sender was\nalso a group member). In this case, the multicast is multicast along the shared tree by the\nfirst-hop router, both downstream (away from the RP) and upstream toward the RP\u2014\nexactly as you would forward multicast datagrams at the link-layer in a spanning-tree\nbridged network [107], This optimization is performed by default in CBT. In PIM\nSparse, it requires explicit action by the RP, which tells the routers between the source\nand RP to revert to source-based routing (as in PIM Dense) for the particular source (S2\nin Figure 9.4).\nShared-tree multicast routing algorithms were designed in an attempt to scale mul-\nticast to larger network sizes than were possible with the older, source-based algorithms\nDVMRP and MOSPF. The idea behind shared-tree protocols is to reduce information\nthat routers need to maintain. You can see this in comparing Figures 9.3 and 9.4; routers\nrunning a source-based multicast algorithm may have to keep track of three trees,\nwhereas routers running the shared-tree algorithm need keep track of only the single\ntree. Yet shared-tree protocols create problems of their own, which have so far pre-\nvented their adoption.\n\u2022 Less efficient paths. As you can see by comparing the path between source SI and\nthe group member on 192.5.1/24 in Figures 9.3 and 9.4, the shared-tree proto-\ncols chose a longer path than the path found by the source-based protocols.\n\u2022 Traffic concentration. As you can see by looking at the two figures, the source-\nbased protocols use more links than the shared-tree protocols do. By concentrat-\ning the same amount of traffic on fewer links, shared-tree protocols may create\nbandwidth shortages.",
        "2b7c1cac-ca9c-46d9-b1fb-75b8a7f9fda2": "Section 9.3 Broadcast Forwarding 181\nFigure 9.3 Source-based trees for group Gl.",
        "f818c815-d774-4abe-9739-347f99c5d6ef": "182 Internet Multicast Routing Chapter 9\nFigure 9.4 Shared multicast tree for group Gl.\nRobustness. Source-based protocols are distributed and are not affected much by\nthe failure of a single router. However, in shared-tree protocols, the failure of the\nRP is a big problem.\nRP selection. In shared-tree protocols, an extra step must be performed in order\nto get multicast forwarding working: An RP must be selected. This selection can\nbe done manually. Bootstrap algorithms allowing automatic selection of RPs\nhave also been proposed [70].\nMulticast Router Processing\nHere we examine how a multicast router forwards IP multicast datagrams, along the\nlines of the unicast-forwarding discussion in Section 1.2. The forwarding process starts\nwhen the source host transmits the datagram onto the local segment as a data-link mul-\nticast. The local multicast router (in fact, all multicast routers attached to the local seg-\nment) receives it, because it has \"opened up\" its data-link multicast filters so that it\nreceives all multicasts, regardless of destination. The router then verifies the IP header\nas it would for a unicast packet, including checking that the TTL in the datagram's IP\nheader is greater than 1. If there are any problems with the IP header, the packet is dis-\ncarded silently\u2014no ICMP errors are ever sent in response to a received IP multicast\ndatagram.",
        "b538ce56-0435-404f-b0b4-93594b0b1be3": "Section 9.3 Broadcast Forwarding 183\nThe router then decrements the TTL in the IP header by 1 (modifying the header\nchecksum accordingly) and finds the matching multicast routing table entry for the\nmulticast datagram. These entries are also called multicast cache entries, since some mul-\nticast routing protocols create entries dynamically as matching datagrams are received\n(see Section 10.3). The matching multicast routing table entry tells the router whether\nit is on the multicast forwarding path (which, as we have seen, forms a tree) for the\ndatagram and, if so, how the router should forward the datagram farther down the\npath.\nIf a source-based routing protocol is being used, the routing table entries are\nindexed on source and destination group, whereas shared-tree protocols index their\nentries on destination group only. Figure 9.5 shows sample multicast routing table\nentries for router R6 that match a datagram having source S3 and destination Gl. In\neither case, the routing table entry specifies an incoming interface and a list of outgoing\ninterfaces. If the incoming interface is empty or if there are no outgoing interfaces, the\nrouter is not on the datagram's path, and the datagram is silently discarded. If the data-\ngram was received on an interface other than the incoming interface found in the rout-\ning table entry, the datagram is again discarded. This circumstance typically indicates\nthe existence of multiple paths.\nSource-based tree\nSource network: 128.4.1/24\nDestination group: Gl\nIncoming interface: from R8\nOutgoing interfaces: to 192.5.2/24\n(a)Shared tree\nDestination group: 61\nIncoming interface: from 192\nOutgoing interfaces: to 192..5.3/24\n5.2/24\n(b)\nFigure 9.5 Router RT6's multicast routing table entry matching a datagram with source S3 and destination Gl.\n(a) The matching entry for a source-based multicast routing protocol; (b) the entry for a shared-tree protocol.\nIf the incoming interface in the entry matches the interface on which the datagram\nwas received, the datagram is transmitted as a data-link multicast out the outgoing\ninterfaces specified in the entry. It is possible that the datagram will have to be frag-\nmented before being transmitted on some interfaces, especially since there is no equiva-\nlent to Path MTU discovery for multicast.\nEach outgoing interface may have additional parameters. For example, the entry\nmay specify a TTL threshold for an outgoing interface: Datagrams whose TTL is less\nthan the threshold will not be forwarded out the interface. TTL threshold may be per-\nformed as a way to control the scope of multicast datagrams (see Section 9.4) or as\nan optimization noting the number of router hops to the nearest group member (Sec-\ntion 10.1.1). The outgoing interface also may be configured as an administrative\nboundary, preventing the forwarding of administratively scoped multicast groups\n(Section 9.2).",
        "2f8c2fad-4c7f-456f-8de3-9eaeec712c53": "184 Internet Multicast Routing Chapter 9\nMulticast forwarding entries are described further in Section 10.3.1. A multicast\ntraceroute facility (Section 12.11) has been developed and deployed, enabling\ndebugging of multicast forwarding in the MBONE. There is also an IP multicast routing\nMIB [142], allowing a network administrator to examine multicast routing table entries.\nThe forwarding process then repeats at the next-hop multicast router, until all the\ngroup members have been reached. Note that multicast datagrams are replicated during\nthe forwarding process as the paths to the group members diverge. Sometimes this rep-\nlication is done by the router (router Rl at the lower left of Figure 9.3) and sometimes as\na by-product of transmitting the datagram as a data-link multicast (segment 192.5.3/24\nat the top of Figure 9.3).\n9.4 MBONE\nThe Internet's multicast service is provided by the Multicast Backbone (MBONE). The\nMBONE was first created in March 1992, organized to audiocast proceedings at an IETF\nmeeting to those people who could not attend [69]. Today the MBONE is still used to\nbroadcast IETF meetings (now both audio and video), for teleconferences and interac-\ntive meetings between researchers, and to broadcast interesting events, such as launches\nof the space shuttle. The MBONE is also a breeding ground for the development of mul-\nticast tools, routing protocols, and applications (Section 9.2). However, the MBONE\nis still not yet a production service\u2014ISPs are still reluctant to run IP multicast code in\ntheir routers, and the MBONE is not available to the public at large (that is, the average\n19.2K/sec dial-up user).\nSince most of the Internet's routers do not have multicasting forwarding capabilities\n(or at least do not have it turned on), the MBONE's routers are typically UNIX worksta-\ntions running the mrouted program [62], which is an implementation of the DVMRP\nrouting protocol. To get multicast packets through the Internet's multicast-ignorant\nrouters, these mrouted workstations are connected via tunnels (Section 1.2.3). This cre-\nates a virtual multicast topology, overlaid on the Internet's unicast topology.\nFor example, suppose that none of the routers in Figure 9.1 had multicast capability.\nTo establish multicast connectivity between sources and group members, each source\nand destination would run the mrouted program, including the workstations Wl and\nW2. The mrouted routers would then be connected via tunnels, resulting in the virtual\ntopology of Figure 9.6.\nThe tunnel topology in Figure 9.6 is fairly rational; the real tunnel topology in the\nMBONE is definitely less planned. In fact, that is one of the things that network opera-\ntors dislike about MBONE tunnels\u2014it is difficult to tell when someone has configured\nan MBONE tunnel through one's network. MBONE tunnels can carry a lot of data\ntraffic, such as packet video, so network operators like to know of their existence in\nadvance. Figure 9.6 demonstrates another problem with the tunnel topology: You can\nget multiple copies of a multicast datagram going over a single segment. Suppose that",
        "541645df-b8f8-46e8-812b-6722352a0fb7": "Section 9.4 MBONE 185\n192.6.128.4.1/24\n192.7.1/24\nFigure 9.6 Constructing an MBONE topology from Figure 9.1.\nSI were also a member of group Gl. Then if S3 sent a multicast datagram to group Gl,\nseparate copies would get forwarded by W2 over the tunnels to Wl, SI, and the group\nmember on 192.7.1/24. Unfortunately the latter two tunnels both go over the link\nbetween routers R7 and R4.\nBesides the multicast traceroute facility, the MBONE has other diagnostic tools\nas well. The mrinf o program can be used to query the configuration of a DVMRP\nrouter. The map_mbone program can use the same query mechanism to produce a map of\nthe MBONE tunnel topology.\nThe core of the MBONE uses DVMRP exclusively. But other routing protocols, such\nas MOSPF and PIM, are sometimes used at the edges.\nTTL Thresholds\nThe MBONE also uses IP TTL in a novel way. A network administrator can configure\nTTL thresholds on the tunnels into the administrator's site. When a threshold is config-\nured, packets having TTL less than the threshold are discarded instead of being for-\nwarded across the tunnels. Conventions were then established for the initial TTLs used\nby common MBONE applications. If the administrator then wanted to prevent certain\napplications from entering the administrator's site, the TTL threshold would be config-\nured higher than that application's initial value.",
        "97258932-13c5-458c-a03f-7beb014c02fb": "186 Internet Multicast Routing Chapter 9\nTable 9.3 shows the initial TTLs for common MBONE applications, taken from the\nMBONE FAQ [36]. For example, if you want to allow only the four IETF audio channels\ninto your site, you would configure a threshold of 128.\nTable 9.3 Default TTL Values for MBONE Applications\nMBONE Application\nIETF channel 1 low-rate GSM audio\nIETF channel 2 low-rate GSM audio\nIETF channel 1 PCM audio\nIETF channel 2 PCM audio\nIETF channel 1 video\nIETF channel 2 video\nLocal event audio\nLocal event videoInitial TTL\n255\n223\n191\n159\n127\n95\n63\n31Threshold\n224\n192\n160\n128\n96\n64\n32\n1\nIt turns out that discarding packets due to TTL threshold has an adverse effect on\nDVMRP's pruning mechanism (Section 14.2). If a router discards a packet due to insuffi-\ncient TTL, it cannot tell whether any group members are downstream and so cannot\ndetermine whether it should send prunes upstream. For that reason, TTL thresholds are\nbeing phased out in favor of administratively scoped group addresses (Section 9.2).\nFurther Reading\nIn Chapter 10, MOSPF, we examine the MOSPF multicast routing protocol in detail. The\nmulticast routing protocols that have been developed for the Internet (DVMRP, MOSPF,\nPIM Dense and PIM Sparse, and CBT) are compared and contrasted in Chapter 14,\nMulticast Routing Protocols.\nIP multicast routing began with Deering's papers [58] and [59], written while he\nwas working on his Ph.D. at Stanford. These papers are required reading for anyone\ninterested in multicast routing. Similarly, Wall's thesis [258] and [259] is the basis of the\nshared-tree multicast routing protocols CBT and PIM Sparse. Dalai and Metcalfe [54] is\nthe original paper on reverse-path forwarding.\nThe lETF's IDMR Working Group has produced a good introduction to multicast\nrouting in [154].\nThose people interested in joining the MBONE should consult the excellent\nMBONE FAQ [36]. An entire book has also been published detailing the MBONE and\nits operational aspects [131].",
        "0cf719de-55df-46a5-b56f-18b166e44a3e": "10\nMOSPF\nContinuing our discussion of multicast routing, this chapter examines a particular\nmulticast routing protocol, the Multicast Extensions to OSPF (MOSPF). MOSPF is an\nextension of OSPF, allowing IP multicast routing to be introduced into an existing OSPF\nunicast routing domain.\nMOSPF has seen considerable deployment in private internets. When a network\nis already running OSPF, MOSPF is probably a better choice than the more common\nDVMRP when introducing a multicast routing capability. Both MOSPF and DVMRP\ncalculate source-based trees. However, unlike MOSPF's link-state basis, DVMRP uses\nDistance Vector routing technology and is susceptible to all the normal convergence\nproblems of Distance Vector algorithms (Section 2.3). MOSPF also always limits the\nextent of multicast traffic to group members, something that a broadcast-and-prune\nalgorithm (Section 14.1), such as DVMRP, cannot always do. Restricting the extent of\nmulticast datagrams is desirable for high-bandwidth multicast applications or limited-\nbandwidth network links (or both). A more detailed comparison of existing TCP/IP\nmulticast routing algorithms is given in Chapter 14, Multicast Routing Protocols.\nThe introduction of MOSPF to an OSPF routing domain can be gradual; MOSPF\nwill automatically route IP multicast datagrams around those routers incapable of\nmulticast routing (see Section 10.5), whereas unicast routing continues to function\nnormally. MOSPF introduces multicast routing by adding a new type of LSA, the\ngroup-membership-LSA, to the OSPF link-state database and by adding calculations\nfor the paths of multicast datagrams.\n187",
        "4f54aa77-3345-4edf-a490-c13a5666f25e": "188 MOSPF Chapter 10\nFrom a multicast datagram's source to any given group member, the path that\nMOSPF calculates for the datagram is always the shortest in terms of the OSPF link met-\nric. MOSPF also provides explicit support for IP multicast's expanding ring search,\ninhibiting all but the necessary multicast datagram traffic as a host looks for the nearest\nserver (see Section 10.1.1). When the OSPF routing domain is split into areas, MOSPF\nemploys a hierarchical multicast routing scheme, as described in Section 10.4.\nMOSPF can be, and is in isolated places, deployed in the MBONE. A MOSPF\ndomain can be attached to the edge of the MBONE, or can be used as a transit rout-\ning domain within the MBONE's DVMRP routing system. To use MOSPF within the\nMBONE, one must exchange multicast source and group membership information\nbetween MOSPF and DVMRP, analogous to the exchange of routing information\nbetween unicast routing protocols. This exchange is described further in Section 10.6.\n10.1 An Extended Example\nFigure 10.1 shows a MOSPF routing domain. All routers pictured are running MOSPF.\nFive MOSPF routers are attached to a central FDDI ring. These routers in turn attach five\nEthernet segments. To get to segment 128.186.4.0/24, a point-to-point link (between\neither routers C and E or routers D and G) must be traversed. Additional point-to-point\nconnections between routers A and B and between routers D and F have been provided\nfor backup purposes. Each router interface is labeled with its OSPF cost. Two multicast\ngroups are shown. Group Gl has members on segments 128.186.4.0/24,128.186.5.0/24,\nand 128.186.6.0/24, whereas group G2 has a single member on segment 128.186.4.0/24.\nFirst, we examine the forwarding of multicast datagrams when the network is in\nsteady state: All links are operational, and all group members have joined their respec-\ntive groups. Then we examine MOSPF's response to network changes. These changes\ninclude hosts joining and leaving multicast groups and network links and routers\nbecoming inoperational and then returning to operation.\n10.1.1 Steady-State Forwarding Behavior\nLet us consider how an Internet radio transmission might work. In Figure 10.1, worksta-\ntion SI is the originator of a radio station, sending digital audio packets on its \"radio\nchannel,\" the multicast group address Gl. Gl itself is a Class D IP address; we'll use the\naddress 226.1.7.6 in this example. Radio listeners have tuned their workstations into\nSi's radio station by joining the group Gl. There are listeners on the LAN segments\n128.186.4.0/24,128.186.5.0/24, and 128.186.6.0/24.\nSI sends its audio packets out onto its local Ethernet segment, 128.186.1.0/24,\nencapsulated in IP headers whose destination address is set to 226.1.7.6. These pack-\nets are multicast onto the Ethernet segment at the data-link level; the IP multicast",
        "42d1c2a5-0d75-494e-9c3b-7a1621f1b8df": "Section 10.1 An Extended Example 189\nFigure 10.1 An MOSPF routing domain.\ndestination of 226.1.7.6 is algorithmically mapped to an Ethernet data-link multicast\naddress of Ox01005e010706 (see [56], [212]).\nSince the audio packets are multicast onto Si's Ethernet segment, hosts and routers\nconnected to 128.186.1.0/24 can receive the audio packets by properly programming\ntheir Ethernet adapters. A radio listener connected to the segment (of which there are\nnone) would program its Ethernet adapter to receive packets sent to Ox01005e010706. A\nmulticast router, such as router A, programs its Ethernet adapter to receive all multicast\npackets; this is sometimes said to be putting the adapter into promiscuous mode.\nThus router A receives the audio packets. Recognizing that it is on the shortest path\nbetween SI and one or more members of Gl (in this case, it is on the path to all Gl mem-\nbers), router A then multicasts the audio packets onto the FDDI segment 128.186.3.0/24.",
        "b488e4ca-66d9-406f-9a62-6e2aeceebeeb": "190 MOSPF Chapter 10\nAs for Ethernet, there is an analogous mapping between the IP multicast address and an\nFDDI multicast address, resulting in the audio packets' being multicast onto the FDDI\nsegment at the data-link level.\nRouters B, C, D, and F receive the audio packets multicast onto the FDDI segment.\nRouter B simply discards the audio packets, since it is not on the shortest path between\nSI and any Gl group member. Routers C and D are both on shortest paths between\nSI and the group member on segment 128.186.4.0/24. Only one router will for-\nward the packets, otherwise unwanted replication of the audio stream will result.\nMOSPF invokes tie-breaking procedures to choose one shortest path over another (see\nSection 10.3). In this case, assuming that router G has a higher OSPF Router ID than\nrouter E does, the shortest path through router D will be chosen. This means that rou-\nter C will discard the audio packets received from the FDDI segment. Router D will\nforward the packets to router G, which in turn will multicast them onto the Ethernet\nsegment 128.186.4.0/24, which contains one of the listeners. Finally, when router F\nreceives an audio packet from the FDDI segment, it will forward copies onto the\nEthernet segments 128.186.5.0/24 and 128.186.6.0/24, where the other two radio\nlisteners are located.\nExpanding Ring Search\nExpanding ring search is a procedure for finding the nearest server. Suppose that in Fig-\nure 10.1, S2 wishes to find the nearest time server. Suppose further that all time servers\nbelong to a multicast group G2. To find the nearest time server, S2 performs an expand-\ning ring search: first multicasting a query to multicast group G2 with IP TTL 1, then\nwith TTL 2, and so on, until S2 receives a response. The response will be from the near-\nest time server, in terms of router hops.\nMOSPF makes expanding ring search more efficient. Let's look at the expanding\nring search performed by S2 in more detail. First, S2 sends a multicast datagram to G2\nwith a TTL of 1. Router B receives this datagram but is not allowed to forward the data-\ngram, since the TTL is too small. Router B then silently discards the datagram; ICMP\nerror messages, such as TTL Exceeded, are not sent in response to multicast datagrams.\n(Note that this means that the unicast traceroute utility does not work for multicast;\nsee Section 12.11.)\nS2 next sends a query to G2 with a TTL of 2. Router B receives this datagram and is\nallowed to forward it. However, router B knows that the datagram will never reach the\nnearest member of group G2, because of insufficient TTL, and so discards this datagram\ntoo instead of wasting network bandwidth and computing resources. Similarly, it dis-\ncards the next query sent by S2. Only when S2 sends a query with TTL of 4 will router B\nforward the query onto the FDDI segment 128.186.3.0/24; this query will be forwarded\nall the way to the group member on 128.186.4.0/24, where it will produce the appropri-\nate reply.",
        "e6b116b4-bd85-4e30-80af-e99170788197": "Section 10.1 An Extended Example 191\n10.1.2 Response to Change\nWe now illustrate the reactions of the MOSPF algorithm to changes within the MOSPF\ndomain: hosts joining and leaving multicast groups, links going in and out of service,\nand so on. We again consider the Internet radio example of Figure 10.1, but this time, we\nassume that the radio station has not yet started its broadcast and that no hosts have yet\ntuned in to the radio channel.\nNow we assume that the following sequence of events transpires.\n1. Host SI starts its radio broadcast. SI simply starts sending audio packets to the IP\nmulticast destination group Gl. On receiving the first of these packets, router A\ncalculates the shortest paths between the multicast packet's source (segment\n128.186.1.0/24) and the members of Gl. Note that router A waits until receiving\nthe packet before calculating a route for the packet. This on-demand calculation\n(see Section 10.3) is in contrast to unicast routing, whereby routes are always\ncalculated in advance.\nSince there are no members of Gl, router A simply discards the audio pack-\nets without forwarding them.\n2. The listener on segment 128.186.4.0/24 tunes in. The listener joins multicast group\nGl by sending an IGMP Host Membership Report for Gl onto segment\n128.186.4.0/24. The OSPF Designated Router for the segment, which we assume\nis router E, then originates a group-membership-LSA and floods the LSA\nthroughout the MOSPF domain. The group-membership-LSA informs all rout-\ners within the MOSPF domain that 128.186.4.0/24 has a Gl member (see Sec-\ntion 10.2).\nRouter A will receive the group-membership-LSA. The next audio packet\nrouter A receives will cause it to recalculate the path of the audio packets. This\ntime, the calculation will tell A to forward the multicast onto the FDDI ring\n128.186.3.0/24. Routers B, C, D, and F will then calculate the path of the data-\ngram, with only D forwarding. When G receives the datagram from D, it too\nwill run the MOSPF routing calculation before multicasting the packet onto\n128.186.4.0/24.\n3. The listener on segment 128.186.5.0/24 tunes in. This time, router F will origi-\nnate a group-membership-LSA announcing a Gl member. However, this\ngroup-membership-LSA will not label 128.186.5.0/24 with group Gl member-\nship but will instead label router F itself as requesting packets for group Gl.\nThis happens because 128.186.5.0/24 is a stub network, and labeling the router\ninstead of the stub network segment accomplishes some aggregation of group\nmembership information.\nAll routers will receive the group-membership-LSA originated by router F.\nThen, on receiving the next audio packet, they will all rerun their routing cal-\nculation for the audio packet's path. However, only router F's forwarding",
        "927a28c7-976d-4cb9-a53d-378557422f17": "192 MOSPF Chapter 10\nbehavior changes; router F will now forward the packet by multicast onto\n128.186.5.0/24.\n4. The listener on segment 128.186.6.0/24 tunes in. Because 128.186.6.0/24 is another\nstub network connected to router F, router F does not need to originate another\ngroup-membership-LSA. Router F simply starts forwarding the audio packets\nonto 128.186.6.0/24, without any other routers in the MOSPF domain even\nnoticing.\n5. The point-to-point connection between routers D and G fails. Routers D and G origi-\nnate new OSPF router-LSAs announcing the link failure and flood the LSAs\nthroughout the MOSPF domain. After the flood, the next audio packet received\nwill trigger a path recalculation in routers A, B, C, D, and F. This time, router C\nwill start forwarding the audio packets to router E, which will then multicast\nthe packets onto 128.186.4.0/24.\n6. The listener on segment 128.186.4.0/24 tunes out. Router E (the Designated Router\non the segment) will eventually notice that the listener has tuned out: The lis-\ntener either sends an IGMP Leave Group message (IGMPv2 only; see [71])\nwhen tuning out or simply stops responding to IGMP Host Membership\nQueries (see Section 10.2). Router E then flushes the group-membership-LSA\nthat it had previously originated, thereby telling the MOSPF domain that there\nis no longer a Gl member on 128.186.4.0/24. The next audio packet causes a\npath recalculation in routers A, B, C, D, and F. Only router C's forwarding\nbehavior will change; router C will no longer forward audio packets on to\nrouter E.\n10.2 Group-Membership-LSAs\nThe Internet Group Membership Protocol (IGMP; see [56]) is used to communicate\ngroup membership information from hosts to multicast routers, regardless of the multi-\ncast routing protocol in use. LAN-attached hosts multicast an IGMP Host Membership\nReport onto the LAN when they join a multicast group, informing all local multicast\nrouters. As long as it remains a member of the group, the host will respond to IGMP\nHost Membership Queries sent by the LAN's IGMP Querier, by again sending a Host\nMembership Report for the group. Multicast routers need keep track only of whether\nthere are one or more group members on the LAN; the routers are not concerned with\nwhich hosts belong to the group. For this reason, a host delays for a random amount of\ntime before answering the Host Membership Query; seeing another Host Membership\nReport in the meantime obviates the host's need to respond with its own report.\nWhen it leaves a multicast group, a host stops answering Host Membership Que-\nries. Some time after the last host on the LAN has left the group, the LAN's multicast\nrouters will realize that there are no longer any group members. This time period is",
        "977d083d-0256-4034-a497-6a696a6ed5a7": "Section 10.2 Group-Membership-LSAs 193\ncalled the leave latency. If the hosts and routers are using IGMPv2 [71], leave latency is\nreduced by having the hosts send IGMP Leave Group messages when they leave the\nmulticast group.\nIn IGMP as specified in [56], it is up to the multicast routing protocol to select the\nIGMP Querier. MOSPF assigns IGMP Querier responsibilities to the LAN's OSPF\nDesignated Router. IGMPv2 provides facilities to elect the IGMP Querier, removing\nthe need for the multicast routing protocol to select the Querier.\nRegardless of which router is providing the query function on the LAN, it is the job\nof the LAN's OSPF Designated Router to listen to the Host Membership Reports sent\nin response, thereby keeping track of the LAN's group membership. The Designated\nRouter then reports the LAN's group membership to the rest of the routers in the\nMOSPF routing domain by originating group-membership-LSAs.\nGroup-membership-LSAs have an LS Type of 6. A group-membership-LSA reports\ngroup membership in a single group; the Link State ID of the group-membership-LSA\nis the multicast group's Class D IP address. The body of the group-membership-LSA\nlists the location of group members by referencing router-LSAs and network-LSAs.\nIf the router detects group members on one or more of its directly connected stub net-\nworks (or if the router itself is running multicast applications), it tells the other MOSPF\nrouters to forward multicasts to the router itself by referencing its own router-LSA.\nFor those transit networks having group members and for which the router is acting as\nDesignated Router, the router tells the other MOSPF routers to forward multicasts\nto the network by referencing the network's network-LSA. These LSAs are refer-\nenced by including their LS Type and Link State ID fields in the body of the group-\nmembership-LSA.\nLet us go back to the example in Section 10.1.2. Router E (OSPF Router ID\n128.186.4.1) has been elected Designated Router on LAN 128.186.4.0/24. As a result,\nit is also serving as the IGMP Querier, periodically sending IGMP Host Membership\nQueries. In the beginning, no group members are on the LAN, and the queries go\nunanswered. Then a host joins group Gl (226.1.7.6), sending a Host Membership Re-\nport in the process. This report causes router E to originate and to flood the group-\nmembership-LSA in Figure 10.2. The body of the group-membership-LSA reports\na Gl member on 128.186.4.0/24 by referencing that LAN's network-LSA. This network-\nLSA, also originated by router E, has Link State ID equal to 128.186.4.1.\nWhen the other group Gl members join Gl, there will be an additional\ngroup-membership-LSA, this one originated by router F. Since 128.186.5.0/24 and\n128.186.6.0/24 are both stub networks connected to router F, F simply lists itself in\nthe body of the group-membership-LSA by referencing its own router-LSA (Refer-\nenced LS Type = 1, Referenced Link State ID = router F's Router ID).\nGroup-membership-LSAs have area flooding scope. They are used to distribute\ngroup membership information throughout a single area only. Distribution of group\nmembership information across area and Autonomous System boundaries is one of the\nfunctions of hierarchical multicast routing, the subject of Section 10.4.",
        "9e1796d6-5549-4fde-85a0-d33685b92440": "194 MOSPF Chapter 10\nFigure 10.2 Sample group-membership-LSA.\n10.3 MOSPF Routing Calculations\nSection 10.1 introduced the multicast paths that MOSPF routers calculate between a\nmulticast source and the destination group's members. This section goes into more\ndetail about those paths, answering the following questions.\n1. How many different multicast paths are there?\n2. How often are paths calculated? When do paths need to be recalculated?\n3. What data derived from the multicast path calculation does a MOSPF router\nstore and use in forwarding?\n4. If the multicast path calculation is a shortest-path calculation, how is this calcu-\nlation different from the OSPF unicast routing calculation, if at all?\nThe answer to the first question is easy. MOSPF has different paths for each combi-\nnation of source network and destination multicast group. This can be many separate\npaths. However, the calculation burden that a MOSPF router bears is reduced by the fact\nthat the multicast routing calculation is performed on demand: A MOSPF router calcu-\nlates a multicast path for a given source network and multicast group only when the\nrouter receives a matching datagram.\nThis behavior accomplishes two things. First, it spreads the number of routing cal-\nculations out over time, as opposed to the unicast routing behavior of calculating all the\nroutes at once. Second, a MOSPF router will never have to calculate paths for a givenLSAge\nOptions LS Type\nLink State ID -\n- Advertising Router \u2014\n\u2014 LS Sequence Number \u2014\nLS Checksum\nLength\n- Referenced LS Type \u2014\n\u2014 Referenced Link State ID \u20140\nE-bit. LS Type 6 (group-membership-LSA)\n226. 1.7. 6 (group G1)\n128.186.4.1 (router E)\n0x80000001\nOx3da9\n28 bytes\n2 (network)\n128.186.4.1 (128.186.4.0/24)",
        "9de78514-936d-4a78-bcc2-d974a9796ca9": "Section 10.3 MOSPF Routing Calculations 195\nsource network and destination group combination unless the router is along the path\nbetween source and one or more destination group members. Often, however, MOSPF\nrouters along the multicast path will not forward the datagram, as the example in Sec-\ntion 10.1 demonstrates. The aggregation of sources and destination groups achieved\nwhen organizing MOSPF routing hierarchically (Section 10.4) further lessens, some-\ntimes drastically, the number of paths that a MOSPF router calculates.\nMulticast paths must be recalculated when network conditions change\u2014routers or\nlinks go in and out of service or when hosts join or leave multicast groups. We will go\ninto the causes of path recalculation in more detail after we discuss the precise data that\na MOSPF router must store from a multicast routing calculation\u2014the multicast for-\nwarding cache entry.\n10.3.1 The Multicast Forwarding Cache\nMOSPF routers calculate the path of the multicast datagram from the datagram's source\nto its destination group members. However, it is not necessary for the MOSPF router to\nstore the entire path. Only the router's position with respect to the path is important.\nThis position is stored within a multicast forwarding cache entry.\nAs mentioned earlier, there are separate paths, and therefore separate forwarding\ncache entries, for each source network and destination group combination. Each of the\nrouter's forwarding cache entries contains information about\n\u2022 The router or network from which the router must receive matching datagrams. This\ninformation is needed because multicast datagrams are replicated when for-\nwarded. In order to ensure that only one copy of each datagram is received on\nany particular segment, those replications taking more circuitous paths must be\ndiscarded.\nIt would be more natural to specify the receiving router interface for each\ndatagram. MOSPF instead specifies the network or router from which the data-\ngram must be received because in one case, MOSPF cannot determine the\nreceiving interface exactly: when multiple point-to-point links connect the\nrouter to the neighbor. For example, suppose that in Figure 10.1, there are two\npoint-to-point links between routers D and G. When building the path of a mul-\nticast datagram sent from SI to group Gl, MOSPF can determine which link\nrouter D will send the datagram on, but router G cannot determine which of the\ntwo links it will receive the datagram on\u2014router D advertises the sending half\nof the links and router G the receiving half, but there is insufficient information\nwithin the OSPF link-state database to match the sending and receiving halves.\n\u2022 The interfaces out which the router should forward matching datagrams. For\nnonbroadcast networks, either NBMA or Point-to-MultiPoint, a router keeps\ntrack of which neighbors the datagrams must be sent to, since datagrams must\nbe forwarded separately to each neighbor. Regardless of whether an interface or",
        "3f9be3c6-8555-481a-8662-56de95093293": "196 MOSPF Chapter 10\nneighbor appears in the forwarding cache entry, the number of hops to the near-\nest group members reached via the interface or neighbor is also recorded. This\ninformation indicates the minimum TTL that multicast datagrams sent via the\ninterface/neighbor must have in order to reach any group member and enables\noptimization of MOSPF's expanding ring search (see Section 10.1.1).\nAs an example of a forwarding cache entry, consider again the MOSPF routing\ndomain in Figure 10.1. In router D, the forwarding cache entry for source network\n128.186.1.0/24 and destination group Gl would indicate that matching datagrams must\nbe received from network 128.186.3.0/24, in which case they are forwarded out the\ninterface to router G, where the nearest group member is one hop away.\nThere is a multicast routing table MIB, described in [142], that allows you to exam-\nine multicast forwarding cache entries via SNMP. This MIB describes cache entries and\nmulticast routing statistics in a way that pertains not only to MOSPF but also to other\nmulticast routing protocols, such as DVMRP and PIM.\nA router can clear one or more of its multicast cache entries at any time. The multi-\ncast cache entries will simply be rebuilt the next time a matching multicast datagram is\nreceived. However, certain multicast cache entries must be deleted in order to force\nrebuilding when network conditions change, as explained next.\n10.3.2 Maintaining the Multicast Forwarding Cache\nWhen changes occur within the MOSPF routing domain, certain multicast paths also\nchange, requiring that forwarding cache entries be rebuilt. However, MOSPF routers do\nnot rebuild the forwarding cache entries directly. Instead they simply delete the cache\nentries. These entries will then be rebuilt as matching datagrams are received, in exactly\nthe same manner as the entries were constructed in the first place. Building the forward-\ning cache entries as matching datagrams are received spaces the routing calculations out\nover time rather than trying to recalculate all cache entries at once.\nWhich entries need to be deleted, forcing a later recalculation? The answer depends\non the nature of the change within the MOSPF domain. A MOSPF router knows that\nsomething has changed when it receives an updated LSA whose contents have been\naltered. The LSA's type indicates the nature and extent of the change.\nReception of a modified router-LSA or network-LSA indicates a router or link fail-\nure (or restoral), or maybe a change in link cost. In these cases, it is impossible to tell\nprecisely which multicast paths will be affected, so a MOSPF router deletes all cache\nentries. In contrast, reception of a modified group-membership-LSA indicates that the\nmembership of a particular group has changed. In this case, a MOSPF router needs to\ndelete only those cache entries that pertain to the particular group.\nGoing back to our example in Figure 10.1, if the link between routers D and G fails,\nnew router-LSAs for D and G will be flooded throughout the MOSPF domain, which\nwill in turn cause all forwarding cache entries (in all routers) to be cleared. If, however,",
        "0b441016-499a-4bc6-94da-95d3437d0287": "Section 10.3 MOSPF Routing Calculations 197\nthe group G2 member on segment 128.186.4.0/24 leaves G2, router E will flood a\nnew group-membership-LSA for G2, and only cache entries pertaining to G2 will be\ndeleted.\nWhen examining hierarchical multicast in MOSPF (Section 10.4), we will see that in\ngeneral, the farther away the change is from a given router, the fewer cache entries the\nrouter has to delete. This is an important property for the scaling of multicast routing in\na MOSPF domain.\n10.3.3 Calculating a Multicast Datagram's Path: Details\nAs mentioned previously in this chapter, the MOSPF multicast routing calculation is\nvery similar to OSPF's unicast routing calculation. Both calculate shortest-path trees,\nusing Dijkstra's algorithm. However, as we examine the details of MOSPF's routing cal-\nculation, we will notice some differences.\nIn OSPF's unicast routing calculation, the shortest-path tree is rooted at the calculat-\ning router itself. A router can get away with this because it does not care about which\ninterface a unicast datagram is received from\u2014the datagram is going to be forwarded\nbased purely on its IP destination address. Rooting the shortest-path tree at the calculat-\ning router also allows the router to calculate routing table entries for all destinations at\nonce. However, in order to control replication of multicast datagrams, the MOSPF\nforwarding decision must be based on both the datagram's source and destination\naddresses. This forces the shortest-path trees calculated by MOSPF to be rooted at the\ndatagram source. One additional consequence of root placement is that, whereas unicast\ncalculations are always specific to the router doing the calculation, every MOSPF router\nperforms the exact same calculation for a given multicast datagram.\nFigure 10.3 shows the shortest-path tree calculated for a multicast datagram sent by\nsource SI to destination group Gl in Figure 10.1. Routers A-G all calculate the same\ntree, in which the backup links between routers A and B and between routers D and F\nhave been pruned.\nAnother difference between unicast and multicast calculations occurs in the treat-\nment of stub networks. In the MOSPF routing calculation, excepting the source network,\nstub network segments do not appear. In MOSPF, group membership of a stub network\nis aggregated and advertised by the stub network's router. In Figure 10.3, router F is\nadvertising membership in group Gl for its two attached stub networks.\nWe have been using the term tree a little loosely in this discussion. The unicast OSPF\ncalculation keeps redundant shortest paths for its equal-cost multipath load-balancing\nfeature. However, in multicast forwarding, redundant paths would cause unwanted\ndatagram replication. In order to remove the redundant paths, the MOSPF calculation\nintroduces tiebreakers that cause one shortest path to be preferred over another: When\nmultiple shortest paths exist to a network or router, the path whose previous hop router\nor network has the highest address is chosen. In Figure 10.3, two shortest paths exist to",
        "be5df929-359b-4932-80d6-76212dc9efdb": "198 MOSPF Chapter 10\nFigure 10.3 MOSPF shortest-path tree. Dashed links labeled with A are pruned when removing redundant\nshortest paths. Dashed lines labeled with B are pruned when removing links that do not lead to group Gl\nmembers.\nnetwork 128.186.4.0/24. Assuming that router G has a higher Router ID than router E\ndoes, the path through router G is chosen, causing the connection from router E to\n128.186.4.0/24 to be pruned from the tree.\nOne case in which MOSPF cannot automatically detect the presence of redundant\npaths is when multiple IP subnets have been assigned to the same physical segment\n(see Section 5.1). MOSPF sees such subnets as completely separate entries, yet for the\npurpose of multicast forwarding, they are the same segment, because IP multicast for-\nwards datagrams as data-link multicast, thereby transcending IP subnet boundaries.",
        "ab8c9d7d-94ca-425b-b2fe-f4d5c3acc6b0": "Section 10.4 Hierarchical Multicast in MOSPF 199\nThese types of redundant paths must be removed through configuration (see Section 6.3\nof [171]).\nDijkstra's algorithm calculates routes to all destinations at once. However, the\nMOSPF calculation is concerned only with calculating the paths from a source to a spe-\ncific group. Therefore the final part of the MOSPF routing calculation prunes those\npaths that do not lead to members of the group. In our example in Figure 10.3, routers B,\nC, and E and their links are pruned from the tree because they do not lead to members\nof group Gl.\n10.4 Hierarchical Multicast in MOSPF\nThe goal of hierarchical multicast routing is the same as for hierarchical unicast routing:\nreduce the resources consumed by the routing algorithms, thereby enabling the network\nto scale to large sizes. OSPF implements a two-level hierarchical routing scheme for uni-\ncast routing by splitting an OSPF routing domain into areas (see Chapter 6). MOSPF\nuses this OSPF area organization to implement a hierarchical multicast routing scheme.\nHierarchical routing in MOSPF allows both datagram source information and mul-\nticast group membership to be aggregated at area boundaries. This aggregation can\ndrastically reduce the number of forwarding cache entries in a router, thereby reducing\nthe number of routing calculations a MOSPF router must perform. However, just as for\nunicast routing, hierarchy can have disadvantages. The disadvantage of hierarchy for\nunicast traffic was that you sometimes get suboptimal paths (see Section 6.1). In MOSPF,\nthe disadvantage of hierarchy is that multicast datagrams are sometimes forwarded\nunnecessarily, only to be discarded later (see Section 10.4.1).\nWe explore the effects of hierarchy on MOSPF in two parts. In Section 10.4.1, we\nshow how the location of datagram sources and multicast group membership is con-\nveyed across area boundaries. In Section 10.4.2, we describe how the MOSPF routing\ncalculation changes in the face of hierarchy and the effect on the paths of multicast data-\ngrams. In both sections, we give examples, using the hierarchical MOSPF domain pic-\ntured in Figure 10.4. The example consists of four separate areas, in which virtual links\nhave been configured between router D and each of the routers B, C, E, and F in order to\nconnect all areas to the backbone area. Area 0.0.0.3 has no configured virtual links and\nso does not provide transit service. Area 0.0.0.3 is configured to aggregate its two sub-\nnets, advertising the aggregate 10.17.0.0/16 to the other areas in OSPF summary-LSAs.\nA MOSPF domain (also called Autonomous System) can be embedded in a larger\nmulticast routing domain. In that case, further levels of multicast hierarchical routing\ncan be achieved, essentially replicating the MOSPF area mechanisms at the AS bound-\nary, where datagram source information and group membership can be further aggre-\ngated. This case is explored further in Section 10.6, using the example of embedding a\nMOSPF domain inside a DVMRP routing system.",
        "4e0547ab-0f86-4387-8001-0550f4078680": "200 MOSPF Chapter 10\nFigure 10.4 A hierarchical MOSPF routing domain.",
        "2b03a612-f21d-44e7-8094-16e00887b1f9": "Section 10.4 Hierarchical Multicast in MOSPF 201\n10.4.1 Advertising MOSPF Information in the Presence of Hierarchy\nArea border routers advertise unicast routing information across area boundaries in the\nform of summary-LSAs (see Section 6.1.1). These same summary-LSAs also serve to\ncommunicate the presence and location of multicast sources, as long as the MC-bit is set\nin the summary-LSAs' Options field. An area border router can aggregate multicast\nsource information by advertising an address prefix that incorporates multiple IP sub-\nnets. Aggregation of multicast sources reduces the number of multicast forwarding\ncache entries required, reducing resource requirements on the MOSPF routers.\nFor example, in Figure 10.4, router F advertises a single summary-LSA for the prefix\n10.17.0.0/16 into area 0.0.0.2. By setting the MC-bit in this summary-LSA, router F lets\nthe routers within area 0.0.0.2 know that the prefix contains multicast sources. By aggre-\ngating IP subnets 10.17.1.0/24 and 10.17.2.0/24 into a single summary-LSA, router F\nallows routers internal to area 0.0.0.2 (for example, router H) to cover both sources S3\nand S4 with a single forwarding cache entry.\nMulticast group membership in nonbackbone areas is always advertised into the\nbackbone area (area ID 0.0.0.0). An area border router aggregates the group membership\nof its attached nonbackbone areas by originating group-membership-LSAs into the\nbackbone area. Analogous to the way MOSPF hides which specific stub networks con-\ntain group members, the area border router simply lists itself as wanting to receive mul-\nticasts for certain groups. Again using Figure 10.4 as an example, we see that router B\nrequests datagrams addressed to Gl by advertising a group-membership-LSA for\ngroup Gl into the backbone area. Routers within the backbone area will then forward\ngroup Gl traffic to router B, even though they do not know which nonbackbone areas\nattached to router B have group Gl members. Similarly routers D, E, and F also adver-\ntise Gl membership into the backbone, whereas routers C, D, and E advertise G2\nmembership.\nIn this way, the MOSPF routers within the backbone area know the identity, but not\nnecessarily the precise location, of all groups within the MOSPF routing domain. How-\never, routers internal to nonbackbone areas do not even know which groups have mem-\nbers within other areas. To deliver multicast datagrams to other areas, the multicast\nequivalent of default routing is employed: The nonbackbone area's area border routers\nadvertise themselves as wildcard multicast receivers. Wildcard multicast receivers are\nthose MOSPF routers that wish to receive all multicast datagrams, regardless of destina-\ntion group. By labeling all area border routers as wildcard multicast receivers, all multi-\ncast datagrams originating in nonbackbone areas are forwarded to the backbone area,\nwhere they can be forwarded in turn to area border routers requesting the particular\nmulticast group.\nIn our example, routers B, D, and F advertise themselves as wildcard multicast\nreceivers in area 0.0.0.2. If S2 then sends a multicast datagram to group G2, router H will\nforward the datagram on to routers B and F, even though router H has no idea whether\nany group members of G2 exist. From there, the multicast datagrams are forwarded to",
        "90ffee9c-e46f-483e-b7a6-3d2551b090b2": "202 MOSPF Chapter 10\nthose backbone routers requesting G2 datagrams (C and D); finally, router C (chosen\nover router D by the MOSPF hierarchical routing calculation; see Section 10.4.2) will for-\nward the datagram to router G, which will multicast the datagram onto the 10.16.3.0/24\nsegment.\nThe path just described shows the trade-off made in MOSPF hierarchical routing:\nnetwork bandwidth for a reduction in the number of cache entries. In order to hide\ngroup membership information from routers in area 0.0.0.2, and to hide membership\nlocation information from the backbone routers, the datagram sent by S2 to group G2 is\nunnecessarily sent to router D (through router F), where it is then discarded in favor of\nthe path through routers B and C.\n10.4.2 Routing Calculations in Hierarchical MOSPF\nIn the presence of hierarchy, calculation of the path of multicast datagrams must change\nslightly. These changes are due to the aggregation of sources and group membership\nacross area boundaries. The neighborhood of a source in another area cannot be deter-\nmined completely, and so the source's location must be estimated using summary -\nLSAs. Also, the location of group members cannot always be precisely pinpointed;\nwildcard receivers must remain on all multicast paths regardless of destination multi-\ncast group.\nPaths are calculated for each area separately. The path through area 0.0.0.2 of a mul-\nticast datagram sent by source SI to group Gl is shown in Figure 10.5. The area border\nrouters in area 0.0.0.2 provide estimates of the location of the source through their\nsummary-LSAs. All routers in area 0.0.0.2 end up being on the path of the multicast\ndatagram: Router B provides the entry of the datagram to the area, router H because\nthere is a group Gl member on H's attached stub network, and routers D and F be-\ncause they are wildcard multicast receivers in area 0.0.0.2. Router D provides an equal-\ncost entrance to area 0.0.0.2 for the datagram on its way to routers D and F, but this\nalternative path is removed by MOSPF tiebreakers.\nTo create the entire path throughout the MOSPF domain, the area border routers\nmerge the shortest-path trees for the individual areas. Assuming that the routers labeled\nwith letters later in the alphabet have larger OSPF router IDs, the resulting complete\npath for our example is as shown in Figure 10.6. Note that some area border routers\nreceive datagram copies from multiple areas. In this case, MOSPF tiebreakers will again\ndictate which interface (if any) should accept the datagram for further forwarding,\nwhereas datagram copies received on all other interfaces are discarded. In our example,\nrouter D receives copies from routers B and C but forwards neither.\nAs mentioned earlier, the farther away from a router a network change occurs, the\nfewer forwarding cache entries need to be recalculated. A change in an area not directly\nattached to the router may cause no new summary-LSAs to be flooded; in this case, the",
        "774aaaa5-83f6-42a4-b576-d5ebfb164086": "Section 10.5 Backward Compatibility: Mixing with Nonmulticast Routers 203\nFigure 10.5 Path of datagram sent by SI to group Gl, through area 0.0.0.2.\nchange is completely hidden from the router, and no forwarding cache entries need be\nrecalculated. If summary-LSAs do get updated, only those forwarding cache entries\nwhose sources fall into the range of the summary-LSA need be redone.\nFigure 10.6 again demonstrates that MOSPF hierarchical routing can produce\nextraneous forwarding hops. For example, routers C, D, E, and G receive copies of the\ndatagram, only to have it be eventually discarded before reaching any group members.\nIn these cases, MOSPF could benefit from a DVMRP-like pruning message (see Sec-\ntion 14.1).\n10.5 Backward Compatibility: Mixing with Nonmulticast Routers\nIn order to be able to deploy a multicast routing capability incrementally, a multicast\nrouting protocol must be able to deal with situations in which the multicast topology is\ndifferent from the unicast topology. Some routers in a network may be capable of multi-\ncast forwarding, and others may not. This difference may be short in duration\u2014for\nexample, as new software is deployed in a network's routers. Or the difference may be\nmore protracted\u2014for example, the Internet's MBONE imposes a different multicast",
        "3c0b245b-78a6-42bb-b3ac-30205a6212cc": "204 MOSPF Chapter 10\nFigure 10.6 Complete path of datagram from SI to group Gl.",
        "f50f90d3-d607-4a82-97e5-84ef91d5d96f": "Section 10.5 Backward Compatibility: Mixing with Nonmulticast Routers 205\ntopology overlaying the unicast topology, a situation that has persisted since the\nMBONE's inception in 1992 [69].\nMOSPF routers deal with differences between multicast and unicast topology by\nforwarding multicast datagrams around those OSPF routers not running MOSPF.\nMOSPF routers announce their multicast capability by setting the MC-bit in the Options\nfield of their router-LSAs (see Chapter 7). Then, when a MOSPF router calculates the\npath of a multicast datagram, only those router-LSAs with MC-bit set are included in\nthe calculation.\nThe advertisement of multicast sources across area boundaries piggybacks on the\nadvertisement of unicast information across area boundaries in summary-LSAs. This\nbehavior does not require that multicast and unicast capabilities match along area\nboundaries: If the MC-bit is not set in a summary-LSA, the summary-LSA is used only\nin unicast calculations. In this case, MOSPF uses the MC-bit to indicate whether the area\nborder router advertising the summary-LSA is both (a) running MOSPF and (b) capable\nof forwarding multicast datagrams across area boundaries.\nIn the analogous situation of inter-AS multicast, MOSPF uses the MC-bit in\nAS-external-LSAs to signal differences in multicast and unicast topology along AS\nboundaries. This case is explained further in Section 10.6.\nRestrictions\nOn LANs, mixing MOSPF routers with OSPF routers incapable of running MOSPF\nposes some problems. All such problems can be solved by making sure that a MOSPF\nrouter is elected Designated Router for the LAN, which is guaranteed when the non-\nMOSPF routers are assigned a Router Priority of 0 (see Section 5.2).\nWhen using IGMP as specified in [56], the OSPF Designated Router is assigned the\nIGMP Querier function, responsible for sending periodic IGMP Host Membership\nQueries onto the LAN. The Designated Router is relieved of this function when IGMPv2\n[71] is deployed, because IGMPv2 itself implements a Querier election.\nHowever, regardless of which version of IGMP is in use, the OSPF Designated\nRouter is responsible for originating group-membership-LSAs to report the LAN's\ngroup membership throughout the MOSPF domain. In addition, the normal OSPF rules\nfor processing optional LSA types apply to group-membership-LSAs: Only MOSPF\nrouters are required to store and flood group-membership-LSAs. Due to the central role\nthat the Designated Router plays in flooding LSAs across the LAN (see Section 5.2),\ngroup-membership-LSAs will not be forwarded across the LAN unless the Designated\nRouter is MOSPF-capable. It is this last restriction that caused the flooding of unknown\nLSA types to be changed in OSPF for IPv6 (see Section 3.7). In OSPF for IPv6, unknown\nLSA types are always flooded locally; in the case of group-membership-LSAs, this\nmeans that group-membership-LSAs would be flooded across a LAN even if the Desig-\nnated Router were not MOSPF-capable.",
        "6a5d7097-9575-4c1a-ad65-7602e7353b3c": "206 MOSPF Chapter 10\n10.6 MOSPF in the MBONE\nJust as there are multiple unicast routing protocols deployed in the Internet, there\nare also multiple multicast routing protocols in use. To forward datagrams between\ndomains using different routing protocols, information must be exchanged between the\nrouting protocols. In unicast routing, this information is the location of IP destinations.\nIn multicast routing, this information is the location of multicast sources and destination\ngroups.\nThis section describes the exchange of information between MOSPF and DVMRP,\nthe routing protocol deployed in the MBONE (see Section 14.2). In order to connect a\nMOSPF domain to the MBONE, one or more of the routers within the MOSPF domain\nmust also run DVMRP. In the interaction between the two protocols, MOSPF plays the\nmulticast equivalent of an IGP, whereas DVMRP acts like an BGP. An example of a\nMOSPF domain connected to the MBONE is shown in Figure 10.7. Routers A and D run\nboth MOSPF and DVMRP, leaking multicast routing information from one protocol to\nthe other. In addition, a BGP connection on router C provides unicast connectivity to the\nInternet.\n10.20.2.0/24\n10.20.3.0/24\nFigure 10.7 Example MOSPF domain within the MBONE.",
        "02379cf2-e8d9-4889-81dc-f2f65b6a45d5": "Section 10.6 MOSPF in the MBONE 207\nProbably the best way to view the interaction between MOSPF and DVMRP is to\nthink of the MOSPF domain as an extended Ethernet segment within the DVMRP rout-\ning system.\n\u2022 DVMRP routers consider the group membership of their attached network seg-\nments when deciding whether to send prune messages: If none of the DVMRP\nrouter's attached network segments have group members and if all of its subor-\ndinate DVMRP routers (see Section 14.2) have sent prunes for a given source\nand destination group, the router itself will send matching prunes back toward\nthe source. Similarly a router running both DVMRP and MOSPF will send\nprunes if (a) there are no group members in the MOSPF domain and (b) all of\nits subordinate DVMRP routers have sent prunes.\n\u2022 DVMRP routers include the addresses of their directly attached LAN segments\nin DVMRP routing updates. A router running MOSPF and DVMRP will include\nall MOSPF intra-area and inter-area addresses in its DVMRP updates.\n\u2022 In order to get DVMRP routing information across a MOSPF domain, one must\nexchange DVMRP routing messages between the DVMRP routers at the edge of\nthe MOSPF domain\u2014this is analogous to running IBGP to communicate BGP\nrouting information across an AS (Section 13.3). DVMRP routing messages are\nmulticast over Ethernet segments. Over a MOSPF domain, DVMRP routing\nmessages are again multicast, this time after encapsulating within an additional\nIP header whose destination is set to the group address 224.0.1.21 (DVMRP over\nMOSPF in [212]). This can be thought of as a DVMRP multicast tunnel. For\nexample, in Figure 10.7, both routers A and D would join the multicast group\n224.0.1.21. Then, when router A sent a DVMRP routing update, it would encap-\nsulate the DVMRP update within a multicast datagram sent to 224.0.1.21, which\nwould be delivered by MOSPF routing to router D.\n\u2022 When multiple DVMRP routers are attached to a LAN, the exchange of DVMRP\nrouting updates determines which DVMRP router is responsible for forwarding\nmulticasts onto the LAN from any given source. Similarly the DVMRP routing\nupdates multicast over the MOSPF domain determine which DVMRP router is\nresponsible for forwarding multicast datagrams into the MOSPF domain.\nSince we are taking a MOSPF-centric view, we will speak of the advertising of MOSPF\ninformation within DVMRP as exporting information to DVMRP and that DVMRP infor-\nmation is imported into MOSPF.\nAs mentioned, MOSPF internal sources are exported to DVMRP as if they were\naddresses assigned to a DVMRP router's attached network segments. In Figure 10.7,\nboth routers A and D would advertise the aggregate 10.20.0.0/16 within their DVMRP\nrouting updates. Group information, on the other hand, is exported indirectly through\nthe DVMRP pruning logic. If, for example, router D sends router A a prune message for\nsource SI and group G2, A will in turn send a prune message back toward SI, since no",
        "a093a308-04fc-49d5-92d7-c8bf2ab7470a": "208 MOSPF Chapter 10\ngroup G2 members are within the MOSPF domain. However, if A receives a prune\nfor SI and Gl, A will not send a prune, due to the presence of group members on\n10.20.2.0/24 and 10.20.3.0/24.\nImporting DVMRP information into MOSPF is analogous to advertising multicast\nrouting information from the OSPF backbone area into nonbackbone areas (see Sec-\ntion 10.4.1). Whereas inter-area source information is advertised in summary-LSAs,\nDVMRP sources are imported in AS-external-LSAs. The MC-bit is set in the AS-\nexternal-LSA's Options field to indicate that, besides advertising a unicast route, the\nadvertised network is also a multicast source. Only this single bit and not a sepa-\nrate metric for multicast is needed, since, according to the fourth item listed, at most\none DVMRP router will be importing any particular source. Of course, the multicast\nand unicast topologies may be quite different, and a DVMRP router may want to ad-\nvertise a multicast source without also advertising a matching unicast route. For\nexample, in Figure 10.7, router A may wish to advertise the multicast source SI but\nmay want unicast traffic destined for SI to be forwarded to router C's Internet connec-\ntion. In order to advertise a multicast-only route, router A originates an AS-external-\nLSA for SI with the MC-bit set and an infinite cost.\nSince only one DVMRP router will import any given source, the DVMRP routers\ncan reduce the number of multicast sources imported into the MOSPF domain by hav-\ning the DVMRP router that would have imported the most sources import a multicast\ndefault route (AS-external-LSA with destination 0.0.0.0 and MC-bit set) instead.\nWe saw earlier that multicast group information is not advertised from the OSPF\nbackbone into nonbackbone areas. Similarly multicast group information learned by\nDVMRP is not imported into the MOSPF domain either. Instead the routers running\nboth DVMRP and MOSPF declare themselves wildcard multicast receivers (see Sec-\ntion 10.4.1), performing the same function that the area border routers did in inter-\narea multicast routing. Labeling the DVMRP routers as wildcard multicast receivers\nensures that multicast datagrams will be forwarded to the point where the DVMRP\ngroup membership information can be accessed and acted on.\nFurther Reading\nIP multicast is based on the work of Steve Deering. He defined the interaction of hosts\nand routers in IP multicast in the original IGMP specification [56]. In [58] and [59], he\nexplored various multicast routing algorithms, which led to the development of both\nthe DVMRP ([202], [255]) and MOSPF routing protocols.\nIGMP has been extended since the development of MOSPF. In IGMPv2 [71], an elec-\ntion algorithm for the designated Querier (the router responsible for sending periodic\nHost Membership Queries) is introduced, removing the need to link this function to the\nMOSPF Designated Router. Also, Leave Membership Reports are introduced to reduce",
        "f5f8dd89-2b8e-4b3c-9e10-55b2d5897ba3": "Section 10.6 MOSPF in the MBONE 209\nthe group leave latency. IGMPvS [28] defines source-specific join and leave group mes-\nsages that MOSPF, in its present form, cannot take advantage of.\nThe encapsulation of IP multicast datagrams varies according to the data-link\nprotocol. For those data links with a multicast capability, the IP multicast destina-\ntion is usually mapped in some way to a data-link multicast address. The IP multicast\nencapsulation for Ethernet is given in [56], FDDI in [122], 802.5 Token Ring in [203], and\nSMDS in [134]. IP multicast support over ATM is still under development, with the lead-\ning proposal described in [4]. Multicast encapsulations for IPv6 are different, as are the\nunicast encapsulations, as described in Section 1.3.\nDetailed description of the MBONE and some of its applications can be found in\n[69] and [131]. Answers to frequently asked questions about the MBONE, including\nhow to get connected to it and where to find the proper applications, can be found\nin [36].\nMOSPF does not have its own Management Information Base, but instead MOSPF\nvariables have been added to the OSPF MIB [14]. For more information on configuration\nand management of MOSPF, see Chapter 11, OSPF Management.\nAdding MOSPF to an OSPF implementation tends to increase code size by about\n30 percent. For further details on code size and other MOSPF performance statistics,\nsee [170].\nExercises\n10.1 What MOSPF-specific events would cause demand circuits' underlying data-link\nconnections to be (re)established? How would this change if the MOSPF domain\nwere split into areas?\n10.2 Which routers originate group-membership-LSAs in Figure 10.7? Which routers\nare declaring themselves wildcard multicast receivers?",
        "231c4607-f88a-4d00-b3fa-4c8f85ff6f7e": "Part IV\nConfiguration and Management\nIn Part IV, we discuss how to configure, monitor, and debug Internet routing. Chap-\nter 11, OSPF Management, explains how to configure and manage an OSPF network. All\nconfigurable OSPF items are contained in the OSPF MIB; we discuss the use of SNMP\nand this MIB. Common configuration tasks, such as the setting of interface costs, are\nexplained. We also discuss whether, and if so how, to split an OSPF routing domain into\nareas. An example of a real OSPF network configuration, the Arkansas Public School\nComputer Network, is provided. The interaction between OSPF and BGP and RIP is\ndescribed. The chapter ends with a description of OSPF's security features.\nChapter 12, Debugging Routing Problems, is a practical discussion of the tech-\nniques for debugging routing problems in a TCP/IP network. All of the common tools\nfor analyzing IP routing difficulties are covered, including ping, traceroute, SNMP,\nnetwork analyzers, and multicast traceroute. We describe how each tool is used, explain\nhow the tool works, and discuss the tool's strengths and weaknesses.\n211",
        "c1cb6863-eec7-4f8d-8da3-31a346ca9278": "11\nOSPF Management\nIn this chapter, we discuss how to manage the OSPF protocol. At the macro level, a net-\nwork administrator must decide how to organize an Autonomous System (AS) that\nruns OSPF as its routing protocol. This involves answering the following questions.\n\u2022 Where are the boundaries of the AS?\n\u2022 Which links should be preferred for data traffic, and which links should be\navoided?\n\u2022 What information learned from other ASs should be imported into the AS?\nConversely how much of the AS's internal routing information should be\nadvertised to other ASs?\n\u2022 Should the OSPF AS be divided into areas? If so, where should the area bound-\naries be placed?\n\u2022 Does the OSPF routing within the AS need to be protected from hostile\nattackers?\nAfter determining the OSPF configuration for the Autonomous System, the admin-\nistrator must then master the mechanics of how to configure the individual routers to\nrun the OSPF protocol. Unfortunately this step is often vendor specific. However, the\nInternet standard network management framework, consisting of SNMP and its MIBs,\nprovides a good place to start.\n213",
        "eaca21b7-f0e9-426f-a8dd-d003fb30690b": "214 OSPF Management Chapter 11\n11.1 SNMP\nThe standard method for configuring and monitoring Internet protocols and devices is\nvia the Simple Network Management Protocol (SNMP) [226]. SNMP manipulates man-\nagement data within an Internet device, such as a router. This management data forms a\ndevice's Management Information Base (MIB) [144], which is organized as a tree struc-\nture, as depicted in Figure 11.1. All management data for Internet devices falls under the\nbranch internet (1.3.6.1), with the subbranch mgmt (2) for standardized management\ndata, experimental (3) for management data currently under development, and private (4)\nfor vendor-specific management data. The core set of management data for Internet pro-\ntocols is called MIB-II and falls under the subbranch labeled mib-2.\nEach Internet protocol running within the device is required to provide its own set\nof management data. Some of these protocol-specific MIBs are pictured in Figure 11.1:\nsystem (1) for generic information about Internet devices, such as system-up time;\ninterfaces (2) for network interface statistics, such as a count of packets sent and received;\nat (3) for ARP; ip (4) for Internet Protocol network-layer data, including the routing\ntable; and MIBs for the various IP routing protocols. These MIBs are defined in a precise\nlanguage so that they can be compiled into a network management station, just like a\nprogram written in any computer language.\nFigure 11.1 The structure of Internet management information.\nEach management variable within one of these MIBs has a number of attributes.\nOne such variable, the cost of an OSPF interface for a particular Type of Service, is\nshown in Figure 11.2 as it has been defined within the OSPF MIB. The variable has been\nassigned the textual name ospf ifMetricValue. The format of the variable's value is",
        "d7ec7266-c7b3-4437-9218-36254e549262": "Section 11.1 SNMP 215\nspecified in the SYNTAX clause; MIB values are coded in basic ASN.l [113] formats, such\nas integers, octet strings, and so on. In this case, the value has been defined to be a\nMetric, which has been defined earlier in the OSPF MIB to be an integer between 0 and\n65,535. The MAX-ACCESS clause indicates whether the variable is writable for configura-\ntion purposes, readable for monitoring, or both. The variable ospf if Metricvalue is\nused for both configuration and monitoring. Variables can also specify default values in\na DEFVAL clause, although this clause has not been provided for ospf if Metricvalue.\nThe last line in the variable specification provides the location, or object identifier, of the\nvariable within the global MIB. The OSPF MIB can be found at branch 1.3.6.1.2.1.14, and\nospf ifMetricValue is subbranch 4 of ospf If MetricEntry, which is itself subbranch\n8.1 within the OSPF MIB. This yields an object identifier of 1.3.6.1.2.1.14.8.1.4. It is this\nidentifier, not the textual name ospf if Metricvalue, that is handed to SNMP when you\nwant to manipulate the cost of an OSPF interface.\nFigure 11.2 Specification of variable ospflfMetricValue within the OSPF MIB.\nThe value of a management variable can depend on context. For example,\nospflfMetricValue can have a separate value for each OSPF interface and also for\neach IP Type of Service (TOS). Within MIBs, such context dependence is captured by\norganizing variables in tables: Each row of a table specifies the value of a set of vari-\nables within a specific context.\nAn example is shown in Figure 11.3. The variable ospf ifMetricTable describes a\nrouter's OSPF interface metrics; ospf if MetricEntry defines what a row of the table\nlooks like. The INDEX clause indicates that there is a separate row for each interface\nand TOS: The interface is given by a combination of ospf ifMetricipAddress (the IP\naddress of an interface), ospf ifMetricAddressLessif (for unnumbered interfaces set\nto the MIB-II Iflndex of the interface but otherwise set to 0), and ospf if MetricTOS (for\nTOS). Each row within ospf if MetricEntry has five variables, including the three\nINDEX variables (required by SNMP to be listed in the table's rows but otherwise unin-\nteresting) and the value of the metric (ospflfMetricValue). The last variable in the\nrow, ospf ifMetricStatus, provides the SNMP standard way of deleting rows from\ntables: Setting ospf if Metricstatus to destroy for a particular index deletes the OSPF\nmetric for a particular interface and TOS combination.",
        "008065c9-876f-433e-99a2-66fee3bf07f6": "216 OSPF Management Chapter 11\nFigure 11.3 Table specifying OSPF interface metrics.",
        "03c46091-c875-4274-8fd9-8b2d013acbbe": "Section 11.1 SNMP 217\nThe value of a management variable within a table row is called an instance of the\nvariable. An SNMP object identifier specifies both a variable and an instance. Returning\nto our previous example, there is a separate instance of ospf IfMetricvalue for each\ninterface and TOS. The object identifier for a particular instance of ospf If Metricvalue\nis formed by concatenating 1.3.6.1.2.1.14.8.1.4 with the relevant instances. The object\nidentifier of ospf IfMetricvalue for interface with IP address of 10.1.1.1 and for TOS 0\nis shown in Figure 11.4.\nIP address of interface ospf ifMetricAddressLesslf\nospflfMetricValue \\^ / TOS\n, --'A-- ^ , A ^ f ^\n1.3.6.1.2.1.14.8.1.4.10.1.1.1.0.0\nFigure 11.4 Object identifier of ospflfMetricValue specifying instances.\nSNMP provides three functions to access the management data: get, get-next, and\nset. These are separate SNMP packet types. However, programs such as Carnegie-\nMellon University's SNMP tools [31] have been written to access these SNMP functions\ndirectly from the UNIX or DOS shells, which is the model we shall assume in the rest of\nthis chapter. The SNMP get function reads the value of a particular instance of a MIB\nvariable; for example, get 1.3.6.1.2.1.14.8.1.4.10.1.1.1.0.0 would return the\nTOS 0 cost of the OSPF interface whose IP address is 10.1.1.1. The get-next function also\ntakes an object identifier as argument but returns the value of the MIB variable instance\nthat immediately follows the given object identifier, in lexicographic order (that is, the\norder that words are listed in a dictionary). This allows one to use get-next repeatedly to\nwalk through the entire management database. Often command line get-next functions\nare implemented so that they issue repeated SNMP get-next queries until reaching an\nobject identifier whose prefix is different from the one issued on the command line. This\nfeature makes it easy to list an entire table or one of a table's columns. For example,\nFigure 11.5 shows how get-next can be used easily to list all of a router's OSPF interface\ncosts by walking through the ospf ifMetricTable. There are three interfaces, having IP\naddresses 10.1.1.1,10.2.3.7, and 10.6.1.1, with OSPF interface TOS 0 costs of 110,10, and\n200, respectively.\nFigure 11.5 Walking the ospf IfMetricTable, using SNMP's get-next function.",
        "c87438ef-e6b5-47d4-aade-08837ccf18d1": "218 OSPF Management Chapter 11\nThe SNMP set command allows you to write a particular MIB variable instance. For\nexample, in order to set the cost of OSPF interface 10.6.1.1 to the value 150, the com-\nmand set 1.3.6.1.2.1.14.8.1.4.10.6.1.1.0.0 150 is issued.\nSNMP also has a facility allowing Internet devices to send asynchronous notifica-\ntion of interesting events, called SNMP traps, to a network management station. SNMP\ntraps have always been controversial: Many people are concerned about the additional\nnetwork load that traps can incur during unexpected network conditions. For this rea-\nson, SNMP traps are used rarely, and much of the MIB development involving traps has\ncentered on ways to rate-limit trap generation [14].\nWork began in 1993 on updating SNMP, resulting in a new version of SNMP,\nSNMPv2 [32], [33]. However, the differences between SNMPv2 and SNMP (now called\nSNMPvl) are fairly minor, and the major advantage of SNMPv2, namely, increased\nprotocol security, failed to materialize, due to lack of consensus. The limited improve-\nments over SNMPvl and the large installed base of SNMPvl devices have prevented\ndeployment of SNMPv2. However, the updated MIB description language used by\nSNMPv2 [34] has gained acceptance and is now used when new Internet MIBs are\ndeveloped.\nAs mentioned, SNMP is the standard for management of Internet devices. How-\never, that does not mean that people always use SNMP to monitor and configure their\ndevices. Many routers are instead managed through command line interfaces, via either\nTELNET or dedicated serial line connections, or via Web browsers. These other methods\nare especially common for configuration, due to SNMP's lack of security. Still, when you\nwant to see how to manage a particular protocol or device, the protocol-specific or\ndevice-specific MIB is the place to start. The IETF puts a lot of its energy into creating\nMIBs, which almost always have all the information you want (in fact, usually more\ninformation than you want), including recommended default values for management\nvariables.\n11.2 OSPF MIB\nOSPF has a large MIB [14], with 110 management variables organized into 12 tables.\nMore than half (65) of the variables, including 3 complete tables, are read-only, meaning\nthat they are used only for monitoring. Of the 45 configurable variables, most have\ndefault values that rarely need to be altered.\nThe structure of the OSPF MIB is shown in Figure 11.6. Those tables containing con-\nfigurable variables are shaded. Notice that there are some gaps in the way object iden-\ntifiers have been assigned to tables. An earlier version of the table used to configure\narea address aggregation, ospf AreaRangeTable (ospf 5), is not pictured, having\nbeen replaced by ospf AreaAggregateTable (ospf 14). Another collection of object\nidentifiers, ospf Rout eGroup (ospf 13), does not specify management variables but\ninstead defines object identifiers that can be used by the IP Forwarding Table MIB [11] to",
        "3ddc19b8-3e13-4ca7-8030-89e97d12c3db": "Section 11.2 OSPF MIB 219\nFigure 11.6 Organization of the OSPF MIB. Shaded tables contain configurable parameters, whereas\nunshaded tables are used only for monitoring.",
        "f9052634-3d77-4110-9dff-e2a3b2caa10b": "220 OSPF Management Chapter 11\nindicate specific kinds of OSPF routes (intra-area, inter-area, external Type 1, and exter-\nnal Type 2).\nWhen configuring an OSPF router, you end up setting variables from one or more of\nthe following tables within the OSPF MIB:\n\u2022 ospf GeneralGroup. This group, a table that has only a single row, contains the\nrouter's global OSPF parameters and statistics. The router's OSPF Router ID is\nset by writing ospf Routerid; ospfAdminstat turns the OSPF protocol on or\noff. The OSPF optional extensions of TOS routing, multicast routing (MOSPF),\nand Demand Circuit extensions (see Chapter 7) are enabled or disabled by writ-\ning appropriate values into ospfTOSSupport, ospfMulticastExtensions, and\nospf DemandExt ens ions, respectively. The optional OSPF database-overflow\nlogic can be enabled through setting ospf ExtLsdbLimit, the maximum number\nof AS-external-LSAs that the router can hold. If more than this number of AS-\nexternal-LSAs are received, the router goes into overflow state (see Section 7.5),\nwhich is automatically left after ospfExitOverflowinterval seconds.\n\u2022 ospf AreaTable. There is a separate row in this table for each of the router's\nattached areas, each identified by the area's OSPF Area ID. The type of\nOSPF area (regular, stub, or NSSA; see Sections 7.2 and 7.4) is dictated by\nospfimportAsExtern. For stub areas, ospf AreaSuimnary controls whether a\nstub area's border routers will originate summary-LSAs into the stub area.\n\u2022 ospf stuhAreaTable. For each stub area or NSSA and for each separate TOS\nvalue, there can be a separate row in this table. This table configures the de-\nfault routes imported into the stub area or NSSA by the area's border rout-\ners, with ospf stubMetric specifying the cost of the default route and\nospf stubMetricType specifying whether the default should be a Type 1 or\nType 2 external metric (NSSAs only).\n\u2022 ospf HostTable. This table indicates which hosts are directly attached to the\nrouter: their addresses (ospf HostipAddress), which OSPF area they belong to\n(ospfHostAreaio), and their advertised cost (ospfHostMetric). For example, a\nremote-access router providing dial-up access might have a configured host\naddress for each dial port.\n\u2022 ospf if Table. There is a row in this table for each OSPF interface. Interfaces are\nidentified by their IP address (ospf if ipAddress) or, if the interface is unnum-\nbered, by the physical interface's MIB-II if index (ospf AddressLessif). The\nOSPF area that the interface attaches to (ospf if Areaid) and the type of inter-\nface (ospf if Type, one of broadcast, NBMA, point-to-point, or Point-to-\nMultiPoint) are configured, together with various timers used by OSPF's\nneighbor maintenance and database synchronization procedures (see Sec-\ntions 4.6 and 4.7). Using this table, you also configure the authentication proce-\ndures used in packets sent and received over the interface (ospf ifAuthType",
        "93fa711c-79a3-4bcb-8f4f-b05f35c0004e": "Section 11.2 OSPF MIB 221\nand ospf if AuthKey; see Section 11.7) and whether the attached subnet\nshould be treated as a demand circuit (ospf if Demand, see Section 7.3).\n\u2022 ospf ifMetricTable. The cost of an interface, advertised in the router's\nrouter-LSA and used by the OSPF routing table calculation, is set by writing\nthe appropriate instance of ospfifMetricValue.\n\u2022 ospfvirtif Table. A router's configured virtual links are specified by the OSPF\nRouter ID of the other end point (ospfvirtifNeighbor) and the nonbackbone\narea that will carry the link (ospfvirtif Areaid). As in the regular interface\ntable, timers used by OSPF neighbor maintenance and database synchroniza-\ntion, and authentication procedures can also be configured for each virtual\nlink.\n\u2022 ospf NbrTable. Neighbors may have to be configured on NBMA and Point-to-\nMultiPoint subnets (see Sections 5.3 and 5.4). Each neighbor is identified by its\nIP address (ospf NbripAddr). On NBMA subnets, the Router Priority of each\nneighbor (ospf NbrPriority) must also be configured.\n\u2022 ospf AreaAggregateTable. Each row in this table indicates a range of IP\naddresses (ospf AreaAggregateNet and ospf AreaAggregateMask) belong-\ning to a given area (ospf AreaAggregateAreaiD), which should be aggre-\ngated into a single prefix when advertised to other areas. By setting\nospfAreaAggregateEf feet accordingly, you can also hide a range of IP\naddresses from other areas. This table can also be used by NSSA areas when\naggregating multiple Type-7-LSAs into a single AS-external-LSA at the NSSA\nboundary (see Section 7.4).\nThe other tables in the OSPF MIB are read-only, for use in monitoring the OSPF\nprotocol.\n\u2022 ospf LsdbTable. This table allows you to scan the link-state database, one OSPF\narea at a time. There is a separate row for each LSA in an area's link-state data-\nbase, with entries in the row for each of the LSA's header fields (ospf LsdbAge\nfor the LS Age field, ospf Lsdbchecksum for the LS Checksum field, and so on)\nand an entry (ospf LsdbAdvertisement) allowing you to get the complete\nLSA represented as an octet string. Using this table, the command get_next\nospf LsdbAdvertisement would dump the entire contents of the link-state\ndatabases for all of the router's attached areas.\n\u2022 ospfvirtNbrTable. This table is used to monitor the state of a virtual link. For\nexample, has the virtual link been established? Have the routers at either end\nsynchronized their link-state databases?\n\u2022 ospfExtLsdbTable. Similar to the ospf LsdbTable, this table is only for those\nLSAs with global flooding scope. For example, the command get_next",
        "bbfa8744-b4e7-473f-b693-43102367ce7f": "222 OSPF Management Chapter 11\nospfExtLsdbAdvertisement.5 (ospfExtLsdbType == 5 == AS-external-LSA)\nwould dump all the AS-external-LSAs in the OSPF routing domain.\nThe OSPF MIB also defines a set of traps, used to provide asynchronous notification\nof significant events. These traps can be turned off and on individually by writing to\nospf SetTrap. Just as there were separate tables for interfaces and virtual interfaces\n(likewise neighbors and virtual neighbors), most of the traps have a \"virtual\" counter-\npart. There are traps to indicate interface state changes (ospf if statechange and\nospfvirtifstatechange); neighbor state changes (ospfNbrStateChange and\nospfvirtNbrstateChange); configuration errors, such as mismatches in timer settings\n(ospf ifConf igError and ospfvirtifconfigError); OSPF packet authentication\nfailures (ospf if AuthFailure and ospfvirtif AuthFailure); reception of improp-\nerly formatted OSPF packets (ospf If RxBadPacket and ospf Virtlf RxBadPacket);\nand retransmission of LSAs during flooding (ospf TxRetransmit and\nospfvirtTxRetransmit). There are also traps to indicate (re)origination of LSAs\n(ospfOriginateLsa), LSAs that naturally age out and are flushed from the rout-\ning domain (ospf MaxAgeLsa), and LSAs that the current number of AS-external-\nLSAs in the link-state database are close to or at the configured maximum\n(ospf LsdbApproachingOverf low and ospf LsdbOverf low; see Section 7.5).\n11.3 Configuring OSPF\nWe have seen that OSPF has many configuration parameters. However, that does not\nnecessarily mean that OSPF is difficult to configure. Most of the parameters can be left\nat their default values. In a basic configuration, OSPF is as simple to configure as RIP:\nYou enable the OSPF protocol and specify which router interfaces you want to run OSPF\non. Some OSPF implementations will also require you to specify the OSPF area to which\neach interface connects, although most implementations will default to the backbone\nOSPF area (Area ID 0.0.0.0).\nThe one additional item that you probably always want to configure is the router's\nOSPF Router ID. If that is left unspecified, most OSPF implementations will set the\nRouter ID to one of the router's interface IP addresses. However, this is problematic:\nWhen that interface is deleted or, in some implementations, even if the interface is dis-\nabled, the router's Router ID is forced to change. A change in Router ID requires that the\nrouter's OSPF software be restarted, which will cause small service disruptions as the\nrouter's link-state database and routing table are rebuilt.\nAs mentioned, SNMP is the common frame of reference for configuring routers. But\nnot all routers are configured using SNMP. As an example, suppose that we want to\nenable a basic OSPF configuration on a router with three interfaces: an Ethernet inter-\nface with an address of 10.1.2.4 (mask 255.255.255.0) and two point-to-point links with\naddresses of 10.2.6.1 and 10.2.6.5, respectively. We also want to explicitly give the router",
        "0dc535c7-6638-4afe-9efb-816f9687bc2e": "Section 11.3 Configuring OSPF 223\nan OSPF Router ID of 10.10.0.4, which is an address that has been assigned to the\nrouter's loopback interface. To configure the router through SNMP, we would use the\nSNMP sets pictured in Figure 11.7.\nFigure 11.7 Basic OSPF configuration, using SNMP.\nTo enable the same configuration on GATED, the syntax in Figure 11.8 is used.\nGATED is a routing daemon for UNIX workstations; its configuration resides on a disk\nfile that you manipulate with a text editor. In the example, we have explicitly assigned\nthe Router ID; if we had not, GATED would instead select one of the IP interface ad-\ndresses to serve as Router ID, using the following order of preference: first addresses\n(other than the 127.0.0.1 address) assigned to the loopback interfaces, then addresses\nassigned to LAN interfaces, and finally addresses assigned to point-to-point interfaces.\nIn addition, in one of the quirks of the UNIX networking code, point-to-point interfaces\nare referred to by the IP address of the neighboring router (assumed to be 10.2.6.2 and\n10.2.6.6 in our example).\nFigure 11.8 Basic OSPF configuration, GATED syntax.\nTo enable the basic configuration on a Cisco router, the commands in Figure 11.9\nwould be typed on the router console or downloaded into the router. Like GATED, the\nCisco router uses one of the IP interface addresses as Router ID. However, the loopback\naddress always takes precedence and can therefore be used to explicitly set the Router\nID. In the Cisco router, each routing protocol runs as a separate process, and you must",
        "cb6ab055-78d6-452d-8c16-dcbecb1234af": "224 OSPF Management Chapter 11\nspecify the process ID when enabling the protocol. The network command pictured in\nFigure 11.9 enables OSPF on all interfaces with prefix 10/8, attaching them to the back-\nbone OSPF area (Area ID 0.0.0.0).\nFigure 11.9 Basic OSPF configuration, Cisco router syntax.\nThe basic configuration is all that you are required to perform in order to get OSPF\nup and running. Note that we did not set the OSPF interface type (ospf if Type)\u2014the\nrouter will figure this out by itself, setting the Ethernet's type to broadcast and the PPP\nlinks to point-to-point. There are, however, some additional parameters that you may\nwant to tune eventually. The first is the link cost (ospf ifMetricValue), which controls\nthe way data traffic is forwarded through your network\u2014which links should be pre-\nferred, which should be avoided, and so on (see Section 11.3.1). If your routing domain\nwill grow very large, you may want to split it into OSPF areas (see Section 11.3.2). Other\nparameters that you may want to set include the following.\n\u2022 You may want to secure your OSPF routing against intruders, by enabling the\nauthentication of OSPF packet exchanges (see Section 11.7).\n\u2022 On nonbroadcast networks, such as Frame Relay, ATM, and X.25 subnets,\nyou have to choose whether NBMA mode or Point-to-MultiPoint mode is\nmost appropriate (see Sections 5.3 and 5.4). In addition, routers attached to\nnonbroadcast networks may not be able to discover their neighbors auto-\nmatically, and neighboring routers may have to be configured instead\n(ospf NbrTable). If you are using NBMA mode, a certain small subset of the\nattached routers should be configured as eligible to become Designated Router.\nNeighbors need be configured only in these eligible routers, although the\nRouter Priority of each neighbor must also be configured in this case.\n\u2022 You may also be running other routing protocols in your network\u2014RIP to your\nedge routers, BGP on your Internet connections, and so on. In these cases, you\nwill want to exchange routing information between OSPF and these other\nprotocols. These routing exchanges most often need to be configured (see\nSection 11.6).",
        "5870a6c5-c628-4cf8-8822-39fb902b18a0": "Section 11.3 Configuring OSPF 225\n11.3.1 Configuring Link Costs\nEach router interface within an OSPF network is assigned a cost, ranging in value from\n1 to 65,535. The cost of any path within the OSPF routing domain is then calculated as\nthe sum of interface costs along the path. IP packets flow along the path having the least\ncost. When multiple shortest paths exist between the packets' source and destination,\nrouters may split the load across the multiple paths. Thus cost represents the desirabil-\nity of using the interface for data traffic; the smaller the cost, the more likely that data\ntraffic will be transmitted out the interface. In particular, if there are multiple parallel\nlinks between a pair of OSPF routers, traffic will load share between the two links if they\nhave equal OSPF cost; otherwise the link with the higher cost will serve as a hot\nstandby.\nAll routers have defaults for OSPF cost, although default values typically vary\nbased on manufacturer. Many set the default cost to 1, matching RIP's metric and result-\ning in minimum hop routing. Others set the default cost to that specified in the OSPF\nMIB, a value proportional to the link's transmission delay. Note that if you mix router\nmanufacturers with different defaults, your routing will still work\u2014that is, packets\nwill be delivered along loop-free paths. However, the paths may very well be subopti-\nmal, leading you to choose one default (or a whole different cost scheme) over the\nother.\nSelecting a cost scheme is up to the routing domain's administrator. Be-\nsides the two common defaults mentioned previously, other cost schemes include the\nfollowing.\n\u2022 Weighted hop count. You may want to use small integers as costs but make some\nlink costs higher than others to bias the routing away from pure hop count.\nFor example, you may have the rule that one Tl hop is equal to three T3 hops,\nin which case you might set the cost of Tl links to 3 and leave the T3 links at\ncost 1.\n\u2022 Delay. You may want to set the cost of each link to the delay that a packet would\nexperience when transmitted over the link. This delay is typically dominated by\npropagation delay instead of the transmission delay used by default in the\nOSPF MIB.\n\u2022 Reverse engineering the link costs based on a measured or expected traffic matrix. If\nyou know the amount of traffic, indexed by source and destination, that your\nnetwork will carry, you can attempt to set link costs to keep the traffic load on\nall links at acceptable levels. This is a subproblem of the network design prob-\nlem, which would tell you which links to provision in the first place [20].\nFor more information on setting OSPF interface costs, see Chapter 8.",
        "2dc0f606-cd58-42c0-8f8e-4bf2f7ab67ac": "226 OSPF Management Chapter 11\n11.3.2 Configuring OSPF Areas\nWhen your OSPF routing domain grows large, you may have to split the domain into\nOSPF areas. OSPF areas reduce the resource demands that OSPF puts on routers and\nlinks. In particular, the use of OSPF areas reduces the router CPU usage by the OSPF\nrouting calculation, since the calculation is performed on each area separately, with a\ncost of O(/ * log(n)), where / is the number of links (that is, router interfaces) in the area,\nand n is the number of routers in the area. Also, it reduces the amount of memory that\nthe router has to use for its link-state databases, since the size of each area's database is\nusually proportional to the number of links in the area. In those cases in which the size\nof the link-state database is dominated by the number of external routes imported into\nthe OSPF domain (that is, AS-external-LSAs), routers with limited resources can be rele-\ngated to OSPF stub areas or NSSAs, which omit external routes and instead rely mostly\non default routing (see Sections 6.3, 7.2, and 7.4).\nAlthough areas can reduce resource requirements, they should not be overused.\nAreas reduce resource requirements by hiding information, but any time you hide infor-\nmation, you potentially create suboptimal data paths (see Section 6.1). Areas also com-\nplicate the task of configuring an OSPF routing domain.\nEach IP subnet belongs to one, and only one, OSPF area. A router, on the other\nhand, may belong to multiple areas: the areas to which the router's interfaces directly\nconnect. Each router interface is configured with the Area ID of the attached subnet\n(ospf if Areaid). Routers belonging to multiple areas are called area border routers.\nAll other area configuration is isolated to the area border routers only.\n\u2022 Area summarization. You can further reduce the size of link-state databases by\naggregating routes at area boundaries. This is configured by writing entries in\nthe ospf AreaAggregateTable of the appropriate area border routers.\nCertain networks can also be hidden from other areas by setting their range's\nospfAreaAggregateEf feet variable to doNotAdvertiseMatching.\n\u2022 Default routes. The cost of the default route advertised by area border routers\ninto stub areas and NSSAs must be configured by writing entries in the\nospfStubAreaTable.\n\u2022 Virtual links. OSPF requires that all nonbackbone areas connect directly to the\nbackbone (Area ID 0.0.0.0) area. When the area configuration violates this rule,\nvirtual links must be configured through certain nonbackbone areas. Virtual\nlinks are configured by writing entries in the ospfvirtifTable of the area bor-\nder routers at both ends of the virtual link. When and where to configure virtual\nlinks is probably the most complicated configuration task in OSPF. Virtual links\nare explained further in Section 6.1.2.\nWhen designing area boundaries, one should think ahead, keeping future network\ngrowth in mind. Changing the area to which a particular network segment belongs is\ndifficult to do in an incremental fashion. All routers connected to the segment must be",
        "167664b7-6fde-4e26-a8d0-4a8e1ca7bb34": "Section 11.3 Configuring OSPF 227\nreconfigured; until then, some routers on the segment will refuse the protocol packets of\nothers, complaining of \"wrong area.\" The safest way to perform such a transition is to\nallocate a second IP subnet to the segment, running OSPF on both subnets. Then, as the\nfirst subnet is undergoing transition, the second subnet's adjacencies will be used to\nmaintain data forwarding across the segment. For more information on configuring\nareas, consult Chapter 8.\n11.3.3 Configuring Timers\nOSPF has a number of configurable timer values, which can be used to tune the neigh-\nbor discovery and maintenance procedures and the flooding process. These timers\nshould almost always be left at their default values, which are given in Table 11.1.\nTable 11.1 Default Timer Values in OSPF\nTimer\nospf If Trans itDelay\nospf IfRetransInterval\nospf If Hellolnterval\nospf If RtrDeadlnterval\nospflfPollIntervalDefault Value (seconds)\n1\n5\n10\n40\n120\nAn OSPF router periodically sends OSPF Hello packets out each of its interfaces at\nthe rate of once every ospf if Hellolnterval seconds. On very low-speed links, you\nmay want to increase the interval between Hello packets so as to use less link band-\nwidth for control packets. Hello packets also serve as a method of last resort to detect\nwhen a neighboring router has failed, although usually the failure is detected much\nmore quickly by the data-link protocol (for example, PPP's link-quality monitoring).\nWhen no Hello packet has been received from the neighbor for ospf RtrDeadlnterval,\nthe neighbor is declared inoperational. To ensure that a couple of lost Hello packets do\nnot incorrectly cause a neighbor to be declared inoperational, ospf RtrDeadlnterval\nshould always be several times the ospf if Hellolnterval. If the OSPF Hello protocol is\nthe only mechanism for detecting failed neighbors, you may want to reduce the values\nof ospf RtrDeadlnterval and ospf if Hellolnterval in order to detect the failure more\nquickly.\nThe ospf if Hellolnterval and ospf RtrDeadlnterval variables must be set iden-\ntically in all router interfaces attached to a common IP subnet. Changing these values\non a subnet is similar to changing the subnet's Area ID (see Section 11.3.2); in order to",
        "b7955461-ccba-48a4-b6dd-ccb1babee16c": "228 OSPF Management Chapter 11\navoid service interruptions, a second subnet must be configured on the link during the\ntransition from one set of timer values to another.\nOn NBMA subnets (see Section 5.3), routers periodically send Hello packets to inop-\nerational neighbors, in an attempt to detect when a neighbor comes back into service.\nThis polling is performed once every ospf if Pollinterval seconds, which is typically\nlarger than ospf if Hellointerval in order to avoid wasting network bandwidth.\nThe time it takes to transmit an LSA to neighbors on the interface is represented by\nospf ifTransitDelay. This value must be greater than 0, and is added to the LS Age\nfield of all LSAs flooded out the interface. This value should not be set to unreasonably\nlarge values (for example, a value near 900 seconds), or the OSPF flooding process will\nfail. The variable ospf if Retransinterval is the length of time before unacknowledged\nLSAs (and also Database Description packets and Link State Request packets) will\nbe retransmitted to the neighbor. This value should be larger than the round-trip time\nto the neighbor and back, or needless retransmissions will ensue. The variable\nospf IfRetransInterval may need to be increased on low-speed and/or satellite links.\n11.4 An Example: The Arkansas Public School Computer Network\nIn this section, we illustrate the configuration of an OSPF routing domain, using the\nArkansas Public School Computer Network (APSCN) as an example. The APSCN,\nwhich interconnects all the public schools in the state of Arkansas, is used for adminis-\ntrative purposes, such as collection of financial and student data, using TELNET-based\napplications. APSCN also provides Internet connections for all of the Arkansas school\ndistricts. Using the Internet, Arkansas students can interact with other students around\nthe world. For example, students participate in environmental surveys in order to study\nworldwide weather patterns.\nAPSCN is an IP network that runs OSPF as its routing protocol. The configuration\nof APSCN's OSPF routing is pictured in Figure 11.10. To date, 778 routers are running\nOSPF, organized into 20 OSPF areas (one backbone area and 19 nonbackbone areas). The\nbackbone OSPF area consists of 4 hub routers (labeled H1-H4) connected by an Ethernet\nsegment. Hub router H4 is also attached to a Token Ring segment that provides a con-\nnection to an Internet Service Provider. H4 has a static default route pointing at the\nISP's router. H4 also imports this static default into the OSPF routing domain in an\nAS-external-LSA with a Type 2 external metric of 1.\nEach hub router attaches to 4-5 nonbackbone OSPF areas. Each of these areas has\n30-70 routers. All of the areas have a similar topology, pictured in the bottom half of Fig-\nure 11.10. Each area connects a number of \"district routers\" (labeled D1-D7) with local\nEthernet segments into a single regional or cooperative site. A minicomputer at the\ncooperative site (labeled SI) collects administrative data entered by the districts. Each\ndistrict is also connected to the hub router, which provides Internet connectivity and",
        "90cb2eaa-3ee4-4f7d-a322-f2c2ef30520d": "Section 11.4 An Example: The Arkansas Public School Computer Network 229\nFigure 11.10 The Arkansas Public School Computer Network (APSCN).",
        "e5054df0-5af9-4dfe-a5b0-0fb31e94874e": "230 OSPF Management Chapter 11\nbackup servers for data collection (labeled S2). Interconnection of the district, coopera-\ntive, and hub sites is provided by Frame Relay PVCs.\nThe collection of PVCs in a single area is configured as a single IP subnet, using\nthe OSPF Point-to-MultiPoint subnet support. Each router has a single OSPF Point-to-\nMultiPoint interface to the subnet, with a cost of 1. As a result, data traffic is forwarded\nover the path consisting of the fewest number of PVC hops; a district router forwards\nInternet traffic directly to its hub router and administrative traffic directly to its\ncooperative router. All OSPF timer values have been left set to their default values\n(Table 11.1).\nAPSCN discovered that it was taking too long for its routers to discover Point-to-\nMultiPoint neighbors using Inverse ARP. To speed up neighbor discovery, neighbors are\nconfigured but only in the downstream end of each neighbor pair. District routers have\nthe identity of their cooperative and hub routers configured, and the cooperative rout-\ners have the identity of their hub router configured.\nAll of APSCN's IP addresses are taken from two Class B networks. Each area is\nassigned pieces from one or the other Class B address, with the area's hub router aggre-\ngating these pieces into a single route for advertisement into the backbone and other\nareas. For example, in one area, there are 31 LAN segments, each of which has been\nassigned a prefix ranging in size from a /28 to a /24. At the area border, the hub router\naggregates all 31 prefixes into a single advertisement for a prefix of length 20 bits\n(a /20). This procedure reduces the size of the routing table within APSCN's routers.\nRouters at the district and cooperative levels have routing tables of 300 entries, whereas\nthe hub routers have routing tables of 700 entries.\nHub routers can have as many as five separate OSPF Point-to-MultiPoint interfaces,\neach belonging to a separate area. These interfaces are multiplexed over two separate Tl\nlinks into the Frame Relay cloud. Each Point-to-MultiPoint interface on the hub router\nsupports 30-70 OSPF neighbors (and hence OSPF adjacencies); a hub router may there-\nfore have more than 200 OSPF adjacencies.\n11.5 Monitoring the OSPF Protocol\nUsually a network administrator does not continually monitor the routing protocols\nused in the network. When the routing protocols are doing their job correctly, they are\nalmost invisible. However, sometimes routing breaks down. This is probably first\nbrought to the administrator's attention by a call from an irate customer or maybe\nbecause of red icons appearing on the network management console. The network\nadministrator then isolates the problem, using such diagnostic tools as ping and\ntraceroute (see Chapter 12, Debugging Routing Problems). The administrator may\ndetermine that the outage is due to a physical problem, such as a dead telephone circuit.\nHowever, if no physical problems are found, the administrator has to start looking at the\nrouting protocols.",
        "d3e50ee4-c947-4b73-8473-66cb14a16d00": "Section 11.5 Monitoring the OSPF Protocol 231\nSynchronization Problems\nThe first thing to determine when diagnosing an OSPF routing system is whether the\nrouters' link-state databases are synchronized. If they are not, OSPF will not function\nproperly. It is difficult to compare two routers' link-state databases one LSA at a time;\nthere can be thousands of LSAs in the database, and the database changes often. But\nthe OSPF MIB provides a database checksum (ospfAreaLsaCksumSum for an area's\nlink-state database and ospfExternLsaCksumSum for AS-external-LSAs) that lets you\ncompare router databases by checking a single number. Using these variables, it is a\nsimple task to write an SNMP application that displays, in a single window, the data-\nbase checksums of all routers, allowing you to verify synchronization networkwide at a\nsingle glance (see Section 3.4). This assumes that you still have SNMP connectivity to\nyour routers; if not, you will need to look at the management variables via more cum-\nbersome out-of-band management schemes, such as dial-up modems connected to the\nrouter consoles.\nIf the databases are not synchronized, you probably want to isolate the problem fur-\nther. Look at the ospf NbrTable in one of the routers that is not synchronized with its\nneighbors. You will probably find that the router (or its neighbor or both) is continually\ntrying to retransmit LSAs to the neighbor, detected by ospfNbrLsRetransQLen remain-\ning nonzero. Continual retransmissions can be due to MTU mismatches between the\ntwo routers or to bugs in the routers' OSPF software. If possible, you should obtain cop-\nies of the LSAs being retransmitted, so you can send the information to your router ven-\ndor(s) for later analysis. This could be done by capturing the transmitted Link State\nUpdate packets on a network analyzer. Even if there are no retransmissions, com-\nparing the two routers' link-state databases one LSA at a time (ospf LsdbTable and\nospfExtLsdbTable) can provide valuable information, possibly indicating bugs in\nthe initial database synchronization (see Section 4.7.1). In any case, restarting the associ-\nated router interface (setting ospfifAdminstat to disabled, then back to enabled) will\nmost likely restore synchronization by forcing the two routers to undergo initial data-\nbase synchronization again.\nChecking Database Contents\nIf databases are synchronized, you have to start looking at the OSPF database to see that\nthe required links (or inter-area routes or external routes) are being advertised. This\nrequires looking at the contents of individual LSAs, something that most OSPF imple-\nmentations help you to do by intelligently formatting the LSAs' displays. The nice thing\nis that this examination can be done at any router\u2014they all have the same database. In\nfact, I have sometimes debugged networks by attaching special routers whose OSPF\nimplementations are instrumented with sophisticated searching and event-monitoring\ncapabilities.",
        "bd86b24f-8eb4-447c-a08e-e15433cf30f7": "232 OSPF Management Chapter 11\nOSPF requires that initial database synchronization be performed over a link (that\nis, an adjacency form) before the link can be included in the database (see Section 4.7).\nYou can tell that a router is having difficulty establishing adjacencies with some of its\nneighbors by looking at the router's ospfMbrstate variables; values consistently other\nthan twoWay and full indicate problems such as\n\u2022 Physical problems. If the link's error rate is too large, the routers attached to the\nlink disagree on the link's MTU, or a broadcast link's multicast services fail, an\nadjacency may fail to form. For example, if a given neighbor's ospfwbrstate\nreads consistently as init, the router can receive from, but not transmit packets\nto, the neighbor (that is, it is a one-way link).\n\u2022 Configuration problems. If routers attached to the link disagree on the link's Area\nID (see Section 11.3.2), the link's Hello protocol timers (Section 11.3.3), or the\nlink's authentication type or keys (Section 11.7), adjacencies will fail to form.\n\u2022 Implementation bugs. Problems in vendor implementations may prevent adjacen-\ncies from forming.\nOther Issues\nIf databases are synchronized and their contents are correct, a router has incorrectly run\nthe routing calculation or has failed to rerun the calculation when LSAs have changed.\nThe guilty router can be found via traceroute. Then, by changing the cost of one of\nthat router's interfaces, you can force the router to rerun its routing calculation and,\nideally, fix the problem.\nNetwork performance problems may also be detected when monitoring OSPF\nrouters. For example, if ospf Spf Runs increases too quickly, a router may be perform-\ning routing calculations (and therefore consuming CPU cycles) unnecessarily. Or\nparticular LSAs that change very often may indicate flapping links (links that go\nup and down very frequently). Very long retransmission queue lengths on a link\n(ospfNbrLsRetransQLen) may indicate that the speed of the link is too low for its com-\nbined data and control traffic demands.\nIf you enable SNMP traps on your network, some of the preceding information\nmay be reported automatically by your routers. For example, a router sends an\nospfNbrStateChange trap when an attempt to form an adjacency with a neighbor fails,\nan ospf if conf igError trap when certain misconfigurations are detected, and an\nospf TxRetransmit trap to indicate that an LSA is being retransmitted. However, many\nadministrators do not like SNMP traps, for fear that the traps themselves will consume\ntoo much network bandwidth. Another possibility for asynchronous notification of\nevents is through the logging facilities (for example, UNIX syslog or printing events\nto the router console) that many routers provide.",
        "ac5a9572-36de-49ad-955b-4242ffbebff6": "Section 11.6 Interactions with Other Routing Protocols 233\n11.6 Interactions with Other Routing Protocols\nAs we describe in Section 13.7, there are few rules about the interaction of TCP/IP\nrouting protocols. However, the interaction between OSPF and BGP has been de-\nscribed in an RFC, and although not formally documented, there are several simple\npossibilities when running OSPF and RIP simultaneously. These interactions are de-\nscribed next.\n11.6.1 OSPF/BGP Interaction\nThe interaction between the BGP and OSPF protocols is specified in [252], which also\nspecifies the interaction between IDRP (Inter-Domain Routing Protocol) and OSPF.\nIDRP is the ISO-customized version of BGP that was expected at one time to replace\nBGP in the Internet, but so far this replacement has not occurred. The document is writ-\nten for implementors, specifying required controls on the exchange of routing informa-\ntion between BGP and OSPF.\nThe assumed environment is an AS running OSPF and exchanging BGP routes with\nother ASs. An example is shown in Figure 11.11. According to [252], no routes should be\nexchanged by default between BGP and OSPF; however, the network administrator\nmust be able to configure the exact set of destination prefixes readvertised from OSPF to\nBGP (and vice versa). When readvertising an OSPF-learned prefix into BGP, you must\nbe able to configure the BGP multiexit discriminator (sort of the BGP metric). When\nreadvertising a BGP-learned prefix into OSPF, you must be able to configure whether\nit is advertised as a Type 1 or 2 external metric and the OSPF external cost.\nAS 1 (OSPF)\nAS 2ASS\nAS 4\nFigure 11.11 A sample BGP/OSPF environment.\nThose were the generic rules, which could also be paraphrased as, \"You have to be\nable to configure everything.\" However, the document goes on to describe some more\nuseful things that you might want to do. When readvertising OSPF-learned routes into",
        "2c7ef212-e10e-41c9-802b-a8a94b192db9": "234 OSPF Management Chapter 11\nBGP, you might just want to specify, \"Readvertise all internal, that is, intra-area and\ninter-area, OSPF routes.\" In addition, you might want to readvertise all OSPF external\nroutes with a particular external route tag (Section 6.2), or with tags matching a particu-\nlar pattern.\nConversely the document notes that when readvertising BGP information into\nOSPF, instead of readvertising specific routes, you may want to conditionally advertise\na default route into the OSPF domain. For example, in Figure 11.11, suppose that the\ncore of the Internet is reached through AS 2. When router C exchanges BGP information\nwith router A from AS 2, router C can tell that AS 2 is connected to the Internet core by\nthe presence of a particular destination and with a particular AS path, received in BGP\nupdates from router A. If, and only if, this destination is received will router C advertise\na default route into AS 1's OSPF system. The origin of this behavior goes all the way\nback to the Fuzzball routers in the original NSFNET [161], which used the presence of\nnetwork 10 (the ARPANET'S network number, which at that time was the Internet core)\nin routing updates as an indication of default route. The document also declares that\neach AS boundary router is responsible for readvertising the information learned\nfrom its external BGP peers; readvertising information learned via IBGP into OSPF is\nforbidden.\nAs explained in the document, both BGP and OSPF allow you to advertise \"third-\nparty information.\" In BGP, this is called the \"BGP next hop.\" In OSPF, this is called the\n\"forwarding address\" (Section 6.2). As an example, suppose that routers A and C in Fig-\nure 11.11 are BGP peers but that routers A and B are not. The internal OSPF network\n192.9.2/24 would be readvertised in C's BGP updates to A, using router B as BGP next\nhop. This avoids an extra hop for data traffic entering the OSPF system destined for\n192.9.2/24. Conversely BGP information learned from A would be readvertised by C\ninto the OSPF system using A as forwarding address, avoiding extra hops for data traf-\nfic sourced by 192.9.2/24 and exiting the OSPF system toward the Internet core.\nHowever, the main part of the document is a description of how to use OSPF to\ntransport BGP information across the OSPF routing domain, removing the necessity of\nrunning IBGP in some circumstances. This is the subject of the next section.\nUsing OSPF to Replace IBGP\nIn its routing updates, BGP advertises an AS path with each destination. The AS path\nlists the sequence of ASs that must be traversed before reaching the destination\u2014in\nessence, a source route. The AS path is used first for loop prevention. On receiving a\nBGP update, a router rejects all destinations with the router's own AS in the AS path; to\naccept any destination would form a routing loop. The AS path is also used to make pol-\nicy decisions. Typically network administrators accept or reject updates based on the\npresence of certain ASs (or patterns of ASs) in the AS path.\nIt is important to maintain this AS path information as BGP updates are advertised\nfrom one BGP router to another. This is why you cannot in general readvertise BGP",
        "ad352e42-79f6-4006-b94a-7fe431fe40e2": "Section 11.6 Interactions with Other Routing Protocols 235\ninformation into your IGP at one side of your AS and then readvertise the IGP informa-\ntion back into BGP at the other side: The IGP cannot carry full path information. For this\nreason, IBGP was invented. You run IBGP internal to your AS to communicate AS paths,\nin addition to your IGP.\nHowever, OSPF associates a 32-bit external route tag with each destination. This tag\ncan be used to carry additional information across an OSPF AS. In particular, there is\nenough information to carry the BGP origin (IGP or EGP; see Section 13.3) and an AS\npath of length 1 within the OSPF Tag field. The formats used in the Tag field for this pur-\npose are defined in [252]. In particular, use of the OSPF Tag field in this way allows you\nto get rid of IBGP in networks such as the one in Figure 11.11. ASs 3 and 4 are stubs,\nconnected only through the Internet through AS 1. Their routing information can be\nreadvertised into AS 1's OSPF routing and tagged with AS 3 or 4, respectively. When\nreadvertised back into BGP by router C, the proper AS path (terminating at either AS 3\nor 4) can then be reconstructed. Similarly router C can advertise a default route into the\nOSPF AS, which can then be readvertised by BGP into ASs 3 and 4.\nSometimes a destination will be advertised both in OSPF AS-external-LSAs and in\nIBGP updates. In this case, it is the OSPF-external-LSA that will dictate the path that\ndata traffic will take to the destination. In order to find the IBGP information (that is, the\nAS path) that matches the route indicated by the AS-external-LSA, [252] requires that\nrouters running both BGP and OSPF set their BGP Identifier and OSPF Router ID to the\nsame value. In a related issue, if OSPF's multipath logic chooses multiple exits from the\nAS toward the destination, the AS paths associated with these exits must be combined\nto form an AS set (as in BGP aggregation, see Section 13.3) before the destination is\nadvertised to an external BGP peer. Failure to do so can result in routing loops, as\ndescribed in the appendix to [252].\nBy using the external-attributes-LSA (Section 7.6), you can carry the entire AS path\nin OSPF LSAs, in theory replacing IBGP regardless of AS path length. However, this\nsolution has never been deployed.\n11.6.2 OSPF/RIP Interaction\nIn this section, we discuss interactions between RIP and OSPF. The original definition of\nan Autonomous System was a collection of routers, all running a common IGP. How-\never, over the years, this definition has been liberalized to be \"a set of routers all under a\ncommon administration.\" It is now quite common to run both OSPF and RIP in a single\nAS. Also, as ASs gradually transition from RIP to OSPF, the interactions between the\ntwo protocols must be addressed.\nThe two types of OSPF external metrics, Type 1 external metrics and Type 2 exter-\nnals, allow for two entirely different strategies, neither requiring metric translation or\nhand-configured routing filters. We illustrate these two methods by using the network",
        "64655093-1dfb-4395-874d-0225d075b505": "236 OSPF Management Chapter 11\nin Figure 11.11, which you should now think of as a central OSPF routing domain\n(region 1) gluing together three isolated regions (2, 3, and 4) running RIP.\nIn the first method, we try to make the combined OSPF and RIP AS look like a\ncoherent whole, attempting a seamless integration of RIP and OSPF and calculating\npaths based on least-hop count. The OSPF metric of each interface is assigned to be 1.\nWhen a RIP route of cost x is learned at the edge of the OSPF routing domain, it is re-\nadvertised (or imported) into the OSPF domain as a Type 1 external route of cost x. At\nthe other side of the AS, n hops away from the OSPF router that imported the original\nRIP route, the route is readvertised into RIP with a cost of x + n. This method does not\nquite give you least-hop routing, because OSPF insists on keeping its routing domain\nconvex: The path between any two OSPF routers is forced to remain within the OSPF\nrouting domain, even if there is a shorter hop-count path that exits and reenters the\nOSPF domain (that is, OSPF->RIP->OSPF). Convexity is a useful property when\ndeploying new features in the OSPF routing domain and is a requirement for deploy-\nment of so-called protocol-independent multicast schemes, such as PIM (see Sections\n14.4 and 14.5).\nThe disadvantage of this scheme is, of course, the hop-count metric. Hop count is\nnot very descriptive (see Section 11.3.1), and RIP limits the diameter of the resulting AS\nto 16 (Section 13.1).\nIn the second method, we treat the entire OSPF routing domain as a single RIP hop.\nThis method allows you to use a different routing metric, say, delay, inside the OSPF\nrouting domain. And it allows you to circumvent RIP's diameter-16 limitation, some-\nthing that could previously be done only with risky metric translation. This method\nemploys OSPF Type 2 external metrics. When a RIP route of cost x is learned at one side\nof the OSPF routing domain, it is readvertised into OSPF as an AS external Type 2 route\nof cost x. Then, at the other side of the RIP domain, it is readvertised back into RIP with\na cost of x + 1. Another way to think about this is to consider the OSPF routing domain\nas \"one big router\" within the collection of RIP routers.\n11.7 OSPF Security\nThe idea behind OSPF's security mechanisms is to prevent the OSPF routing domain\nfrom being attacked by unauthorized routers. For example, a misconfigured router or\na router operated by parties with malicious intent may try to join the OSPF routing\ndomain and advertise false information in its OSPF LSAs. Or someone may gain physi-\ncal access to one of the network segments and intentionally modify OSPF routing infor-\nmation as it flows across the segment. Or that same party may record OSPF protocol\npackets and replay them at a later time when those same packets would disrupt estab-\nlished OSPF conversations. OSPF's cryptographic authentication is designed to prevent\nthese kinds of attacks.",
        "4a302145-1027-409a-b7d2-3f11ef844d8e": "Section 11.7 OSPF Security 237\n11.7.1 OSPF Cryptographic Authentication\nThe idea behind OSPF's cryptographic authentication is simple. All OSPF routers con-\nnected to a common network segment share a secret key. When transmitting an OSPF\npacket onto the segment, an OSPF router signs the packet using the key. This signing is\nperformed in such a way that, if the packet is intercepted by a hostile party, the key can-\nnot be recovered. However, on receiving the packet, legitimate routers easily can deter-\nmine whether the signature is valid, and a valid signature implies both that the sending\nrouter is trusted (that is, the sending router has the key) and that the OSPF packet has\nnot been altered.\nFigure 11.12 shows the packet-signing process. An OSPF packet has been built, both\nheader and body, and is ready to be sent onto a given network segment. The sending\nrouter picks the primary key for the attached network segment. This key is identified by\nan 8-bit Key ID and specifies a cryptographic hash algorithm and a shared secret. (Key\nIDs have only per segment scope; a key with Key ID of 5 on segment 10.1.1.0/24 is dif-\nferent from the key with Key ID of 5 on segment 10.1.2.0/24). The Key ID is then\ninserted into the OSPF packet header. The cryptographic hash function will produce a\nhash value of some fixed length; the length of the hash in bytes is also inserted in the\nOSPF header. Finally, a 32-bit cryptographic sequence number is inserted into the OSPF\nheader for replay protection. The sequence number in the current packet must always\nbe greater than or equal to the sequence number used in the previous packet sent out\nonto the segment; using a value such as \"seconds since the router was booted\" is\nsufficient.\nThe secret is then appended to the packet, and the cryptographic hash algorithm\nis run, using the combination packet and secret as input. The hash algorithm pro-\nduces an output hash of fixed length, which is then written over the secret at the end\nof the packet. The packet and appended hash are then transmitted onto the network\nsegment.\nIn particular, Figure 11.12 shows this process when a key with Key ID of 5, using\nMD5 as the hash algorithm. Following the procedure specified in [216], a 16-byte secret\nis appended to the OSPF packets and then is overwritten by the 16-byte MD5 crypto-\ngraphic hash (or message signature).\nMD5 is the only cryptographic hash algorithm that is completely specified by the\nOSPF specification, although other cryptographic hash algorithms may be used. A good\ncryptographic hash has the following one-way property: It is easy to find the hash for\nany particular input but difficult to find two inputs that hash to the same value. For\nOSPF's application of hash functions, this means that it is difficult for an attacker to\nmodify the OSPF packet without the receiver's detecting the modification (see Sec-\ntion 11.7.2). In addition, since OSPF's hash includes a secret key in its input, it is hoped\nthat a good hash function will prevent an attacker from generating a false packet:\nNot knowing the secret key, the attacker cannot figure out the correct hash value to\nappend to the false packet.",
        "71a1d6d4-0057-44be-8809-2f5521fd6264": "238 OSPF Management Chapter 11\nFigure 11.12 Message generation when performing OSPF cryptographic authentication.\nUnfortunately it is very difficult to prove the security of various algorithms. In addi-\ntion, although some algorithms may be secure, the way in which they are used (called a\nsecurity protocol) may be insecure. MD5 has been popular in the Internet community due\nto the relative speed of generating MD5 hashes. However, some progress has been made\nin attacking MD5 [225], and so other hash algorithms, such as SHA [182], may be more\nappropriate. In addition, the security of the security protocol, namely, simply append-\ning the secret to the packet before hashing, has been called into doubt [121], leading to\nthe development of the HMAC construction [185].",
        "d45bb600-f55a-4083-a4cd-2b6065df5f96": "Section 11.7 OSPF Security 239\n11.7.2 Message Verification\nAn OSPF router running cryptographic authentication on one of its interfaces verifies all\npackets received on the interface. Verification proceeds as follows. The OSPF header\nand packet contents have been transmitted in the clear. By looking at the Key ID in the\nOSPF header, the receiving router knows which key has been used to generate the hash\n(multiple keys are used when transitioning from one key to another; see Section 11.7.3).\nTo verify that the sending router really does know the key the receiving router stores\nthe received hash and then regenerates the hash, using its own secret key. If the regener-\nated hash does not match the received hash, the receiving router rejects the packet as\nbeing invalid.\nThe receiving router now knows that the received packet was generated by a router\nthat has the secret key. However, the packet could have been generated a while ago and\nthen resent later by an attacker to confuse the routing: a replay attack. To guard against\nthis attack, the receiving router looks at the cryptographic sequence number in the OSPF\nheader. As long as this number is greater than or equal to the last sequence number\nreceived from the sending router, the received packet is accepted as being both valid\nand up to date.\nNote in Figure 11.12 that the OSPF packet checksum is not calculated when crypto-\ngraphic authentication is in use, because the checksum is redundant in this case. The\ncryptographic hash is already guaranteeing that the packet has not been corrupted\n(either unintentionally, which is what a checksum is designed to detect, or maliciously).\nOSPF cryptographic authentication ensures that received packets have been gener-\nated by trusted routers, have not been modified, and are up to date. However, since\npackets are transmitted in the clear, OSPF cryptographic authentication does not pro-\nvide other typical security functions, such as confidentiality. For example, anyone who\ngains physical access to any single network segment can collect all OSPF packets trans-\nmitted and can build a complete network map of the OSPF routing domain. Encryption\nof OSPF data must be employed to prevent intruders from gaining this kind of data (see\nSection 11.7.4).\n11.7.3 Key Management\nThe security of OSPF's cryptographic authentication depends on the following: All of\nthe trusted routers must know the secret key, but this same key must be kept hidden\nfrom any attacker. How this property is accomplished falls under the general category\nof key management. First, the key must be chosen in a random fashion. Then the key must\nbe distributed to the trusted routers, without disclosing the key to others. Also, the key\nmust be stored in the routers so that it can be accessed after a router restart but so that it\ncannot be retrieved by an unauthorized party. All of these issues are difficult to solve,\nand none are addressed directly by the OSPF specification.",
        "23337812-9e76-4c30-9051-8a369aefb2ee": "240 OSPF Management Chapter 11\nIt is assumed that the distribution of keys for OSPF's cryptographic authentication\nwill be done either manually, through a protocol such as Diffie-Hellman, which uses\npublic-key cryptography [66], or through the standard key-management mechanisms\nbeing developed by the Internet Engineering Task Force [155].\nThe one thing that the OSPF specification does address is the changing of keys. The\nmore messages that an attacker sees signed with a particular key, the more likely it is\nthat the attacker will be able to \"break the key.\" (One commonly thinks that the attacker\nneeds to discover the secret key, but it may be possible for the attacker to learn enough\nto modify and/or originate false messages, without ever learning the key.) So in order to\nmaintain security, you want to change keys every so often. You cannot change all rout-\ners' keys simultaneously. Therefore to prevent routing disruption while keys are being\nchanged, OSPF allows for multiple keys to be active at once, identified by Key ID. The\nswitchover to a new key then goes as follows: The new key is installed router by router,\nleaving the old key in place. As soon as all routers have the new key, the old key can\nthen be deactivated.\n11.7.4 Stronger Security\nStronger security has been proposed in OSPF with Digital Signatures [179] and [249],\nalong the lines of previous link-state protocol security designs described in [190] and\n[236]. In this proposal, in addition to the authentication of packet exchanges using algo-\nrithms such as OSPF cryptographic authentication, OSPF LSAs carry signatures so that\nrouters can verify the LSAs' integrity as the LSAs are flooded through the OSPF routing\ndomain.\nWhat does this additional security gain you? The OSPF cryptographic authentica-\ntion of Section 11.7.1 already protects against attackers that gain access to a network\nsegment\u2014these attackers can neither disrupt OSPF protocol exchanges nor imper-\nsonate OSPF routers. However, the addition of signatures to LSAs even prevents\nerrors in trusted routers from corrupting LSAs [261]. For example, the OSPF spe-\ncification says that only the originator of the LSA can flush it from the routing domain.\nWith the addition of signatures to LSAs, when a router receives the directive to flush\nan LSA (that is, an LSA with Age set to MaxAge), the router can tell whether it was the\noriginator or another router that is attempting to flush the LSA and can ignore the\nlatter. Another example that happened in the ARPANET network is the following:\nA router became confused about its Router ID and started originating LSAs claiming\nto be a different router. With the addition of signatures to LSAs, this failure is also\ndetected. Signing of LSAs even allows the certification authority to indicate which net-\nwork addresses a given router is allowed to advertise (see [179], [261]).\nOSPF with Digital Signatures employs public-key cryptography. Each router has a\nprivate key and then obtains a certificate for the corresponding public key from a certifi-\ncation authority (see [225] for an explanation of key certificates). The router's public key",
        "b3201c4b-6e10-4484-a6dd-92f7e1416494": "Section 11.7 OSPF Security 241\nis then distributed, together with its certificate, throughout the routing domain, using\nstandard OSPF flooding mechanisms. When a router wishes to originate an LSA, it signs\nthe LSA, using the router's private key and the RSA algorithm [224]. As the LSA is\nflooded, the other routers can verify the LSA's integrity by using the originating router's\npublic key.\nAs with OSPF cryptographic authentication, OSPF with Digital Signatures protects\nthe routing via authentication. But it does not provide additional security functions,\nsuch as confidentiality.\nFurther Reading\nThe Simple Book [218] by Marshall Rose is an excellent introduction to SNMP and the\nmanagement of TCP/IP networks. Schneier's book Applied Cryptography [225] is an\nexcellent resource for communications security and authentication issues, including\ndetailed explanations of cryptographic hash functions, public-key cryptography, and\nkey management. A good explanation of security threats to routing protocols is [261]. A\ncompanion paper [253] describes a security attack to OSPF that exploits a common bug\nin OSPF implementations.\nExercises\n11.1 Suppose that one of the routers in Figure 5.3 has its Hellolnterval\nmisconfigured. How would you tell which router is misconfigured: by look-\ning at ospfLsdbTable? ospfNbrTable? OSPF traps?\n11.2 Suppose in Figure 11.11 that routers D and F are continually reoriginating their\nrouter-LSA. What is going on?\n11.3 Suppose that router C in Figure 11.11 is readvertising more BGP information into\nOSPF than simply a default route but that some of these AS-external-LSAs are\ncontinually getting reoriginated. What is going on?\n11.4 Describe a scenario in which the replay of old OSPF packets could disrupt current\nOSPF routing exchanges.\n11.5 Specify in detail how SHA and HMAC would be used in OSPF cryptographic\nauthentication.",
        "cecb99a2-6a96-43cf-b44d-002bf14e46fb": "Debugging Routing Problems\nNetwork administrators can be assured that their routing will break every once in a\nwhile. Internet routing is not yet a science\u2014many parts of the Internet have been glued\ntogether in a hodge-podge fashion. And sometimes the glue comes loose. Fortunately a\nnumber of tools are available to help you debug the situation.\nIn this chapter, we survey the available tools\u2014what they do, how they work, and\ntheir strengths and weaknesses. In addition to being used by network administrators,\nsome of these tools may be used by users of the network to diagnose routing problems\nbefore reporting them to their ISPs. For example, the first two tools that we examine,\nping and traceroute, are often performed by network users.\nThe tools in this chapter are specifically for diagnosing IP connectivity at the net-\nwork layer. Can an IP packet be forwarded from one place to another, and if so, what\nis the path that the packet is currently taking? If not, what is the network problem\nthat is preventing the forwarding of the packet? Different tools may be necessary to\ndiagnose connectivity at the application layer, such as problems with electronic mail\ndelivery.\nWhen IP connectivity has deliberately been hampered through the deployment of\nfirewalls (Section 1.2), some or all of the tools described in this chapter may fail. To see\nwhether a given tool will work through your firewall, you have to read the \"how it\nworks\" section for the tool and then consult the documentation provided with your fire-\nwall to see whether the firewall will permit the necessary packets to pass through.\n243",
        "49e914e1-e521-45b6-8ed9-5990bf6e53e8": "244 Debugging Routing Problems Chapter 12\nAll of the tools mentioned in this chapter are for debugging IPv4 routing. However,\nsince the routing architecture of IPv6 is so similar to IPv4 (Section 1.3), it is assumed that\nsimilar tools will eventually be available to debug IPv6 routing.\n12.1 War Stories\nMost routing problems are of the form: I can't get there from here. These are usually\npretty easy to pinpoint. A traceroute (see Section 12.5) will usually tell you which\nrouter is at fault. However, finding out what exactly is wrong with that router is some-\ntimes difficult.\nEveryone has a war story to tell. People who are involved in day-to-day operations\nof Internet Service Providers can tell many of them. I've never been a network operator,\nbut as a developer of router software, I've seen quite a few problems over the years.\nHere are some examples.\n1. \"I loaded new software and lost my Internet connection.\" The router that had been\nreloaded had a point-to-point link to our Internet Service Provider. Everything\nseemed all right, but the router never populated its routing table with the cor-\nrect number of entries. Finally, I turned on the router's logging messages and\nnoticed that the router on the other end of the connection was sending routing\npackets that exceeded my router's MTU. Apparently the point-to-point link's\nMTU had been changed in the new release.\nNote 1:1 happened to be running OSPF over the point-to-point link, which\nhas a tendency to send maximum-sized packets when initializing routing con-\nversations. This is a feature. If the routing had come up, more subtle application\nproblems would have appeared because of the MTU mismatch.\nNote 2: Had I been using a better data-link protocol, the MTU mismatches\nwould not have happened. For example, the PPP data-link protocol [232] nego-\ntiates the MTU of the point-to-point link.\n\u2022 \"The whole subnet loses its Internet connectivity.\" Someone had brought up a host\nthat had the same IP address as the subnet's default router. This was not so\nmuch a routing problem as an ARP problem. All hosts on the subnet ended up\nwith their ARP caches pointing at the host instead of to the default router.\n\u2022 \"One of my networks becomes unreachable from the outside world.\" Unfortunately\nthat network happens to have my mail server on it, so we're not getting our\nelectronic mail anymore. I could TELNET out to the Internet from another one\nof my networks, and when I did a traceroute back to the network having the\nproblem, the traceroute goes all the way to the destination. But it goes to\nanother customer of my provider, not to me! Obviously someone has hijacked\none of my network numbers. I call up my provider to complain, and the",
        "7bc1c9a5-90c9-4a89-8986-57ffbfcf9aa1": "Section 12.3 Tool Interpretation 245\nproblem is soon fixed. Undoubtedly my provider started filtering the routing\nadvertisements that it was getting from that customer (see Section 13.7).\n\"My MBONEfeed stops, and the router connecting us to the MBONE is continuously\ncrashing.\" I can tell from the router's crash dump that the MBONE routing table\nis much bigger all of a sudden. Soon that is confirmed by messages on the\nMBONE mailing list. The size of the MBONE's routing updates has grown dra-\nmatically, and the MBONE is pretty much unusable. This problem turns out to\nbe a difficult one to solve\u2014there were not many tools for debugging multicast\nrouting at the time, and the instability of the MBONE routers made it difficult to\nget any data from them. Finally, people tracked down the source of the large\nupdates (an experimental PIM-to-DVMRP translator) by dumping the mrouted\nrouting tables and following the bogus routing table entries hop by hop back to\ntheir source.\n12.2 Finding Tools for Debugging Routing Problems\nThe remainder of this chapter covers useful routing debugging tools. For each tool, we\nexplain how to use it, how it works, and its strong and weak points.\nMost of these tools are publicly available over the Internet. The most common way\nto find them is to use the search engine in your Web browser. Search engines predating\nthe Web, such as Archie, may give more concise answers when looking specifically for\nsoftware, although the Archie database is probably not as up to date as the more popu-\nlar Web search engines. For example, using Archie, I found many sites supplying ping\nsoftware; some of those sites are listed in Figure 12.1. For people who like to do every-\nthing from within their Web browsers, Archie servers with HTML interfaces can easily\nbe found.\n12.3 Tool Interpretation\nIP routing deals with IP addresses, and that is why most of the examples in this chap-\nter display IP addresses as the output of the various debugging tools. However, when\nyou are trying to track down the human who can fix the routing problem you're see-\ning, a domain name is probably more useful than an IP address. For example, when\na traceroute (Section 12.5) shows that your packets are being thrown away by the\nrouter with address 38.1.3.4, you'd rather know that the router's domain name is\nsw.sc.psi.net. That way, you could check the Web sitewww.psi.net for contact\nand outage information.\nFortunately most debugging tools do output domain names by default. The tools\nproduce domain names by performing reverse domain name lookups on the IP\naddresses that they discover. (The Domain Name System, or DNS, was originally",
        "04457966-9a78-4398-8895-68c9e319d887": "246 Debugging Routing Problems Chapter 12\nFigure 12.1 Sample of sites supplying ping software.\ndesigned to map ASCII domain names into IP addresses; the reverse mapping was\nintroduced later, using the IN-ADDR domain of the DNS [163].) There are times, how-\never, when you might want to skip the reverse domain name lookup\u2014for one thing,\nthis makes the tools run faster. For UNIX-based tools, the -n command line option usu-\nally turns off reverse domain name lookups in favor of the raw IP addresses. This is how\nmany of the figures in this chapter were produced.\nMany operating systems supply an application that performs DNS lookups. For\nexample, on UNIX, you can use the command ns lookup. After typing the ns lookup\ncommand in a UNIX shell, you obtain a prompt. If you enter an ASCII domain name at\nthe prompt, nslookup prints the corresponding IP address; if you enter an IP address,\nthe domain name resulting from the reverse lookup will be printed.\nOn many operating systems, you can get contact information for a domain name\nby using the whois command, an implementation of the whois protocol [92], which\nlooks up records in the Network Information Center (NIC) database. For example, the",
        "ae5a02d8-af66-4da0-ab14-12162d43e5db": "Section 12.4 The ping Tool 247\ncommand whois mci .net on a UNIX workstation will produce the contact information\nfor MCI Internet Services. The protocol can also be used to find the contact information\nfor a particular AS number. For example, whois \"as l\" produces the contact informa-\ntion for the owner of AS 1: BBN Planet. Whois can also be used to look up information\non IP addresses, people, and so on; the command whois help gives details on the cor-\nrect syntax for these types of queries.\n12.4 The ping Tool\nYou can use ping to verify connectivity between your host and a given Internet destina-\ntion. Simply type ping destinationJiost (specified as either a domain name or an IP\naddress), and ping sends a packet (called a ping packet) to the destination and tells you\nwhether the destination responds. An example is shown in Figure 12.2.\nFigure 12.2 Sample output of ping.\nIf the destination does not respond but an ICMP error response is received instead,\nthe ICMP error code is displayed. This may help pinpoint the problem. An ICMP TTL\nExceeded error code indicates a probable routing loop, whereas an ICMP Destination\nUnreachable may identify an intermediate router with an incomplete routing table.\nYou can also specify an IP multicast group as the destination_host, if you have a\nmulticast-capable host. In this case, every ping packet will elicit multiple responses,\none from each member of the multicast group, as shown in Figure 12.3. This allows\nyou to find all the members of a particular multicast group. Similarly using a broad-\ncast address as destination in the ping command allows you to see all the IP hosts at-\ntached to a given IP subnet.",
        "a57583e6-233a-4502-962d-29bffb14aaac": "248 Debugging Routing Problems Chapter 12\nFigure 12.3 Sending ping to a multicast address.\nIf you look around, you will find an infinite number of variations on the basic ping\nprogram. Some ping programs, like the one in Figure 12.2, can be used to indicate the\nquality of the connection between your host and the destination. These programs send\na continuous stream of packets, telling you how long it takes to receive the responses\n(thereby giving you round-trip delay) and what percentage of packets are responded to\n(giving you an idea of packet-loss rates).\nOther common options in ping programs include the ability to specify\n\u2022 The number of packets to send and the rate at which to send them.\n\u2022 The size of packets sent.\n\u2022 The data contents of the ping packet. This may allow you to uncover\ndata-sensitivity problems in certain network paths. Also, the ping program\nmay allow you to randomly vary the size and contents of the ping packet.\n\u2022 One or more intermediate hops through which the ping packets should go on\nthe way to the destination. This is useful in several situations. Instead of debug-\nging connectivity between your own host and a destination, you may want to\ndebug connectivity between two remote hosts. In this case, use ping with one\nremote host as intermediate hop and the other as destination_host. Also, you\nmay encounter routing problems such that you cannot reach a destination Y but\nyou can reach X and they can then reach Y. This can be determined by pinging Y\nwith an intermediate hop of X, after a simple ping of Y fails.\n\u2022 The ability to report the path the ping packet takes through the Internet.",
        "daef6735-d862-45ed-ba9e-5593287bcfb2": "Section 12.4 The ping Tool 249\nHow It Works\nThe ping tool is implemented using ICMP (see Section 1.2 and [194]). The ping packets\nare ICMP Echo Requests (ICMP type 8). Any host or router receiving an ICMP Echo\nRequest addressed to one of its IP addresses responds with an ICMP Echo Reply (ICMP\ntype 0). As with other kinds of IP packets, if a host or router is unable to deliver the\nICMP Echo Request to the addressed destination, an ICMP error message is returned.\nICMP Echo Requests contain a Sequence Number field that enables you to match\nreceived ICMP Echo Replies to the proper Echo Request, when a sequence of pings is\nbeing transmitted. The data portion of the ICMP Echo Request must be returned\nunchanged in the Echo Reply. This enables the ping program to store such things as\ntimestamps in the packet, for later calculation of round-trip delays.\nForcing ping packets through one or more intermediate hops is done by inserting\nan IP loose-source route option in the ICMP Echo Request's IP header. Recording the\npath a ping packet takes is done through the inclusion of an IP record-route option.\nBecause of size limitation in the IP packet header (60 bytes), a maximum of nine hops\ncan be recorded.\nStrong Points\nSupport for ping is ubiquitous. All sorts of machines have IP in them these days\u2014\nnetworked printers, disk arrays, in-circuit emulators, and so on. Since ICMP support\nis also required of all IP implementations, these devices all reply to ping. In fact, using\nping on the device is always one of the first things you do after installation to see that\nthe device has been properly configured. Available on virtually every operating system,\nping programs support a variety of useful options.\nIf you are new to network programming, modifying a ping program to meet your\nspecial needs is a good place to start. Also, ping is the one tool that remains essentially\nunchanged when debugging multicast routing problems.\nWhen you are having intermittent routing problems, using ping to test connection\nquality can uncover patterns that lead to the cause of the problem. For example, at one\ntime, connections through a particular ISP were suffering performance problems. A con-\ntinuous ping to destinations whose paths traversed the provider showed that ping\ntimes increased dramatically every 90 seconds. This was found to be an architectural\nconstant in the routing protocol employed by the ISP and uncovered problems in the\nrouting protocol's implementation provided by the ISP's router vendor (see [78]).\nWeak Points\nIf the destination is unreachable, ping returns only limited information: received ICMP\nerrors. In trying to pinpoint where the routing problem is, you are reduced to pinging",
        "5eb548a2-c01c-43b2-a9e6-b617dbad27ca": "250 Debugging Routing Problems Chapter 12\nintermediate destinations. However, you may not be able to determine the intermediate\nhops. Even if you can, each of them may be reachable while your destination still may\nnot be (see the earlier discussion of intermediate hops).\nWhen ping to a destination succeeds, it cannot be relied on to give you the route\nyour data packets are taking, as ping's record-route feature is limited to nine hops. In\naddition, you have the common problem that the act of measurement changes the sys-\ntem's behavior (see [97]): Using IP options forces the ICMP Echo packet off the main\nforwarding path in many vendors' routers, possibly changing the path the packet\nwill take.\nAll these problems are solved by the traceroute diagnostic. This tool is covered in\nthe next section.\n12.5 The traceroute Tool\nThe traceroute program is usually the best tool for diagnosing routing problems.\nOriginally developed on UNIX systems, it is now available on many other host and\nrouter platforms as well. Given a destination (domain name or IP address, as usual),\ntraceroute traces the routers on the path to the destination, stopping when the\ndestination is reached, an ICMP Destination Unreachable is received, or the maxi-\nmum number of router hops has been exceeded (the default is 30, but it can be over-\nridden with the -m option). The traceroute program was written by Van Jacobson at\nLawrence Berkeley Laboratories. An excellent UNIX man page is available describing\ntraceroute's usage and options [247].\nThe traceroute program probes each successive hop along the path to the destina-\ntion. By default, each hop is probed three times (this can be changed with the -q option).\nThe results of the probes for a given hop are printed on a single line, with the hop num-\nber, the router at that hop (printed as a domain name or as an IP address if the -n option\nis given), and the round-trip delay encountered by each of the probes.\nFigure 12.4 shows a sample traceroute. The output shows the path to 128.9.0.32,\ngoing through routers 132.236.200.1,132.236.230.1, and so on.\nTwo other options are commonly available in traceroute tools.\n\u2022 You can trace the route between two remote hosts by using the -g option. For\nexample, to trace the route between 128.9.0.32 and 198.49.45.10, you can give the\ncommand traceroute -g 128.9.0.32 198.49.45.10 from any Internet host.\n\u2022 You can trace paths for traffic of differing IP Type of Service (TOS; see Sec-\ntion 1.2) by using the -t option.\nWhen a traceroute probe fails for a given hop, instead of a round-trip time, an indica-\ntion of the failure is displayed. Table 12.1 lists the most common failure indications.",
        "2e7abcfe-bd44-4343-b599-964f9b63c984": "Section 12.5 The traceroute Tool 251\nFigure 12.4 Sample output of traceroute.\nTable 12.1 Common Failure Indications of traceroute\nThe traceroute program fails when the ultimate destination is not reached. Such\nfailures commonly end with the reception of an ICMP Host or Net Unreachable or with\nprobe failures until the maximum hop count is received, as shown in Figure 12.5.",
        "dde2b537-52ca-4d26-836c-1ea3c73120ad": "252 Debugging Routing Problems Chapter 12\nFigure 12.5 Sample output of traceroute, showing probe failures.\nAnother common failure is the repetition of one or more router hops, which indi-\ncates a routing loop. For more examples of traceroute problem diagnosis, see the\ntraceroute UNIX man page [247].\nYou can find traceroute gateways on the Web by typing traceroute into your favorite\nWeb search engine. These gateways are servers on which you are allowed to execute the\ntraceroute command remotely. You enter the traceroute command options on a Web\nform, and the results are displayed in your Web browser. The result is the path that\npackets would take from the server to your machine or from the server to any other des-\ntination you specify. You can also use the traceroute gateway to trace the path of your\nhost to any destination, by using the -g option to traceroute. This option is useful if\nyou do not have traceroute installed on your host.\nVan Jacobson has recently extended traceroute, creating a more sophisticated\ntool called pathchar [118]. In addition to finding the path to a given destination, the\npathchar tool analyzes the path's performance by estimating the bandwidth, propaga-\ntion delay, packet loss, and queuing delay of each link in the path.\nHow It Works\nA traceroute probe is a UDP packet addressed to the destination host and specifying\nan (ideally) unused UDP port. A base UDP port of 33434 is used but can be overridden\nwith the -p option. The traceroute program first sends a set of probes with IP TTL set\nto 1, then sends a set with IP TTL set to 2, and so on. The nth set of probes is sent with IP\nTTL set to n and a UDP port set to the base UDP port plus n. These should elicit either\nan ICMP TTL Exceeded from the nth hop router or an ICMP Port Unreachable from the\ndestination host. Tracing the path between two remote hosts is done by inserting an IP\nloose-source route option in the UDP probe's IP header.",
        "e610d100-cd70-4cf1-b47a-d8979d8fd2a2": "Section 12.5 The traceroute Tool 253\nThe size of the UDP packets used by traceroute is so small (38 bytes) that IP frag-\nmentation problems should not be encountered. However, the size of the probes can be\nchanged on invocation by specifying the probe size in bytes after the destination host.\nIn order to estimate the performance of each hop in the path, the pathchar tool\nsends UDP packets of varying sizes for each IP TTL value. By examining the different\nresponse times to these variable-sized probes, link characteristics, such as bandwidth,\npropagation delay, and queuing delay, can be deduced after some rather complicated\nmathematics [117].\nStrong Points\nThe traceroute program is the most powerful tool for diagnosing routing problems. It\ndepends only on something that is required in the main forwarding path of all IP rout-\ners and hosts\u2014TTL processing.\nAlso, traceroute is quite robust. For example, it cleverly flags implementation\nbugs, such as the BSD UNIX 4.3 TCP/IP bug that makes destination hosts look twice as\nfar away as they in fact are (see the ! failure indication in Table 12.1). As another exam-\nple, incrementing the UDP port on each hop may circumvent port collisions at the desti-\nnation host (with the side effect of insertion of phantom hops).\nWeak Points\nEven though TTL processing is required in the main path of every IP router and host, it\nmay still be broken, with the router/host remaining more or less functional. For exam-\nple, a common error is to forward packets after decrementing the TTL to 0 instead of\nresponding with an ICMP TTL Exceeded. Routers exhibiting this error will be omitted\nfrom the traceroute path, with the next-hop router instead appearing twice.\nSome routers may not send ICMP errors or may not send ICMP TTL Exceeded\nmessages. These routers will also not show up in a traceroute. Other routers may\nrate-limit the number of ICMP messages that they generate; these routers appear in\ntraceroute output only intermittently.\nSome routers do not put large enough TTLs in their ICMP error responses, and so\nthe ICMP responses do not get back to the traceroute-executing host. The BSD UNIX\n4.3 bug described in Table 12.1 is in this category\u2014the TTL in the ICMP error response\nis set to the remaining TTL in the offending packet.\nA traceroute can be difficult to interpret when routers are doing multipath, since\nthere is then no good way to associate consecutive hops. Also, traceroute does not\nwork for IP multicast, because ICMP errors, and in particular ICMP TTL Exceeded\nand ICMP Port Unreachables, are not returned in response to IP multicast datagrams.\nInstead a totally separate mechanism for multicast, called multicast traceroute, or\nmtrace, has been developed (see Section 12.11).",
        "d0c3ae7a-e714-4adb-af64-637eb2a14759": "254 Debugging Routing Problems Chapter 12 1\n12.6 SNMPMIBs\nSNMP [226] is the standard protocol used to monitor and control Internet devices.\nIn SNMP, management data within an Internet device is organized into various\nManagement Information Bases (MIBs) [144]. There is no shortage of MIBs. MIBs exist for\nEthernet interfaces, printers, uninterruptible power supplies, and you name it. In the\ndesire for a more manageable Internet, the IETF has mandated the creation of a MIB for\neach of its standard protocols. Also, many vendors have created large proprietary MIBs\nfor the management of their own products.\nOne way to debug routing problems is to dump routing tables and examine routing\nprotocol state through SNMP. The following routing-related MIBs can be used for this\npurpose.\n\u2022 MIB-II, documented in RFC 1213 [143]. This is the granddaddy of all Internet\nMIBs and is the one that you can almost be assured that any Internet device\nimplements. This MIB contains IP and ICMP statistics, such as packets received\nand packets forwarded. It also contains ARP mappings, which can be used to\nindicate which neighboring IP hosts and routers the device is talking to\u2014this\nhas been used for automatic network map discovery in some network manage-\nment products. MIB-II also contains a routing table, although one that has been\nsuperseded by later MIBs. However, in the name of backward compatibility,\nMIBs or pieces of MIBs never go away even when superseded. So there are\nplenty of implementations of MIB-II routing tables still out there.\n\u2022 The IP Forwarding MIB, documented in RFC 1354 [10], This provides a way to\ndump a device's IP routing table. It improves on the routing table in MIB-II by\nallowing multiple routes per IP destination. Also, a separate set of paths can be\nrepresented for each Internet Type of Service (TOS). However, this routing table\ndoes not allow representation of all routes possible in CIDR routing and so has\nalso been superseded.\n\u2022 The recently revised IP Forwarding MIB. The resulting RFC 2096 [11] replaces RFC\n1354. This MIB now can express CIDR routes; two routing entries, both having\nthe same network address by differing masks, can now be distinguished.\n\u2022 The OSPF MIB, documented in RFC 1850 [14]. This is a large MIB, with more than\n100 variables. You can use this MIB to examine the OSPF link-state database;\ngeneral OSPF statistics, such as the number of routing calculations performed;\nand the state of OSPF areas, interfaces, and neighbors. This MIB can also be\nused to monitor and configure the OSPF extensions, including MOSPF.\n\u2022 The BGP MIB, documented in RFC 1657 [262]. This MIB contains a BGP router's\nAS number, the state of its BGP peers, and the BGP routing information that has\nbeen received from each of the peers.",
        "27cc131d-e18e-47ee-bb4b-89ee9c9f52a2": "Section 12.6 SNMP MIBs 255\n\u2022 The RIPv2 MIB, documented in RFC 1724 [150]. This MIB provides RIP statistics,\nmonitoring and configuration data for each RIP interface, and (optionally)\ninformation about each RIP neighbor.\n\u2022 A MIB developed for DVMRP [243]. This MIB allows the monitoring of the\nDVMRP protocol via SNMP. The contents of the DVMRP routing table can be\nexamined, along with information about DVMRP physical interfaces, tunnels,\nand neighbors. The administrative boundaries of the DVMRP routing domain\ncan also be examined.\n\u2022 An experimental MIB for IGMP [141]. This MIB allows you to monitor the state of\nIGMP within a multicast router. Two tables are provided. The first table shows\ninterfaces on which the router is sending Host Membership Queries and at\nwhat rate. The second table shows the group membership of the attached net-\nwork segments, including the last reporting host and the time of the report.\n\u2022 An experimental multicast forwarding MIB [142]. This MIB is the multicast analog\nof the IP Forwarding MIB. For each [source net, multicast group] combination,\nthis MIB shows the interface on which matching datagrams should be received\nand the set of interfaces out which the datagram should be forwarded.\nHow It Works\nSNMP is a query-response protocol. SNMP packets are encoded in a dialect of ASN.l\n[113]. There are five separate SNMP packet types: GetRequest, GetNextRequest,\nGetResponse, SetRequest, and Trap. Requests for specific management data are accom-\nplished with GetRequest, with the answers returned by GetResponse. A MIB can be lin-\nearly searched using GetNextRequest (for example, this is how you would dump a\nrouting table using SNMP; see Figure 12.6), and SetRequest is used to configure devices;\nboth of these packet types also elicit GetResponses. Traps are unsolicited messages sent\nby Internet devices as a result of an event (for example, a router interface going out of\nservice). Traps are somewhat controversial within the SNMP community and are used\nsparingly.\nManagement data in an Internet device are represented as variables. Variables have\nASCII names, such as ipCidrRouteif Index, and Object Identifiers, or OIDs, such as\n1.3.6.1.2.1.4.24.4.1.5. OIDs and their values are also coded in ASN.l. When multiple\ninstances of data exist within a device\u2014for example, separate routes in a routing table\u2014\nthey are identified by a combination of OID and instance (see Figure 12.6). Instances can\nbe thought of as indexes into a table of entries.\nVariables are organized into groups and tables, which in turn are collected into\nManagement Information Bases, or MIBs. The collection of MIBs is further organized\ninto a tree structure, which is reflected in the variables' OIDs (see Figure 11.1). MIBs are",
        "b761e8ba-fa56-4f3d-9bff-e4d88c83b1a7": "256 Debugging Routing Problems Chapter 12\nFigure 12.6 Dumping a routing table using SNMP's get-next function; ipCidrRoutelf Index\ngives the outgoing interface for the entry; the next hop is one of the indexes.\ndocumented using a specific syntax that allows them to be converted by MIB compilers\ninto formats easily processed by network management applications.\nFor more information on SNMP and the structure of MIBs, see Section 11.1.\nStrong Points\nThe IETF mandates that MIBs be developed for each standard Internet protocol. As a\nresult, many MIBs have been defined, potentially making a great deal of data accessible\nvia SNMP.\nSNMP provides a vendor-independent way to get data out of an Internet device.\nFor example, no matter how a vendor has organized its routing table internally, if the IP\nforwarding MIB has been implemented, the routing table can be dumped in a standard\nmanner.\nAt this point, almost all Internet devices support SNMP. Although support for spe-\ncific MIBs varies, almost all devices include an implementation of MIB-II. Many public-\ndomain SNMP tools also are available.\nWeak Points\nVendor support for MIBs beyond MIB-II is spotty. Although the IETF can mandate that\nMIBs be developed for all protocols, it cannot force vendors to implement the MIBs. For\nexample, a poll of OSPF implementations indicated that only a third of them supported\nthe OSPF MIB.\nOn the other hand, when MIBs are implemented, they often contain so much data\nthat it can be difficult to find the piece of information you are looking for. Browsing a\nMIB can be frustrating, due to the cryptic nature of variable names and OIDs. Both of\nthese problems can be solved via the implementation of MIB-based tools, as described\nin Section 12.7.",
        "d4e5d28a-e589-496f-bb35-525a7db6da55": "Section 12.7 MIB-Based Tools 257\nOperations, such as dumping a routing table via SNMP, can be very slow and cum-\nbersome, due to the fact that an SNMP packet exchange is required for each routing\ntable entry. This issue has been addressed by SNMPv2, which, however, is not yet\nimplemented in most Internet devices.\nNeither SNMP nor SNMPv2 has very strong security provisions. For that reason,\nvendors do not always implement SNMP SetRequests in their products. Even if\nSetRequests are implemented, network administrators often disable the SetRequests in\norder to plug an obvious security hole. In fact, for security reasons, administrators often\nblock SNMP read access to part or all of an Internet device's management information\nbase. These limitations to SNMP read and write access can limit the usefulness of SNMP\nas a debugging tool, especially when you are trying to debug a device that is owned and\nmanaged by someone else.\nRouting diagnostic information collected from a device using SNMP may not reflect\nthe true behavior of the device. Processing of SNMP GetRequests and GetNextRequests\nis a separate code path from the device's forwarding and routing protocol processing\nand therefore is subject to measurement errors. In particular, GetNextRequest is difficult\nto interpret and implement for some tables when multiple indexes are involved, and so\nMIB walks (of which a routing table dump is a portion) are sometimes wrong.\nSNMP only works when the management station can communicate with the Inter-\nnet device. If a routing problem prevents the management station from sending packets\nto the device, SNMP cannot be used to debug problems within the device.\n12.7 MIB-Based Tools\nA multitude of SNMP-based tools exist. These tools automate the process of getting\nSNMP data out of Internet devices, organizing and displaying the returned data in a\nform that is better suited for human consumption.\nNetwork management stations fall into this category. Typically they are window-\nbased applications running on PC or UNIX platforms; they monitor devices using stan-\ndard MIBs, such as MIB-II. Often a network map is part of the user interface, with the\ncolor of map components reflecting their current status (such as green for OK and red\nfor out of service). These applications also often include MIB browsers, which allow you\nto search through MIBs, based on the variables' ASCII names (instead of their more\nobscure ASN.l representations). MIB compilers are also often included, allowing you to\nadd additional MIBs to the browser. Standard dialog boxes may display information,\nsuch as interface statistics, in an easy-to-understand manner, although display of\nrouting-related data is usually restricted to a dump of the device's routing table.\nMIB-based tools can be built fairly easily to accomplish specific tasks. A couple of\nexamples follow.\n\u2022 At the 1991INTEROP, an OSPF demonstration was given. The INTEROP back-\nbone network consisted of OSPF routers from 11 vendors, providing complete",
        "27e2b7e1-cbde-476a-a5d3-8fb1fedb9ed9": "258 Debugging Routing Problems Chapter 12\nconnectivity between show booths and between the show and the Internet (see\nSection 3.4 for more details). The state of the backbone was monitored from a\nUNIX network management station. An additional dialog box in the NMS\napplication was created for the demo, which displayed the OSPF link-state\ndatabase checksum (OSPF MIB variable ospf AreaLsaCksumSum, see Sec-\ntion 11.5) for all OSPF routers in the network simultaneously. This display\ngave a quick indication of whether OSPF databases were synchronized.\nA UNIX program called ospf query [204] has been written by Tom Pusateri.\nThis program organizes the information in the OSPF MIB into easy-to-read\nscreens, with command line options to show OSPF interfaces, neighbors, and\nthe link-state database (see Figure 12.7). In addition, ospf query dumps and dis-\nplays RFC 1354's IP Forwarding MIB in a tabular form.\nFigure 12.7 Examination of OSPF neighbor status, using the ospfquery program (excerpted from the\nospf (juery UNIX man page).\nHow They Work\nMIB tools for specific tasks can be built fairly easily, using publicly available SNMP pro-\ngrams such as CMU's SNMP toolkit, combining them with user interface and scripting\nlibraries, such as Tk/Tcl. On the other hand, general-purpose SNMP network manage-\nment stations can be significant development tasks, typically using commercial data-\nbases and interfaces to other management protocol stacks.",
        "92dd37bf-af3e-48be-bcdd-108df6a877f0": "Section 12.8 Network Analyzers 259\nStrong Points\nThe main advantage of SNMP tools is their vendor independence. SNMP tools can pro-\nvide nice graphical configuration and monitoring tools for specific applications, which\ncan be used with any device that implements standard SNMP MIBs.\nWeak Points\nSNMP tools inherit some of SNMP's problems: Many SNMP MIBs are not widely imple-\nmented; write and even sometimes read access to MIBs may be restricted due to security\nconcerns; SNMP data can suffer from measurement errors; and SNMP GetNextRequest\nis sometimes incorrectly implemented. Also, dumping large volumes of data, such as\nlarge routing tables via SNMP, can be extremely slow.\n12.8 Network Analyzers\nNetwork analyzers are tools that collect packets as they are transmitted on one or more\nnetwork segments. These tools are used to troubleshoot and monitor networks, as well\nas while developing and debugging protocols.\nNetwork analyzers usually display a summary of packets in real time. For example,\na single line may be printed for each packet, displaying IP source and destination\naddresses, IP protocol number, and the time the packet was received (Figure 12.8). Com-\nplete packet contents may be saved to memory or disk, allowing later examination in\nmore detail. Often an analyzer understands how to decode packets of a given protocol\ninto fields to make analysis of packet contents easier. Sometimes an analyzer will allow\nyou to write your own parsing routines for your favorite protocol. For example, I wrote\nOSPF parsing routines for the Network General Sniffer to help initial debugging of the\nOSPF protocol.\nAnalyzers usually allow you to specify filters for packet collection and/or display,\nallowing you to restrict your view to only those packets you are interested in.\nSome analyzers will allow you to construct packets for transmission onto the seg-\nment or to play back collected packets. The latter capability can be very useful when try-\ning to reconstruct a failure.\nSome analyzers can perform in a distributed fashion. Collection points can be estab-\nlished on multiple remote segments, with the gathered packet sent to a central location\nfor correlation and display.\nSome analyzers can also perform more intelligent functions, verifying checksums,\nchecking for common errors (such as illegal broadcast addresses), or associating all\npackets belonging to a given TCP connection.",
        "1a8c1aa2-896f-49fc-b042-a6bdb78d7e77": "260 Debugging Routing Problems Chapter 12\nFigure 12.8 Example of a packet trace from a Network General Sniffer.",
        "e32a91ab-aade-4cdb-b029-54fe0f4f8549": "Section 12.8 Network Analyzers 261\nNetwork analyzers can be implemented as dedicated platforms or as add-on\nsoftware for existing hosts. Many network analyzers are available, some commer-\ncially and some in the public domain. A small sample of the available analyzers\nfollows.\n\u2022 The tcpdump program. Freely available for UNIX systems, this program collects\npackets seen on one of the UNIX system's attached network segments, printing\nthe headers of those packets matching a Boolean expression given on the pro-\ngram command line. The program understands the format of ARP, TCP, and\nUDP packets and has been extended to understand the format of most routing\nprotocols' packets.\n\u2022 The etherf ind program. Available on SunOS 4.x, this program allows collec-\ntion of specified packets, displaying one collected packet per line of program\noutput. A better analyzer, called snoop, is available in SunOS 5.x (also called\nSolaris 2.x).\n\u2022 LANzuatch. This add-on software turns a DOS platform into a network analyzer.\nIt features real-time display of captured packets, flexible filtering, and an exam-\nine mode to display packet contents in more detail. LANwatch is available com-\nmercially from FTP Software.\n\u2022 Network General Sniffer. This self-contained, portable analyzer is available in\nstandalone or distributed configurations. Besides the usual analyzer functions,\nit supports LAN diagnostics and traffic generation and allows people to write\ntheir own protocol interpreters. It is available commercially from Network\nGeneral.\nHow They Work\nMost network analyzers are implemented as either dedicated platforms or software\nadd-ons to existing hosts (such as PCs or UNIX workstations). By putting one or more of\ntheir LAN interfaces into promiscuous mode, they can receive all packets being\ntransmitted on the attached network segment. Network analyzers for point-to-point\nmedia (such as synchronous serial lines) are generally implemented with pass-through\nor Y cables that allow the monitor to receive all transmitted packets in a transparent\nfashion.\nAny host or router implementing the variables in RFC 1757's Remote Network\nMonitoring (RMON) [256] MIB can also be used to capture and store packets for later\nanalysis. Network management stations or other MIB-based tools can then be used to\nimplement the display and filtering functions of a typical network analyzer.",
        "c4d19ae7-443a-4426-ba96-466e2aa4bc1d": "262 Debugging Routing Problems Chapter 12\nStrong Points\nFor debugging complex protocol interactions, network analyzers are invaluable. We\nheld numerous bake-offs during the development of the OSPF protocol; all the various\nimplementors got together for several days of testing. When two implementations were\nnot interoperating, we invariably used a network analyzer to capture the packets that\nwere being sent. This technique uncovered numerous implementation bugs, as well as a\nfew protocol bugs. After a bake-off, I often went home with a large collection of packet\ntraces that I used later to analyze OSPF protocol performance.\nNetwork analyzers are used extensively in any multivendor testing situation. For\nexample, the INTEROP ShowNet is typically constructed so that a network analyzer can\nbe patched onto any given network segment. Typical complaints, such as \"Booth 24 is\nnot getting routing advertisements,\" are quickly resolved by the Network Operations\nCenter.\nWatching protocol exchanges with a network analyzer is a terrific way to learn how\na protocol works. This is the reason that we have included many network analyzer\ntraces in this book.\nWeak Points\nNetwork analyzers require physical access to the network segment being monitored.\nEither a dedicated piece of hardware must be attached to the segment, or software must\nbe added to one of the segment's existing hosts. Alternatively if a router or host imple-\nments the variables in the RMON MIB, it can be used for packet collection. A chicken-\nand-egg situation often arises. You do not monitor a segment until a problem occurs,\nand then you may have missed the problem's root cause. This has happened to me\nnumerous times during interoperability tests.\nMost software-only analyzers are incapable of collecting all packets when the net-\nwork segment is fully utilized. Dedicated platforms usually can collect at full speed but\nare often quite expensive.\nNetwork analyzers are generally passive. You can see everything that is currently\nhappening on a segment, but you cannot test the reaction of devices to situations of\nyour own choosing.\nNetwork analyzers are good at breaking packets into their component fields and\nat doing simple calculations, such as checksum verifications, but that is usually where\nthe analyzers' intelligence ends. Problem diagnosis of a packet trace is usually left to a\nhuman being who has good knowledge of the protocol being debugged.\nThe use of network analyzers invokes privacy and security concerns. Since they\ncapture all traffic transmitted on a given network segment, analyzers can be misused to\ncapture sensitive data, such as user passwords. This is the reason that network analyz-\ners on UNIX systems generally require root access.",
        "056f2a6b-9e9f-4c1e-870c-91c013a950c1": "Section 12.9 Protocol-Specific Tools 263\n12.9 Protocol-Specific Tools\nCertain routing protocols have built-in diagnostics, allowing tools to be written to\ndebug protocol, implementation, and configuration problems. A few such tools follow.\n\u2022 The ripquery program [51], written by Jeff Honig, enables you to see part or all\nof a RIP router's routing table. In addition, you can see the RIP packets that the\nRIP routing is currently sending. Example output from the ripquery program\nis shown in Figure 12.9.\nFigure 12.9 Sample output from the ripquery program.\nThe ospf_monitor program [50], written by Rob Coltun and Jeff Honig,\ncan display an OSPF router's link-state database and routing table, along\nwith OSPF statistics and errors and information about OSPF interfaces and\nneighbors.",
        "531b93cf-3480-4d76-ade9-91a965ed4971": "264 Debugging Routing Problems Chapter 12\nThe mrinf o program [116], written by Van Jacobson, allows you to query the\nstate of a DVMRP router. A description of the router is printed, including its\nDVMRP revision level and its capabilities (such as whether it implements prun-\ning or responds to multicast traceroute). A list of the router's DVMRP interfaces\nis then given. The type of interface is listed (for example, whether a tunnel and,\nif so, whether it is source routed or encapsulated), along with the interface met-\nric, the TTL threshold, a list of neighbors, and whether the interface has been\nelected the Querier.\nThe nature of OSPF's synchronized link-state database allows you to monitor\nan OSPF routing domain by attaching an instrumented OSPF implementation\nto any network segment in the domain. With an OSPF implementation modi-\nfied to note rate of database change and database anomalies, such as one-way\nlinks, you can easily locate flapping links, duplicate OSPF router IDs, and so on.\nThe OSPF implementation contained in the companion to this book (OSPF Com-\nplete Implementation) can be used for this purpose. Another thing that you can\ndo is calculate the routing table of any OSPF router in the routing domain from\nthe instrumented implementation.\nHow They Work\nTypically the tools are enabled by the routing protocol designers' and implementors'\nadding monitoring request and response packets to the various protocols.\nThe ripquery program utilizes RIP's request, response, and poll commands. Each\nRIP packet has a Command field. RIP request packets (Command = 1) sent to a RIP\nrouter elicit RIP responses. The RIP response contains all the router's RIP routing table,\nunless specific RIP routes have been indicated in the body of the request. This RIP\nrequest/response procedure was not designed for diagnostic purposes; its purpose is to\nenable a RIP router to get a download of its neighbor's routing table quickly on restart.\nAs a result, there is one possible undesirable behavior of request/response. When the\nentire table is requested, the response packet has the RIP split horizon (or split horizon\nwith poison reverse) applied to it, possibly obscuring some of the routing information.\nFor this reason, certain RIP implementations (such as the UNIX gated and routed dae-\nmons) added the poll command, which has equivalent semantics but is used only for\nmonitoring and thus avoids the split-horizon rules.\nThe ospf^monitor program works in a similar fashion. The gated OSPF implemen-\ntation added a new OSPF packet type to be used in querying the gated OSPF for opera-\ntional information.\nThe mrinf o program uses the DVMRP ASKNEIGHBORS2 and NEIGHBORS2 pack-\nets, the \"2\" having been appended to replace an earlier pair of monitoring packets.\nWhen a DVMRP router receives an ASKNEIGHBORS packet, it responds with a\nNEIGHBORS2 packet describing the router, its interfaces, and neighbors. This same",
        "e3530751-1715-44f8-bac2-56c4468e2197": "Section 12.10 Product-Specific Monitoring and Tracing 265\nprocedure is utilized by the map_mbone program, which, when given a seed router, can\nmap an entire DVMRP routing system (such as the MBONE).\nStrong Points\nThese tools have generally been designed by the protocol designers and implementors\nspecifically for protocol debugging. As such, the tools are generally efficient and pro-\nvide concise, accurate troubleshooting information.\nWeak Points\nMany routing protocols do not have built-in diagnostic capabilities. If not included from\nthe very start, it is often difficult to retrofit diagnostics after the protocol has been\nwidely deployed. Also, if a diagnostic capability is not necessary for a protocol's opera-\ntion (for example, the RIP poll command), it is likely that the diagnostic will not be sup-\nported by all implementations.\nMany people in the SNMP community believe that SNMP should be used to moni-\ntor protocols rather than building protocol-specific monitoring support.\n12.10 Product-Specific Monitoring and Tracing\nMost TCP/IP hosts and routers have product-specific monitoring and debugging tools\nbuilt into their TCP/IP implementations. Normally these tools are accessed through a\nterminal interface, either local or remote through TELNET or a Web server. Sometimes\nthe tools can also be accessed through a proprietary MIB. These tools can be used to\nexamine in real time routing state and data. In addition, many products have tracing\ncapabilities so that a log of significant events can be made to a terminal or a local disk,\nvia SNMP traps, or sometimes even through the UNIX syslog facility.\nFor example, most routers have built-in tools to\n\u2022 Dump the routing table. Although this can also be done through SNMP, it is\noften faster and more reliable to do this via a product's terminal interface.\n\u2022 Dump the ARP table. This can tell you which hosts and routers are currently\nactive on attached network segments.\n\u2022 Query the router as to how it would route to a given destination.\n\u2022 Enable tracing of specific protocol events, such as all BGP packets received and\ntransmitted.\nMonitoring commands and tracing facilities have been built into most OSPF imple-\nmentations, including the one contained in the companion to this book (OSPF Complete",
        "ad6c2f83-78d3-4df6-83b6-8977bacc71a9": "266 Debugging Routing Problems Chapter 12\nImplementation). As an example, we include monitoring information taken from a large\noperational OSPF network, the Arkansas Public School Computer Network, which is\ndiscussed in more detail in Section 11.4. Commands executed on the command line\ninterface of that network's routers allow the network managers to examine OSPF's\nrouting table, link-state database (Figure 12.10), and the state of OSPF's database syn-\nchronization procedures. In addition, OSPF protocol activity can be traced by examining\nlogging messages (printed either locally on a router's console or remotely on a network\nmanagement station via the TELNET protocol), as shown in Figure 12.11.\nHow They Work\nThese product-specific tools have usually been designed by the original product devel-\nopers for initial debugging and then later for remote problem diagnosis.\nStrong Points\nThese commands often provide exactly what the product developers want to see,\nshould you end up asking their help in debugging a problem. Developers often include\na lot of interesting information in these commands and in a concise manner; they are\nmotivated to be able to debug their product remotely, lest they be woken up in the\nmiddle of the night and told to take the first plane to Omaha in the morning.\nWeak Points\nThese tools are often cryptic and poorly documented, if documented at all. Sometimes\nthese tools are removed from a product when it ships or are made inaccessible to the\ncustomer.\n12.11 Multicast Traceroute\nMulticast traceroute, implemented as the mtrace utility for UNIX systems, is the IP\nmulticast analog to the unicast traceroute utility (see Section 12.5). This tool allows\nyou to trace the path of a multicast datagram with a given group destination as it travels\nfrom a given source to a specific group member (indicated by the group member's uni-\ncast IP address). As with unicast traceroute, you can trace the path until either (a) a\nrouter on the path fails to answer or (b) an error indication is returned. This information\nlets you pinpoint the precise router that is having a problem when multicast datagrams\nare for some reason not getting delivered.\nHowever, unlike in unicast traceroute, the path is traced backward, from the spe-\ncific group member back to the source. The reason is that in the forward direction, the",
        "5e01f252-e318-4fd8-a9b4-fd56945e8494": "Section 12.11 Multicast Traceroute 267",
        "9e21c9ce-0bcc-4e82-bdbb-550e765b2cbe": "268 Debugging Routing Problems Chapter 12\nFigure 12.11 Implementation-specific tracing of OSPF events.\nmulticast delivery tree has many branches, and it is in general difficult to find the exact\nbranch leading to any particular group member.\nEven when multicast routing is working, mtrace can be used to find problems that\nare affecting the delivery of multicast datagrams. The program indicates how large the\nsource must set a datagram's IP TTL field in order for the datagram to be delivered suc-\ncessfully to the destination group member. In IP multicast, TTL has additional seman-\ntics over and above simple hop count: TTL thresholds are configured at administrative\nboundaries to restrict the scope of multicast traffic (see Section 9.4). TTL information\ncoming from mtrace can help discover configuration errors in these thresholds. In addi-\ntion, mtrace collects packet statistics, allowing you to detect congestion along the multi-\ncast path.\nAlthough you can specify the source, multicast group, and specific group member\nfor your trace, you need specify only the source. By default, the multicast group is set\nto the MBONE's audio channel (224.2.0.1), and the group member is set to the host on\nwhich you are executing mtrace. In other words, mtrace by default indicates how pack-\nets on the MBONE audio channel will be delivered from a specified speaker to you.\nAlso, mtrace prints a separate line for each multicast router encountered on the\nway from the multicast group member back to the multicast datagram source. Each line\nincludes\n\u2022 The DNS name and/or IP address of the multicast router.\n\u2022 The multicast routing protocol being used by the multicast router.\n\u2022 The minimum TTL required in the multicast datagram for it to be forwarded by\nthe multicast router.",
        "2dd656f9-017a-47cf-99fd-cc5107477575": "Section 12.11 Multicast Traceroute 269\nA router along the path may also report an error, which causes matching multicast\ndatagrams not to be forwarded. Example of such errors reported by mtrace include the\nfollowing.\n\u2022 The multicast router does not know how to forward multicast datagrams from\nthe given source.\n\u2022 The multicast router's outgoing interface for this datagram does not match the\nincoming interface for the next multicast router on the way to the destination\ngroup member.\n\u2022 The multicast router has pruned the multicast group.\n\u2022 The multicast group is subject to administrative scoping at this router (see\nSection 9.4).\nThe syntax and output of the mtrace program parallels that of traceroute. Also\nlike traceroute, mtrace has a very good UNIX man page that describes how to use\nthe program in various scenarios. Figure 12.12 displays an example of mtrace out-\nput. In this example, the path of a multicast datagram addressed to group 224.2.0.1 is\ntraced backward from one of the group's members, a host with a unicast address of\n206.34.99.38, to the datagram's source (which defaults to the host that the mtrace com-\nmand is executed on, in this case, the host 132.236.199.65).\nFigure 12.12 Sample mtrace output.\nHow It Works\nTwo additional IGMP packet types, OxlF for traceroute request and OxlE for traceroute\nresponse, were created in order to implement mtrace. The processing of these new",
        "0f2a486e-cb75-40b8-aeee-c928f2ba78fb": "270 Debugging Routing Problems Chapter 12\nIGMP types has been documented by the lETF's Inter-Domain Multicast Routing Work-\ning Group (see [72]).\nWhen mtrace is executed, a traceroute request packet is sent to the last-hop router\non the path of a multicast datagram from multicast source to destination group member.\nThe traceroute request packet is then forwarded hop by hop toward the multicast\nsource. The multicast router at each hop reports a set of data, such as the IP addresses of\nthe incoming and outgoing interfaces that the multicast datagram would traverse, the\nmulticast routing protocol responsible for the incoming interface, the minimum TTL\nthat the datagram would have to contain in order to be forwarded, and various statis-\ntics, such as the number of matching multicast datagrams that have been forwarded by\nthe router. Forwarding of the traceroute request packet stops when (a) a maximum\nnumber of hops, specified by the mtrace program, has been reached; (b) the reported\ndata has filled the traceroute request packet; (c) the first-hop router along the multicast\ndatagram's path is reached; (d) a router is reached that does not know the route back to\nthe multicast datagram's source; or (e) a router that does not understand traceroute\nrequests is encountered. In all but the last case, the traceroute request is converted to a\ntraceroute response and is then sent back to the host executing the mtrace.\nWhen a router that does not understand traceroute requests is encountered, mtrace\ngets no response. In this case, mtrace starts an expanding-length search, sending a\nsequence of traceroute request packets to the last-hop router, first with maximum hop\ncount of 1, then with 2, and so on. In this way, the path from the last-hop router back to\nthe traceroute-ignorant multicast router is discovered.\nThe identity of the last-hop router may be specified by using the -g option on\nthe mtrace command line. If the identity of the last-hop router is unknown, mtrace\nattempts to discover it by multicasting the traceroute request to the same group whose\ndatagrams are being traced. This should reach the last-hop router, assuming that (a) the\nTTL in the traceroute request is high enough (settable by mtrace's -t option); (b) the\n\"destination group member\" is truly a member of the group; and (c) multicast routing is\nworking between the host executing mtrace and the destination group member (which\nare often the same host).\nTracing a multicast datagram's path using traceroute request packets is very similar\nto how you would trace the path using SNMP and the multicast forwarding MIB. How-\never, traceroute requests use fewer packets and enable you to discover the last-hop\nrouter (which you could do with the multicast forwarding MIB unless you multicasted\nSNMP requests!).\nStrong Points\nThe mtrace program is definitely the best way to track down multicast routing prob-\nlems. It allows you to trace partial paths efficiently, locating the problematic multicast\nrouter. The program discovers not only inconsistencies in multicast forwarding between",
        "45689d76-dd98-4835-aa92-f84da339235b": "Section 12.11 Multicast Traceroute 271\nrouters but also configuration and congestion problems. The only other tools available\nfor debugging multicast routing are ping and the multicast forwarding MIB.\nThere is wide deployment of routers that understand multicast traceroute on the\nMBONE. This functionality was first released in mrouted 3.3.\nAs with the unicast traceroute utility, the implementors of mtrace have thought\nabout many contingencies, enabling useful information to be returned in the face of a\nwide variety of failures. As one example, they allow the traceroute response packet to be\nreturned as a multicast instead of being unicast to the host running mtrace, for those sit-\nuations in which multicast connectivity exists but unicast does not!\nWeak Points\nUnlike unicast traceroute, a separate mechanism (IGMP traceroute request and response\npacket types) had to be developed for multicast traceroute, rather than just using\nrequired features of the data forwarding in all multicast routers. This means that, just\nlike SNMP solutions, multicast traceroute may be subject to measurement errors.\nIf the last-hop multicast router does not understand traceroute request packets or is\ngrossly malfunctioning, mtrace cannot gain any information at all. Similarly mtrace\nmay not be able to discover the identity of the last-hop router in some cases. Examples\nof such cases are when the traceroute destination is not really a group member or when\nthere is no multicast connectivity between the host executing mtrace and the traceroute\ndestination.\nFurther Reading\nThe Network Management Tool Catalog [68] provides a good, although somewhat dated,\nlist of tools for network monitoring and control, including analyzers, SNMP program-\nming libraries, and debugging and mapping tools. Pointers to a more up-to-date online\nversion of the tool catalog are also provided.\nMarshall Rose's The Simple Book [218] is the best introduction to SNMP. We examine\nSNMP and its MIBs in more detail in Chapter 11.\nThe Tk/TCL toolkit [187] allows you to quickly code applications such as those\ndescribed in Section 12.9. Perl [260] is another scripting language popular with applica-\ntion developers. Both packages are freely available on the Internet.\nThe MBONE\u2014its applications, design, and management tools\u2014is described further\nin [36], [69], and [131]. The mtrace man page [37] provides the best description on how\nto use multicast traceroute to track down problems in multicast routing, just as the\ntraceroute man page [247] is a good resource for unicast routing debugging.\nThe gated routing daemon can turn a UNIX workstation into a TCP/IP router.\nUnlike the routed program, which runs only RIP, gated contains an implementation of\nmost IP unicast and multicast protocols. It is also used as a platform to experiment with",
        "6faef32f-79a3-442e-b1bb-dc0c02d1554b": "272 Debugging Routing Problems Chapter 12\nnew routing protocols and has been incorporated into many commercial routers as well.\nSee [83] for detailed documentation on gated configuration and internals. The Routing\nServer created as part of the NSF-funded Routing Arbiter project [223], used at some\nexchange points to simplify the administration of BGP peering, is also built on top of\ngated.\nExercises\n12.1 Find the number of routers your packets traverse on the way to the Internic's RFC\ndepository (ds. internio .net). Which ISPs and backbone service providers do\nyou end up using?\n12.2 Modify the ping program so that it returns whether the destination is reachable\nand, if so, the number of hops to the destination, assuming a symmetric path.\n12.3 Use SNMP to dump an IP routing table. First, use a command line tool (such as\nthe publicly available CMU SNMP tools), and then write your own MIB-based\ntool.\n12.4 Write a program to receive and display all RIP packets broadcast on your local\nnetwork segment.\n12.5 Write a program to find all DVMRP routers within n hops of a given DVMRP\nrouter, where n is specified by the user.",
        "136b4833-82c1-4fb4-8b7e-6457b8df9572": "PartV\nRouting Protocol Comparisons\nIn Part V, we survey the routing protocols, both unicast and multicast, in use in the\nInternet. Chapter 13, Unicast Routing Protocols, compares and contrasts the unicast\nrouting protocols in use in today's Internet: RIP, OSPF, BGP, IGRP, and Integrated IS-IS.\nEach protocol is explained in terms of the basic functions that every IP routing protocol\nprovides: neighbor discovery, distribution of routing data, routing calculations, aggre-\ngation, policy controls, and so on. We end with a discussion of how routing information\nis exchanged between routing protocols.\nChapter 14, Multicast Routing Protocols, examines the multicast routing protocols\nthat have been developed for the Internet: DVMRP, MOSPF, PIM Dense, PIM Sparse,\nand CBT. Before getting into the details of the specific protocols, we describe the opera-\ntion of broadcast-and-prune protocols.\n273",
        "6bd66045-8417-4978-9834-9ad3f2a8609c": "13\nUnicast Routing Protocols\nIn this chapter, we compare and contrast the routing protocols in use in today's Internet:\nRIP, OSPF, BGP, IGRP, and Integrated IS-IS. As we have seen, routing protocols can be\ncategorized into IGPs and BGPs. (By the way, many TCP/IP routing protocols contain\nthe word gateway. This was the original term for what we now call a router, a network-\nlayer switching device. Today the word gateway is used for devices that switch at\nhigher levels of the OSI reference model: mail gateways, application-level gateways,\nand so on.) Internet routing protocols can also be classified according to the basic rout-\ning technology they employ: Distance Vector or link-state (Table 13.1).\nTable 13.1 Classification of TCP/IP Routing Protocols. (Boldface type indicates\nprotocols in use in the Internet.)\nProtocol Type\nIGPs\nBGPsDistance Vector\nGGP\nHello\nRIP\nIGRP\nBGP\nBGPLink State\nOSPF\nIntegrated IS-IS\nIDPR\nIn the sections that follow, we will describe each of the Internet's routing protocols.\nEach routing protocol has to perform a basic set of activities. For example, a router has\n275",
        "b6b71187-8bfc-45e0-ad18-ca8e973b5ad5": "276 Unicast Routing Protocols Chapter 13\nto be able to detect its neighboring routers. It also has to have a reliable way of collecting\nrouting data and of turning this data into routing table entries. In order to better under-\nstand how the protocols work and to compare and contrast them, we will describe each\nprotocol in terms of the following categories.\n\u2022 Type. Is the protocol an BGP or an IGP; does it employ Distance Vector or link-\nstate routing technology?\n\u2022 Encapsulation. Does the routing protocol run directly over IP, over one of the\nInternet transport protocols (TCP or UDP), or directly over the data-link layer?\n\u2022 Path characteristics. What do the \"best\" paths selected by the protocol look like?\nFor example, RIP always selects paths that go through a minimum number of\nrouters. Other protocols can select minimum-delay paths or minimize other\nmetrics. Still other protocols do not include a metric but allow the network\nadministrator to indicate path preferences.\n\u2022 Neighbor discovery and maintenance. How does a router running the protocol dis-\ncover the routers (called neighbors, or peers) with which it is to exchange rout-\ning information? How does the router discover failures in these neighbors so\nthat it can route traffic around them when necessary?\n\u2022 Routing data distribution. What is the raw routing data that is distributed\nbetween routers running the protocol, and how is this distribution performed?\n\u2022 Route deletion. When a destination prefix becomes unreachable, how is this\ninformation propagated by the routing protocol?\n\u2022 Routing table calculation. How does the router calculate routing table entries\nfrom the raw routing data received from its neighbors?\n\u2022 Robustness/reliability. How does the protocol ensure that routing data is trans-\nmitted reliably between routers? In what other ways does the protocol try to\nensure that transmission errors and hardware or software errors within the\nrouters do not permanently impair routing?\n\u2022 Aggregation. How does the protocol combine routing information for a col-\nlection of prefixes, producing a routing advertisement for a single, smaller\nprefix?\n\u2022 Policy controls. In what ways can the network administrator bias the paths calcu-\nlated by the protocol? For example, an ISP may wish to ensure that traffic going\nbetween two of its customers never leaves the ISP's network. Or, the network\nadministrator may not wish to route traffic to prefixes originating from a partic-\nular AS number.\n\u2022 Security. How does the protocol guard against intruders trying to disrupt proto-\ncol exchanges and/or corrupt routing data?",
        "f6827075-1136-4f22-831d-d25e9f8d4fba": "Section 13.1 RIP 277\n13.1 RIP\nThe development of TCP/IP and the Internet was strongly influenced by the University\nof California at Berkeley's BSD UNIX project. BSD UNIX was the first widely deployed\nTCP/IP host implementation and still serves as the reference implementation for\nTCP/IP developers [264]. The work done in BSD UNIX on TCP congestion control has\nbeen one of the major factors enabling the Internet to grow to its present size. And BSD\nUNIX provided the Internet with its first widespread routing protocol implementation,\nwhich is still probably the most common routing protocol in use in today's Internet: the\nRouting Information Protocol (RIP) [95]. RIP also is run commonly by TCP/IP hosts as a\nrouter discovery mechanism and as a way to find the best router to use for a given des-\ntination (Section 1.2). The routed program, an implementation of RIP, is shipped with\nall UNIX systems.\nTCP/IP's RIP is an adaptation of the XNS Routing Information Protocol [265]. Leav-\ning the protocol mechanisms largely unchanged, the BSD networking developers made\nRIP multiprotocol by advertising UNIX sockaddr structures within RIP routing\nupdates. This allowed RIP to be used not only as a TCP/IP routing protocol but also\nfor other network stacks, such as OSI.\nTCP/IP's RIP is the classic Distance Vector protocol (Section 2.3) and is used as an\nIGP within the Internet. As such, RIP employs a distributed computation scheme: RIP\nrouters cooperate by sending routing updates to their neighbors. These updates cause\ntheir neighbors to change their routing tables incrementally and to send new updates in\nresponse, causing further routing table changes. Eventually this process causes all the\nrouters' routing tables to converge to stable values (see Figure 13.1).\nFigure 13.1 Operation of RIP. The received routing table entry having the shortest cost is installed in the\nrouter's routing table and then rebroadcast in the router's own RIP updates.\nRIP depended on the original division of TCP/IP addresses into Class A, B, and C\nnetworks, allowing any of these networks to be split into physically contiguous, fixed-\nsized subnets. In order to support CIDR, a new version of RIP was developed, RIPv2.\nThe original RIP protocol, also now called RIPvl, has the following properties.\n\u2022 Type: RIP is a Distance Vector IGP.\n\u2022 Encapsulation: RIP runs over UDP, using UDP port 520.",
        "274b9900-8d41-4b35-af0a-87763580faa1": "278 Unicast Routing Protocols Chapter 13\nPath characteristics: RIP routes are based solely on hop count. To get to a particu-\nlar destination, RIP routers choose the path that goes through the minimum\nnumber of routers. The maximum hop count supported by RIP is 15; destina-\ntions 16 hops or farther away are considered unreachable.\nNeighbor discovery and maintenance: RIP has no neighbor discovery and mainte-\nnance procedures separate from route distribution. In particular, RIP has no\nway to discover one-way links.\nRouting data distribution: RIP routers broadcast RIP updates to their neighbors.\nRIP updates list a collection of destination prefixes, together with their metrics\n(Figure 13.2). On receiving a RIP update from a neighbor, a RIP router decides\nwhether to update its routing table. However, unlike OSPF, with its link-state\ndatabase, and BGP, with its RIB-In, a RIP router keeps only the current best\nroute, which is stored directly in the router's routing table. RIP routing updates\nare limited to a size of 512 bytes. Each prefix entry within a RIP routing update\nconsumes 20 bytes, limiting the number of prefixes per routing update to 25. To\nadvertise a larger number of prefixes, multiple RIP updates are sent.\nResponse to changes: When a routing table in a RIP router changes, the RIP router\nusually will broadcast updates for the new prefix immediately, before waiting\nfor the normal 30-second timer. These updates, called triggered updates, are\ncaused by (a) one of the router's interfaces becoming operational, in which case\nthe router starts advertising the attached prefix with a cost of 1; (b) one of the\nrouter's interfaces going inoperational, in which case the router advertises the\nprefix as unreachable by assigning the prefix a metric of 16; (c) a RIP update\nfrom a neighbor has modified the routing table; or (d) a routing table entry has\ntimed out (more on this later). Triggered updates advertise only those prefixes\nwhose cost has changed.\nRouting table calculation: Prefixes belonging to directly connected network seg-\nments are always installed in the routing table with a cost of 1. The next hop for\nother prefixes is set equal to the RIP router advertising the smallest metric N,\nwith the routing table cost for the prefix set to N + L\nRobustness/reliability: A RIP router broadcasts its complete routing table every 30\nseconds. If for some reason a neighbor fails to receive one of the router's RIP\nupdate packets\u2014for example, the packet is damaged by transmission errors or\ndropped due to congestion\u2014the neighbor will probably just receive an identical\nupdate 30 seconds later.\nAggregation: RIP aggregates routing information at the boundary of a subnetted\nnetwork (the collected subnets of a Class A, B, or C network). Inside the subnet-\nted network, individual subnets are advertised separately. Outside the subnet-\nted network, the entire subnetted network is advertised as a single prefix\nhaving a cost of 1. For example, if RIP were running in Figure 1.5, routers G-J",
        "e5ac5443-5caf-419f-9ee4-cf0f0071da47": "Section 13.1 RIP 279\nwould exchange information about the four subnets of 128.1/16, but G adver-\ntises only the single prefix 128.1/16 to the routers C and D.\n\u2022 Policy controls: Although not formally part of the RIP specification, most RIP\nimplementations allow the implementation of routing policies through the con-\nfiguration of routing filters. By configuring routing filters, a network adminis-\ntrator can control which subnets a RIP router will accept and which subnets a\nRIP router will advertise, usually on a per neighbor basis.\n\u2022 Security: RIPvl has no provisions for security.\nWhen a RIP router first comes up, it need not wait for 30 seconds before getting RIP\nupdates from its neighbors. The RIP router can instead broadcast RIP request packets,\nasking its neighbors to immediately send their updates.\nFigure 13.2 shows a packet trace of a router, 192.148.30.22, broadcasting its RIP\nupdates. Since the router's routing table has 355 entries, 15 consecutive RIP packets\nmust be sent back to back. RIP's strategy of broadcasting the entire routing table every\n30 seconds is a simple, fairly robust scheme for reliably delivering routing information.\nHowever, as this trace shows, the scheme also has its problems. First, it can take a lot of\nconsecutive update packets to transmit even a moderate-sized table: 1,000 entries would\ntake 40 packets, utilizing an average bandwidth of 5.4 Kbits/sec (in comparison, OSPF\nwould use only 142 bits/sec). Also, many routers cannot process a large number of\nback-to-back routing updates. In these situations, the receiving router usually drops the\nsame part of the back-to-back packet sequence every time, resulting in the inability to\nreceive certain prefixes.\nSince a RIP router expects to receive routing updates continually confirming its\nchoice of next hop, it eventually gives up on the next-hop router if updates cease to be\nreceived. After not hearing from the next hop for 90 seconds, the router will move the\nnext hop to any neighboring router that advertises a path of equal cost. After not hear-\ning from the next hop for 180 seconds, the routing table entry will simply be declared\nunreachable.\nRIP routers usually implement some of the standard mechanisms for improving\nconvergence of a Distance Vector algorithm (Section 2.3). These include triggered\nupdates, split horizon, and infinite split horizon.\nRIPv2\nIn order to support CIDR, a new version of RIP was designed, called RIPv2 [149]. By\nadding a mask field to each route, RIPv2 can advertise CIDR prefixes. All RIP mecha-\nnisms and convergence behaviors are maintained in RIPv2. But additional fields besides\nthe mask are advertised with each route: a 16-bit route tag, used to group routes together\nfor policy reasons; and a next-hop field, used to eliminate extra forwarding hops at the\nedge of a RIP routing domain (see the documentation of the equivalent OSPF functions,",
        "46593cb8-3b36-44bc-869a-3ac2f81e9955": "280 Unicast Routing Protocols Chapter 13I",
        "84c7b420-0064-4a86-a532-cc42568112b7": "Section 13.2 OSPF 281\nOSPF's external route tag and forwarding address, in Section 11.6). RIPv2 also allows\nreceived RIP updates to be authenticated by including authentication information\nwithin the RIP updates [13]. RIPv2 routing updates are multicast to the address\n224.0.0.9, although all RIPv2 routers can be configured to revert to broadcast in order\nto interoperate with RIPvl routers.\nRIP has also been modified to carry IPv6 addresses, resulting in the RIPng routing\nprotocol for IPv6 [151].\n13.2 OSPF\nThe Open Shortest Path First (OSPF) protocol is a link-state IGP designed expressly for\nthe Internet. OSPF was originally built as a RIP replacement, designed to provide quick\nconvergence with only a small amount of routing control traffic, even in ASs with a\nlarge number of routers. The original proving grounds for OSPF were some of the\nsecond-level networks of the Tl NSFNET, the so-called NSF regional networks [168].\nOSPF is now the recommended IGP for the Internet [85]. This is a recommendation\nmade by the Internet Engineering Task Force (IETF). It is impossible to legislate protocol\nusage in the Internet, so the recommendation simply encourages all makers of Internet\nrouters to implement the OSPF protocol.\nAs a link-state protocol, the core of OSPF consists of creating and maintaining a dis-\ntributed replicated database, called the link-state database. As long as every OSPF router\nhas an identical link-state database, OSPF calculates loop-free paths; most of the proto-\ncol machinery within OSPF is dedicated to keeping the database synchronized between\nrouters. Figure 13.3 shows how OSPF operates.\nFigure 13.3 Operation of the OSPF protocol. OSPF LSAs received on one interface are installed in the link-\nstate database and flooded out the router's other interfaces. From the link-state database, an OSPF router cal-\nculates its routing table, using Dijkstra's Shortest Path First (SPF) algorithm.\nA router running OSPF discovers its neighboring OSPF routers by multicasting\nOSPF Hello packets onto its directly connected network segments. After discovering a\nneighboring router, the router synchronizes link-state databases with the neighbor. Only",
        "a67019e4-f04a-413b-92b3-1c4df0745da9": "282 Unicast Routing Protocols Chapter 13 A\nthen does the router advertise the connection to the neighbor in a link-state advertisement\n(LSA, the name OSPF uses for individual pieces of the link-state database). The router\nthen starts the distribution of the LSA to all other routers through OSPF's reliable flooding\nmechanism. Once the other routers receive this LSA, they rerun their routing calcula-\ntions, which consist of Dijkstra's SPF algorithm performed on the link-state database.\nThe output of the calculation is the new set of best-cost paths to the network's destina-\ntions. Some of these new paths will probably utilize the just established connection from\nthe LSA's originating router to its new neighbor.\nA two-level routing hierarchy can be implemented in an OSPF domain by dividing\nthe routing domain into regions called OSPF areas. Routing information from other pro-\ntocols can be imported into the OSPF domain and readvertised by OSPF routers as exter-\nnal routing information.\n\u2022 Type: OSPF is a link-state IGP.\n\u2022 Encapsulation: OSPF runs directly over the Internet Protocol as IP protocol 89.\nOSPF Hello packets, which are used to discover and maintain neighbor rela-\ntionships, are multicast to the IP multicast address 224.0.0.5. OSPF's reliable\nflooding uses a combination of multicasting to 224.0.0.5,224.0.0.6, and uni-\ncasting.\n\u2022 Path characteristics: The network administrator of an OSPF routing domain\nassigns a cost to the output side of each router interface. The cost of a path is\nthen the sum of all output interfaces contained by the path\u2014paths are unidirec-\ntional. OSPF selects the path(s) with the lowest cost; therefore the higher an\ninterface's cost, the fewer packets the interface will be asked to transmit. The\nnetwork administrator has complete control over the units and semantics of\ninterface cost. For example, if each interface is assigned a cost of 1, OSPF finds\nminimum-hop paths (just like RIP). If, instead, each interface is assigned a cost\nof the length in kilometers of the underlying physical circuit, OSPF will calcu-\nlate paths having minimum static delay. The cost of an output interface must be\nbetween 1 and 65,535 inclusive. There are no limits on path cost.\n\u2022 Neighbor discovery and maintenance: An OSPF router discovers a neighbor when\nit receives the neighbor's OSPF Hello packet. The neighbor multicasts these\nHello packets periodically; if the router fails to receive Helios from the neigh-\nbor, the router will in time report as down the connection to the neighbor. The\nrate of sending Helios and the length of time before declaring the neighbor\nunreachable are configurable per network segment.\n\u2022 Routing data distribution: OSPF LSAs are distributed throughout the OSPF rout-\ning domain via a reliable flooding mechanism. The router originating the LSA\nbegins the flood by sending the LSA to its neighbors. Any other router will,\nwhen receiving the LSA, acknowledge receipt of the LSA and then compare the\nLSA to the contents of its present database. If the received LSA is more recent,",
        "1dbeb54a-3995-48bb-98bf-5b6510daadc6": "Section 13.2 OSPF 283\nthe receiving router will send the LSA out all interfaces other than the one on\nwhich the LSA was received. In order to make this flood reliable, after having\nsent the LSA out an interface, the router will retransmit the LSA until it is\nacknowledged.\nResponse to changes: Changes to a router's local environment\u2014for example, one\nof the router's interfaces is no longer operational or its cost changes, cause the\nrouter to modify one of its existing LSAs and reflood, to originate a new LSA\nand flood, or to begin flushing one of its LSAs from the routing domain. All\nLSAs include the age in seconds since they were originated, called the LS Age\nfield. Setting the LS Age field to a value that is not normally attained, 3,600 sec-\nonds, or 1 hour, and then reflooding the LSA, is an instruction to the other rout-\ners to delete the LSA rather than to insert it into their databases.\nRouting table calculation: Using the link-state database as input, an OSPF router\nuses Dijkstra's Shortest Path First algorithm to calculate the shortest paths to all\nprefixes within the network.\nRobustness/reliability: Flooding is made reliable by requiring that all transmitted\nLSAs be acknowledged explicitly. In addition, OSPF requires that all LSAs be\nreoriginated at 30-minute intervals, even if their contents have not changed.\nIn this way, even if an LSA has been damaged or deleted mistakenly from a\nrouter's database, the LSA will eventually be replaced and correct routing\nrestored without human intervention.\nOSPF also has additional robustness features. First, all LSAs have check-\nsums that are permanently attached to the LSA. The checksum allows LSA data\ncorruption, either during flooding or while held in a router's link-state data-\nbase, to be detected. Second, to protect against flooding loops, the LSA's LS Age\nfield also functions as a TTL field. By incrementing LS Age at least 1 every\nflooding hop, a looping LSA will eventually be discarded when its LS Age\nreaches 3,600. Third, to prevent black holes due to one-way links, links are not\nincluded in the OSPF link-state database until they are known to be bidirec-\ntional. Fourth, to prevent routing loops due to unsynchronixed databases, links\nare not advertised in LSAs (and hence are not used for data traffic) until the\nrouters at each end of the link have synchronized their databases.\nAggregation: Routes can be aggregated at area borders, under configuration\ncontrol of the network administrator. By configuring a prefix as an OSPF area\naddress range, all addresses within the area that match the prefix will be adver-\ntised as a single route outside the area.\nPolicy controls: Configuration of area borders can also implement rudimentary\nrouting policies. If possible, OSPF always chooses paths that stay within a sin-\ngle area. OSPF also prefers intra-AS paths over paths that leave the Autono-\nmous System. Routing filters may also be configured at area borders\u2014area",
        "32761176-6ce9-40ea-8b64-a3b0a88129f3": "284 Unicast Routing Protocols Chapter 13\naddress ranges can be configured as no advertise, keeping information about cer-\ntain network segments local to a given area. An external route tag may also be\nattached to each external route imported into the OSPF routing domain. This\nallows external routes to be grouped together, simplifying the configuration of\nredistribution into other protocols (Section 13.7).\n\u2022 Security: An OSPF router can authenticate received OSPF packets by requiring\nthe sender to append keyed message digests to the OSPF packet. Stronger secu-\nrity has been proposed for OSPF by attaching digital signatures to OSPF LSAs.\nRouting data distribution works slightly differently on LANs and other network\nsegments having more than two routers attached (which OSPF calls multiaccess net-\nworks). On each multiaccess network, a special router, called the Designated Router (DR),\nis elected in order to cut down on the number of acknowledgments. Routers other than\nthe DR require only an acknowledgment from the DR when flooding LSAs onto the\nmultiaccess network; the DR ensures that acknowledgments have been seen from all\nother routers attached to the segment.\nOSPF keeps the size of its LSAs small and types the LSAs according to function. The\nrouter-LSA advertises the state of all of a router's interfaces, the network-LSA advertises\nall routers attached to a multiaccess network segment, summary-LSAs advertise routing\ninformation across area boundaries, and each external route is imported into OSPF in a\nseparate AS-external-LSA. It is not unusual for a single OSPF router to originate hun-\ndreds of LSAs; the link-state database may consist of many thousands.\nThe packet trace in Figure 13.4 shows the beginning of an OSPF protocol exchange\nbetween two neighboring routers, routers A and B. After the second Hello from router\nA indicates bidirectional connectivity, the two routers start describing the current con-\ntents of their link-state databases by exchanging OSPF Database Description packets.\nWhen router B notices that some of its LSAs are out of date or that it is missing other\nLSAs, it requests the LSAs from router A in OSPF Link State Request packets. Router A\nthen floods the requested LSAs to router B in OSPF Link State Update packets, just as if it\nwere flooding newly received LSAs.\nOSPF was designed with variable-length subnet masks in mind and always adver-\ntises the prefix mask instead of depending on Class A, B, and C network divisions.\nHowever, OSPF did require a bug fix when CIDR was deployed (see Section 3.7). A\nnew version of the OSPF protocol has been designed as an IPv6 routing protocol (Sec-\ntion 3.7).\n13.3 BGP\nThe Border Gateway Protocol (BGP) [208] is a Distance Vector BGP. BGP is the work-\nhorse of the Internet; routing information is exchanged between the Internet's ISPs\nusing BGP. Each ISP expends a considerable amount of its people resources managing",
        "0a8aec8b-e3af-43dd-a60d-c20da7a4f854": "Section 13.3 BGP 285\nSUMMARY Time Destination Source Summary\n21 2.2391 01005E000005 Router A OSPF Hello\n23 4.3046 01005E000005 Router B OSPF Hello\n29 12.2715 01005E000005 Router A OSPF Hello\n35 12.2832 Router A Router B OSPF Database Description\n36 12.2866 Router B Router A OSPF Database Description\n37 12.2878 Router B Router A OSPF Database Description\n38 12.4461 Router A Router B OSPF Database Description\n39 12.4479 Router B Router A OSPF Database Description\n41 12.5994 Router A Router B OSPF Link State Request\n42 12.6030 Router B Router A OSPF Link State Update\nOSPF:\nOSPF: Version = 2\nOSPF: Type = 4\nOSPF: Length = 504\nOSPF: Source Router ID = 2.160.14.67 (Router A)\nOSPF: Area ID = 0.0.0.0\nOSPF: Checksum = Oxl9cl\nOSPF: Authentication type = 1\nOSPF: Authentication data = 4152454130303030\nOSPF:\nOSPF:\nOSPF: 11 link state advertisement (s) follow.\nOSPF: Each displayed as (type, id,adv,seq,xsum, age) .\nOSPF:\nOSPF: (1, 11. 3. 0.10, 11. 3.0. 10, OxSOOOOOlb, 0x1957,1032)\nOSPF: ( 1,2. 160. 60. 7, 2. 160. 60. 7, 0x80000038, Ox3cc6, 81)\nOSPF: ( 1,11. 3. 0.3, 11. 3. 0.3, 0x80000019, Oxaefd, 112)\nOSPF: (1,6.6.6.6,6.6.6.6,0x80000048,0x8914,456)\nOSPF: ( 1,128. 185. 200. 1,128. 185. 200.1, 0x80000008, Ox30e2, 457)\nOSPF: (1, 10. 0.0. 5, 10. 0.0. 5, 0x80000070, Oxa6df, 462)\nOSPF: ( 1,4. 4. 4. 4, 4. 4. 4. 4, 0x80000044, OxfSbb, 471)\nOSPF: (2,15.2.1.9,2.160.60.7,0x80000003,0xe770,1031)\nOSPF: ( 2, 10. 0.0. 6, 6. 6. 6. 6, 0x80000005, Ox3dbf, 371)\nOSPF: (2,10.0.0.4,4.4.4.4,0x8000000a,0xf43c,471)\nOSPF: (5, 0.0. 0.0, 128. 185. 200.1, 0x80000001, Oxl7b6, 703)\nFigure 13.4 Packet trace showing the beginning of an OSPF protocol exchange.\nits BGP routing\u2014deciding which other ISPs to peer with, maintaining the access lists of\nprefixes that can be received from and sent to each peer, and debugging the inevitable\nrouting problems as they occur. Although BGP is the routing protocol that keeps the\nInternet running, it is used hardly at all in private TCP/IP networks. These networks",
        "128a1d9f-946a-4599-ae99-b3189b4d7c78": "286 Unicast Routing Protocols Chapter 13\ntypically run an IGP, such as OSPF; if they run BGP at all, they do so in only the single\nrouter that connects their network to the Internet. Figure 13.5 shows how BGP operates.\nFigure 13.5 Operation of BGP. Received BGP updates are stored in the BGP router's RIB-In. For each prefix,\nthe best route from the RIB-In is installed in the routing table and then advertised to the router's BGP peers.\nThe routers with which a BGP router X exchanges BGP information are called X's\nBGP peers. A BGP router's peers are configured by a network operator. To begin the\nexchange of BGP routing information with a peer, the BGP router sends a BGP Open\nmessage to the peer. If the peer also wishes to exchange BGP routing information, it\nresponds with its own BGP Open message. At this point, the two routers exchange rout-\ning tables by transferring a collection of BGP Update messages. Each update message\ncontains a list of prefixes and their BGP path attributes\u2014attributes being the equivalent\nof other routing protocols' metrics, which we discuss further later. After this initial\nexchange of routing tables, only changes are transmitted, again in BGP Updates. If\nchanges are infrequent, the peers exchange BGP Keepalives to keep the BGP session\nestablished. Receipt of a BGP Notification message informs the router that the BGP ses-\nsion has been terminated, either because of an error or by intentional action by the net-\nwork operator. When a session with a peer is terminated, all information learned from\nthe peer is deleted from the router's routing table.\nBGP differs from a standard Distance Vector protocol in two significant ways. First,\nrather than continually resending their routing tables, after the first exchange of routing\ntables, two BGP routers send each other only changes. Transmission of routing updates\nmust then be made reliable, which in BGP is accomplished by running over TCP. In\nstandard Distance Vector protocols, such as RIP, if the best route disappears, the RIP\nrouter will know that it will be notified of all possible alternatives within the next 30 sec-\nonds. In contrast, since a BGP router's peers transmit only changes, a BGP router must\nstore any alternative routes that it receives in order to recover from failures of the pri-\nmary route. BGP stores these alternative routes in a database called the RIB-In (Routing\nInformation Base-Inbound). The size of the RIB-In can be many times the size of the\nrouter's routing table.\nSecond, unlike standard Distance Vector algorithms, BGP always selects loop-free\npaths. To maintain loop-free routing a BGP router employs a simple mechanism: When\nadvertising a prefix, the complete path to the prefix is included. Since the purpose of the\nBGP protocol is to exchange routing information between Autonomous Systems, this\ncomplete path consists of the sequence of ASs (called the AS path) that are traversed as",
        "977fee4d-0f92-49b1-83a3-039def33f7d7": "Section 13.3 BGP 287\ndata traffic is forwarded from the advertising router to the destination prefix. A router\nthen avoids loops by never accepting an advertised prefix if the associated path already\nincludes the router's own AS number.\nLet's demonstrate this behavior by using the AS configuration of Figure 13.6 as an\nexample. If the prefix 200.19.8.0/24 belongs to AS 3, it would be advertised in BGP\nupdates from router A to router G (and from B to F and from B to I) with the AS path\n[AS 1, AS 2, AS 3]. If now the link between routers C and D fails, a standard Distance\nVector protocol could form a loop between routers C-A-G-H-I-B-C, until counting to\ninfinity removes the prefix from the routers' routing tables. However, BGP prevents the\nloop because the advertisement for 200.19.8.0/24 from router I to B would carry the AS\npath [AS 5, AS 4, AS 1, AS 2, AS 3], which B would reject after seeing its own AS, AS 1,\nalready in the path to the destination prefix.\nAlso unlike standard Distance Vector algorithms, BGP updates do not include a\nmetric for each prefix. Since BGP routing updates can be thought of as providing a list\nof paths instead of a list of distances, BGP is sometimes referred to as a Path Vector\nprotocol.\nFigure 13.6 Sample Autonomous System configuration.",
        "672c0122-c006-4227-acab-e4e1e3ed5227": "288 Unicast Routing Protocols Chapter 13\nType: BGP is a Distance Vector BGP.\nEncapsulation: BGP runs over TCP, using TCP port number 179. Running over\nTCP ensures the reliable, sequenced delivery of BGP routing messages between\nBGP peers. Although BGP information is carried within TCP's reliable byte\nstream, BGP information is still packetized. Each BGP packet has a 19-byte\nheader, with the maximum BGP packet size 4,096 bytes.\nPath characteristics: As seen earlier, BGP ensures that BGP routers find loop-free\npaths. However, the exact form that these paths take is determined by the rout-\ning policies configured by the network administrators. Unlike the other routing\nprotocols considered in this chapter, BGP has no metric that it is trying to mini-\nmize. Instead, when a BGP router receives a number of paths to any particular\ndestination, it chooses the most preferable path, based on configured policies. A\ncommon policy is to choose the path consisting of the fewest number of ASs.\nAnother common policy is to allow the network administrator to associate a\nweight with each AS. The weight is a positive integer, with ASs of smaller\nweight preferred. Each path is then assigned a weight equal to the sum of\nthe weights of its constituent ASs, with the paths having the smallest weight\ninserted into the routing table.\nNeighbor discovery and maintenance: A BGP router's peers are configured instead\nof being learned dynamically. When a BGP session is established between two\npeers, they exchange BGP Open messages and Keepalives. During the exchange\nof Open messages, the peers negotiate a Hold Time. If Hold Time is nonzero, no\nmore than Hold Time seconds can elapse between BGP messages (Keepalives or\nUpdates) received from the peer, or the peer will be declared unreachable and\nthe BGP session terminated.\nRouting data distribution: As in any Distance Vector protocol, BGP routers\nexchange routing tables in their routing updates. Each BGP Update message\na router sends has two parts (Figure 13.7). The first part lists prefixes that\nthe BGP router has deleted from its routing table; BGP calls these withdrawn\nroutes. Next comes a list of prefixes all having common BGP path attributes.\nBGP calls these prefixes Network Layer Reachability Information (NLRI); the path\nattributes include the AS path discussed earlier and other BGP path attri-\nbutes discussed later. Unlike the other routing protocols in this chapter, BGP\nUpdate messages are always sent directly to a peer; they are never broadcast\nor multicast.\nResponse to changes: As in any Distance Vector protocol, changes to the routing\ntable in one BGP router invoke a distributed recalculation, with the router send-\ning the changed parts of its routing table in BGP Update messages, which in\nturn cause its peers to recalculate their routing tables and to send Update mes-\nsages, and so on. However, advertising the AS path with each prefix prevents",
        "b6ca70a7-930e-4a86-a77e-7316860b5062": "Section 13.3 BGP 289\nFigure 13.7 Beginning of a BGP routing session.\ncommon Distance Vector convergence problems, such as counting to infinity\n(Section 13.1). To keep a prefix's AS path up to date, a BGP router prepends its\nown AS number to the prefix's existing AS path before transmitting the prefix\nin an Update message to a peer. In our example, if router G accepts and installs\ninto its routing table the update for 200.19.8.0/24 received from A having AS",
        "00aeb626-8241-4a3e-b73c-7eff0ea6ce7d": "290 Unicast Routing Protocols Chapter 13\npath [AS 1, AS 2, AS 3], it transmits the prefix to H with the prepended AS path\nof [AS 4, AS 1, AS 2, AS 3].\nRouting table calculation: The process of calculating routing table entries from the\nRIB-In is called the Decision Process. Based on configured policy information, a\npreferred path for each prefix is installed in the routing table. The Decision Pro-\ncess is invoked when the RIB-In changes\u2014when new BGP updates are received,\nor a BGP session with a neighbor terminates, causing all data received from\nthat neighbor to be deleted from the RIB-In. The Decision Process also must\nbe invoked on policy changes, as these changes may well affect which of the\nRIB-In's paths are preferred.\nRobustness/reliability: Unlike the operation of the other protocols in this chap-\nter, a BGP router does not refresh its routing information, instead sending up-\ndates only when changes occur. Since BGP runs over TCP, BGP Updates are\ndelivered reliably, in order, and free from corruption. However, implementa-\ntion or router hardware errors resulting in the corruption and/or deletion of\nparts of the BGP RIB-In are not rectified until BGP sessions are restarted\u2014a\nmanual process.\nAggregation: A network operator can configure a BGP router so that it aggre-\ngates routing information. Aggregating multiple routes into a single prefix\nposes a problem: What path should be advertised for the aggregate? For exam-\nple, suppose that in Figure 13.6, AS 1 is handing out pieces of two CIDR address\nblocks, 192.9.0.0/18 and 200.16.64.0/18, to its customers ASs 2-5. Router B is\nthen configured to aggregate the BGP information received from ASs 2-5 into\nthese two CIDR blocks before sending BGP updates to router F. But if the rele-\nvant part of router B's routing table is as pictured in Table 13.2, there is no ac-\ncurate AS path that can be used for either block. To solve this problem, BGP\nintroduces the concept of an AS set. Whereas an AS path (also called an AS\nsequence) indicates the exact sequence of ASs encountered on the way to the des-\ntination, an AS set indicates only the ASs that may be encountered somewhere\nalong the path. AS sequences and AS sets can be concatenated within a BGP\npath attribute. Using brackets to indicate AS sequences and braces to indicate\nAS sets, router B would advertise 192.9.0.0/18 with an AS path attribute of\n[AS 1, AS 2]{AS 3} and 200.16.64.0/18 with an AS path of [AS 1]{AS 2, AS 3,\nAS 4, AS 5} in its BGP updates to F.\nPolicy controls: BGP provides more opportunity for policy-based controls than\ndo the other routing protocols in this chapter, combining the routing filters com-\nmonly deployed in Distance Vector protocols with the additional information\nprovided by the AS path. BGP routers usually can be configured to accept a\ngiven set of prefixes, but only if they originated ultimately from a given AS.\nAlternatively, BGP routers usually can be configured to accept a different set of",
        "b591b346-e29c-4bae-8d74-0d3605479677": "Section 13.3 BGP 291\nTable 13.2 Aggregation Example Requiring AS Sets\nprefixes, but only if the paths to the prefixes go through a particular provider.\nSometimes these routing policies can even be configured automatically. ISPs\nmaintain databases, such as the RIPE database [215], that describe which pre-\nfixes belong to which providers, together with other information on BGP peer-\nings between ISPs. People have then written tools that convert these databases\ninto automatically generated BGP router configuration files.\n\u2022 Security: The first 16 bytes of a BGP message are reserved for authentication\npurposes. MD5-based authentication algorithms have been designed for BGP,\nsimilar to those used for RIPv2 and OSPF (Section 11.7.1). However, for BGP,\nthis kind of authentication alone cannot prevent simple denial of service at-\ntacks, such as inserting TCP Resets to break the BGP routers' underlying TCP\nsession. Preventing these attacks would require the deployment of additional\nsecurity mechanisms at the IP and/or TCP level.\nFigure 13.7 shows the beginning of a BGP session between the two routers 200.8.2.1\nand 200.8.2.2. After exchanging Open messages and Keepalives, the two routers send\neach other a full set of routing updates, starting with the BGP Update message sent by\n200.8.2.1. This update advertises eight prefixes, all having the AS path [AS 1367, AS 12],\nand a next hop of 200.8.2.1 (the advertising router itself). The setting of the Origin\nattribute to IGP in the update indicates that the eight prefixes belong to AS 12.\nThe other routing protocols in this chapter rely on an objective metric to converge\neventually on loop-free paths. The fact that BGP does not have a true routing metric\nand instead allows routers to pick their routes based on configured policies can lead to\nproblems\u2014grossly inconsistent policies can lead to routing oscillations and/or un-\nreachable destinations. For example, suppose in that Figure 13.6, router G has been\nconfigured to prefer sending traffic through AS 5 on its way to AS 1 and that similarly,Prefix AS path\n192.9.3.0/24 [AS 2, AS 3]\n192.9.17.0/24 [AS 2]\n200.16.67.0/24 [AS 4]\n200.16.68.0/24 [AS 4]\n200.16.75.0/24 [AS 5]\n200.16.80.0/24 [AS 2, AS 3]\n200.16.92.0/24 [AS 2]",
        "6db4b33e-fc51-4b99-845d-74a0a26410cc": "292 Unicast Routing Protocols Chapter 13\nrouter H has been configured to prefer using AS 4 as transit. G and H will initially find\ndirect routes to the prefixes in AS 1, but after exchanging BGP Updates, they will prefer\neach other briefly, until they each realize that a loop is formed and go back to their direct\nroutes. This process could then repeat indefinitely.\nBGP has undergone a number of revisions since it was first published in 1989 [137],\nCurrently version 4, referred to as BGP-4, is deployed in the Internet. Previous versions,\nBGP-2 and BGP-3, were also deployed in the Internet; BGP-4 is the first BGP version\ncapable of advertising CIDR prefixes.\nBGP was also modified to create the OSI Inter-Domain Routing Protocol (IDRP). There\nare three main differences between IDRP and BGP. First, although IDRP was created to\nadvertise OSI addresses, it can also advertise routes for other protocol suites at the same\ntime (similar to Integrated IS-IS; see Section 13.5). Second, a reliable transport for rout-\ning updates was built directly into IDRP rather than relying on an external protocol\nsuch as TCP. Finally, IDRP implements another level of routing hierarchy by allowing\nthe organization of ASs into clusters; similar support was introduced into BGP under\nthe term BGP confederations. IDRP is considerably more complicated than BGP and has\nnever seen any significant deployment.\nThe BGP used by IPv6 will undoubtedly be some form of BGP/IDRP. To date, the\nexact details of the resulting protocol are somewhat up in the air. The original intention\nof the IPv6 designers was to use IDRP, because it already supported the addressing\nflexibility to express IPv6 addresses. However, lately more effort has gone into devel-\noping multiprotocol extensions to BGP-4 [124] that can be used to carry IPv6 routing\ninformation.\nIBGP\nBGP information must be propagated across ASs. For example, in Figure 13.6, when\nrouter C learns BGP routing information from the neighboring AS 2, this information\nmust somehow be conveyed to routers A and B so that it can be readvertised to ASs 4\nand 6, respectively. In its original design, BGP accomplished this propagation by estab-\nlishing BGP peering sessions between the routers of AS 1: A, B, and C. These sessions\nbetween routers belonging to the same Autonomous System are called Internal BGP\n(IBGP) sessions; BGP sessions between routers belonging to different Autonomous Sys-\ntems are called External BGP (EBGP) sessions. Since IBGP routing exchanges are not pro-\ntected against looping by the AS path mechanism, within each Autonomous System,\nevery BGP router had to peer directly with every other BGP router. This situation is\ncalled full-mesh IBGP.\nBecause IBGP routing is not protected by AS path, policy inconsistencies between\nIBGP peers are potentially more serious than between EBGP peers, possibly resulting in\nrouting loops. These problems have been seen in some networks, with the default IBGP\npreferences specified in the BGP specification and implemented by the two most com-\nmon BGP implementations (Cisco and GATED) known to be at odds.",
        "3abc788d-6b3b-4a7d-ae23-f8fb5ceae910": "Section 13.3 BGP 293\nFull-mesh IBGP can strain the capacity of a BGP router. The more peers (IBGP or\nEBGP) a BGP router has, the greater the number of transport connections and the larger\nthe Routing Information Base. Ever since BGP was devised, people have been work-\ning on ways to avoid the full-mesh IBGP requirement. Several proposals have since\nemerged, with two of them, BGP route reflection and BGP confederations, seeing signif-\nicant deployment in today's Internet.\nIn both BGP route reflection and BGP confederations, the AS is divided into regions,\nor clusters. BGP routers internal to each region then need establish IBGP sessions only\nwith routers in their own region, with routers on the region boundaries establishing\nIBGP sessions with routers in other regions. Figure 13.8 shows a division of AS 1 into\nthree such regions, with each region containing three IBGP speakers.\nto AS 4 to AS 2\nto AS 5\nto AS 6\nFigure 13.8 Partitioning AS 1 to avoid a full IBGP mesh.\nIn BGP route reflection [17], one router in each region is designated the Route Reflec-\ntor (RR). Each other router in the region (collectively called the Route Reflector's client\npeers) establishes a single IBGP session to the Route Reflector. When the Route Reflector\nreceives an IBGP update from one of its client peers, the Route Reflector forwards (or\nreflects) the update to its other clients and also to its peers in other regions. In Fig-\nure 13.8, Al would be designated the Route Reflector for the leftmost region; IBGP up-\ndates received from A2 would be reflected by Al to router A and also sent to the\nRoute Reflectors in the two other regions (routers Bl and Cl). The various Route\nReflectors (routers Al, Bl, and Cl in our example) are connected together in a full",
        "783d6a02-6940-4aa1-ad49-74217165d0e0": "294 Unicast Routing Protocols Chapter 13\nIBGP mesh, and so, when properly configured, IBGP route reflection resists routing\nloops. IBGP route reflection also employs two mechanisms to prevent loops in the case\nof misconfiguration. To prevent loops within a region, the Route Reflector inserts its cli-\nent's BGP Identifier into the ORIGINATORJD attribute when reflecting the client's\nroutes. The Route Reflector then knows never to reflect these labeled routes back to the\noriginating client. To prevent loops between regions, each region is assigned a cluster\nID. When advertising IBGP updates to another region, the Route Reflector prepends its\ncluster ID to a new BGP path attribute called the CLUSTER_LIST, which in turn pre-\nvents intercluster loops, just as the BGP AS path prevents inter-AS loops.\nIn BGP confederations [248], the regions are called confederations. Within a single con-\nfederation, full-mesh IBGP is performed. To prevent interconfederation loops, each\nconfederation is assigned a confederation ID. A BGP router then prevents loops by\nprepending its confederation's ID to the AS path attribute when sending IBGP updates\nto other confederations. To keep the division into confederations from being visible out-\nside the AS, confederation IDs are later stripped from the AS path attribute at the AS\nboundary.\nBGP Route Servers [94] are another proposed alternative, similar in many respects to\nBGP route reflection. In this proposal, regions are called clusters. Each cluster is assigned\na Route Server, to which all other IBGP speakers in the cluster (called the Route Server's\nclients) establish IBGP sessions. An IBGP update received by a Route Server from a cli-\nent is sent to the other clients in the cluster and to the Route Server's IBGP neighbors in\nother clusters. To avoid looping within a cluster, each client inserts its BGP Identifier\ninto an ADVERTISER path attribute in updates sent to the Route Server. To prevent\nintercluster loops, cluster IDs are accumulated within an RCID path attribute similar in\nfunction to BGP's AS path.\nOne last alternative is to use the AS's Interior Gateway Protocol to propagate BGP\ninformation across the AS. The BGP-OSPF interaction document (Section 11.6.1) shows\nhow to use OSPF to propagate BGP routes for prefixes belonging to neighbor ASs\u2014that\nis, prefixes whose BGP AS path is of length 1. To propagate BGP information for pre-\nfixes having longer AS paths, a special OSPF LSA, called the external-attribute-LSA\n(Section 7.6) was designed but has never been deployed in a production network.\nBGP Path Attributes\nEach Update message contains a collection of path attributes and a list of prefixes shar-\ning the attributes. BGP attributes employ type-length-value (TLV) encoding. The current\nlist of BGP attribute types is given in [153] and is reproduced in Table 13.3. Some BGP\nattributes, such as the AS path, must be present in every Update message\u2014these are\ncalled mandatory attributes. Another category of attributes, the transitive attributes, are\ncarried unaltered from one BGP speaker to the next.",
        "d2a6ea06-5d94-449c-bc34-0d4069f74781": "Section 13.3 BGP 295\nTable 13.3 BGP Path Attributes\nType Code\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13BGP Attribute\nORIGIN\nAS_PATH\nNEXT_HOP\nMULTI_EXIT_DISC\nLOCAL_PREF\nATOMIC_AGGREGATE\nAGGREGATOR\nCOMMUNITY\nORIGINATORJD\nCLUSTERJJST\nDPA\nADVERTISER\nRCID_PATHCategory\nMandatory\nMandatory\nMandatory\nTransitive\nTransitive\nTransitive\nAs described earlier, the AS_PATH attribute is used to prevent BGP routing loops\nand also allows BGP to support certain routing policy configurations. The ORIGIN\nattribute indicates whether the AS path is complete. If the ORIGIN is set to IGP, the AS\npath is complete; otherwise (ORIGIN set to INCOMPLETE or BGP) the AS path may be\nonly a subset of the ASs encountered on the way to the destinations. Most BGP routers\ncan be configured to make policy decisions based on the ORIGIN attribute, although the\nmain use of this attribute was to mark those routes that were learned by the (now histor-\nical) BGP protocol during the EGP-to-BGP transition.\nThe NEXT_HOP attribute can be used by a BGP router to indicate that data should\nbe forwarded to an IP router other than the BGP router itself. Sometimes called third-\nparty routing information, a similar field was present in the BGP protocol's routing\nupdates, and there are similar concepts in other protocols, such as OSPF's forwarding\naddress. NEXT_HOP eliminates extra forwarding hops in some situations (see Sec-\ntion 11.6.1).\nMULTI_EXIT_DISC, LOCAL_PREF, and DPA are all metrics of a sort. When two\nneighboring ASs are connected at multiple points, one AS can use MULTI_EXIT_DISC\n(multiple exit discriminator) to inform the other AS which is the better entry point; the\nentry with the lower MULTI_EXIT_DISC value should generally be favored. A BGP\nrouter uses LOCAL_PREF (local preference) to tell its IBGP neighbors whether it should",
        "817b64a0-cd54-42df-892e-8bf93e6c0ec2": "296 Unicast Routing Protocols Chapter 13\nbe a preferred exit point from the AS; BGP routers advertising higher LOCAL_PREF\nvalues are usually chosen as exits. The DPA (destination preference attribute [40]) can be\nused by a router to bias the routing of its BGP neighbors. DPA has been proposed as a\nmechanism to encourage symmetric routing (that is, traffic going from A to B takes the\nsame path as traffic from B to A) in the Internet, although DPA has not been widely\ndeployed. All these three metrics are advisory. Any BGP router can be configured to\nignore them in favor of other routing policies.\nWhen it combines a collection of routes into a single aggregate, the BGP router\nadvertises the aggregate route with an AGGREGATOR attribute containing the router's\nAS number and IP address. This attribute is for information purposes only. Another\nattribute, ATOMIC_AGGREGATE, was intended to prevent certain advertised aggre-\ngates from being later deaggregated (that is, overridden by more specific prefixes) by a\nrouter's BGP peers; however, both the specification and implementation of this attribute\nseem to be minimal.\nThe COMMUNITY attribute [39] is used to group a collection of prefixes so that\nthey can be treated as a single unit by configured BGP policies. A few standard com-\nmunities are specified, such as the NO_EXPORT community\u2014prefixes tagged with\nNO_EXPORT will not be advertised out of their Autonomous System. Other communi-\nties can be established by each AS. For example, an ISP might want to create a separate\ncommunity for each of its customers. Using communities in this way would allow a pol-\nicy, such as \"Advertise the prefixes of customers A, B, and C to this peer only,\" to be\nconfigured without explicitly itemizing the prefixes that belong to A, B, and C. Al-\nthough labeled as transitive, the COMMUNITY attribute is commonly stripped at AS\nboundaries. The COMMUNITY attribute is similar in function to OSPF's external route\ntag (Section 3.2).\nThe remaining attributes implement loop prevention in the various alternatives to\nfull-mesh IBGP. ORIGINATORJD and CLUSTER_LIST are used by BGP route reflec-\ntion [17], and ADVERTISER and RCID_PATH are used by the BGP Route Server\nproposal [94].\nBGP Operational Issues\nThe BGP routers at an Autonomous System's boundary may have much larger routing\ntables than the routers interior to the AS. The question is, How do the routers internal to\nthe AS get enough routing information to participate in loop-free forwarding? If the AS\ndoes not provide transit services (that is, all traffic entering or leaving the AS has either\na local source or a local destination) the answer is easy: Just have the BGP routers im-\nport a default route into the IGP.\nTransit ASs have two alternatives for getting routing information into their interior\nrouters. First, they can leak enough BGP information into the IGP so that, combined\nwith a default route, the interior routers can make good forwarding decisions (Sec-\ntion 13.7). This brings up the subject of IGP synchronization. If the interior routers are",
        "5147596e-1323-4097-8899-97b1aa12651b": "Section 13.4 IGRP 297\nlearning BGP information through the IGP, the BGP routers on the other side of the AS\nshould not readvertise these routes to their EBGP peers until the appropriate IGP routes\nhave been installed. This is the general principle that a route should not be advertised\nunless it is being used for forwarding. For example, in Figure 13.6, router A would not\nreadvertise AS 3's networks to router G until these routes appear in AS 1's IGP routing.\nUsing these mechanisms, the default-free ASs at the core of the Internet would\nhave to leak the whole Internet routing table into their IGPs, which they are usually\nloathe to do. Instead they typically run IBGP between all their routers\u2014commonly\ncalled Universal IBGP. In these ASs, the IGP is relegated to the role of resolving BGP\nNEXT_HOP addresses. (Another alternative, which is to tunnel traffic between the BGP\nrouters, would work, although it has not been deployed, to my knowledge.)\nThe size of the routing tables in the Internet's core routers is always a concern. To\nkeep the routing tables small and to encourage aggregation, some of the backbone pro-\nviders refuse to accept BGP updates for prefixes longer than a certain length. To date,\nthe current limit is 18 bits, although addresses assigned before the advent of CIDR (for\nexample, Class C networks falling into 192/8) are usually excluded from this limit.\nBGP routing within the Internet has shown considerable instability, with a number\nof unexpected and pathological behaviors uncovered by studies (such as [132]) of BGP\ntraffic patterns. To reduce the amount of BGP routing oscillations, some BGP imple-\nmentations perform route dampening [254], whereby a BGP router seeing a prefix that\nis flapping (that is, is withdrawn and then reappears) will wait an interval before\nreadvertising the prefix; the more often the prefix flaps, the longer the router will wait\nbefore readvertising.\nWhen configuring BGP routing policies or when debugging BGP routing problems,\nyou often want to find the ISP (and the people contacts) associated with a particular AS\nnumber. For example, you may suddenly find that the routing table size in your routers\nhas doubled, with all new routes originating from a particular AS number. The Internic\nkeeps a list of AS number assignments [7]. Contact information for a particular AS can\nalso be obtained by using the command who is -h rs. internic. net \"as as-number\".\nThe ISP community has developed other tools to analyze BGP routing, such as\nASExplorer [6]. This tool can display the routes that are currently flapping in the\nInternet's BGP system, the nets that are currently being announced by any given AS,\ncontact information for the AS, and so on.\n13.4 IGRP\nThe Inter-Gateway Routing Protocol (IGRP) [96] is Cisco Systems' proprietary routing pro-\ntocol. IGRP is a Distance Vector IGP and is deployed in many Internet sites that use\nCisco routers. Cisco has also used IGRP to route other protocol stacks, such as OSI.\nIGRP is very similar to RIP. The main difference between the two protocols is their\nchoice of metrics. Instead of using hop count, an IGRP router advertises six separate",
        "b6f5ead8-2681-4bfc-ac61-db0b16bf956a": "298 Unicast Routing Protocols Chapter 13\npieces of information with each destination: (a) the static delay that packets will incur,\n(b) the amount of bandwidth provided by the path to the destination, (c) the current\ntraffic load on the path, (d) the path's error rate, (e) the path's MTU, and (f) the number\nof router hops to the destination. If it sees a routing advertisement from one of its neigh-\nbors, an IGRP router combines the first four of these factors into a single composite met-\nric that is inversely proportional to available bandwidth and proportional to both delay\nand error rate (for the exact equation, see [96]). If an IGRP router sees the same des-\ntination being advertised by multiple neighboring routers, it chooses the path going\nthrough the router that advertises the smallest composite metric. IGRP's composite\nmetric allows better path discrimination than RIP's hop count. For example, RIP can-\nnot discriminate between a 9,600-baud line and a Tl line, whereas IGRP's composite\nmetric can.\nIGRP's hop-count metric is used to terminate the counting-to-infinity behavior\nexperienced by IGRP and most Distance Vector protocols. When the number of hops to\na destination exceeds a configured value (set to 100 by default and not to exceed 255),\nthe destination is considered unreachable.\nIGRP is more aggressive than most routing protocols in trying to spread out traffic\nfor a single destination over multiple links (also called load sharing). Not only can traf-\nfic be spread across equal-cost paths (as is done in the OSPF and IS-IS protocols) but\nalso, with care, an IGRP router can be configured to load share over paths of relatively\nsimilar costs.\n\u2022 Type: IGRP is a Distance Vector IGP.\n\u2022 Encapsulation: IGRP runs directly over the Internet Protocol, as IP protocol 88.\n\u2022 Path characteristics: An IGRP router selects the path with the smallest composite\nmetric. For example, if two paths are otherwise equivalent, the path with the\nsmaller static delay is chosen. Or, if two paths differ only in their available\nbandwidth, the one having the higher available bandwidth is chosen.\n\u2022 Neighbor discovery and maintenance: IGRP has no neighbor discovery or mainte-\nnance procedures aside from the exchange of routing updates.\n\u2022 Routing data distribution: An IGRP router broadcasts its routing table to its\nneighbors every 90 seconds. For each destination, the IGRP router advertises six\nproperties of the path that the router is currently using to that destination: the\npath's static delay, provisioned bandwidth, current load, error rate, MTU, and\nhop count.\n\u2022 Response to changes: When its routing table changes, an IGRP router sends trig-\ngered updates rather than waiting for the next 90-second epoch. However,\nunlike RIP, each triggered update in IGRP advertises the full routing table.\n\u2022 Routing table calculation: When an update for a destination is received from a\nneighbor, the path's properties are modified to take into account the delay,",
        "9a300ff5-85c5-48ad-bda4-21ae78e10185": "Section 13.4 IGRP 299\nbandwidth, and error characteristics of the link to the neighbor. When an\nIGRP router receives updates for the same destination from two or more\nneighbors, the (modified) path having the smallest composite metric is in-\nstalled into the routing table and is then broadcast in the router's own IGRP\nupdates.\n\u2022 Robustness/reliability: To ensure that routing updates are delivered, an IGRP\nrouter sends a complete set of routing updates (describing the entire routing\ntable) every 90 seconds. If the receiving IGRP router goes 270 seconds without\nreceiving an update for a given destination, the router deems the destination\nunreachable.\n\u2022 Aggregation: Like RIP, IGRP automatically aggregates routing information at the\nboundary of a subnetted network. In the updated version of IGRP for CIDR\naddressing, called EIGRP, an EIGRP router can be configured to aggregate\nroutes into any CIDR prefix (similar to the address aggregation that may occur\nat OSPF area borders; see Section 6.1).\n\u2022 Policy controls: Routing policies are implemented by configuring routing filters,\nwhich tell the IGRP routers which routes they are allowed to receive and which\nroutes they are allowed to advertise. However, Cisco recommends that route\nfiltering be performed mostly at the edge of an IGRP routing domain. For\nexample, if two sets of routers did not want to exchange complete routing\ninformation, they could be broken into two separate routing domains; one or\nmore routers participating in both IGRP routing domains would control which\nroutes were advertised from one domain to the other (see Section 13.7).\n\u2022 Security: IGRP has no provisions to protect its routing protocol exchanges and\ndata from security attacks.\nTo improve on the basic Distance Vector convergence properties, IGRP employs\nsome of the same stabilizing mechanisms that are used by RIP. These mechanisms are\ntriggered updates, split horizon, and hold down (Section 13.1).\nUnlike the other routing protocols in this chapter, which express a default route as\nthe prefix 0.0.0.0/0, IGRP allows the network administrator to say, \"The default path\nshould follow the same path as packets to network X.\" For example, network X could\nbelong to your service provider. Hello, the original NSFNET's routing protocol, had\nsimilar logic, with the default path following network 10, the ARPANET'S network\nnumber.\nAlso like RIP, IGRP is not a \"classless\" routing protocol, assuming instead that the\nTCP routing domain consists of Class A, B, and C networks, possibly divided into fixed-\nsized subnets. In order to support CIDR addressing and also to improve the conver-\ngence properties of IGRP, Cisco developed Enhanced IGRP (EIGRP) [43].",
        "87ab430a-815a-4c1f-9a26-ce5e380609b2": "300 Unicast Routing Protocols Chapter 13\nEIGRP\nEIGRP not only is capable of advertising CIDR prefixes but also contains significant\nchanges in protocol mechanism and has improved convergence properties. EIGRP is\nstill a Distance Vector protocol, but by implementing the Distributed Update Algorithm\n(DUAL) of [82], it maintains loop-free paths even while the network changes, avoiding\ncounting to infinity. As with previous proposals for loop-free Distance Vector protocols,\nDUAL maintains loop-free paths by synchronizing the distributed routing calculations\nacross routers. This synchronization significantly complicates the basic Distance Vector\nalgorithm.\n\u2022 Hello messages are added to monitor the reachability of neighbors.\n\u2022 A reliable transport mechanism is added to ensure the reliable and sequenced\ndelivery of EIGRP messages between neighboring routers.\n\u2022 Instead of just keeping the best route, alternate loop-free routes must also be\nstored by the EIGRP router. If the best route has a cost of X, the alternate routes\nare those that are advertised by neighboring routers as having a cost less than X.\nIf the neighbor advertising the best route fails, one of the alternate routes is\nplaced into the routing table.\n\u2022 If the neighbor advertising the best route fails and there are no alternate paths,\nthe EIGRP router begins a new distributed calculation for a loop-free route\nto the destination by contacting its neighbors. A neighbor having a loop-free\nroute responds with the route; otherwise the neighbor contacts its neighbors.\nIn essence, requests for recalculation flood through the network until a new\nloop-free route is returned. During this recalculation, the destination remains\nunreachable, similar to a hold-down operation.\n13.5 Integrated IS-IS\nIntegrated IS-IS is an adaptation of the standard OSI connectionless data routing proto-\ncol, IS-IS, to be used for IP routing. Integrated IS-IS is also sometimes called Dual IS-IS.\nThe basic protocol mechanisms for Integrated IS-IS, including the data-link encapsula-\ntion, are defined in the IS-IS specification (ISO document 10589 [112]). The Internet's\nRFC 1195 [30] then defines how IP routing data is carried by the protocol and the\nrequired calculations to produce an IP routing table from this data. The resulting proto-\ncol can perform routing for the IP and OSI protocol stacks simultaneously; hence the\nterm integrated. (The creators of Integrated IS-IS coined the term Ships in the Night, or\nSIN for short, for the alternative of running separate routing protocols for each protocol\nstack.)",
        "d81342b3-ad97-4a19-a330-25d64e607a84": "Section 13.5 Integrated IS-IS 301\nIntegrated IS-IS is not widely deployed in the Internet but is run in a handful of\nlarge ISPs employing Cisco routers. Integrated IS-IS is a link-state IGP that resembles\nOSPF in many ways.\nThe OSI terminology used in IS-IS is a little difficult to follow for people who are\nfamiliar only with TCP/IP. Routers are called Intermediate Systems (ISs); hence the name\nIS-IS for the standard protocol spoken between ISs. The packets used by the routing\nprotocol are called Protocol Data Units (PDUs).\nThe individual pieces of the IS-IS link-state database are called link-state PDUs\n(LSPs). LSPs are distributed throughout the IS-IS routing domain by a reliable flood-\ning algorithm similar to OSPF's. IS-IS again uses the Dijkstra algorithm to calculate\nthe router's routing table from the collected LSPs. However, by restricting the\nmaximum path length to 1,024, IS-IS improves the performance of the standard\nDijkstra.\nRouting domains running Integrated IS-IS can be organized into a two-level\nhierarchy by splitting the routing domain into IS-IS areas.\n\u2022 Encapsulation: Integrated IS-IS runs directly over the data-link layer. For ex-\nample, when run over Ethernet, IP and Integrated IS-IS use separate Ether-\nnet type codes; when run over an ATM subnet, an encapsulation (such as\nLLC/SNAP [133]) that can distinguish IP traffic from IS-IS control traffic\nmust be used.\n\u2022 Path characteristics: A value between 1 and 32 is configured for each network\nsegment, called circuit by IS-IS. The cost of a path is then the sum of the path's\nconstituent circuit costs. IS-IS selects the least-cost path(s). Path cost cannot\nexceed 1,024, or the path is deemed unusable.\n\u2022 Neighbor discovery and maintenance: Neighboring ISs are discovered through the\nperiodic transmission and reception of IS-IS Hello PDUs (IIH PDUs). Each IIH\nPDU specifies a Hold Time: the number of seconds that the neighbor should\nmaintain reachability to the sending IS without receiving further IIH PDUs. The\nHold timer is set so that even if some IIH PDUs are dropped, the neighbor con-\nnection remains active.\n\u2022 Routing data distribution: An IS describes its local environment, for example, its\nattached circuits and their costs, IP prefixes, and so on, in at least 1 and not\nmore than 256 LSPs. These LSPs are then reliably flooded throughout the IS-IS\ndomain. The format of LSPs is rather free-form and easily extendable, with each\nLSP containing a sequence of TLV (type-length-value) encoded data items. A\nspecial LSP, called the pseudonode LSP, lists all of the ISs attached to a particular\ncircuit (the equivalent of OSPF's network-LSA). The collection of LSPs gener-\nated by all IS-IS routers forms the link-state database.",
        "58370cc5-3939-4cc1-96d6-311dc06dc07b": "302 Unicast Routing Protocols Chapter 13\n\u2022 Response to changes: Changes in the local environment of an IS cause it to update\none of its LSPs, originate a new LSP, or purge an LSP from the IS-IS routing\ndomain. Purging an LSP works as follows. Each LSP has a Lifetime field, the\nnumber of seconds remaining before the LSP is considered to be defunct. In\norder to purge an LSP from all ISs' link-state databases, the IS sets the LSP's\nLifetime to 0 and refloods the LSP.\n\u2022 Routing table calculation: IS-IS performs a Dijkstra calculation on the collection of\nLSPs, producing the routing table. The Dijkstra algorithm is made more effi-\ncient by limiting the path cost to values less than 1,024.\n\u2022 Robustness/reliability: In case LSPs are damaged or mistakenly discarded by an\nIS, each IS reoriginates its own LSPs every 15 minutes, whether or not the con-\ntents have changed. IS-IS also protects against flooding loops by decrementing\nan LSP's Lifetime by at least 1 at each flooding hop, and an LSP checksum field\ndetects LSP corruption during flooding or when held in the link-state database\nof an IS. IS-IS also ensures that a link is bidirectional before using the link in the\nDijkstra calculation.\n\u2022 Aggregation: In Integrated IS-IS, routing information can be aggregated at area\nboundaries before being advertised into the Level 2 subdomain.\n\u2022 Policy controls: As with OSPF, area boundaries can be configured to implement\ncertain policies. Data traffic stays within a single area if at all possible; if not,\npaths internal to the IS-IS routing domain are preferred over those that exit and\nreenter the domain.\n\u2022 Security: The PDUs of Integrated IS-IS may be authenticated. Only trivial\nauthentication, a clear password such as that used by the TELNET application,\nhas been completely defined for the protocol.\nBecause an IS can originate only a relatively small number (namely, 256) of LSPs, ISs\ntypically create large LSPs containing a mixture of data: interface costs, area informa-\ntion, external routing information, and so on. However, since IS-IS runs over the data-\nlink layer and does not have access to the fragmentation services of the network layer,\ncare must be taken so that the size of any LSP does not exceed the MTU of any segment\nwithin the IS-IS domain.\nAn IS describes a collection of LSPs, using Sequence Number PDUs. Partial Sequence\nNumber PDUs are used to acknowledge receipt of LSPs during the IS-IS reliable-\nflooding algorithm. Immediately after an IS discovers a neighboring IS, the two ISs\nsynchronize link-state databases. Synchronization is performed by each IS sending a\nfull summary of its link state-database, using Complete Sequence Number PDUs\n(CSNPs). After receiving the full set of Complete Sequence Number PDUs from the\nneighbor, an IS floods to its neighbor the LSPs that the neighbor is missing.",
        "62bd4da0-5ffe-4c2c-98e0-1ff01fb079d8": "Section 13.6 Historical Protocols 303\nTo simplify flooding over LANs, IS-IS elects a Designated Intermediate System for\neach LAN, similar to OSPF's Designated Router. However, unlike OSPF, IS-IS does not\nexplicitly acknowledge LSPs flooded over the LAN. Instead flooding reliability is\nachieved by having the Designated Intermediate System multicast a complete set of\nComplete Sequence Number PDUs onto the LAN every 10 seconds; in essence, the Des-\nignated Router is continually performing the full database synchronization with the\nother ISs on the LAN.\nIS-IS is a little more laissez faire about database synchronization than is OSPF. For\nexample, unlike OSPF, IS-IS does not require database synchronization over a circuit\nbefore the circuit is made available for data traffic. Also, because LSPs are not explicitly\nacknowledged on LANs, synchronization problems are somewhat more difficult to\ndetect in IS-IS, and the LSP purge operation is not absolutely reliable.\nThe area routing scheme in IS-IS is subtly different from OSPF's area routing. IS-IS\nrequires a single physically connected Level 2 subdomain, with areas (Level 1 subdomains)\ndirectly connected to it. Partitions of areas are automatically repaired by tunneling\n(Section 1.2.3) through the Level 2 subdomain. On the other hand, OSPF's central sub-\ndomain, called the OSPF backbone area, is not required to be physically connected, and\nOSPF has no provision to repair area partitions (see Chapter 6). IS-IS forces strict hier-\narchical routing between areas: Inter-area data traffic originating in one area follows a\ndefault route to the Level 2 subdomain, where it is forwarded by Level 2 routing to the\ndestination area. In comparison, OSPF allows data traffic to bypass the backbone area\nthrough configuration of OSPF virtual links (Section 6.1.2).\nIS-IS needed no modification to support CIDR addressing. The IS-IS protocol was\ndeveloped at the same time that OSPF was designed. OSPF considered, but did not use,\nIS-IS as a starting point; see Section 3.2 for more information.\n13.6 Historical Protocols\nWe have now discussed all the unicast routing protocols in use in the Internet today;\nmulticast routing protocols are discussed in Chapter 14, Multicast Routing Protocols.\nHowever, additional unicast routing protocols have been deployed in or designed for\nthe Internet in the past. They are mentioned briefly in this section for completeness; also\nincluded are further references for the interested reader.\nThe Gateway-to-Gateway Protocol (GGP) [101] was one of the Internet's first routing\nprotocols, a Distance Vector IGP run by the ARPANET'S routers when the ARPANET\nwas the core of the Internet. GGP had a couple of unusual features for a Distance Vector\nprotocol. To keep track of the state of a neighbor, a GGP router periodically sent GGP\necho messages, expecting GGP echo replies in response. When ;' out of n (typically two\nout of four) replies were received, the neighbor was declared operational; if k out of n\n(typically three out of four) echoes failed to provoke responses, the neighbor was",
        "5ab1c9f7-0f35-4073-aa8b-f4efab93d16c": "304 Unicast Routing Protocols Chapter 13\ndeclared down. This procedure allowed the routing protocol to reject links having\nexcessive error rates [146]. GGP also called for explicit acknowledgment of routing\nupdates, allowing a GGP router to send changes only to a neighbor instead of continu-\nally rebroadcasting the entire routing table. GGP shared packet formats with another\nprotocol that was being developed at the same time: EGP.\nThe Exterior Gateway Protocol (EGP) [162], [219] was the first instance of the class\nof Internet protocols called BGPs. Until replaced by BGP, EGP was the protocol used\neverywhere in the Internet for exchanging routing information between Autonomous\nSystems. EGP was a Distance Vector protocol that its designers felt did not have good\nenough convergence properties to be run over an arbitrary topology of ASs. For this rea-\nson, while running EGP, the Internet was forced into organizing its ASs into a strictly\nhierarchical tree structure. Since the AS topology was supposed to have no loops, BGP's\nrouting metric could be ignored (a metric being something to compare two different\npaths but there being only a single possible path in strict tree), earning EGP the reputa-\ntion of being a reachability protocol rather than a routing protocol. Experience with EGP\nwas a driving force in the design of BGP, from the compactness of routing updates\n(indexed by metric and next hop) to the way network administrators configured EGP\nto accomplish rudimentary forms of policy-based routing ([206]).\nThe Hello Protocol [161] was a Distance Vector IGP. Hello was deployed within the\noriginal NSFNET network, which consisted of LSI-11 routers (Fuzzballs) interconnected\nby 56K links. Hello's distinguishing feature was its choice of routing metric: measured\ndelay. As a result, Hello calculated least-delay paths for data traffic. When the NSFNET\ntransitioned to IBM RT routers and Tl links, the Hello Protocol was replaced by a rout-\ning protocol (called the NSFNET IGP [207]) based on an early version of the IS-IS proto-\ncol specification.\nInter-Domain Policy Routing (IDPR) [236] is a link-state EGP. Designed as a re-\nplacement for the Internet's EGP protocol, IDPR competed against BGP for widescale\ndeployment in the Internet and eventually lost. IDPR is capable of expressing very\nsophisticated routing policies. For example, using IDPR, an AS could specify that it only\nallows commercial traffic during the hours from midnight until 5A.M. IDPR also has\nsuperior security provisions, allowing digital signatures on routing information along\nthe lines of [190]. IDPR is considerably more complicated than other Internet routing\nprotocols, and its abandonment of the Internet's hop-by-hop routing paradigm proba-\nbly sealed its doom. In the Internet, every router makes an independent decision on\nhow to forward a packet, after consulting the router's routing table. In contrast, the first-\nhop IDPR router calculates the entire path of a datagram and then explicitly installs the\npath in all the IDPR routers on the way to the destination, a procedure sometimes called\nflow setup.",
        "101c550c-0dab-488a-85da-87bf526bd94b": "Section 13.7 Interaction among Routing Protocols 305\n13.7 Interaction among Routing Protocols\nAs we have shown in this chapter, TCP/IP has many routing protocols. As originally\ndesigned, routers within an AS were to run a common routing protocol (IGP) among\nthemselves, whereas a different routing protocol (BGP) was used to exchange routing\ninformation with other ASs. But in practice, routing in the Internet is a little more\nchaotic than originally designed, and it is not at all unusual for a router to be running\nthree or four different routing protocols simultaneously.\nWhen a router runs multiple routing protocols, it must arbitrate among them, per-\nforming the following tests on each learned route.\n1. When a route is learned from a routing protocol, should it be accepted and\ninstalled in the routing table, to be used when forwarding data traffic?\n2. When two or more routing protocols learn routes to the same destination, and\nall are acceptable, which route should be preferred?\n3. When should destinations learned by one routing protocol be readvertised by\nanother? If readvertised, what costs and other advertised parameters should be\nused?\nThese three tests are by no means independent. Only when a route passes test 1,\nthe route filter, will it be eligible to enter the preference contest in test 2. And only if\nthe route wins the preference test and is installed in the forwarding table will it be eli-\ngible for possible readvertisement by other routing protocols in test 3: A router readver-\ntising a route that it does not really use in forwarding may create routing loops or black\nholes.\nDesigning these tests is a difficult task. Route filters are essentially hop-by-hop pol-\nicy statements and work fairly well with Distance Vector algorithms, such as RIP and\nBGP. In fact, automated tools exist to generate BGP routing filters from Internet routing\npolicy databases, such as the RIPE database [215]. However, route filters in general can-\nnot be used on routes learned by the shortest-path calculation of a link-state routing\nprotocol such as OSPF.\nDeciding which routing protocol's route to prefer is made difficult because of the\ndifferent, incomparable routing metrics employed by the various protocols. OSPF\nassigns a 16-bit cost to each link, with no bound on path cost (Section 11.3.1). RIP uses\nhop count, with a maximum hop count of 16 (Section 13.1). BGP, like its precursor, BGP,\nreally has no metric, making all of its routing decisions based on user-defined policies\n(Section 13.3). Integrated IS-IS assigns a cost of 1 to 32 to each link, with path cost\ncapped at 1,024 (Section 13.5). And the list goes on.\nThese differing metrics also make it difficult to readvertise routes from one protocol\nto another. Should you try to translate the metric from one protocol into another or sim-\nply require the network administrator to configure the advertised costs? Either way,",
        "18983a12-28da-4fac-a057-859be9c7e6ac": "306 Unicast Routing Protocols Chapter 13\nsome information is lost when readvertising, which may lead to routing loops in some\ncircumstances. This information loss during readvertisement is the reason why IBGP is\nused to transport BGP routing information across ASs rather than just importing the\nBGP information into the IGP at one side of the AS and the readvertising back into BGP\nat the other (although you can make an IGP carry full BGP information in some cases;\nsee Sections 7.6 and 11.6.1). There are other issues besides differing metrics that make\nreadvertisement difficult. For example, not all routing protocols can even express the\nsame set of destinations\u2014RIPvl, still in common use today, cannot express general\nCIDR prefixes but is instead limited to the traditional Class A, B, and C networks with\nfixed-sized subnets (see Section 1.2.2).\nThere are very few documents describing the interaction of multiple routing proto-\ncols. RFC 1812, Requirements for IP Version 4 Routers [12], has a few sections explaining\ngeneral principles for arbitrating between multiple protocols and readvertising infor-\nmation from one protocol to another. Although at one point it looked as though the IETF\nwas going to attempt to write documents defining the interaction between every pair of\nInternet routing protocols, the only document written to date is the one describing\nOSPF-BGP interaction (see Section 11.6.1).\nNonetheless all router vendors have been forced to design interactions between the\nvarious routing protocols they support, and by now, all vendors support a common core\nfunctionality. They all allow you to specify which destinations you are willing to accept\nfrom a given routing protocol, and, depending on protocol, you can filter on additional\nparameters. For example, using RIP, you can usually say that you will accept a route but\nonly if it is received from a particular RIP neighbor. When using BGP, you can specify\nthat the route have a given AS path or that it originated from a particular AS, and so on.\nTo arbitrate among multiple protocols wishing to write the same routing table entry,\nthey usually allow you to associate a preference value with each accepted route. And\nthe vendor usually allows you to specify the exact list of networks to readvertise into a\nrouting protocol, together with costs and other protocol-specific advertised attributes,\nsuch as the ability to modify advertised AS paths in BGP. To be sure, this leaves a lot of\nthe responsibility for making things work with the network administrator who creates\nall this configuration, but such is the state of the art.\nLet us use the GATED program [83] as an example. Suppose that our GATED box is\ntalking BGP to neighboring AS 174, from which we are willing to accept the networks\n18/8,192.1/16, and 199.18.93/24 but no others. Suppose that our GATED box is also\ntalking RIP to router 10.1.4.200, from which we are willing to accept only 199.18.93/24\nand 200.2.67/24. Furthermore, if we receive 199.18.93/24 from both BGP and RIP, we\nwant the RIP route to win. Finally, we want the RIP routes, but not the BGP routes,\nimported into OSPF as external Type 2 routes of cost 1. This leads to the configuration\nfile depicted in Figure 13.9.",
        "32e660e7-c321-4191-8231-d80bbab933c4": "Section 13.7 Interaction among Routing Protocols 307\nFigure 13.9 Interaction between routing protocols in GATED.\nFurther Reading\nThe book Routing in Communications Networks by Steenstrup [237] provides a good\ndescription of routing algorithms used in packet-switching networks, such as the Inter-\nnet. The book also covers routing in circuit-switched networks; high-speed networks,\nsuch as optical networks; and mobile networks, such as cellular and packet-radio\nnetworks.\nFor information on how the Internet's BGP routing is configured and managed, see\nInternet Routing Architectures by Halabi [89].import proto bgp autonomoussystem 174 {\n18.0.0.0 exact;\n192.1.0.0 masklen 16 exact;\n199.18.93.0 exact preference 2;\n}\nimport proto rip gateway 10.1.4.200 {\n199.18.93.0 exact preference 1;\n200.2.67.0 exact;\n}\nexport proto ospfase type 2 metric 1 {\nproto rip gateway 10.1.4.200 {\n199.18.93.0 exact;\n200.2.67.0 exact;\n}\n}",
        "26aae293-3610-434b-9ee2-93183a1ee7ef": "H\nMulticast Routing Protocols\nIn this chapter, we compare and contrast the multicast protocols that have been devel-\noped for the Internet: DVMRP, MOSPF, PIM Dense, PIM Sparse, and CBT. This chapter\nbuilds on the basic information presented on multicast routing in Chapter 9. In particu-\nlar, throughout this chapter, we use the multicast network shown in Figure 9.1 and the\ncorresponding source-based trees and shared trees in Figures 9.3 and 9.4 to illustrate the\noperation of each protocol.\nAs summarized in Table 14.1, these protocols can be split into two categories: those\nthat produce source-based trees and those that construct a shared tree.\nTable 14.1 Categorization of Internet Multicast Protocols. (Asterisks\nindicate that the protocol relies on unicast routing to locate multicast sources.)\nShared Tree\nPIM Sparse*\nCBT*Source-Based Trees\nBroadcast-and Prune\nDVMRP\nPIM Dense*Domainwide Reports\nMOSPF\nThe categories that we used for unicast routing protocols in Chapter 13 also apply\nsomewhat to multicast routing protocols. The Distance Vector versus link-state debate is\nalso present in the multicast routing arena. A router running a source-based protocol\nneeds to know where a multicast source is, in order to calculate the router's place on the\n309",
        "538834c7-7f65-412b-9df7-49d93ff14a73": "310 Multicast Routing Protocols Chapter 14\ndatagram's path, if any. DVMRP advertises source information using a standard Dis-\ntance Vector mechanism. MOSPF, on the other hand, advertises its sources by using\nOSPF's link-state routing mechanisms. But a third mechanism is possible for a source-\nbased multicast routing protocol: You can simply get the source information from the\nunicast routing, employing reverse-path forwarding (also called reverse-path broadcast-\ning; see Section 9.3) to construct the path of each multicast datagram. This is the strategy\nof the Protocol Independent Multicast, Dense Mode (PIM Dense) protocol. Both PIM\nSparse and CBT also depend on unicast routing so that their routers can forward multi-\ncast packets to the shared tree's RP for further distribution down to the leaves. In fact,\nthe \"protocol independent\" in PIM is a reminder that any unicast routing protocol can\nserve this function.\nRelying on unicast routing has its advantages. Unicast routing is ubiquitous in the\nInternet, and protocols that do not advertise source (or RP) routing information do not\nhave to worry about routing updates and convergence times. However, relying on uni-\ncast routing makes incremental deployment difficult. DVMRP and MOSPF can handle\nsituations in which multicast and unicast paths diverge (that is, they can forward multi-\ncast datagrams around nonmulticast routers), whereas the other protocols in this chap-\nter require that the unicast path to the multicast source (or RP) consist completely of\nmulticast-capable routers.\nIn the multicast equivalent of the IGP-EGP split, there are intradomain and\ninterdomain multicast routing protocols. MOSPF, since it is built on top of an OSPF rout-\ning domain, is clearly an intradomain protocol. DVMRP and PIM Dense are definitely\nalso more suited to intradomain use, although DVMRP plays both the intradomain and\ninterdomain role on the MBONE. Both PIM Sparse and CBT were originally conceived\nas interdomain routing protocols, designed within the lETF's Inter-Domain Multicast\nRouting (IDMR) Working Group. However, due to difficulties in incremental deploy-\nment and in automated RP (core) placement, it now looks as though both protocols will\nbe initially deployed as intradomain protocols instead.\n14.1 Broadcast-and-Prune Protocols\nSource-based multicast protocols can be further divided into broadcast-and-prune pro-\ntocols versus those protocols that broadcast their group membership information (these\nlatter broadcasts are sometimes called domainwide reports). In a broadcast-and-prune\nprotocol, the source-based tree is initially built to encompass all network segments,\nregardless of group membership. The first multicast datagram will be sent along this\ninitial tree. A router at a leaf of this tree may receive the datagram and realize that it has\nno group members on its attached segments. If so, the router indicates that it does not\nneed to receive these datagrams anymore, by sending Prune messages to its upstream\nneighbor. This neighbor may in turn send a Prune to its upstream neighbor, and so on,\nuntil the tree has been rolled back to reach only group members.",
        "7b01f80f-f160-4c35-9648-773834480ad6": "Section 14.1 Broadcast-and-Prune Protocols 311\nFigure 14.1 shows an example from our sample multicast network. A multicast\ndatagram with source SI and destination Gl is initially forwarded to two segments\nwithout group members: 128.4.1/24 and 128.4.2/24. This causes R8 and R9 to send\nPrunes to R7, R7 to R4, and so on, until the tree on the lower left of Figure 9.3 is attained.\n192.5.1/24\nFigure 14.1 Operation of a broadcast-and-prune protocol.\nPrune information is eventually deleted, to make the routing robust in the face of\nunexpected failures (implementation bugs and so on). This deletion causes the pruning\nprocess to periodically begin anew. If a new group member appears on a segment not\ncurrently on the tree, Graft messages are forwarded toward the source to extend the tree\nto the new group member. Graft messages need to be reliable, and so they are retrans-\nmitted until acknowledged. In Figure 14.1, if a host on 128.4.1/24 were to join Gl, grafts\nwould be sent from R8 to R7, R7 to R4, and so on, until the branch R1-R2-R4-R7-R8 is\ngrafted onto the tree.\nMOSPF, on the other hand, is an example of a protocol that broadcasts its group\nmembership information throughout the routing domain. This allows MOSPF to restrict\nthe initial tree to group members only, avoiding the broadcast-and-prune procedure\nentirely.\nOne other useful concept when discussing these protocols is data-driven versus\ncontrol-driven actions. Data-driven actions occur in a router during the process of for-\nwarding a multicast datagram. Examples include MOSPF routers building multicast",
        "720cde39-09eb-43ef-b17d-4a9b99b303b0": "312 Multicast Routing Protocols Chapter 14\ncache entries, DVMRP routers sending Prunes, and PIM routers sending Assert\nmessages. Control-driven actions occur because of the reception of routing protocol or\nIGMP messages, or external events, such as link failures. Examples of control-driven\nactions include the sending of Grafts in DVMRP, the broadcast of group information in\nMOSPF, and the creation of a branch of the shared tree in CBT.\n14.2 DVMRP\nThe original design of the Distance Vector Multicast Routing Protocol (DVMRP) was docu-\nmented in [255]. By the time that DVMRP was first implemented, by the UNIX mrouted\nprogram, the protocol had changed considerably. The mrouted code served as the\nDVMRP specification for several years, until the code was reverse engineered and an\nup-to-date DVMRP written specification was produced [202]. Even today, mrouted\nchanges more quickly than the DVMRP specification can keep up. Almost all of the\nMBONE consists of multicast routers running DVMRP.\nDVMRP is a broadcast-and-prune protocol that employs Distance Vector technol-\nogy to advertise multicast sources. DVMRP uses IGMP's encapsulation. All DVMRP\npackets are encoded as IGMP Type 0x13, with the second byte of the IGMP header indi-\ncating the DVMRP packet type. There are separate DVMRP packet types for neighbor\ndiscovery (DVMRP Probes), distribution of multicast source information (DVMRP\nRoute Reports), tree maintenance (DVMRP Prunes, Grafts, and Graft Acks), and for\nmonitoring DVMRP routers (DVMRP Ask Neighbors 2 and Neighbors 2).\nEach DVMRP router periodically broadcasts to its neighbors a list of sources and the\ndistance from these sources to the router. In this way, a DVMRP router can calculate\nthe previous hop on each multicast source's path, just as RIP calculates the next hop to\nthe destinations it advertises: The previous hop on a source's tree is the DVMRP router\nthat is advertising the shortest distance/rom the source. This calculation has all the con-\nvergence problems normally associated with a Distance Vector protocol (see Sec-\ntion 13.1), although DVMRP attempts to improve convergence by employing the\ntechniques of split horizon with poison reverse and hold down.\nIn order to start the prune process, each router in a broadcast-and-prune protocol\nneeds to know whether it is the leaf of a particular source's broadcast tree. In DVMRP,\nthis is accomplished via reception of Route Reports. For example, in Figure 14.1, router\nR7 knows that it is not a leaf for source SI, because both routers R8 and R9 indicate that\nthey are downstream by setting the cost of SI to infinity in Route Reports sent back to\nR7 (in DVMRP, R8 and R9 are said to be subordinate to R7). R7 then knows that it cannot\nsend prunes upstream until prunes have first been received from both R8 and R9.\nRoute Reports are also used to get rid of equal-cost paths to group members. At the\ntop of Figure 9.3, routers RIO and Rll would both be sending DVMRP Route Reports\nonto segment 192.7.1/24, advertising source S2 with the same cost. On receiving each\nother's Route Reports, the two routers would agree that the router having the smaller IP",
        "a13adfe2-e3e8-4c6c-8888-c13d53169b0e": "Section 14.3 MOSPF 313\naddress (assumed to be RIO in this case) is responsible for forwarding multicasts from\nS2 onto the segment.\n14.3 MOSPF\nThe Multicast Extensions to OSPF (MOSPF) [171] is a source-based multicast routing\nprotocol. MOSPF, described in detail in Chapter 10, allows introduction of a multicast\nrouting capability to an OSPF routing domain. MOSPF has seen considerable deploy-\nment in private internets, and limited deployment at the edges of the MBONE. MOSPF\nrouters can interoperate with regular, nonmulticast OSPF routers, and MOSPF capabil-\nity can be introduced piecemeal into an OSPF routing domain.\nMOSPF introduces no new OSPF packet formats but does add a new LSA, the\ngroup-membership-LSA, and flags MOSPF-capable routers by setting an appropriate\nbit in their router-LSAs. Group membership is broadcast throughout the entire MOSPF\nrouting domain by flooding group-membership-LSAs.\nCreation of MOSPF multicast routing entries is data driven. The first time a MOSPF\nrouter sees a datagram with a given source and destination group, the router performs\na Dijkstra SPF calculation rooted at the datagram source. Non-MOSPF routers are\navoided by this calculation, and since the location of group members is known in\nadvance, the resulting tree extends only to active group members. In MOSPF, tiebreak-\ners are introduced to the Dijkstra calculation so that all MOSPF routers produce exactly\nthe same tree.\nWhen the state of the network changes\u2014for example, a link goes inoperational,\ngroup membership changes, and so on\u2014updated LSAs are flooded, describing the new\nnetwork state. When a MOSPF router receives one of these updated LSAs, the router\ndeletes all multicast routing table entries that might possibly change, knowing that they\nwill be recreated by the next matching data packet.\nSince MOSPF routers have a global view of the routing domain, supplied by the\nlink-state database, the routers can perform a special forwarding optimization. By\nexamining a multicast datagram's TTL, a MOSPF router can tell when a multicast data-\ngram has no chance of reaching the nearest group member. In these cases, rather than\nwaste network bandwidth by forwarding the datagram, a MOSPF router simply dis-\ncards the datagram instead. This is advantageous when hosts are performing expanding\nring searches (Section 10.1.1).\nIn order to deploy MOSPF in the MBONE, the interactions between MOSPF and\nDVMRP have been defined (Section 10.6). MOSPF has a hierarchical multicast capabil-\nity, used between areas and when multicasting datagrams to members outside of the\nAS. When so doing, MOSPF has incomplete group membership information and so\nrequires certain routers at the area borders/AS boundary to receive all multicast data-\ngrams, regardless of destination. Unfortunately this means that some datagrams get",
        "3794048a-9a81-4ae4-9224-ee5ca274b56d": "314 Multicast Routing Protocols Chapter 14\nforwarded into areas of the routing domain that have no group members, wasting net-\nwork bandwidth in the process.\n14.4 PIM Dense\nProtocol Independent Multicast, Dense Mode (PIM Dense) [60] can be thought of as\nDVMRP without the routing updates. PIM Dense is a source-based, broadcast-and-\nprune protocol that uses unicast routing to build reverse-path forwarding trees. The\n\"dense\" refers to the PIM designers' belief that PIM Dense mechanisms are more appro-\npriate when group members are densely populated throughout the routing domain.\nWhen group members are few and scattered, PIM Sparse (Section 14.5) is thought to be\na better protocol.\nBoth PIMs run directly over IP, using IP protocol 103. In PIM Dense, there are mes-\nsage types to detect neighboring PIM routers (PIM Helios) and to perform maintenance\nof source-based trees (PIM Join/Prunes, Grafts, and Graft Acks).\nPIM Dense must supply mechanisms for two functions that are implemented by\nDVMRP Route Reports: leaf detection and removal of equal-cost paths. For leaf detec-\ntion, a PIM router can tell whether any other PIM routers are on a network segment by\nwhether it is receiving PIM Helios. The PIM router then assumes that all neighbors are\ndownstream for any given source; if a neighbor is not downstream for a given source, it\nwill simply send a PIM Prune message.\nRemoval of equal-cost paths is data driven. Again using the example at the top of\nFigure 9.3, if this network is running PIM Dense, the first datagram sent from S2 to Gl\nwill be multicast twice onto segment 192.7.1/24, once by RIO and once by Rll. On\nreceiving these data packets from segment 192.7.1/24, which is different than the correct\nincoming interface for source S2, RIO and Rll both multicast PIM Assert messages onto\n192.7.1/24. Asserts contain metrics; on receiving each other's Assert, the two routers\nwill agree that only the router advertising the smaller metric will continue forwarding\nmulticasts from S2 onto the segment.\nCisco has implemented both PIMs (Sparse and Dense), together with a gateway\nfunction to DVMRP, allowing deployment of PIM in some places at the edge of the\nMBONE.\n14.5 PIM Sparse\nProtocol Independent Multicast, Sparse Mode (PIM Sparse) [70] is one of two shared-\ntree multicast routing protocols developed by the lETF's IDMR Working Group. PIM's\nunique feature is that the forwarding of multicasts matching a particular source and\ndestination group can be shifted off the group's shared tree onto a source-based tree,\npresumably when the traffic levels warrant the more efficient paths produced by a",
        "86e443ce-b9a4-4ecd-8cec-b56bcf5cbc78": "Section 14.7 Interaction among Multicast Routing Protocols 315\nsource-based scheme (Section 9.3.1). PIM Sparse shares packet formats with PIM\nDense, running directly over IP, using IP protocol 103. PIM Sparse contains message\ntypes to detect neighboring PIM routers (PIM Helios), maintain the shared tree\n(PIM Join/Prunes and Asserts), switch from shared trees to source-based trees\n(PIM Register and Register-Stop messages), and select Rendezvous Points, or RPs\n(PIM Bootstrap and Candidate-RP-Advertisement messages).\nPIM Sparse elects a Designated Router for each network segment. When one of the\nnetwork segment's hosts joins a group Gl, the Designated Router sends Join messages\ntoward Gl's RP to add a new branch to the shared tree. The state of the shared tree is\nperiodically confirmed by resending Joins toward the RP.\nBranches of the shared tree are torn down when hosts leave a group. In this case,\nPrune messages are forwarded toward the RP. Branches are also torn down when uni-\ncast routing indicates that the best path toward the RP has changed. A new branch will\nthen be grafted at the next Join refresh.\n14.6 CBT\nCore Based Trees (CBT) [16] is the other shared-tree multicast routing protocol de-\nveloped by the lETF's IDMR Working Group. CBT, which has not yet been deployed\nin the Internet, runs directly over IP, using IP protocol 7. Separate message types\nare used to elect a Designated Router on LANs (CBT Helios) and to perform mainte-\nnance of the shared tree (CBT JOIN_REQUEST, JOIN_ACK, QUIT_NOTIFICATION,\nECHO_REQUEST, ECHO_REPLY, and FLUSH_TREE messages).\nWhen a host joins a multicast group, the host's Designated Router forwards\nJOIN_REQUESTs to the group's core, adding a branch to the group's shared tree. Con-\nstruction of the branch is confirmed by forwarding JOIN_ACKs in the reverse direction.\nThe state of the shared tree is periodically verified by sending ECHO_REQUESTs\nand ECHO_REPLYs between neighboring CBT routers on the shared tree. If a CBT\nrouter's upstream neighbor (the CBT router one hop nearer the core) is determined\nto be inoperational, the downstream branches of the tree are removed, using the\nFLUSH_TREE messages, and then these branches are reconstructed from the leaves,\nusing the JOIN__REQUEST mechanism. When the host leaves a group, the host's branch\nis removed by sending QUIT_NOTIFICATIONs toward the core.\n14.7 Interaction among Multicast Routing Protocols\nThe interaction among multicast routing protocols is not nearly as well developed as\nthat among unicast routing protocols. Multicast routing interactions are more difficult\nthan unicast interactions. Multicast protocols must agree on a single, strict tree for each\nmulticast datagram, and not all multicast protocols even agree on the number of trees",
        "c282983e-28f4-4160-83cf-8504677b34b5": "316 Multicast Routing Protocols Chapter 14\nthat should be constructed\u2014the source-based protocols construct a tree for each source\nand destination group combination, whereas the shared-tree protocols construct a single\ntree for each group.\nHowever, progress has been made in connecting specific multicast protocols (Sec-\ntion 10.6), and routers have been developed that attach MOSPF and PIM domains to\nthe MBONE's DVMRP. Proposals have also started coming out of the IDMR Working\nGroup for the way that interactions among various multicast routing protocols should\nbe structured [15], [244], [245].",
        "5d348473-7c1d-4b2a-bd30-230eb1627ec5": "Bibliography\n1. Address Lifetime Expectations (ALE) Working Group.\n<http : //www. ietf. org/proceedings/ 94d.ec/ipng/ale .html>.\n2. Alaettinoglu, C, T. Bates, E. Gerich, D. Karrenberg, D. Meyer, M. Terpstra, and\nC. Villamizer. Routing Policy Specification Language (RPSL), April 1997.\n3. Almquist, P. Type of Service in the Internet Protocol Suite. RFC 1349, July 1992.\n4. Armitage, G. Support for Multicast over UNI 3.0/3.1 based ATM Networks. RFC 2022,\nNovember 1996.\n5. Armstrong, S., A. Freier, and K. Marzullo. Multicast Transport Protocol. RFC 1301,\nFebruary 1992.\n6. ASExplorer. <http: //www .merit. edu/ipma/asexplorer>.\n7. ASN Numbers. <f tp: //rs . internic. net/netinf o/asn. txt>.\n8. ATM Forum Technical Committee. LAN Emulation over ATM, Version 1.0, January 1995.\n9. ATM Forum Technical Committee. Private Network-Network Interface, Specification\nVersion 1.0 (PNNI 1.0), March 1996.\n10. Baker, F. IP Forwarding Table MIB. RFC 1354, July 1992.\n11. Baker, F. IP Forwarding Table MIB. RFC 2096, January 1997.\n317",
        "49145fae-62cb-448c-ac68-3b18c5f0f7bf": "318 OSPF: Anatomy of an Internet Routing Protocol Bibliography\n12. Baker, F. Requirements for IP Version 4 Routers. RFC 1812, June 1995.\n13. Baker, P., and R. Atkinson. RIP-2 MD5 Authentication. RFC 2082, January 1997.\n14. Baker, P., and R. Coltun. OSPF Version 2 Management Information Base. RFC 1850,\nNovember 1995.\n15. Ballardie, T. Core Based Trees (CBT version 2) Multicast Border Router Specification for\nConnecting a CBT Stub Region to a DVMRP Backbone. Work in progress.\n16. Ballardie, T. Core Based Trees (CBT version 2) Multicast Routing Protocol Specification. RFC\n2189, September 1997.\n17. Bates, T., and R. Chandra. BGP Route Reflection, An Alternative to Full Mesh /BGP. RFC\n1966, June 1996.\n18. Bellman, R. Dynamic Programming. Princeton University Press, 1957.\n19. Berkowitz, H. Router Renumbering Guide. RFC 2072, January 1997.\n20. Bertsekas, D., and R. Gallagher. Data Networks, 2nd ed. Prentice Hall, 1992.\n21. Braden, R. Requirements for Internet Hosts\u2014Application and Support. RFC 1123, October\n1989.\n22. Braden, R. Requirements for Internet Hosts\u2014Communication Layers. RFC 1122, October\n1989.\n23. Braden, R., and J. Postel. Requirements for Internet Gateways. RFC 1009, June 1987.\n24. Braden, R., J. Postel, and Y. Rekhter. Internet Architecture Extensions for Shared Media.\nRFC 1620, May 1994.\n25. Bradley, T., and C. Brown. Inverse Address Resolution Protocol. RFC 1293, January 1992.\n26. Bradner, S., and A. Mankin. IPng: Internet Protocol Next Generation. Addison-Wesley,\n1996.\n27. Brodnik, A., S. Carlsson, M. Degermark, and S. Pink. Small Forwarding Tables for Fast\nRouting Lookups. ACM SIGCOMM '97, September 1997.\n28. Cain, B., S. Deering, and A. Thyagarajan. Internet Group Management Protocol, Version 3.\nWork in progress.\n29. Callaghan, B., B. Pawlowski, and P. Staubach. NFS Version 3 Protocol Specification. RFC\n1813, June 1995.\n30. Gallon, R. Use of OSIIS-IS for Routing in TCP/IP and Dual Environments. RFC 1195,\nDecember 1990.\n31. Carnegie-Mellon University. CM.U SNMP archives.\n<f tp : //^Lancaster. andrew. emu. edu/pub/smnp-dist>.",
        "c6fc302d-4fa6-4982-b076-8e792fed08e5": "Bibliography OSPF: Anatomy of an Internet Routing Protocol 319\n32. Case, J., K. McCloghrie, M. Rose, and S. Waldbusser. Introduction to Version 2 of the\nInternet-Standard Network Management Framework. RFC 1441, May 1993.\n33. Case, J., K. McCloghrie, M. Rose, and S. Waldbusser. Protocol Operations for Version 2 of\nthe Simple Network Management Protocol (SNMPv2). RFC 1905, January 1996.\n34. Case, J., K. McCloghrie, M. Rose, and S. Waldbusser. Structure of Management\nInformation for Version 2 of the Simple Network Management Protocol (SNMPv2). RFC\n1902, January 1996.\n35. Case, J., K. McCloghrie, M. Rose, and S. Waldbusser. Textual Conventions for Version 2 of\nthe Simple Network Management Protocol (SNMPv2). RFC 1903, January 1996.\n36. Casner, S. Frequently Asked Questions (FAQ) on the Multicast Backbone (MBONE).\n<f tp://ftp.isi.edu/mbone/faq.txt>, 1993.\n37. Casner, S. mtrace UNIX manual page. mtrace(8).\n38. Castineyra, I., J. Chiappa, and M. Steenstrup. The Nimrod Routing Architecture. RFC\n1992, August 1996.\n39. Chandra, R., and P. Traina. BGP Communities Attribute. RFC 1997, August 1996.\n40. Chen, E., and T. Bates. Destination Preference Attribute for BGP. Work in progress.\n41. Cheswick, W., and S. Bellovin. Firewalls and Internet Security: Repelling the Wily Hacker.\nAddison-Wesley, 1994.\n42. Cisco Systems. Cisco IOS Software Configuration.\n<http://cio.Cisco.com/univercd/data/doc/software.htm>.\n43. Cisco Systems. Introduction to Enhanced IGRP. Cisco Technical Report #3.\n44. Clark, D. \"The Design Philosophy of the DARPA Internet Protocols.\" Proceedings,\nACM SIGCOMM '88. Computer Communication Review 18, no. 4, August 1988.\n45. Clark, D., and J. Wroclawski. An Approach to Service Allocation in the Internet. Work in\nprogress.\n46. Coltun, R., D. Ferguson, and J. Moy. OSPF for IPv6. Work in progress.\n47. Coltun, R., and V. Fuller. The OSPF NSSA Option. RFC 1587, March 1994.\n48. Comer, D. Internetworking with TCP/IP, Vol. 1: Principles, Protocols, and Architecture.\nPrentice Hall, 1995.\n49. Conta, A., and S. Deering. Internet Control Message Protocol (ICMPv6)for the Internet\nProtocol Version 6 (IPv6). RFC 1885, December 1995.\n50. Cornell GateDaemon project. ospf_monitor UNIX manual page. ospf_monitor(8).\n51. Cornell GateDaemon project, ripquery UNIX manual page. ripquery(S).",
        "d9711661-a563-4bef-ad75-c7fed5874f8a": "320 OSPF: Anatomy of an Internet Routing Protocol Bibliography\n52. Crawford, M. A Method for the Transmission of IPv6 Packets over Ethernet Networks.\nRFC 1972, August 1996.\n53. Croft, W., and J. Gilmore. Bootstrap Protocol. RFC 951, September 1985.\n54. Dalai, Y., and R. Metcalfe. \"Reverse Path Forwarding of Broadcast Packets.\"\nCommunications of the ACM 21, no. 12, December 1978.\n55. Dang, W. imm distribution. <f tp: //ftp. hawaii . edu/paccom/iinm>.\n56. Deering, S. Host Extensions for IP Multicasting. RFC 1112, May 1988.\n57. Deering, S. ICMP Router Discovery Messages. RFC 1256, September 1991.\n58. Deering, S. Multicast Routing in a Datagram Internetwork. Stanford Technical Report\nSTAN-CS-92-1415. Department of Computer Science, Stanford University.\n<f tp://gregorio. Stanford, edu/vmtp/sd-thesis.ps>, December 1991.\n59. Deering, S. \"Multicast Routing in Internetworks and Extended LANs.\" ACM\nSIGCOMM Summer 1988 Proceedings, August 1988.\n60. Deering, S., D. Estrin, D. Farinacci, V. Jacobson, A. Helmy, D. Meyer, and L. Wei.\nProtocol Independent Multicast Version 2 Dense Mode Specification. Work in progress.\n61. Deering, S., and R. Hind en. Internet Protocol, Version 6 (IPv6) Specification. RFC 1883,\nDecember 1995.\n62. Deering, S., A. Thyagarajan, and W. Fenner. mrouted UNIX manual page. mrouted(S).\n63. Delgrossi, L., and L. Berger. Internet Stream Protocol Version 2 (ST2) Protocol\nSpecification\u2014Version ST2+. RFC 1819, August 1995.\n64. Demers, A., S. Keshav, and S. Shenker. \"Analysis and Simulation of a Fair Queueing\nAlgorithm.\" Journal of Internetworking: Research and Experience 1,1990.\n65. deSouza, O., and M. Rodrigues. Guidelines for Running OSPF over Frame Relay\nNetworks. RFC 1586, March 1994.\n66. Diffie, W., and M. Hellman. \"New Directions in Cryptography.\" IEEE Transactions on\nInformation Theory. IT-22, no. 6, November 1976.\n67. Droms, R. Dynamic Host Configuration Protocol. RFC 1541, October 1993.\n68. Enger, R., and J. Reynolds. FYI on a Network Management Tool Catalog: Tools for\nMonitoring and Debugging TCP/IP Internets and Interconnected Devices. RFC 1470,\nJune 1993.\n69. Eriksson, H. \"MBONE: The Multicast Backbone.\" Communications of the ACM 37, no. 8,\nAugust 1994.",
        "82c1c553-d949-4459-89f4-f8b9094fc0bb": "Bibliography OSPF: Anatomy of an Internet Routing Protocol 321\n70. Estrin, D., D. Farinacci, A. Helmy, D. Thaler, S. Deering, M. Handley, V. Jacobson,\nC. Liu, P. Sharma, and L. Wei. Protocol Independent Multicast\u2014Sparse Mode\n(PIM-SM): Protocol Specification. RFC 2117, June 1997.\n71. Fenner, W. Internet Group Management Protocol, Version 2. October 1996.\n72. Fenner, W., and S. Casner. A \"traceroute\" Facility for IP Multicast. Work in progress.\n73. Ferguson, D. The OSPF External Attributes LSA. Work in progress.\n74. Ferguson, P., and H. Berkowitz. Network Renumbering Overview: Why Would I Want It\nand What Is It Anyway? RFC 2071, January 1997.\n75. Floyd, S. \"TCP and Explicit Congestion Notification.\" ACM SIGCOMM. Computer\nCommunications Review 24, no. 5, October 1994.\n76. Floyd, S., and V. Jacobson. \"Link-Sharing and Resource Management Models for\nPacket Networks.\" IEEE/ACM Transactions on Networking 3, no. 4, August 1995.\n77. Floyd, S., and V. Jacobson. \"Random Early Detection Gateways for Congestion\nAvoidance.\" IEEE/ACM Transactions on Networking 1, no. 4, August 1993.\n78. Floyd, S., and V. Jacobson. \"The Synchronization of Periodic Routing Messages.\"\nACM SIGCOMM '93 Conference Proceedings, September 1993.\n79. Francis, P., and K. Egevang. The IP Network Address Translator (NAT). RFC 1631, May\n1994.\n80. Frederick, R. nv distribution.\n<f tp://parcftp.xerox.com/pub/net-research/nv-3.3beta>.\n81. Fuller, V., T. Li, J. Yu, and K. Varadhan. Classless Inter-Domain Routing (CIDR): An\nAddress Assignment and Aggregation Strategy. RFC 1519, September 1993.\n82. Garcia-Luna-Aceves, J. \"Loop-Free Routing Using Diffusing Computations.\"\nIEEE/ACM Transactions on Networking 1, no. 1, February 1993.\n83. GATED project Web pages. <http: //www.gated. org>.\n84. Green, P., R. Chappuis, J. Fisher, P. Frosch, and C. Wood. \"A Perspective on Advanced\nPeer to Peer Networking.\" IBM Systems Journal 26, no. 4,1987.\n85. Gross, P. Choosing a Common IGPfor the IP Internet (The lESG's Recommendation to the\nIAB). RFC 1371, October 1992.\n86. Guerin, R., S. Kamat, A. Orda, T. Przygienda, and D. Williams. QoS Routing\nMechanisms and OSPF Extensions. Work in progress.\n87. Hafner, K., and J. Markoff. Cyberpunk: Outlaws and Hackers on the Computer Frontier.\nSimon and Schuster, 1991.",
        "3d25406d-5ce6-4c0e-a80b-96b2ea4274bd": "322 OSPF: Anatomy of an Internet Routing Protocol Bibliography\n88. Hagouel. \"Issues in Routing for Large and Dynamic Networks.\" Ph.D. thesis.\nColumbia University, 1983.\n89. Halabi, B. Internet Routing Architectures. Cisco Press. New Riders Publishing, 1997.\n90. Haller, N. \"The S/KEY One-Time Password System.\" Proceedings of the ISOC\nSymposium on Network and Distributed System Security. San Diego, February\n1994.\n91. Handley, M, and V. Jacobson. SDP: Session Description Protocol. Work in progress.\n92. Harrenstien, K., M. Stahl, and E. Feinler. NICNAME/WHOIS. RFC 954, October 1985.\n93. Harris, S., and E. Gerich. \"Retiring the NSFNET Backbone Service: Chronicling the\nEnd of an Era.\" Connexions 10, no. 4, April 1996.\n94. Haskin, D. A BGP/IDRP Route Server Alternative to a Full Mesh Routing. RFC 1863,\nOctober 1995.\n95. Hedrick, C. Routing Information Protocol. RFC 1058, June 1988.\n96. Hedrick, C., and L. Bosack. An Introduction to IGRP. Rutgers University, July 1989.\n97. Heisenberg, W. Physics and Beyond, Encounters and Conversations. Harper and Row,\n1971.\n98. Hinden, R. Internet Routing Protocol Standardization Criteria. RFC 1264, October 1991.\n99. Hinden, R., and S. Deering. IP Version 6 Addressing Architecture. RFC 1884, December\n1995.\n100. Hinden, R., S. Knight, D. Whipple, and D. Weaver. Virtual Router Redundancy Protocol.\nWork in progress.\n101. Hinden, R., and A. Sheltzer. The DARPA Internet Gateway. RFC 823, September 1982.\n102. Hubbard, K., M. Kosters, D. Conrad, D. Karrenberg, and J. Postel. Internet Registry\nAllocation Guidelines. RFC 2050, November 1996.\n103. Huitema, C. IPv6: The New Internet Protocol. Prentice Hall, 1997.\n104. Huitema, C. Routing in the Internet. Prentice Hall, 1996.\n105. lannucci, D., and J. Lekashman. The Research Internet Gateways. NAS Technical Report\nRND-94-008. <http: //science. nas. nasa. gov/Pubs/TechReports/\nRNDreports/RND-94-008/94-008.html>, August 1994.\n106. IEEE. IEEE Standard for Information Technology\u2014Protocols for Distributed Interactive\nSimulation Applications. IEEE Std. 1278-1993.\n107. IEEE. IEEE Standard for Local and Metropolitan Area Networks: Media Access Control\n(MAC) Bridges. IEEE Std. 802.1D-1990.",
        "c3a00615-44c7-49be-9e3f-b15a96cb79cd": "Bibliography OSPF: Anatomy of an Internet Routing Protocol 323\n108. IETF Secretariat and G. Malkin. The Tao of the IETF\u2014A Guide for New Attendees of the\nIETF. RFC 1718, November 1994.\n109. Internet Architecture Board. Applicability Statement for OSPF. RFC 1370, October 1992.\n110. Internet Architecture Board, J. Postel, ed. Internet Official Protocol Standards. RFC 2200,\nJune 1997.\n111. Internet Architecture Board, R. Braden, D. Clark, S. Crocker, and C. Huitema. Report\non IAB Workshop on Security in the Internet Architecture\u2014February 8-10,1994. RFC\n1636, June 1994.\n112. ISO. 10589: Information Processing Systems\u2014Data Communications\u2014Intermediate System\nto Intermediate System Intra-Domain Routing Protocol. 1992.\n113. ISO. Information Processing Systems\u2014Open Systems Interconnection\u2014Specification of\nAbstract Syntax Notation One (ASN.l). International Standard 8824, December\n1987.\n114. ISO. Information Processing Systems\u2014Open Systems Interconnection\u2014Specification of\nBasic Encoding Rules for Abstract Notation One (ASN.l). International Standard\n8825, December 1987:\n115. Jacobson, V. \"Congestion Avoidance and Control.\" Computer Communication Review\n18, no. 4, August 1988.\n116. Jacobson, V. mrinf o UNIX manual page. mrinfo(8).\n117. Jacobson, V. \"Pathchar\u2014A Tool to Infer Characteristics of Internet Paths.\" MSRI talk.\n<f tp: //ftp. ee. Ibl. gov/pathchar/msri -talk. ps . gz>, April 1997.\n118. Jacobson, V. pathchar distribution. <f tp: //ftp. ee. Ibl. gov/pathchar>.\n119. Jaffe, J., and F. Moss. \"A Responsive Distributed Routing Algorithm for Computer\nNetworks.\" IEEE Transaction on Communications COM-30, no. 7, July 1982.\n120. Johnson, M. \"Analysis of Routing Table Update Activity After Resource Failure in a\nDistributed Computer Network.\" ACM SIGCOMM '83 Symposium, March 1983.\n121. Kaliski, B., and M. Robshaw. \"Message Authentication with MD5.\" CryptoBytes (RSA\nLabs Technical Newsletter) l,no. 1. <http: //www. rsa.com/PUBS/c2rvptol .pdf>,\nSpring 1995.\n122. Katz, D. Transmission of IP and ARP over FDDI Networks. RFC 1390, January 1993.\n123. Katz, D., D. Piscitello, B. Cole, and J. Luciani. NBMA Next Hop Resolution Protocol\n(NHRP). Work in progress.\n124. Katz, D., Y. Rekhter, T. Bates, and R. Chandra. Multi-Protocol Extensions for BGP-4.\nWork in progress.",
        "7d39bc00-9461-4652-b518-ebbdbd6bdadd": "324 OSPF: Anatomy of an Internet Routing Protocol Bibliography\n125. Kent, C., and J. Mogul. \"Fragmentation Considered Harmful.\" Proceedings, ACM\nSIGCOMM '87 17, no. 5, October 1987.\n126. Kessler, G., and S. Shepard. A Primer on Internet and TCP/IP Tools and Utilities. RFC\n2151, June 1997.\n127. Khanna, A., and J. Zinky. \"The Revised ARPANET Routing Metric.\" Proceedings,\nACM SIGCOMM 1989, Austin. September 1989.\n128. Kleinrock, L., and F. Kamoun. \"Hierarchical Routing for Large Networks:\nPerformance Evaluation and Optimization.\" Computer Networks 1.1977.\n129. Knuth, D. The Art of Computer Programming, Vol. 3. Sorting and Searching. Addison-\nWesley, 1973.\n130. Krawczyk, H., M. Bellare, and R. Canetti. HMAC: Keyed-Hashing for Message\nAuthentication. RFC 2104, February 1997.\n131. Kumar, V. MBONE: Multicast Multimedia for the Internet. New Riders Publishing,\n1997.\n132. Labovitz, C., G. Malan, and F. Jahanian. Internet Routing Instability. CSE-TR-332-97,\nUniversity of Michigan and Merit Network.\n133. Laubach, M. Classical IP and ARP over ATM. RFC 1577, January 1994.\n134. Lawrence, J., and D. Piscitello. The Transmission of IP Datagrams over the SMDS Service.\nRFC 1209, March 1991.\n135. Leiner, B., V. Cerf, D. Clark, R. Kahn, L. Kleinrock, D. Lynch, J. Postel, L. Roberts, and\nS. Wolff. A Brief History of the Internet.\n<http://www.isoc.org/internet-history/>, 1997.\n136. Li, T., B. Cole, P. Morton, and D. Li. Hot Standby Router Protocol (HSRP). Work in\nprogress.\n137. Lougheed, K., and Y. Rekhter. Border Gateway Protocol (BGP). RFC 1105, June 1989.\n138. McCanne, S., and V. Jacobson. sd distribution.\n<ftp://ftp.ee.Ibl.gov/conferencing/sd>.\n139. McCanne, S., and V. Jacobson. vat distribution.\n<ftp://ftp.ee.Ibl.gov/conferencing/vat>.\n140. McCanne, S., and V. Jacobson. wb distribution.\n<f tp://ftp.ee.Ibl.gov/conferencing/wb>.\n141. McCloghrie, K., D. Farinacci, and D. Thaler. Internet Group Management Protocol MIB.\nWork in progress.",
        "6056ee81-dd7a-40a0-93cd-7e19aecdc47b": "Bibliography OSPF: Anatomy of an Internet Routing Protocol 325\n142. McCloghrie, K., D. Farinacci, and D. Thaler. IP Multicast Routing MIB. Work in\nprogress.\n143. McCloghrie, K., and M. Rose. Management Information Base for Network Management of\nTCP/IP-Based Internets: MIB-II. RFC 1213, March 1991.\n144. McCloghrie, K., and M. Rose. Structure and Identification of Management Information for\nTCP/IP-Based Internets. RFC 1155, May 1990.\n145. McKenzie, A. ISO Transport Protocol Specification. ISO DP 8073. RFC 905, April 1984.\n146. McQuillan, J., I. Richer, and E. Rosen. ARPANET Routing Algorithm Improvements.\nBBN Report 3803. Bolt Beranek and Newman, April 1978.\n147. McQuillan, J., I. Richer, and E. Rosen. \"The New Routing Algorithm for the\nARPANET.\" IEEE Transactions on Communications COM-28, no. 5, May 1980.\n148. MAE East. <http://www.mfsdatanet.com/MAE/east.html>.\n149. Malkin, G. RIP Version 2 Carrying Additional Information. RFC 1723, November 1994.\n150. Malkin, G., and F. Baker. RIP Version 2 MIB Extension. RFC 1724, November 1994.\n151. Malkin, G., and R. Minnear. RIPngfor IPv6. RFC 2080, January 1997.\n152. Mallory, T. \"SPF Routing in the Butterfly Gateway.\" Slides given to X3.S3 Standards\nCommittee, April 1987.\n153. Manning, B. Registering New BGP Attribute Types. RFC 2042, January 1997.\n154. Maufer, T., and C. Semeria. Introduction to IP Multicast Routing. Work in progress.\n155. Maughan, D., M. Schertler, M. Schneider, and J. Turner. Internet Security Association\nand Key Management Protocol (ISAKMP). Work in progress.\n156. Medin, M. \"The Great IGP Debate\u2014Part Two: The Open Shortest Path First (OSPF)\nRouting Protocol.\" Connexions 5, no. 10, October 1991.\n157. Merlin, P., and A. Segall. \"A Failsafe Distributed Routing Protocol.\" IEEE Transactions\non Communications COM-27, no. 9, September 1979.\n158. Meyer, D. Administratively Scoped IP Multicast. Work in progress.\n159. Meyer, G. Extensions to RIP to Support Demand Circuits. RFC 1582, February 1994.\n160. Meyer, G., and S. Sherry. Triggered Extensions to RIP to Support Demand Circuits. RFC\n2091, January 1997.\n161. Mills, D. DCM Local-Network Protocols. RFC 891, December 1983.\n162. Mills, D. Exterior Gateway Protocol Formal Specification. RFC 904, April 1984.",
        "74ae176b-bb9b-43d9-a597-85edc7666a1c": "326 OSPF: Anatomy of an Internet Routing Protocol Bibliography\n163. Mockapetris, P. Domain Names\u2014Implementation and Specification. RFC 1035,\nNovember 1987.\n164. Mogul, J. Broadcasting Internet Datagrams in the Presence of Subnets. RFC 922, October\n1984.\n165. Mogul, J., and S. Deering. Path MTU Discovery. RFC 1191, April 1990.\n166. Mogul, J., and J. Postel. Internet Standard Subnetting Procedure. RFC 950, August 1985.\n167. Morris, R. Bulk Multicast Transport Protocol. INFOCOM 97.\n168. Moy, J. Experience with OSPF. RFC 1246, July 1991.\n169. Moy, J. Extending OSPF to Support Demand Circuits. RFC 1793, April 1995.\n170. Moy, J. MOSPF: Analysis and Experience. RFC 1585, March 1994.\n171. Moy, J. Multicast Extensions to OSPF. RFC 1584, March 1994.\n172. Moy, J. OSPF Database Overflow. RFC 1765, March 1995.\n173. Moy, J. OSPF Protocol Analysis. RFC 1245, July 1991.\n174. Moy, J. OSPF Specification. RFC 1131 (obsoleted by RFC 1247), October 1989.\n175. Moy, J. OSPF Standardization Report. Work in progress.\n176. Moy, J. OSPF Version 2. RFC 1247 (obsoleted by RFC 1583), August 1991.\n177. Moy, J. OSPF Version 2. RFC 1583 (obsoleted by RFC 2178), March 1994.\n178. Moy, J. OSPF Version 2. RFC 2178, July 1997.\n179. Murphy, S., M. Badger, and B. Wellington. OSPF with Digital Signatures. RFC 2154,\nJune 1997.\n180. Nagle, J. Congestion Control in IP/TCP Internetworks. RFC 896, January 1984.\n181. Narten, T., E. Nordmark, and W. Simpson. Neighbor Discovery for IP Version 6 (IPv6).\nRFC 1970, August 1996.\n182. National Institute of Standards and Technology. Secure Hash Standard. NIST FIPS PUB\n180. U.S. Department of Commerce, January 1992.\n183. North American Network Operators Group (NANOG). <http: //www. nanog. org>.\n184. Novell. NetWare Link Services Protocol (NLSP) Specification. 1993.\n185. Oehler, M., and R. Glenn. HMAC-MD5 IP Authentication with Replay Prevention. RFC\n2085, February 1997.\n186. Oran, D. OS/ /S-/S Intra-domain Routing Protocol. RFC 1142, December 1991.\n187. Ousterhout, J. Tel and the Tk Toolkit. Addison-Wesley, 1994.",
        "4406240b-c1fb-4090-8322-c969fd4fea14": "Bibliography OSPF: Anatomy of an Internet Routing Protocol 327\n188. Perkins, C. IP Encapsulation within IP. RFC 2003, October 1996.\n189. Perlman, R. \"Fault Tolerant Broadcast of Routing Information.\" Computer Networks,\nDecember 1983.\n190. Perlman, R. \"Network Layer Protocols with Byzantine Robustness.\" Ph.D. thesis.\nDepartment of Electrical Engineering and Computer Science, MIT. August 1988.\n191. Perlman, R., and R. Gallon. \"The Great IGP Debate\u2014Part One: IS-IS and Integrated\nRouting.\" Connexions 5, no. 10, October 1991.\n192. Plummer, D. Ethernet Address Resolution Protocol: Or Converting Network Protocol\nAddresses to 48-bit Ethernet Addresses for Transmission on Ethernet Hardware. RFC\n826, November 1982.\n193. Postel, J. Instructions to RFC Authors. RFC 1543, October 1993.\n194. Postel, J. Internet Control Message Protocol. RFC 792, September 1981.\n195. Postel, J. Internet Protocol. RFC 791, September 1981.\n196. Postel, J. Simple Mail Transfer Protocol. RFC 821, August 1982.\n197. Postel, J. Transmission Control Protocol. RFC 793, September 1981.\n198. Postel, J. User Datagram Protocol. RFC 768, August 1980.\n199. Postel, J., and J. Reynolds. File Transfer Protocol. RFC 959, October 1985.\n200. Postel, J., and J. Reynolds. Telnet Protocol Specification. RFC 854, May 1983.\n201. Pummill, T., and B. Manning. Variable Length Subnet Table for IPv4. RFC 1878,\nDecember 1995.\n202. Pusateri, T. Distance Vector Multicast Routing Protocol. Work in progress.\n203. Pusateri, T. IP Multicast over Token-Ring Local Area Networks. RFC 1469, June 1993.\n204. Pusateri, T. ospf query UNIX manual page.\n<http://www. j nx.com/~pusateri/ospfquery.html>.\n205. RAToolSet. <http: //www. isi .edu/ra/RAToolSet>.\n206. Rekhter, Y. EGP and Policy Based Routing in the New NSFNET Backbone. RFC 1092,\nFebruary 1989.\n207. Rekhter, Y. NSFNET Backbone SPF Based Interior Gateway Protocol. RFC 1074, October\n1988.\n208. Rekhter, Y, and T. Li. A Border Gateway Protocol (BGP-4). RFC 1771, March 1995.\n209. Rekhter, Y, and T. Li. Implications of Various Address Allocation Policies for Internet\nRouting. RFC 2008, October 1996.",
        "141d8a7e-5c78-459a-999d-dd63cdf77152": "328 OSPF: Anatomy of an Internet Routing Protocol Bibliography\n210. Rekhter, Y., R. Moskowitz, D. Karrenberg, G. de Groot, and E. Lear. Address Allocation\nfor Private Internets. RFC 1918, February 1996.\n211. Reynolds, J. Helminthiasis of the Internet. RFC 1135, December 1989.\n212. Reynolds, J., and J. Postel. Assigned Numbers. RFC 1700, October 1994.\n213. RFC Index. <f tp://ds.internic.net/rfc/rfc-index.txt>.\n214. Rigney, C., A. Rubens, W. Simpson, and S. Willens. Remote Authentication Dial-In User\nService (RADIUS). RFC 2138, April 1997.\n215. RIPE database. <http: //www. ripe. net>.\n216. Rivest, R. The MD5 Message-Digest Algorithm. RFC 1321, April 1992.\n217. Rose, M, ed. A Convention for Defining Traps for Use with the SNMP. RFC 1215, March\n1991.\n218. Rose, M. The Simple Book, An Introduction to Management of TCP/IP-Based Internets.\nPrentice Hall, 1991.\n219. Rosen, E. Exterior Gateway Protocol EGP. RFC 827, October 1982.\n220. Rosen, E. \"The Updating Protocol of ARPANET'S New Routing Algorithm.\"\nComputer Networks 4,1980.\n221. Rosen, E. \"Vulnerabilities of Network Control Protocols: An Example.\" Computer\nCommunication Review, July 1981.\n222. routed UNIX manual page. routed(8).\n223. Routing Arbiter Web pages. <http: //www. ra. net>.\n224. RSA Data Security. PKCS #1: RSA Encryption Standard, Version 1.4. 3 June 1991.\n225. Schneier, B. Applied Cryptography. Wiley, 1994.\n226. Schoffstall, M., M. Fedor, J. Davin, and J. Case. A Simple Network Management Protocol\n(SNMP). RFC 1157, May 1990.\n227. Schooler, E. mmcc distribution. <f tp: //ftp. isi.edu/confctrl/mmco.\n228. Schulzrinne, H. nevot distribution.\n<ftp://gaia.cs.amass.edu/pub/hschulz/nevot>.\n229. Schulzrinne, H., S. Casner, R. Frederick, and V. Jacobson. RTF: A Transport Protocol for\nReal-Time Applications. RFC 1889, January 1996.\n230. Sedgewick, R. Algorithms. Addison-Wesley, 1984.\n231. Seeger, J., and A. Khanna. \"Reducing Routing Overhead in a Growing DDN.\"\nMILCOMM 86,1986.",
        "d6960dfa-b08c-4fdb-b3b8-6dfac2c38573": "Bibliography OSPF: Anatomy of an Internet Routing Protocol 329\n232. Simpson, W. The Point-to-Point Protocol (PPP). RFC 1548, December 1993.\n233. Sollins, K. The TFTP Protocol (Revision 2). RFC 1350, July 1992.\n234. Srinivasan, R. RFC: Remote Procedure Call Protocol Specification Version 2. RFC 1831,\nAugust 1995.\n235. Srinivasan, R. XDR: External Data Representation Standard. RFC 1832, August 1995.\n236. Steenstrup, M. Inter-Domain Policy Routing Protocol Specification: Version 1. RFC 1479,\nJuly 1993.\n237. Steenstrup, M. Routing in Communications Networks. Prentice Hall, 1995.\n238. Steiner. J., B. Neuman, and J. Schiller. Kerberos: An Authentication Service for Open\nNetwork Systems. Usenix Conference Proceedings, February 1988.\n239. Stevens, W. TCP Slow Start, Congestion Avoidance, Fast Retransmit and Fast Recovery\nAlgorithms. RFC 2001, January 1997.\n240. Stevens, W. TCP/IP Illustrated, Volume 1: The Protocols. Addison-Wesley, 1994.\n241. Tajibnapis, W. \"A Correctness Proof of a Topology Maintenance Protocol for a\nDistributed Computer Network.\" Communications of the ACM 20, no. 7, July 1977.\n242. Tanenbaum, A. Computer Networks. 3d edition. Prentice Hall, 1996.\n243. Thaler, D. Distance Vector Multicast Routing Protocol MIB. Work in progress.\n244. Thaler, D. Interoperability Rules for Multicast Routing Protocols. Work in progress.\n245. Thaler, D., D. Estrin, and D. Meyer. Grand Unified Multicast (GUM): Protocol\nSpecification. Work in progress.\n246. Thurletti, T. ivs distribution. <f tp: //zenon. inria. f r/rodeo/ivs/versions . 6>.\n247. traceroute UNIX manual page.\n<http://ack.berkeley.edu/cgi-bin/traceroute.8>.\n248. Traina, P. Autonomous System Confederations for BGP. RFC 1965, June 1996.\n249. Trusted Information Systems. OSPF with Digital Signatures, Implementation\nInformation. <http: //www. tis . com/docs/research/network/ospf. html>.\n250. Tsuchiya, P. On the Assignment of Subnet Numbers. RFC 1219, April 1991.\n251. UNH Interoperability Lab. <http: //www. iol. vmh.edu>.\n252. Varadhan, K., S. Hares, and Y. Rekhter. BGP4/IDRPfor IP-OSPF Interaction. RFC 1745,\nDecember 1991.\n253. Vetter, B., F. Wang, and F. Wu. \"An Experimental Study of Insider Attacks for the\nOSPF Routing Protocol.\"",
        "62f41c1b-8846-4493-83fc-734aaecf829c": "330 OSPF: Anatomy of an Internet Routing Protocol Bibliography\n<http://shang.csc.ncsu.edu/papers/Wu-AESoIAftORP.ps.gz>.\nSubmitted for publication, May 1997.\n254. Villamizar, C. Controlling BGP/IDRP Routing Traffic Overhead. Work in progress.\n255. Waitzman, D., C. Partridge, and S. Deering. Distance Vector Multicast Routing Protocol\nRFC 1075, November 1988.\n256. Waldbusser, S. Remote Network Monitoring Management Information Base. RFC 1757,\nFebruary 1995.\n257. Waldvogel, M., G. Varghese, J. Turner, and B. Plattner. \"Scalable High Speed IP Routing\nLookups.\" ACM SIGCOMM '97, September 1997.\n258. Wall, D. Mechanisms for Broadcast and Selective Broadcast. Ph.D. thesis. Stanford\nUniversity, June 1980.\n259. Wall, D., and S. Owicki. \"Center-Based Broadcasting.\" Computer Systems Lab Technical\nReport TR189. Stanford University, June 1980.\n260. Wall, L., R. Schwartz, T. Christiansen, and S. Potter. Programming Perl, 2d edition.\nO'Reilly and Associates, October 1996.\n261. Wang, F., B. Vetter, and F. Wu. \"Secure Routing Protocols: Theory and Practice.\"\n<http://shang.csc.ncsu.edu/papers/CCR-SecureRP2.ps. gz>.\nSubmitted for publication, May 1997.\n262. Willis, S., J. Burruss, and J. Chu. Definitions of Managed Objects for the Fourth Version of\nthe Border Gateway Protocol (BGP-4) Using SMIv2. RFC 1657, July 1994.\n263. Wimer, W. Clarifications and Extensions for the Bootstrap Protocol. RFC 1542, October\n1993.\n264. Wright, G., and W. Stevens. TCP/IP Illustrated, Volume 2: The Implementation. Addison-\nWesley, 1995.\n265. Xerox Corporation. Internet Transport Protocols, Xerox System Integration Standard XSIS\n028112. December 1981.\n266. Zhang, L., S. Deering, D. Estrin, S. Shenker, and D. Zappala. \"RSVP: A New Resource\nReSerVation Protocol.\" IEEE Network, September 1993.\n267. Zhang, Z. Fixing Backbone Partition with Dynamic Virtual Links. Work in progress.",
        "e5650b40-34c8-4173-9704-6420a28cfd8b": "Index\nABRs (area border routers), 122-123\ndefinition of, 158-159\nin MOSPF, 201\nconfiguration of, 226\nAbstraction, 55,102\nof broadcast subnets, 108-110\nof NBMA subnets, 113\nof Point-to-MultiPoint subnets, 116\nAdapters in promiscuous mode, 189, 261\nAdd-ons for IP datagram forwarding, 13-14\nadd route command, 30\nAddress prefixes, 16-18\nAddress scoping, 23\nAddresses\nIP, 8,16-22\nlending, 18\nmulticast, 175\nAdjacent neighbors, 90\nAdministrative scoping, 175\nAdvanced Peer-to-Peer Networking (APPN) pro-\ntocol, 49\nAdvanced Research Projects Agency network\n(ARPANET), 3,33\nrouting algorithm in, 48-50sequence bug in, 56, 77\nsynchronization in, 89\nADVERTISER attribute, 296\nAdvertising routers, 75-76,156\nAggregation, 17-18\nin BGP, 290\nin IGRP, 299\nin IS-IS, 302\nin MOSPF, 199-203\nin NSSA, 144\nin OSPF, 157, 283\nin OSPF MIB, 218\nin RIP, 278-279\nAll-subnets-broadcast addresses, 20\nAUDRouters address, 95\nAUSPFRouters address, 95\nAnalyzers\nfor debugging, 259-262\nfor interoperability testing, 58\nintegrated with IP datagram forwarding, 14\nApplication layer, 9\nApplication protocols, 5\nAPPN (Advanced Peer-to-Peer Networking) pro-\ntocol, 49\nAPSCN (Arkansas Public School Computer Net-\nwork) example, 228-230\n331",
        "e17241ad-8cc4-4cde-9f3c-fe221bbdac46": "332 OSPF: Anatomy of an Internet Routing Protocol Index\nArea border routers (ABRs), 122-123\ndefinition of, 158-159\nin MOSPF, 201\nconfiguration of, 226\nArea flooding scope, 132\nArea IDs, 86\nAreas. See also OSPF areas\nin MOSPF, 199-203\nin IS-IS, 301\nArkansas Public School Computer Network ex-\nample, 228-230\nARPANET (Advanced Research Projects Agency\nnetwork), 3,33\nrouting algorithm in, 48-50\nsequence bug in, 56, 77\nsynchronization in, 89\nAS-external-LSAs, 75,128-131, 284\nin Database Overflow extensions, 145\nwith external-attributes-LSAs, 147-149\nflooding, 131-132\nwith IBGP, 235\nvs. Type-7-LSAs, 143\nAS flooding scope, 131\nAS numbers, 34\nAS_PATH attribute, 295\nAS paths in BGP, 286,295\nAS sequences, 290\nAS sets, 235, 290\nASBR-summary-LSAs, 75,131\nASBRs (Autonomous System boundary routers),\n127-128,133,144\nASN.l format, 215\nASs (Autonomous Systems), 32-34\nin BGP, 147-149, 296-297\nconfiguring, 213\nrouting protocols with, 146\nATOMIC_AGGREGATE attribute, 296\nAuthentication\ncryptographic, 237-240\nheader fields for, 86\nAutomatic neighbor discovery, 106\nAutonomous System boundary routers (ASBRs),\n127-128,133,144\nAutonomous Systems (ASs), 32-34\nin BGP, 147-149, 296-297\nconfiguring, 213\nrouting protocols with, 146B\nBackbone areas, 55,125\nBackup Designated Router field, 87\nBackup Designated Routers\nin database synchronization, 106-110\ndesign rationale, 53-54\nfunction of, 156-157\nin NBMA subnets, 111-113\nBellman-Ford Vector algorithm, 36,39\nBest matches in routing tables, 28\nBGP (Border Gateway Protocol), 34, 39,284-292\nwith ASs, 147-149,296-297\nIBGP, 292-294\ninteractions with, 233-235\nMIB for, 254\noperational issues, 296-297\npath attributes, 286,294-296\nBinary trees for routing tables, 30-31\nBorder Gateway Protocol. See BGP (Border Gate-\nway Protocol)\nBoundaries of OSPF areas, 157-158\nBroadcast-and-prune multicast routing protocols,\n310-312\nBroadcast forwarding, 178-184\nBroadcast IP addresses, 16\nBroadcast storms, 10\nBroadcast subnets, 104-105\nabstraction of, 108-110\ndatabase synchronization in, 106-108\nneighbor discovery and maintenance in,\n105-106\nproblems in, 110-111\nBSD UNIX, 277\nBurgan, Jeff, 63\nCache hits with hash functions, 31\nCaches\nin multicast forwarding, 183\nin MOSPF, 195-197\nfor routing tables, 31-32\nCandidate lists, 97-98\nCBQ (Class Based Queuing) algorithm, 13\nCBT (Core Based Trees) routing protocol, 180,315\nCheckAge constant, 80",
        "a1c71c5d-d992-4827-9fb1-de3ec48d050a": "Index OSPF: Anatomy of an Internet Routing Protocol 333\nChecksums\nin database synchronization, 94\nin IP headers, 24-25\nfor LSAs, 78, 84,159-160\nin OSPF headers, 86\nCIDR (Classless Inter-Domain Routing), 17, 67\nfor hierarchical routing, 121\nfor RIP, 277\nCIDR blocks, 33\nCIDR notation, 17\nCisco routers, 223-224\nCIXs (Commercial Internet Exchanges), 34\nClass Based Queuing (CBQ) algorithm, 13\nClasses of IP addresses, 17,19-21,172-174\nClassless Inter-Domain Routing (CIDR), 17, 67\nfor hierarchical routing, 121\nfor RIP, 277\nClients of Route Reflectors, 293\nClocks for OSPF aging, 160\nCloud subnets, 110\nCLUSTER_LIST attribute, 293,296\nClusters in BGP, 294\nColtun, Rob, 56, 60,151, 263\nCommercial Internet Exchanges (CIXs), 34\nCOMMUNITY attribute, 296\nCompatibility\nof Database Overflow, 146\nof Demand Circuit, 142\nwhen extending OSPF, 136\nof external-attributes-LSA, 149\nin MOSPF, 203-205\nof NSSA areas, 145\nof stub areas, 140\nof IOS-based routing, 139\nComplete Sequence Number PDUs\n(CSNPs), 302\nConfederations in BGP, 292-294\nConferencing applications, 174\nConfiguration, OSPF, 222-225\ndifficulties in, 155-156\nlink costs, 225\nOSPF areas, 226-227\ntimers, 227-228\nConvergence\nDistance Vector, 35-39\nas OSPF design issue, 45\nin routing, 27\nConvergence time, 27\nCore Based Trees (CBT) routing protocol, 180, 315\nCore routers, 180. See also Rendezvous PointsCosts\nlink, 152-153,225\nin MOSPF, 163-166\nCounting to infinity, 37-39, 298\nCryptographic authentication, 237-240\nCSNPs (Complete Sequence Number PDUs), 302\nData-link layer, 7\nDatabase Description packets, 75, 284\nand compatibility, 80,136\nin database synchronization, 89-90\nDatabase Exchange procedure, 60,89-91\nwith database snapshots, 162-163\non link start-up, 163\nin Point-to-MultiPoint subnets, 116\nDatabase Overflow extensions, 145-146\nDatabase synchronization, 87, 101. See also Link-\nstate databases\nover broadcast subnets, 106-108\nover Demand Circuits, 141\nDesignated Router election in, 107-108\ninitial, 89-92\nin IS-IS, 303\nmonitoring, 59-60, 231\nin NBMA subnets, 112-113\nin Point-to-MultiPoint subnets, 116\nreliable flooding in, 92-95\nDatagrams, forwarding. See Forwarding data-\ngrams\nDebugging routing problems, 243-244\nexample problems, 244-245\nMIB-based tools for, 257-259\nmtrace tool for, 266-271\nnetwork analyzers for, 259-262\nping tool for, 247-250\nproduct-specific tools for, 265-266\nprotocol-specific tools for, 263-265\nSNMP MIBs for, 254-257\ntool interpretation in, 245-247\ntool sources for, 245\ntraceroute tool for, 250-253\nDeering, Steve, 68, 208\nDefault-free zones, 32\nDefault routes, 29\nDelay schemes in link-cost configuration, 225\nDeleting LSAs from distributed databases, 79-80\nDemand Circuit extensions, 65,140-143",
        "3a68c8d0-ddec-4e91-a90f-0f836951b3d2": "334 OSPF: Anatomy of an Internet Routing Protocol Index\nDesign considerations\nBackup Designated Routers, 53-54\ncommon mechanisms over disparate link lay-\ners, 52-53\nencapsulation, 50-51\nexternal route tags, 54\nhierarchical abstraction, 55\nlink-state basis, 49-50\nlink-state vs. Distance Vector, 47-49\nLSA fragmentation, 52\nDesignated Intermediate Systems in IS-IS, 303\nDesignated Router field, 87\nDesignated Routers, 53-54,284\nin CBT, 315\nin database synchronization, 106-110\nelection of, 107-108\nfunction of, 156-157\nin MOSPF, 193, 205\nin NBMA subnets, 111-113\nin PIM Sparse, 315\nDestination IP address, 10,85\nDestination Unreachable messages, 12-13,28,247\nDiffie-Hellman protocol, 240\nDigital signatures, 237, 240-241\nDijkstra Shortest Path First algorithm, 39, 48,\n96-98,282, 301, 313\nDirected-broadcast addresses, 20\nDIS (Distributed Interactive Simulation) applica-\ntions, 175\nDiscontiguous subnet masks, 20-21\nDistance Vector routing protocols\nconvergence, 35-39\ncounting to infinity, 37-38\nvs. link-state, 40,47-49\nparallels in OSPF areas, 125-127\nDistributed computations, 35\nDistributed database model, 48\nDistributed databases, deleting LSAs from, 79-80\nDistributed-processing model, 47\nDMZ Ethernet, 63-64\nDNS (Domain Name System), 9\nDomain names, debugging tools for, 245-246\nDomainwide reports, 310\ndoNotAcivertiseMatching value, 226\nDoNotAge bit\nin Demand Circuit, 141-143\nin LSA refreshing, 161\nDotted decimal notation, 16\nDownstream ISPs, 32-33\nDPA attribute, 295-296Drop-tail gateways, 13\nDUAL (Distributed Update Algorithm), 300\nDVMRP (Distance Vector Multicast Routing Pro-\ntocol), 21,68,163,312-313\nin MBONE, 206-208\nMIB for, 255\nvs. MOSPF, 187-188\nmulticast tunnels, 207\ntools for debugging, 264\nEBGP (External Border Gateway Protocol), 292\nEcho Replies 15,248\nECHO_REPLY messages, 315\nEcho Requests\nin ICMP 15,174,248\nmulticasting, 174\nECHO_REQUEST messages, 315\nEfficiency\nof broadcast subnets, 106\nof shared-tree protocols, 180\nEGP (Exterior Gateway Protocol), 34,147,304\nEIGRP (Enhanced Inter-Gateway Routing Proto-\ncol), 39,300\nElection of Designated Routers, 107-108\nEncapsulation\nin BGP, 288\nas design consideration, 50-51\nin DVMRP, 312\nin IGRP, 298\nin IS-IS, 301\nin OSPF, 282\nin RIP, 277\nin tunneling, 22\nEnd stations, 5\nEnhanced Inter-Gateway Routing Protocol\n(EIGRP), 39,300\nEqual-cost multipath, 45-46, 98\nether find network analyzer, 261\nEthernet networks, 9\nencapsulation in, 51\nin multicasting, 104\nExpanding-length searches, 270\nExpanding ring searches, 190\nExporting DVMRP information, 207-208\nExtensions, OSPF, 135-137\nDatabase Overflow, 145-146\nDemand Circuit, 140-143",
        "80c474f0-b49d-4382-a866-6488805694ab": "Index OSPF: Anatomy of an Internet Routing Protocol 335\nexternal-attributes-LSA, 146-149\nNSSA areas, 143-145\nstub areas, 139-140\nIOS-based routing, 137-139\nExterior Gateway Protocol (EGP), 34,147,304\nExternal-attributes-LSAs, 75,146-149\nExternal Border Gateway Protocol (EBGP), 292\nExternal Data Representation (XDR) protocols, 9\nExternal route tags\nin AS-external-LSAs, 131\nin design, 54\nin OSPF, 284\nExternal routing information, 127-132,282\nExternal Type 1 metrics, 129\nExternal Type 2 metrics, 129-130\nFAQs\nABRs, 158-159\nconfiguration difficulties, 155-156\nDatabase Exchange process, 163\nDesignated Router with Backup Designated\nRouter, 156-157\ndiscussion sources, 152\ninstalling MaxAge LSAs, 162-163\ninterface types for Frame Relay subnets, 156\nlink-state database refreshing, 160\nlink-state metrics, 152-153\nLSA checksums, 159-160\nMOSPF reverse costs, 163-166\nMOSPF support, 163\nnetwork load routing responses, 153\nOSPF aging, 160\nOSPF area size, 157-158\nOSPF design improvements, 166-167\npoint-to-point link agreements, 155\npoint-to-point link representation, 153-155\nrouting table sizes and LSA refresh traffic, 161\nsoftware sources, 151-152\n2-Way states, 156\nunreachable routers, 161-162\nvirtual links, 158-159\nField trials, 61-63\nfeature requests from, 63-65\nproblems found in, 65\nFile Transport Protocol (FTP), 9,14\nFiltering\nby network analyzers, 259\npacket, 14route, 305\nFirewalls, 14, 69\nFirst-hop routers, finding, 14-16\nFlat routing, 119\nFletcher checksum algorithm, 78\nFlooding. See Reliable flooding\nFlow Label field, 23-24\nFlow setup, 304\nFLUSHJTREE messages, 315\nForwarding addresses, 64,130-131\nForwarding behavior in MOSPF, 188-190\nForwarding caches in MOSPF, 195-197\nForwarding datagrams, 9-10\nadd-ons for, 13-14\nbroadcast, 178-179\nfirst-hop routers in, 14-16\nICMP errors in, 12-13\nmodification of, 10-12\nmulticast, 179-184\ntunneling in, 21-22\nFragmentation, LSA, 52\nFragments, packet, 10\nFrame Relay networks, 67-68\ninterface types for, 156\nwith NBMA subnets, 111\nproblems in, 113-114\nFront ends for routing tables, 31\nFTP (File Transport Protocol), 9,14\nFull-mesh IBGP, 292-294\nFuller, Vince, 63\nFully adjacent neighbors, 90\nFunctional requirements, 43-^7\nFuzzbaU routers, 20,33,234\nGATED program, 151-152\ndevelopment of, 56\nIBGP considerations, 292\nOSPF configuration, 223\npoll command in, 264\nprotocol interaction in, 306-307\nGateway-to-Gateway Protocol (GGP), 303-304\nGateways, 15\ndrop-tail, 13\nmeaning of, 275\nget function, 217\nget-next function, 217\nGetNextRequest packets, 255,257\nGetRequest packets, 255,257",
        "ccaa054a-273b-435c-8e7e-4289f562c09b": "336 OSPF: Anatomy of an Internet Routing Protocol Index\nGetResponse packets, 255\nGGP (Gateway-to-Gateway Protocol), 303-304\nGraft messages, 311\nGroup-membership-LSAs, 75, 146, 191-194, 201,\n205,313-314\nH\nHash functions\nin cryptographic authentication, 237-238\nfor routing tables, 31-32\nHash tables, 31-32\nHeader Checksum field, 24-25\nHeaders, 5-6\nIP, 9-10,85\nIPv6,23-25\nOSPF, 85-86\nHello packets, 73,281\nin Demand Circuit, 140-142\nin NBMA subnets, 111-112\nin neighbor discovery, 86-88\nOptions field in, 80,136\nin Point-to-MultiPoint subnets, 115-116\nsubnet model enforcement, 104\nHello Protocol, 304\nHellolnterval variable, 87\nHidden prefixes, 125\nHierarchical abstraction, 55\nHierarchical multicast\nadvertising information in, 201-202\nin MOSPF, 199-203\nrouting calculations in, 202-203\nHierarchical routing, 119-122\nexternal routing information in, 127\u2014132\nOSPF area types in, 132-134\nOSPF areas in, 122-127\nHold downs\nin Distance Vector protocols, 38\nin IGRP, 299\nHonig, Jeff, 263\nHop Limit field, 23-24\nHop counts\nin routing tables, 27-32\nweighted, 83, 96, 225\nHost Membership Queries, 176-177,192-193, 205\nHost Membership Reports, 176-177,192-193\nHosts, 5,8\nHot standby router protocol, 15\nHub-and-spoke topology, 127I\nIANA (Internet Assigned Number Authority), 17,\n174\nIBGP (Internal Border Gateway Protocol), 292-294\nexternal-attributes-LSA alternative, 147-149\nfull mesh IBGP, 292\nfull mesh alternatives, 293-294\ninteractions with, 234\u2014235\nUniversal IBGP, 297\nICMP (Internet Control Message Protocol), 8\nin IPv6,25\nfor multicasting, 174\nfor ping tool, 248\nsending messages in, 12-13,15\nIDPR (Inter-Domain Policy Routing), 39, 304\nIDRP (Inter-Domain Routing Protocol), 233, 292\nIETF (Internet Engineering Task Force)\nmeetings by, 152\nrecommendations by, 56,66,281\nIflndex values, 81-82\nIGMP (Internet Group Management Protocol),\n172,174,176-178\nfor DVMRP, 312\nMIB for, 255\nwith MOSPF, 192-193\nIGMPv2,177-178,193\nIGMPvS, 178\nIGP (Interior Gateway Protocol), 34\nwith ASs, 146\nsynchronization with IBGP, 296-297\nIGRP (Inter-Gateway Routing Protocol), 38,\n297-300\nimm tool, 174\nImplicit acknowledgments in reliable flooding,\n92-93\nImporting DVMRP information, 207-208\nINDEX clauses, 215\nInfinite split horizon procedure, 38\nInitialSequenceNumber value, 77\nInstances\nLSA, 76-77\nSNMP variables, 217\nIntegrated IS-IS routing protocol, 300-303\nInter-area destinations, 122\nInter-area routing, 129\nInter-Domain Policy Routing (IDPR), 39, 304\nInter-Domain Routing Protocol (IDRP), 233,292",
        "06ce722c-38bd-4953-b51a-937f6eb312e2": "Index OSPF: Anatomy of an Internet Routing Protocol 337\nInter-Gateway Routing Protocol (IGRP), 38,\n297-300\nInteractions, routing protocol, 233-236, 305-307,\n315-316\nInterdomain multicast routing protocols, 310\nInterface timers, 155-156\nInterface types with Frame Relay subnets, 156\nInterfaces, 8\nInterior Gateway Protocol (IGP), 34\nwith ASs, 146\nsynchronization with IBGP, 296-297\nIntermediate Systems (ISs), 301\nInternal Border Gateway Protocol (IBGP), 292-294\nexternal-attributes-LSA alternative, 147-149\nfull mesh IBGP, 292\nfull mesh alternatives, 293-294\ninteractions with, 234-235\nUniversal IBGP, 297\nInternet\nCIDR for, 67\ndebugging tools for, 245\nFrame Relay subnets in, 67-68\nIPv6 for, 69\nmulticasting in. See Multicast routing and pro-\ntocols\nrouters in. See Routers\nrouting architecture of, 32-34\nrouting protocols in. See Routing and routing\nprotocols\nsecurity for, 68-69\nInternet Assigned Number Authority (IANA), 17,\n174\nInternet Control Message Protocol (ICMP), 8\nin IPv6,25\nfor multicasting, 174\nfor ping tool, 248\nsending messages in, 12-13,15\nInternet Drafts, 152\nInternet Engineering Task Force (IETF)\nmeetings by, 152\nrecommendations by, 56, 66, 281\nInternet Group Management Protocol (IGMP),\n172,174,176-178\nDVMRP interactions, 312\nMIB for, 255\nMOSPF interactions, 192-193\nInternet Protocol (IP). See IP (Internet Protocol)\nInternet routing table, 29\nInternet Service Providers (ISPs), 32-34\nInternet worm, 68-69INTEROP demo, 61,257-258,262\nInteroperability testing, 57-58\nINTEROP demo, 61\nproblems found in, 60-61\ntools for, 58-60\nIntra-area routing, 129\nIntradomain multicast routing protocols, 310\nInverse ARP, 10,115\nIP (Internet Protocol), 8\naddresses, 8,16-22,175\ndatagram forwarding. See Forwarding data-\ngrams\nfragmentation in, 10\nheaders, 6, 9-10, 85\npackets, 8\nsubnet model, 102-104,121\nIP Forwarding MIB, 254\nIP options, 11, 249, 252\nIPv4 vs. IPv6, 23-25\nIPv6,22-25\nIPv6 Neighbor Discovery protocol, 25\nIS-IS protocol, 48,50,300-303\nISPs (Internet Service Providers), 32-34\nISs (Intermediate Systems), 301\nivs tool, 174\nJacobson, Van, 250,252,264\nJOIN_ACK messages, 315\nJOIN_REQUEST messages, 315\nJoins in IGMP, 176\nJoins in IGMPvS, 178\nK\nKeepalives in BGP, 286\nKeys in cryptographic authentication, 237,\n239-240\nLANs, flooding LSAs over, 53\nLANWatch network analyzer, 261\nLeaf detection\nin DVMRP, 312\nin PIM Dense, 314\nLeave Group messages\nin IGMPv2,178\nin IGMPvS, 178\nLeave latency, 177-178,193",
        "9dd5f8fc-8f35-4751-92fc-2db51c9f9b2e": "338 OSPF: Anatomy of an Internet Routing Protocol Index\nLength field, 80\nLetter bombs, 179\nLink Data field, 82\nLink layer, encapsulation in, 50-51\nLink Management Interface (LMI) protocol,\n115-116\nLink start-up, Database Exchange process on, 163\nLink State Acknowledgments\nfor broadcast subnet synchronization,\n106-107\nfor NBMA subnet synchronization, 112-113\nin reliable flooding, 92-93\nLink-state advertisements. See LSAs (link-state ad-\nvertisements)\nLink-state algorithms, 39\u201440\ndevelopment of, 71-72\nvs. Distance Vector, 40,47--19\nmetrics for, 152-153\ntechnology for, 49-50\nLink-state databases, 83-85,281\naging, 160\nMaxAge LSAs in, 162-163\nin OSPF areas, 122\nrefreshing, 160-161\nin stub areas, 133\nsynchronizing. See Database synchronization\nLink State IDs, 75, 81,130,147\nLink-state PDUs (LSPs), 301\nLink State Requests, 90, 284\nLink State Updates, 90,146,284\nfor broadcast subnet synchronization,\n106-107\nfor NBMA subnet synchronization, 112-113\nin reliable flooding, 92-93\nLink Type field, 82\nLinks\ncosts of, 152-153,225\nvirtual. See Virtual links\nLMI (Link Management Interface) protocol,\n115-116\nLoad balancing, 10-11\nLocal area networks, LSAs over, 53\nLOCAL_PREF attribute, 295-296\nLollipop-shaped sequence number space, 77\nLongest matches in routing tables, 28\nLoopback addresses, 18-19\nLoose-source route option, 11-12\nLS Age field, 283\nin link-state database refreshing, 160\nin LSAs, 77, 79-80in reliable flooding, 92, 94\nLS Checksum field, 78, 84\nLS Sequence Number field, 76-77\nLS Type field, 74-75\nLSAs (link-state advertisements), 48, 72-74, 282.\nSee also specific LSAs by name\nchecksums for, 78,84,159-160\nin Database Overflow, 145\ndeleting, 79-80\nin Demand Circuit, 141\ndigital signatures for, 240\nfragmentation, 52\nidentifying, 74-76\ninstances, 76-77\nfor LANs, 53\nMaxAge, 56,65, 79,90, 92,162-163\nOptions and Length fields in, 80\nrefresh traffic and routing tables, 161\nsample, 81-83\nself-originated, 76-77\nsynchronization of, 59-60\nfor unreachable routers, 161-162\nverifying contents, 78\nLSPs (link-state PDUs), 301\nLSRefreshTime constant, 80\nM\nMAEs (Metropolitan Area Ethernets), 34\nMailing lists, 152\nManagement, 213\nArkansas public school example, 228-230\nOSPF MIB, 218-222\nOSPF protocol monitoring, 230-232\nrouting protocol interactions, 233-236\nsecurity, 236-241\nSNMP, 214-218\nManagement Information Bases (MIBs)\nin debugging routing problems, 254-257\nOSPF, 218-222\nSNMP, 214-215,254-257\nMandatory attributes, 294\nmap_bone program, 185,265\nMatches in routing tables, 28\nMAX-ACCESS clauses, 215\nMaxAge constant, 80\nMaxAge LSAs, 56,65,79,90,92,162-163\nMaxAgeDiff constant, 80\nMaximize reliability TOS service, 46\nMaximize throughput TOS service, 46",
        "d910381d-278d-4909-8857-4b3d437e87a9": "Index OSPF: Anatomy of an Internet Routing Protocol 339\nMaximum Transmission Units (MTUs), 10\nMaxSequenceNumber value, 77\nMBONE (Multicast Backbone), 21-22, 68\napplications for, 174-175\nMOSPF in, 188,206-208\nmulticast routing in, 184-186\nTTL thresholds in, 185-186\nMD5 hash algorithm, 237-238\nMedin, Milo, 54, 63\nMerit GATED Consortium, 152\nMessage verification, 239\nMetric field, 83\nMetropolitan Area Ethernets (MAEs), 34\nMIB-n, 254\nMIBs (Management Information Bases)\nin debugging routing problems, 254-257\nOSPF, 218-222\nSNMP, 214-215,254-257\nMinimize delay TOS service, 46\nMinimize monetary cost TOS service, 46\nMinLSArrival constant, 80,94-95\nMinLSInterval constant, 80,95\nmmcc tool, 174\nMonitoring\nOSPF protocol, 230-232\nproduct-specific, 265-266\nMore specific matches in routing tables, 28\nMorris, Robert, 68-69\nMOSPF (Multicast Extensions to OSPF), 187-188,\n313-314\nadvertising information in, 201-202\nbackward compatibility in, 203-205\nexpanding ring searches in, 190\ngroup-membership-LSAs in, 192-194\nhierarchical multicast in, 163,199-203\nin MBONE, 188,206-208\nresponse to changes in, 191-192\nreverse costs in, 163-166\nrouting calculations in, 194-199,202-203\nsteady-state forwarding behavior in, 188-190\nvendor support for, 163\nmrinf o program, 185, 264\nrerouted program, 68,184, 245, 271,312\nmtrace tool, 253, 266-271\nMTUs (Maximum Transmission Units), 10\nMULTI_EXIT_DISC attribute, 295\nMultiaccess networks, 284\nMulticast caches, 183,195-197\nMulticast Extensions to OSPF. See MOSPF\n(Multicast Extensions to OSPF)Multicast groups, 172\nMulticast routers, 172\nMulticast routing and protocols, 7, 68,171,\n309-310\nbroadcast-and-prune, 310-312\nCBT, 315\nDVMRP, 312-313\nforwarding in, 178-184,195-197, 255\nhierarchical, 199-203\nIGMP, 176-178\ninteraction among, 315-316\nInternet model, 171-173\nIP addresses for, 16,176\nMBONE, 184-186\nMOSPF. See MOSPF (Multicast Extensions to\nOSPF)\nmtrace tool for, 253, 266-271\nPIM Dense, 314\nPIM Sparse, 314-315\nprotocol stack in, 173-178\nsubnet mode in, 104\nmulticast tunnels, DVMRP, 207\nMultipath routing, 10-11,98\nN\nNANOG (North American Network Operators\nGroup), 33\nNAPs (Network Access Points), 34,64\nNASA Science Internet network, 63\nNAT (Network Address Translation) devices, 19,\n23\nNBMA (nonbroadcast multiaccess) subnets, 53,\n67-68\nabstraction of, 113\ndatabase synchronization in, 112-113\nneighbor discovery and maintenance in,\n111-112\nproblems in, 113-114\nNeighbor discovery and maintenance, 25, 86-87,\n101\nin BGP, 288\nin broadcast subnets, 105-106\nin DVMRP, 312\nin IGRP, 298\nin IS-IS, 301\nin NBMA subnets, 111-112\nin OSPF, 282\nin Point-to-MultiPoint subnets, 115-116\nin RIP, 278",
        "9040878b-4cc1-4b79-9bb0-98a701ea677f": "340 OSPF: Anatomy of an Internet Routing Protocol Index\nNetWare Link Services Protocol (NLSP), 49\nNetwork Access Points (NAPs), 34, 64\nNetwork Address Translation (NAT) devices, 19,\n23\nNetwork analyzers\nfor debugging, 259-262\nfor interoperability testing, 58\nintegrated with IP datagram forwarding, 14\nNetwork General Sniffer network analyzer, 261\nNetwork layer, 7-8\nNetwork Layer Reachability Information (NLRI),\n288\nNetwork loads, routing responses to, 153\nNetwork-LSAs, 75,108-109,284\nfor NBMA subnets, 113\nNetwork management stations, 257\nNetwork Mask field, 87\nNetwork segments, 8-9, 83-85\nNetwork-summary-LSAs, 75,122-124\nNetwork types, 101-102\nbroadcast subnets. See Broadcast subnets\nIP subnet model, 102-104\nNBMA subnets, 111-114\nPoint-to-MultiPoint subnets, 114-117\nNext Header field, 23-24\nnevot application, 174\nNEXT_HOP attribute, 295\nNext-hop field in RIPv2, 279\nNHRP (Next Hop Resolution Protocol), 103\nNLRI (Network Layer Reliability Information),\n288\nNLSP (NetWare Link Services Protocol), 49\nNonbroadcast multiaccess (NBMA) subnets, 53,\n67-68\nabstraction of, 113\ndatabase synchronization in, 112-113\nneighbor discovery and maintenance in,\n111-112\nproblems in, 113-114\nNonmulticast routers with MOSPF, 203-205\nNormal TOS service, 46\nNorth American Network Operators Group\n(NANOG), 33\nNot-so-stubby areas (NSSAs), 133-134,143-145\nNotification messages in BGP, 286\nNSF regional networks, 281\nNSFNETIGP, 304\nnslookup command, 246\nNSSAs (not-so-stubby areas), 133-134,143-145\nnv application, 174OIDs (Object Identifiers)\nin OSPF MIB, 218\nin SNMP, 215\nin SNMP MIBs, 255\nOpen messages in BGP, 286\nOptions fields, 87,136\nfor Demand Circuit, 142\nin LSAs, 80\nfor MOSPF, 201\nfor NSSA areas, 145\nfor stub areas, 140\nfor TOS-based routing, 139\nORIGIN attribute, 291, 295\nORIGINATORJD attribute, 293,296\nOSI reference model, 5-9\nOSPF Area IDs, 86\nOSPF areas, 55,122-125\naddress ranges for, 283\nboundaries of, 157\nconfiguring, 226-227\nexternal routing information in, 131-132\nNSSA, 133-134,143-145\norganization of, 125-127\nsize of, 157\nstub, 64,133, 139-140\nvirtual links for, 127\nOSPF MIB, 218-222,254\nospf_monitor program, 263-264\nOSPF packet types, 85-86\nOSPF Router ID, 86\nOSPF routing protocol, 3, 71-72, 281-284\ndesign issues. See Design considerations\nfunctional requirements, 43-47\nmonitoring, 230-232\nOSPF with Digital Signatures, 240\nOSPF Working Group, 43,152\nmailing list, 152\nospf AddressLessif variable, 220\nospf AdminStat variable, 220,226\nospf AreaAggregateArealD variable, 221\nospfAreaAggregateEf feet variable, 221, 226\nospf AreaAggregateMask variable, 221\nospf AreaAggregateNet variable, 221\nospf AreaAggregateTable table, 156, 218-219,\n221, 226\nospf AreaLsaCkSumSum variable, 84, 231,258\nospf AreaLsaCount variable, 84\nospf AreaRangeTable table, 155, 218-219",
        "e7b0dfdf-751a-4c69-8131-944762504344": "Index OSPF: Anatomy of an Internet Routing Protocol 341\nospfAreaSummary variable, 220\nospf AreaTable table, 219-220\nospfDemandExtensions variable, 220\nospf ExitOverf lowlnterval variable, 220\nospf ExternLsaCkSumSum variable, 84,231\nospf ExternLsaCount variable, 84\nospfExtLsdbAdvertisement variable, 222\nospfExtLsdbLimit variable, 145-146, 220\nospf ExtLsdbTable table, 219, 221, 231\nospf GeneralGroup table, 219-220\nospfHostArealD variable, 220\nospfHostlpAddress variable, 220\nospf HostMetric variable, 220\nospf HostTable table, 219-220\nospfIfAdminStat variable, 231\nospf IfAreald variable, 156, 220, 226\nospf IfAuthFai lure variable, 222\nospf IfAuthKey variable, 221\nospf IfAuthType variable, 220-221\nospf IfConf igError variable, 222, 226, 232\nospf If Demand variable, 221\nospf IfHelloInterval variable, 155, 227\nospf If IpAddress variable, 155, 220\nospf If IpMetricValue variable, 155\nospfIfMetricAddressLessIf variable, 215\nospf IfMetricEntry variable, 215-216\nospf IfMetricIpAddress variable, 215\nospf IfMetricStatus variable, 215\nospf IfMetricTable table, 215-217, 219, 221\nospf IfMetricTOS variable, 215\nospf IfMetricValue variable, 214-217,221,224\nospf If Polllnterval variable, 227-228\nospf IfRetransInterval variable, 155,\n227-228\nospflfRtrDeadlnterval variable, 155-156,\n227\nospfIfRxBadPacket variable, 222\nospfIfStateChange variable, 222\nospf If Table table, 219-221\nospf IfTransitDelay variable, 155, 227-228\nospf If Type variable, 220, 224\nospf ImportAsExtern variable, 220\nospf LsdbAdvertisement variable, 221\nospf LsdbAge variable, 221\nospf LsdbApproachingOverf low variable, 222\nospfLsdbChecksum variable, 221\nospfLsdbOverf low variable, 222\nospfLsdbTable table, 219, 221, 226\nospfMaxAgeLsa variable, 222\nospfMulticastExtensions variable, 220ospfMbrlpAddr variable, 221\nospf NbrLsRetransQLen variable, 231-232\nospf NbrPriority variable, 221\nospfNbrState variable, 232\nospfNbrStateChange variable, 222,232\nospfNbrTable table, 219, 221,224, 231\nospf OriginateLsa variable, 222\nospf query program, 258\nospfRouteGroup variable, 218\nospfRouterld variable, 220\nospf SetTrap variable, 222\nospf SpfRuns variable, 232\nospf StubAreaTable table, 219-220,226\nospf StubMetric variable, 220\nospf StubMetricType variable, 220\nospf TOSSupport variable, 220\nospfTxRetransmit variable, 222, 232\nOSPFvl, 56-57\nospfVirtlf Areald variable, 221\nospfVirtlf AuthFailure variable, 222\nospfVirtlf Conf igError variable, 222\nospfVirtlfNeighbor variable, 221\nospfVirtlfRxBadPacket variable, 222\nospfVirtlf StateChange variable, 222\nospfVirtlf Table table, 156, 219,221, 226\nospfVirtNbrStateChange variable, 222\nospfVirtNbrTable table, 219, 221\nospfVirtTxRetransmit variable, 222\nPacket radio, 111,114,141\nPackets, 3\nnetwork analyzers for, 259-262\nbetween OSPF routers, 85-\u00ab6\nrouting.",
        "4de01670-64f4-45f3-a8b4-3350870760ff": "See Routing tables and routing table\ncalculations\ntracing, 14\nPartial Sequence Number PDUs, 302\nPartitions in hierarchical routing, 120\nPath attributes in BGP, 286, 294-296\nPath calculations. See Routing tables and routing\ntable calculations\nPath characteristics\nof BGP, 288\nof IGRP, 298\nof IS-IS, 301\nof OSPF, 282\nof RIP, 278\nPath Vector protocols, 287",
        "938a0625-f2c5-41ab-8e99-07a14598f827": "342 OSPF: Anatomy of an Internet Routing Protocol Index\npathchar tool, 253\nPatricia trees, 30-31\nPayload Length field, 23-24\nPDUs (Protocol Data Units), 301\nPeering agreements, 32\nPeers in BGP, 286\nPhysical layer, 7\nPhysical protocols, 5\nPIM protocol, 180\nPIM Dense (Protocol Independent Multicast\nDense Mode), 314\nPIM Sparse (Protocol Independent Multicast\nSparse Mode), 314-315\nping tool, 247-250\nPNNI (Private Network-to-Network Interface)\nprotocol, 49\nPoint-to-MultiPoint subnets, 114-116\nPoint-to-point links\nunnumbered, 155\nrepresentation of, 153-155\nPolicy considerations in area boundaries, 158\nPolicy controls\nin BGP, 290-291\nin IGRP, 299\nin IS-IS, 302\nin OSPF, 283-284\nin RIP, 279\nPort Unreachable messages, 252\nPremature aging of LSAs, 79\nPresentation layer, 8-9\nPriority field in IPv6,23-24\nPrivate Network-to-Network Interface (PNNI)\nprotocol, 49\nProduct-specific debugging tools, 265-266\nPromiscuous mode, 189,261\nProtocol Data Units (PDUs), 301\nProtocol Independent Multicast Dense Mode\n(PIM Dense), 314\nProtocol Independent Multicast Sparse Mode\n(PIM Sparse), 314-315\nProtocol-specific tools, 263-265\nProtocol stacks, 5\nProtocols, 4-5\nProvider addressing, 17-18\nPrune messages, 310\nPseudonode LSPs, 301\nPublic-key encryption, 240-241\nPusateri, Tom, 258Queriers, 176-178,192-193,205\nQUIT_NOTIFICATION messages, 315\nRADIUS (Remote Authentication Dial-In User\nService), 14\nRandom Early Detection (RED) algorithm, 13\nRCID_PATH attribute, 296\nReachability protocols, 304\nReal-Time Transport Protocol (RTF), 174\nRecord-route option, 11\nRED (Random Early Detection) algorithm, 13\nRedirect messages, 12\nRefreshing link-state database, 160-161\nReliable flooding, 48,72,83,282\nAS-external-LSAs, 131-132\nin database synchronization, 92-95,107-108\nin NBMA subnets, 112\nin Point-to-MultiPoint subnets, 116\nrobustness of, 94-95\nscope of, 131-132\nRemote Authentication Dial-In User Service\n(RADIUS), 14\nRemote Monitoring MIB (RMON), 14\nRemote Network Monitoring (RMON), 261\nRemote Procedure Call (RPC), 8\nRendezvous Points (RPs)\nin PIM protocol, 180\nin shared-tree protocols, 182\nReplicated distributed database approach, 39\nResearch Internet Gateway project, 138\nResponse to changes\nin BGP, 288-290\nin IGRP, 298\nin IS-IS, 302\nin OSPF, 283\nin RIP, 278\nReverse costs, 163-166,225\nReverse-path broadcasting, 179\nRIB-In database in BGP, 286\nRIP (Routing Information Protocol), 277-279\ncounting to infinity in, 37-39\nas Distance Vector algorithm, 35-37\ninteractions with, 156,\" 235-236\nRIPv2,279-281\ntools for monitoring, 263-264\nfor wiretapping, 16",
        "7fa4f34f-cc44-4334-8d17-7c6adaf90aa4": "Index OSPF: Anatomy of an Internet Routing Protocol 343\nRIP request packets, 279\nripquery tool, 263-264\nRIPv2 MIB, 255\nRMON (Remote Monitoring MIB), 14\nRMON (Remote Network Monitoring), 261\nRobustness and reliability\nin BGP, 290\nin database synchronization, 94-95\nin Demand Circuit, 142\nin IGRP, 299\nin IS-IS, 302\nin OSPF, 283\nOSPF areas for, 124\nin RIP, 278\nin shared-tree protocols, 182\nRoute dampening, 297\nRoute filters, 305\nRoute Reflectors (RRs), 293-294\nRoute Reports, 312-313\nRoute Servers, 34,294\nRoute tags, 279\nrouted program, 151,264,277\nRouter Discovery messages, 12\nRouter Type field, 81\nRouter IDs, 73,81,222-223\nRouter-LSAs, 74,108-109, 284\nexample, 81-83\nin MOSPF, 193\nin NBMA subnets, 113,116\nin OSPF areas, 122-124\nin IOS-based routing, 138-139\nRouter Priority field, 87\nRouterDeadlnterval variable, 87\nRouters, 3-4\nAdvertising, 75-76,156\nin forwarding datagrams. See Forwarding da-\ntagrams\nin Internet protocol suite, 4-9\nin IPv6,22-25\nin link-state database, 83-85\nmulticast, 182-184\npackets between, 85-86\nunreachable, 161-162\nRoutes in routing tables, 28\nRouting and routing protocols, 3-4,27, 275-276\narchitecture of, 32-34\nBGP, 284-297\ndebugging. See Debugging routing problems\nDistance Vector algorithms, 35-39\nhierarchical. See Hierarchical routinghistorical, 303-304\nIGRP, 297-300\nintegrated IS-IS, 300-303\ninteractions among, 233-236,305-307,\n315-316\nlink-state algorithms, 39-40\nmetrics for, 45\nmulticast. See Multicast routing and protocols\nOSPF, 281-284\nprotection for, 125\nRIP, 277-281\nrouting tables in. See Routing tables and rout-\ning table calculations\nRouting Arbiter project, 34\nRouting domains, 34\nRouting Information Protocol. See RIP (Routing\nInformation Protocol)\nRouting protocols. See Routing and routing proto-\ncols\nRouting tables and routing table calculations,\n27-30,95-98\nin BGP, 290\nin extending OSPF, 136\nin hierarchical MOSPF, 202-203\nin IGRP, 298-299\nimplementing, 30-32\nin IS-IS, 302\nand LSA refresh traffic, 161\nin MOSPF, 194-199\nin OSPF, 283\nin RIP, 278\nsize of, 121-122\nRFC (Remote Procedure Call), 8\nRPs (Rendezvous Points)\nin PIM protocol, 180\nin shared-tree protocols, 182\nRRs (Route Reflectors), 293-294\nRSA algorithm, 241\nRSVP protocol, 13\nRIP (Real-Time Transport Protocol), 174\nsd tool, 174-175\nSecret keys in cryptographic authentication, 237,\n239-240\nSecurity, 236\nin BGP, 291\ncryptographic authentication, 237-238\nin IGRP, 299",
        "53e3bc52-1441-46ff-bc39-7973fcdc4dc6": "344 OSPF: Anatomy of an Internet Routing Protocol Index\nSecurity (continued)\nimprovements, 240-241\nInternet worm, 68-69\nin IP datagram forwarding, 13-14\nin IS-IS, 302\nkey management, 239-240\nmessage verification, 239\nin OSPF, 46, 284\nin RIP, 279\nin SNMP, 257\nSecurity protocols, 238\nSelf-originated LSAs, 76-77\nSemantic fragmentation, 95\nSequence Number PDUs, 302\nSession layer, 8\nset function, 217\nSetRequest packets, 255,257\nShared-tree protocols, 180,182-183\nShortest Path First (SPF) algorithm, 48, 96-97\nSignatures, digital, 237, 240-241\nSimple Mail Transport Protocol (SMTP), 9\nSimple Network Management Protocol (SNMP),\n214-218\nSIN (Ships-in-the-Night) approach, 66, 300\nSize\nof OSPF areas, 157-158\nof packets with ping tool, 248\nSMDS (Switched Multi-Data Service), 105,110\nSMTP (Simple Mail Transport Protocol), 9\nSniffers\nfor debugging, 259-262\nfor interoperability testing, 58\nintegrated with IP datagram forwarding, 14\nSNMP (Simple Network Management Protocol),\n214-218\nSNMP MIBs, 254-257\nSNMP tools, 217\nsnoop analyzer, 261\nsockaddr structures, 277\nSoftware sources, 151-152\nSource-based multicast routing protocols,\n179-181,183,309-310\nSource Quench messages, 12-13\nSource route tunneling option, 22\nSource-specific joins and leaves, 178\nSpanning trees, 94\nSPF (Shortest Path First) algorithm, 48, 96-97\nSplit horizons\nin Distance Vector protocol, 38\nin IGRP, 299Standards, IETF, 66\nStatic routing, 29-30\nStatistics collection, 14\nSteady-state forwarding behavior in MOSPF,\n188-190\nStrict-source route option, 11-12\nStub areas, 64,133,139-140\nSubnet masks, 20-21\nSubnet numbers, 20\nSubnets, 19-21\nas OSPF design issue, 46\nin subnet model, 102-104\nSubnetwork-dependent convergence functions,\n101\nSummary-LSAs, 284\nin Database Overflow, 146\nin MOSPF, 201,205\nin OSPF areas, 122-125\nin stub areas, 133,139\nSupernets, 21\nSwamp, 33\nSwitched Multi-Data Service (SMDS), 105,110\nSynchronization\ndatabase. See Database synchronization\nIGP, 296-297\nSynchronized clocks, 160\nSYNTAX clauses, 215\nsyslog facility, 232, 265\nTables, routing. See Routing tables and routing ta-\nble calculations\nTCP (Transmission Control Protocol), 6, 8, 51\nTCP/IP (Transmission Control Protocol/Internet\nProtocol), 4-9,13,277\ntcpdump network analyzer, 261\nTELNET protocol, 9\nTFTP (Trivial File Transport Protocol), 9\nTimers, 155-156,227-228\nTimestamp option, 11\nTools\nfinding, 245\ninteroperability testing, 58-60\ninterpretation of, 245-247\nMIB-based, 257-259\nmtrace, 266-271\nnetwork analyzers, 259-262\nping, 247-250\nproduct-specific, 265-266",
        "17cfa016-5656-4b11-8d5f-ae675f81fbef": "Index OSPF: Anatomy of an Internet Routing Protocol 345Iprotocol-specific, 263-265\nSNMP MIBs, 254-257\ntraceroute, 250-253\nTopology considerations in OSPF area bound-\naries, 157-158\nIOS (Type of Service) field, 11\nTOS (Type of Service) routing, 39\noperation of, 137-139\nas OSPF design issue, 46-47\ntraceroute tool, 244-245, 250-253\nfor interoperability testing, 58\nfor multicasting, 184\nTracing, product-specific, 265-266\nTraffic concentration in shared-tree protocols, 180\nTransit ASs, 296-297\nTransit provision by ISPs, 33\nTransitive attributes, 294\nTransitivity assumption for broadcast subnets,\n110-111\nTranslation of Type-7-LSAs, 143-144\nTransmission Control Protocol (TCP), 6, 8, 51\nTransmission Control Protocol/Internet Protocol\n(TCP/IP), 4-9,13,277\nTransport layer, 8\nTraps in SNMP, 218, 222, 255\nTrees\nin Dijkstra's algorithm, 96-97\nin MOSPF, 197-198\nin multicast forwarding, 180\nTriggered updates\nin Distance Vector protocol, 38\nin IGRP, 299\nTrivial File Transport Protocol (TFTP), 9\nTroubleshooting. See Debugging routing prob-\nlems\nTTL field, 10,12, 85,190, 247, 252\nTTL thresholds, 185-186\nTunneling\nin DVMRP multicasts, 207\nin IP datagram forwarding, 12, 21-22\n2-Way states, 156\nType-7-LSAs, 133,143-144\nType of Service (TOS) routing, 39\noperation of, 137-139\nas OSPF design issue, 46^7Unicast IP addresses, 16\nUnicast routing protocols, 275-276\nBGP, 284-297\nhistorical, 303-304\nIGRP, 297-300\nIntegrated IS-IS, 300-303\ninteraction among, 305-307\nwith multicast routing protocols, 310\nOSPF, 281-284\nRIP, 277-281\nUnits for link-state metrics, 152-153\nUniversal IBGP, 297\nUnnumbered point-to-point links, 155\nUnreachable routers, 161-162\nUpdate messages in BGP, 286\nUpstream ISPs, 33\nUser Datagram Protocol (UDP), 8, 51\nV\nVariable-length subnet masks (VLSMs), 20\nvat application, 174\nVectors in Distance Vector algorithm, 36\nVerification\nLSA contents, 78\nmessage, 239\nVirtual IP addresses, 15-16\nVirtual links, 55\nbenefits of, 158\ncosts in, 152-153\ndata traffic on, 159\nfor OSPF areas, 127, 226\nin stub areas, 133\nVirtual Router Redundancy Protocol, 15\nViruses, 68-69\nVLSMs (variable-length subnet masks), 20\nw\nwb tool, 174\nWeighted hop counts, 83,96, 225\nWFQ (Weighted Fair Queuing) algorithm, 13\nwhois command, 246-247\nWildcard multicast receivers, 201\nWiretapping, 16\nu\nUDP (User Datagram Protocol), 8, 51\nUnicast communication, 7X.25 subnets, 111, 140\nXDR (External Data Representation) protocols, 9\nXNS Routing Information protocol, 277",
        "cda90f05-0443-4567-9115-d7e39190ff8f": "PATHOFAPACKET INTHE LINUX\nKERNEL STACK\nAshwin Kumar Chimata\nashwinc@ittc.ku.edu\nUniversity ofKansas\nJuly 11,2005\n1",
        "d3150e6d-a31d-4681-9808-76ab7f4b5394": "Contents\n1INTR ODUCTION 3\n2TCP/IP -Overview 3\n3When Data issent through socket 4\n3.1 Application Layer ..........................4\n3.2 TheSock etInterf ace ........................5\n3.3 Transport Layer ...........................7\n3.4 Netw orklayer (IP) .........................9\n3.5 Data Link Layer ...........................10\n4When data isreceivedfromtheMedium 12\n4.1 Physical layer ............................12\n4.2 Netw orkLayer -IP.........................14\n4.3 Transport Layer ...........................14\n4.4 Application Layer ..........................17\n4.5 Conclusions .............................19\n2",
        "ead8c39e-e03a-4ded-a2e3-663d6c79243c": "1INTR ODUCTION\nThe\u0003owofthepacketthrough thelinux netw orkstack isquite intriguing and\nhasbeen atopic forresearch, with aneyeforperformance enhancement inend\nsystems. This document isbased ontheTCP/IP protocol suite inthelinux kernel\nversion 2.6.11 -thekernel core prevalent atthetime ofwriting thisdocument. The\nsolepurpose ofthisdocument istotakethereader through thepath ofanetw ork\npacketinthekernel with pointers toLXR targetswhere onecanhavealook atthe\nfunctions inthekernel which dotheactual magic.\nThis document canserveasaready look upforunderstanding thenetw ork\nstack, anditsdiscussion includes KUR TDSKI instrumentation points, which are\nhighly useful inmonitoring thepacketbehaviorinthekernel.\nWebase ourdiscussion onthescenario where data iswritten toasocketandthe\npath oftheresulting packetistraced inacode walkthrough sense\n2TCP/IP -Overview\nTCP/IP isthemost ubiquitous netw orkprotocol onecan\u0002nd intoday' snet-\nwork. The protocol hasitsroots inthe70'sevenbefore theformulation ofthe\nISO OSI standards. Therefore, there arefour well de\u0002ned layers intheTCP/IP\nprotocol suite which encapsulate thepopular sevenlayered architecture, within it.\nRelating TCP/IP totheOSI model -Theapplication layer intheTCP/IP pro-\ntocol suite comprises oftheapplication, presentation andthesessions layer ofthe\nISOOSImodel.\nThesocketlayer actsastheinterf acetoandfrom theapplication layer tothe\ntransport layer .This layer isalso called astheTransport LayerInterface .It\nisworth mentioning that there aretwokinds ofsocketswhich operate inthis\nlayer ,namely theconnection oriented (streaming sockets)andtheconnectionless\n(datagram sockets).\nThenextlayer which exists inthestack istheTransport Layerwhich encapsu-\nlates theTCP andUDP functionality within it.This forms Layer 4oftheTCP/IP\n3",
        "22140315-b266-4da1-ac02-6be64ad0087b": "protocol stack inthekernel. TheNetw orkLayerintheTCP/IP protocol suite is\ncalled IPlayerasthislayer contains theinformation about theNetw orktopology ,\nandthisforms Layer 3oftheTCP/IP protocol stack. This layer also understands\ntheaddressing schemes andtherouting protocols.\nLink Layerforms Layer 2ofthestack andtakescare oftheerror correction\nroutines which arerequired forerror freeandreliable data transfer .\nThelastlayer isthePhysical Layerwhich isresponsible forthevarious mod-\nulation andelectrical details ofdata communication.\n3When Data issent through sock et\nLetusexamine thepack et\u0003owthrough aTCP socket asamodel, tovisual-\nizetheNetw orkStack operations inthelinux kernel.\nNOTE: Allbold faced textareLXR search strings andthe\ncorresponding \u0002les aremostly mentioned alongside each LXR target.\nIntheeventof\u0002lenames notbeing mentioned, anidenti\u0002er search\nwith theLXR targetswilllead tothecorrect location which isin\nconte xt.\n3.1 Application Layer\nThejourne yofthenetw orkpacketstarts attheapplication layer where data is\nwritten tothesocketbyauser program. Theuser program mostly uses thesocket\nAPI which provides thesystem calls fortheuser toperform theread&write\noperations tothesocket.Most operations onasocketwill besimlilar tothose\nwith anormal \u0002ledescriptor ,butallthemain functionality arewell abstracted in\nthekernel.\nTheAPIprovides arichsetofoptions fortheuser tointeract with thenetw ork,\nsome ofthecommon calls aresend, sendto, sendmsg ,write ,write v.Outofthese,\nsend, write andwrite vonly workwith connected sockets,because theydonot\nallowthecaller tospecify thedestination address. Thewrite system calltakesin\nthree arguments\n4",
        "04f98476-4675-4a0e-844d-c36877679153": "write(socket,buffer,lengt h);\nThewrite vcallperforms thesame function asthewrite call, except thatituses\na\u0094gather write\u0094 form, which allowsanapplication program towrite amessage\nwithout copying thedata tocontiguous bytes ofmemory .\nwritev(socket, iovector, vectorlen);\nWhere iovector givestheaddress ofanarray oftype iovecthatcontains ase-\nquence ofpointers totheblocks ofbytes thatform themessage.\nWhen amessage sending calllikesend, write etcismade, thecontrol reaches\nthesock sendmsg system callwhich isinnet/soc ket.c,irrespecti veofthekind\nofsystem call. This checks iftheuser bufferisreadable andifso,itobtains the\nsockstruct byusing thesocketdescriptor available from theuser-levelprogram\nwhich isissuing thecall. Itthen creates themessage header based onthemessage\ntransmitted andasocketcontrol message which hasinformation about theUID,\nPID andGID oftheprocess. Allthese operations arecarried outintheprocess\nconte xt.\nThecontrol calls the sock sendmsg ,which traverses totheprotocol speci\u0002c\nsendmsg function. Theprotocol options areconsulted, through thesendmsg \u0002eld\noftheprotoopsstructure andthe,protocol speci\u0002c function isinvoked.Thus,\nifitisaTCP socketthen thetcpsendmsg function iscalled andifitisaUDP\nsocketthen theudp sendmsg function iscalled. These decisions aremade after\nthecontrol passes overtheTransport Layer Interface andadecision ismade on\nwhich protocol speci\u0002c function tocall.\nThetcpsendmsg function, de\u0002ned in\u0002lelinux/net/ipv4/tcp.c is\u0002nally invoked\nwhene veranyuser-levelmessage sending isinvokedonanopen SOCK STREAM\ntype socket.\n3.2 The Sock etInterface\nTheSock etInterf acelayer issometimes called theglue layer asitactsasanin-\nterfacebetween theApplication layer andthelowerTransport Layer .This isalso\n5",
        "18d6c5da-3969-445c-972e-8f452423e274": "called theTransport Layer Interface andisresponsible forextracting thesock\nstructure andchecking ifitisfunctional. Ineffectthislayer invokestheappro-\npriate protocol fortheconnection. This function iscarried outininet sendmsg\nwhich isinnet/ipv4/af inet.c\nTheother relevantoperations which takeplace atthislayer arethesystem call\ntranslation forthevarious socketcreation routines. Themain functionality corre-\nsponding tosocketcreation takesplace inthenet/soc ket.c.This istheregion in\nthekernel where allthetranslations forthevarious socketrelated system calls like\nbind, listen, accept, connect, send &recvarepresent.\nInaKUR Tenabled kernel, wecan\u0002ndvarious instrumentation points which\ncanbeturned ontogiveanelaborate narrati veofwhen andhoweach ofthese\nsystem calls arebeing called. Some oftheinstrumentation points wecan\u0002ndin\nthislayer are:\nEVENT_SOCKET ->whenasocketiscreated.\nEVENT_BIND ->Eventwhenasocketisboundtoanaddress.\nEVENT_LISTEN ->Eventwhensocketlisteniscalled.\nEVENT_CONNECT ->Eventwhentheconnect systemcalliscalled\nfromaclientmachine.\nEVENT_ACCEPT ->Eventwhentheserveraccepts theconnection\nfromaclient.\nEVENT_SOCK_SENDMSG ->Whenamessage iswritten tothesocket.\nEVENT_SOCK_RECVMSG ->Whenamessage isreadfromasocket.\nTherearesome moreinstrumentation points inthislevel,whichhave been omit-\ntedinthisdiscussion forthesakeofclarity .Foralistofallinstrumentation points\nplease refernetw ork.ns inkernel/scripts/dski/network.ns\nTheSock etlayer isresponsible foridentifying thetype oftheprotocol andfor\ndirecting thecontrol totheappropriate protocol speci\u0002c function. The protocol\nregistration takesplace here andtheappropriate transport layer routines arein-\nvoked.\n6",
        "872412a6-6279-40df-8979-11cd183f8fdb": "3.3 Transport Layer\nWhen theprotocol speci\u0002c routines forsending message iscalled, theopera-\ntions which takeplace nowareintheTransport Layer oftheNetw orkstack. The\nfunction pointer which would havebeen setintheprotostructure will direct to\ntcpsendmsg orudp sendmsg asthecase may be.\nAswearedealing with theTCP case, letusexamine thetcpsendmsg routine.\nThetcpsendmsg isde\u0002ned inlinux/net/ipv4/tcp.c which performs theTCP spe-\nci\u0002c workonthepacket.Itwaitstilltheconnection isestablished, asTCP cannot\nsend data tillaconnection isestablished. This section ofcode isshownbelow,\nhere itischecking iftheconnection isestablished before thetimeout occurs.\n/*Waitforaconnection tofinish. */\nif((1<<sk->sk_state) &~(TCPF_ESTABLISHED |TCPF_CLOSE_WAIT))\nif((err=sk_stream_wait_connect(sk, &timeo)) !=0)\ngotoout_err;\nTheother operation which thetcpsendmsg takescare ofissetting uptheMax-\nimum Segment Sizefortheconnection.\nOnce theconnection isestablished, andother TCP speci\u0002c operations areper-\nformed, theactual sending ofmessage takesplace. This isdone through theIO\nvector structure, which isamechanism fortransferring data from theuser space\nintothekernel space. This istheplace where thestruct skbuff*skb iscreated\nandtheuser data gets copied from theuser space tothesocketbuffersinthis\nfunction partofthecode.\nThe tcpsendmsg checks ifthere isbufferspace available inthepreviously\nallocated buffers. Ifso,itwrites theuser data ontothat. Else anewbuffer\nisrequested forthewrite operation. Basically thisstructure, tries tocopyuser\ninformation intoavailable socketbuffers, ifnone areavailable, newallocation is\nmade forthepurpose.\nOnce thesocketbufferis\u0002lled with data, tcpsendmsg copies thedata from\nuser space tokernel space bycalling theskbcopy topage function, which in-\nternally calls checksum routines before copying data intokernel space. There are\n7",
        "0af0d044-a79f-4a47-9021-ce3f08883d46": "other page faulthandling functionality which isincorporated inthetcpsendmsg\ncode which canbelookedupinthefunction. These areroutines which takecare\nofallocating pages when message copyroutines need them andsoon. This\nfunction \u0002nally calls thetcppush one function which isoneofthepaths to\ntcptransmit skbfunction, which isthemain function which transmits theTCP\nsegments. The other waysbywhich thetcptransmit skb canbecalled are\nthrough:\nexterninttcp_write_xmit(struct sock*,intnonagle);\nexterninttcp_retransmit_skb(struct sock*,structsk_buff *);\nexternvoidtcp_xmit_retransmit_queue (structsock*);\nexternvoidtcp_simple_retransmit(str uctsock*);\nandsoon...\nThetcptransmit skbdoes theactual packettransmission totheIPLayer .This\nfunction builds theTCP header andsends thepackettotheIPlayer .Building\ntheheader ineffectmeans thatthesource anddestination ipaddresses, theTCP\nsequence number areallsetup.Theimportant datastructures which arerelevantin\nthissection aretcphdr -which stores theheader information, tcpskbcb-isthe\nTCP control bufferstructure which contains the\u0003ags forthepartially generated\nTCP header .\nThis function also takescare oftheTCP scaling options andtheadvertised\nwindo woptions arealsodetermined here. Checksum calculations accompan yany\ndata additions totheheader orthedata section. Finally thequeue xmit function\niscalled asshownbelow,thisqueues thepackettoitsdestination. Itcaneither be\naninternal destination oranexternal destination, butthese aredecided onthenext\nlayer .\nerr=tp->af_specific->queue_xm it(skb,0);\nif(err<=0)\nreturnerr\n/*wheretpisthetcp_sock structure */\nAreturn value less than zero inthiscase indicates that thepackethasbeen\ndropped. Therelevantinstrumentation points inaKUR Tenabled kernel are:\n8",
        "4c6fb98d-014a-46d8-8475-cfe0d2465f4a": "EVENT_TCP_SENDMSG ->Whentcp_send_msg iscalled\nEVENT_TCP_WRITEXMIT ->whentcp_write_xmit iscalled\nEVENT_TCP_TRANSKB ->whentcp_transmit_skb iscalled\nEVENT_TCP_RECVMSG ->thetcpreceive message event\nEVENT_TCP_DATA_QUEUE ->whentcp_data_queue iscalled\nThese instrumentation points areplaced inthedifferent stages ofdata &header\nformation. The EVENT TCP TRANSKB istheinstrumentation point which is\nplaced inthetcptransmit skbfunction. Allthese functions arestillexecuted in\nprocess conte xt.\n3.4 Netw orklayer(IP)\nTheIPlayer recei vesthepacketandbuilds theIPheader forthepacket.This\nlayer takescareoftheroute lookup forthepacketsandalsomaintains theTimeTo\nlive(TTL forthese packets). Inaddition toIP,theICMP andIGMP alsogohand\ninhand with theIPlayer .Therefore these protocols canalso bethought ofasa\npartofIP.This layer handles theroute look upforincoming andoutgoing packets\ninthesame way.Ifitisanexternal address itisdelivered tothelowerLink Layer\nelseifitismeant forlocal delivery(incoming packet)then itisdelivered tothe\nhigher layer .\nWhen thequeue xmit function iscalled from within thetcpsock structure, the\ncontrol passes totheIPLayer where thefunction ipqueue xmit which isde\u0002ned\nin/net/ipv4/ip output.c iscalled.\nThe mechanisms offorwarding androuting arealso incorporated inthisrou-\ntine, byusing theForwar ding Information Base (FIB), which mainly handled by\nusing thekernrtastructure. Thediscussion about forwarding androuting isnot\nincluded inthisdocument.\nTherouting information ischeck edforpossible routing atthislevelbyusing the\nskdstcheck Thepacketisfragmented, ifneeded, bycalling theipfragment\nfunction.\n9",
        "41c1c4fc-554a-468d-95a4-73ab82ae2013": "After thechecks areperformed thefunction iproute output \u0003owiscalled,\nwhich isthemain function which takescare ofrouting thepacketsbymaking use\nofthe\u0003owistructure, which stores the\u0003owinformation. Theiproute output \u0003ow\nwhich isde\u0002ned in/net/ipv4/r oute.c,calls the iproute output keyfunction\nwhich \u0002nds aroute andchecks ifthe\u0003owistructure isnon-zero. The\niproute output key\u0002rstsearches theroute cache(anarea where recently ac-\ncessed routes arestored) forfastroute retrie val.Ifaroute isfound itisused, else\nittries to\u0002ndaroute bysearching theFIB.\nThe abovefunction ismeant forfastroute retrie val,ifitfailsto\u0002nd aroute\nfrom either theroute cacheortheForwar ding Information Base then theslow\nroute look upfunction, iproute output slowiscalled, which isthemain output\nroute resolving function. These controls stillhappens intheprocess conte xt.\nThecomple xities which reside intheroute look upcode andthedepth offor-\nwarding hasbeen omitted inthisdocument topreserv eclarity .\nTostate insimple terms, allthepacketrouting isdone bysetting uptheoutput\n\u0002eld oftheneighbour cachestructure. Once alltheprocessing ofanoutput packet\nisdone oneofthethree things canhappen:\n\u000fIfthepacketismeant tobeforwarded then theoutput pointer oftheneigh-\nbour cache structure willpoint toipforward .\n\u000fIfthere isanunresolv edroute forapacketevenafter alltheprocessing is\ndone, then theoutput pointer points toipoutput function.\n\u000fIfthere isaresolv edroute after atthisstage, then theoutput function pointer\noftheneighbour cache function willpoint tothedevqueue xmit function.\nWewillforwardourdiscussion with theassumption thataroute isresolv edand\nthedevqueue xmit function iscalled.\n3.5 Data Link Layer\nTheData Link Layer isresponsible foralargesetofoperations apart from just\nhanding overthepackettothedevice. This layer issometimes referred toasthe\nqueuing layer asmost ofthequeuing disciple implementation takesplace inthis\n10",
        "099ca442-e918-4e18-94b7-95f647a6cd7a": "region. Apart from queue disciples, traf\u0002cshaping functions arealso carried out\ninthislayer .\nThe devqueue xmit isthedata link layer function which iscalled forany\npacketwhich ismeant tobedelivered toanexternal destination. This function\nchecks ifthedevice registered with thesocketbuffer,hasanexisting queue disci-\nple. This function disables alllocal bottom halves before obtaining thedevices'\nqueue locks.\nHere we\u0002ndtheDSKI instrumentation which identi\u0002es theeventwhen apacket\nisabout tobequeued into itscorresponding device queue. This eventisnamed\nasEVENT DEV QUEUE andisplaced right before theactual packetenqueuing\ntakesplace. Thedevqueue xmit calls theqdisc runroutine, inavanilla kernel.\nThis function \u0002rstruns intheprocess conte xtandchecks ifthedevice haspackets\nwhich need tobetransmitted. Ifthere arepacketspresent then itinitiates the\ntransmission. Ifthedevice isnotfree, then thesame function isexecuted again in\ntheSoftIRQ conte xt,toinitiate thetransmission.\nWhen queue disc iscalled intheprocess conte xt,itchecks thestate ofthede-\nvice with thenetif queue stopped function. Ifthefunction con\u0002rms thatthede-\nvice state tobeup,then itcalls theqdisc restart function which tries totransmits\nthepacketinprocess conte xt.It\u0002rsttries toobtain thexmit lockforthedevice, if\nitissuccessful then itcalls thedev->hard start xmit which transmits thepacket\noutofthesystem. This routine isadevice speci\u0002c routine andisimplemented in\nthedevice drivercode ofthedevice.\nThe packetissent outinto themedium bycalling asetofI/Oinstructions to\ncopythepackettoharw areandstart transmitting. After thepackettransmission\niscompleted, thedevice frees theskbuffspace occupied bythepacketinthe\nhardw areandrecords thetime when thetransmission took place.\nIfthistransmission failsforanyreason, then thepacketisrequeued again for\nprocessing atafuture time. This isdone from theerror handling routines inthe\nqdisc restart function. Ifforsome reason thepackettransmission could notoc-\ncur,then itcalls thenetif schedule function, which schedules thepackettranmis-\nsion intheSoftIRQ conte xt.\n11",
        "2d1e17d2-8ce2-4267-acdb-f94db0d20195": "The netif schedule function calls the netif schedule function, which raises\ntheNET TXSOFTIRQ forthistransmission. TheDSKI eventwhich isinserted\natthispartofthepackettransmission iscalled EVENT NET TXSOFTIRQ .\nAfter thepackettransmission isscheduled again andcompleted inthenext\navailable time, thedevice frees thespace occupied bytheskbuffstructur eand\ncalls thenetif wakequeue which informs thatthedevice isfreeandcantakein\nmore packetsfortransmission. This function alsoraises aSOFT IRQ toschedule\nthenextpacketsending.\nThis completes thediscussion onhowapacketissent from theapplicationm\nlayer tothemedium. The nextsection deals with theprocess when apacketis\nrecei vedfrom themedium intothesystem.\n4When data isreceivedfromtheMedium\nInthissection wedeal with thepath ofanetw orkpacketfrom thephysical\nmedium uptotheapplication layer .Therecei vesideismore complicated than the\nsend sideasthecontrol \u0003owdoes notfollowalinear path.\n4.1 Physical layer\nWhen apacketarrivesattheNetw orkInterf aceCard ofthemachine, thecard\nrecei vesthepacketandthepacketistransferred into arxring through DMA.\nTherxring isaring inthekernel memory where thenetw orkcard transfers the\nincoming packetthrough DMA. Therawdata which isstored intherxring struc-\ntureiseither copied intoaskbuffstructure.\nAfter thepacketistransferred tothekernel memory ,thecard interrupts the\nCPU, toinform about theavailability ofanewpacket.The CPU then transfers\nthecontrol tothecore ISR which will takecare ofthepacketprocessing. As\ntheprocessing intheinterrupt conte xtshould beaslowaspossible, theInterrupt\nService Routine initiates theNET RXSOFTIRQ which willtakethepacketpro-\ncessing further .Theinterrupt handler calls thenetif rxschedule function which\nisde\u0002ned in(include/linux/netde vice.h),Which inturncalls netif rxschedule .\n12",
        "cca49b46-e55f-4a76-a80f-5dadbf06b8db": "The netif rxschedule function puts areference tothedevice into thesoft-\nnetdata polllist,andschedules theNET RXSOFTIRQ .From nowon,further\nprocessing ofthepacketistakencare ofinthesoftirqconte xt.\nWhene vertheNET RXSOFTIRQ isscheduled bythescheduler ,itexecutes\nitsregistered handler function which isthenetrxaction which isde\u0002ned in\nnet/cor e/dev.c.Inakurtenabled kernel wecan\u0002ndtheNET DEVICE LAYER FAM\ninstrumentation point named asEVENT NET RXACTION which appears ev-\nerytime thenetrxaction function iscalled.\nThe netrxaction function, disables theinterrupts, tillallthepacketsinthe\nrxring ofeach ofthedevices arehandled bytheSoft IRQ.This function polls\neach oftheregistered devices andprocesses therxring ofeach ofthedevices.\nThenetdevicestructure de\u0002ned in(include/linux/netde vice.h)hasafunction pointer\nforpoll which points towhich process backlog function which isde\u0002ned in\n(/net/cor e/dev.c).\nThebacklog devisapseudo device which isadded tothepolllist,whene ver\nnetif rxfunction iscalled, from thedevice driver,ifitisnotalready present inthe\npolllist.This isthemechanism, which isused toremo veapacketwhich hasbeen\nenqueued into theinput pktqueue bythenetw orkdrivers. The poll function\nofthebacklog device,which points toprocess backlog ,isused toremo vethe\npacketsfrom theinput queue, andtoprocess each ofthem.\nTherefore, when netrxaction polls each ofthedevices, ultimately thepro-\ncess backlog function gets called foreach ofthepackets,enqueued byeach of\nthedevices.\nThe process backlog function dequeues thepacketfrom theinput queue of\nthedevice bycalling the skbdequeue function, intoaskbuffstructure. Here\nwewillhaveaccess totheactual device, from theskbuffofthepacketandthe\nnetif receiveskbfunction iscalled forfurther processing.\nThenetif receiveskbfunction, classi\u0002es thepacketaccording toitstype, and\ndirects ittotheappropriate packethandler function, forinstance, inthecase ofIP\nthefunction iprcvistheregistered packethandler .\n13",
        "4f71df2c-e87a-4bf6-9050-b9f6fa54e603": "4.2 Netw orkLayer-IP\nThe main function which recei vesthepacketfrom thenetdevice layer isthe\niprcvfunction. This function checks thepacketforerrors anddiscards theIP\nheader ,defragments thepacketifnecessary .Thepacketpasses through thepre-\nrouting net\u0002lter hook andthen reaches iprcv\u0002nish function, which isde\u0002ned\ninnet/ipv4/ip input.c .\nInaKUR Tenabled kernel wewill \u0002nd theIPLAYER FAM family event\nEVENT IPRCV ,which corresponds totheinstance when apacketisrecei ved\nattheIPlayer .\nTheiprcv\u0002nish does theroute look upforthispacketanddecides ifthepacket\nistobedelivered locally oristobeforwarded and\u0002nally calls thedstinput\nfunction.The dstinput function inturn calls theiplocal deliverfunction, ifthe\npacketismeant tobedelivered locally .\nInaKUR Tenabled kernel theIPLAYER FAM event,\nEVENT IPLOCAL DELIVER ispresent atthisstage ofpacketdelivery.The\niplocal deliverfunction de\u0002ned in/net/ipv4/ip input.c ,de-fragments thepacket\nifnecessary andcalls theiplocal deliver\u0002nish function which inturn calls the\nprotocol speci\u0002c functions toprocess thepacket.\nTheiplocal deliver\u0002nish function strips thepacketofitsIPheader and\u0002nds\ntheprotocol associated with thepacketbyusing ahash function which hashes\nbased ontheprotocol number .Based ontheprotocol identi\u0002cation number ,the\nappropriate packethandlers foreach protocol getscalled.\nIfitistheTCP protocol then thetcpv4rcvfunction getscalled. This signi\u0002es\nthetransition tothetransport layer ofthenetw orkstack, during packetreception.\n4.3 Transport Layer\nTCP associates ahandler function, byinitializing aninstance oftheinet protocol\nstructure. This handler \u0002eld issettotcpv4rcvfunction. Therefore, tcpv4rcv,\nde\u0002ned inlinux/net/ipv4/tcp ipv4.c ,iscalled from ipv4 when theprotocol type in\ntheIPheader contains theprotocol number forTCP.\n14",
        "7d049cca-08b2-440e-bae9-76d078a147ff": "This function checks ifthepackethasavalidTCP header ,bycalling thepskb may pull\nfunction, which checks ifthepacketheader \u0002eld hasacomplete header .The\ntcpv4rcvfunction then initializes thechecksum extracts required \u0002eld from the\nTCP header ,which isused forfastpath processing.\nThis function internally uses amacro called TCP SKB CBtogettotheTCP\ncontrol bufferfrom thesocketbuffer.The TCP control buffermaintains state\nregarding parameters likeselecti veackno wledgement, thetcpsequence number\netc.\nThenextstepforthisfunction isto\u0002ndanopen socketforthisincoming packet,\nthisisdone bycalling the tcpv4lookup ,inthefollowing segment ofcode:\nsk=__tcp_v4_lookup(skb->nh.iph ->saddr,th->source,\nskb->nh.iph->daddr, ntohs(th->dest),\ntcp_v4_iif(skb));\nIfnoTCP socketisfound bythiscall, then thepacketisdiscarded atthis\nstage. IfavalidTCP socketisfound then wecontinue with theprocessing of\nthepacket.TheIPsecurity parameters arecheck edinthisroutine andtheconnec-\ntionischeck edtoseeifitisintheTCP TIME WAIT state. Ifthisisthecase,\nthen delayed TCP segments arediscarded.\nThe socketischeck edifitisinthelockedstate, intop-half conte xt,ifsoit\ncannot accept packetsandsotheother incoming packetsareadded tothebacklog\ndevice. One theother hand ifthesocketisnotinthelockedstate, then thepackets\nareputintheprequeue struture. Once thepacketsareintheprequeue then the\npacketscanbeprocessed intheprocess conte xtrather than inthekernel conte xt.\nThis transfer from kernel touser space isdone bythefunction tcpprequeue\nwhich iscalled from thetcpv4rcvfunction. Ifthetcpprequeue returns zero,\nwhich meants thatthere wasnocurrent user task which wasassociated with the\nsocketinhand, then tcpv4dorcviscalled which istheslowpacketdelivery\npath.\nWewillcontinue ourdiscussion based onthetcpprequeue semantics initially .\nThetcpprequeue isde\u0002ned asaninline function ininclude/net/tcp.h ,andisthe\nmain function which isresponsible forqueuing upthebuffersforanywaiting user\n15",
        "1d8ef19a-6103-445c-a73c-8889fd0851f8": "process. When auser levelsocketiswokenupandaread isissued onthesocket\napplication, thetcpprequeue immediately processes thesocket'sprequeue. This\nfunction checks ifauser taskiswaiting fordata from asocket,andprocesses the\nprequeue buffer.The following portion ofcode copies thesocketbuffertothe\nuser' saddress space:\nif(!sysctl_tcp_low_latency &&tp->ucopy.task) {\n__skb_queue_tail(&tp->ucop y.prequeue,skb);\ntp->ucopy.memory +=skb->truesize;\nWhen theslowpackettransfer path istaken,thatis,when tcpv4dorcvfunc-\ntioniscalled, then thefollowing semantics isfollowed. When tcpv4dorcvis\ncalled, itchecks iftheTCP connection isinestablished state, byexamining the\nstate variable tobeTCP ESTABLISHED .Iftheconnection isestablished then\nthetcprcvestablished function iscalled.\nThetcprcvestablished function starts processing thepacketwith theassump-\ntion thatthepacketsaretobeprocessed inthefastpath. Ifoptions aresetin\nthepacketthen thepacketprocessing isdiverted totheslowpath. This function\nchecks toseeifthepacketsequence number isinorder andthen direct thepacket\ntofastorslowpath based onoptions setupinthepacket.\nIfthisfunction detects afastpath thepacketiscopied directly totheuser space\nafter checking toseeiftheglobal currentisthesame asthetaskthathasrequested\ntheservice. Thefollowing code segment istheplace where thisisdone:\nif(tp->ucopy.task ==current &&\ntp->copied_seq ==tp->rcv_nxt &&\nlen-tcp_header_len <=tp->ucopy.len &&\nsock_owned_by_user(sk)) {\n__set_current_state(TASK_R UNNING);\n.\n.\nTheslowpath processing, iftakendoes various checks based onoptions and\nbranches outdepending ontheoptions, after sucessful packetreception ACKis\n16",
        "56b188a1-7d9b-47cf-a0da-5cd52d6bd574": "sentand\u0002nally thetcpdata queue function iscalled which queues thedata seg-\nments inthesocket'snormal recei vequeue.\nForsegments inthesocket'srecei vequeue, processing isdone when theappli-\ncation calls theread system call, which inturncalls thetcprecvmsg function.\nInaKUR Tenabled system, thisstage ofprocessing issymbolized bythe\nEVENT TCP RCV MESSA GEinstrumentation point.\n4.4 Application Layer\nWhene veranuser application issues anAPI calllikeread, recvfr om,theyare\nmapped onto system calls sysrecvde\u0002ned in/net/soc ket.cwhich gets translated\nintothesysrecvfr omcall.\nThesysrecvfr omandother recvsystem calls getstranslated intothesock recvmsg\nfunction de\u0002ned in/net/soc ket.c.Inthecase ofINET sockets,theinet recvmsg\nde\u0002ned in/net/ipv4/af inet.c iscalled, which calls theprotocol speci\u0002c recei ve\nfunction. Inthecase ofTCP thetcprecvmsg iscalled.\nAllsystem calls gettranslated intothetcprecvmsg function atthesocketlayer\nwhich isde\u0002ned inlinux/net/ipv4/tcp.c This isthefunction which copies data\nfrom anopen socketbufferintoauser buffer.TheKUR Tinstrumentation point\nEVENT TCP RECVMSG canbefound inthisfunction.\nThis function alsoincludes processing, when anurgent data processing need is\ncommunicated through theSIGURG signal byanyprocess. Thebasic mechanism\ninvolvedinthisfunction is,atargetbyte sizeischeck andthisisused forlimiting\nthesizeofdata transferred from thesocketbuffertotheuser space.\nThis completes thepath ofthepacketfrom themedium totheuser applica-\ntion. Thepacketpath canbevisualized bythenetw orkinstrumentation diagram\nattached attheendofthedocument. The diagram illustrates thesalient instru-\nmentation points atthedifferent layers oftheNetw orkstack wehavediscussed\ntillnow.Apass through thediagram while going through thedocument canbe\nveryeducational.\n17",
        "f15dfdfe-28ee-487f-bdc8-424d858a1944": "TheDiagram isanillustration ofastimulus response loop which exists between\naMaster andaclient(sla ve)machine. Thepath ofthestimulus corresponds tothe\npath ofanynetw orkpacket,intheTCP/IP netw orkstack.\nFigure 1:Linux Netw orkStack Instrumentation Points\n18",
        "924f200e-aa0c-4b0b-b90a-ff4cf83adeac": "4.5 Conclusions\nThe document presented adetailed \u0003owthrough thelinux TCP netw orkpro-\ntocol stack, forboth thesend andrecei vesides ofthetransmission. Though the\ndocument canbeappreciated better bymaking LXR references pointed outinthis\ndocument, following thedocument evenotherwise isveryhelpful.\nRefer ences\n[1]The Linux TCP/IP Stack: Netw orking forEmbedded Systems by\nTHOMAS F.HERBER T\n[2]Badri Subramanian. Real-T imeNetw orking forQuality ofService\nonTDM based Ethernet Master' sThesis., University ofKansas,\n2005\n[3]Hariprasad Sampathkumar .Using Time Division Multiple xing to\nsupport Real-time Netw orking onEthernet Master' sThesis., Uni-\nversity ofKansas, 2005\n[4]Ashwin Kumar Chimata &Senthil Shanmugham. Stimulus Re-\nsponse Characteristics ofEthernet TDM using starTopology Ad-\nvanced Operating Systems, Semester Project, June 2005.\n19",
        "b27bb312-64b6-4550-98d4-dfeeff624848": "See discussions, st ats, and author pr ofiles f or this public ation at : https://www .researchgate.ne t/public ation/221164236\nOpen Shortest Path First (OSPF) Routing Protocol Simulation.\nConf erence Paper \u00a0\u00a0 in\u00a0\u00a0ACM SIGC OMM Comput er Communic ation R eview \u00b7 Oct ober 1993\nDOI: 10.1145/167954.166243 \u00a0\u00b7\u00a0Sour ce: DBLP\nCITATIONS\n29READS\n9,282\n5 author s, including:\nDeepinder Sidhu\nUniv ersity of Mar yland, Baltimor e County\n99 PUBLICA TIONS \u00a0\u00a0\u00a01,509  CITATIONS \u00a0\u00a0\u00a0\nSEE PROFILE\nRaj Nair\nAvesha\n30 PUBLICA TIONS \u00a0\u00a0\u00a01,405  CITATIONS \u00a0\u00a0\u00a0\nSEE PROFILE\nAll c ontent f ollo wing this p age was uplo aded b y Raj Nair  on 28 May 2014.\nThe user has r equest ed enhanc ement of the do wnlo aded file.",
        "2e06b55b-41db-43e9-b3b8-90b7de6e7cba": "OpenShortest PathFirst(OSPF)\nRouting Protocol Simulation*\nDeepinder Sidhu, Tayang Fu,Shukri Abdallah andRajNairt\nMaryland Center forTelecommunications Research &\nDepartment ofComputer Science\nUniversity ofMaryland \u2014BC\nBaltimore, MD21228\nand\nInstitute forAdvanced Computer Studies\nUniversity ofMaryland \u2014CP\nCollege Park,MD20742\nRobColtun\nConsultant\nAbstract\nOpenShortest PathFirst(OSPF) isadynamic,\nhierarchical routing protocol designed tosupport\nrouting inTCP/IP networks. Asimulation ofthe\nOSPF Election Protocol showsthreeresults: (1)\nTheDesignated Router(DR) canbeelected incon-\nstanttime,(2)Ifarouterhasalimited number of\ninputbuffers, acompetition forbuffers between the\nElection andtheFlooding Protocols increases the\nelection timeandcauses anoscillatory behavior.\n*Thisresearch wassupported inpartbytheDepartment of\nDefense attheUniversity ofMaryland Baltimore County. The\nviewsandconclusions contained inthisdocument arethoseof\ntheauthors andshould notbeinterpreted asrepresenting theof-\nficialpolicies, eitherexpressed orimplied, oftheDepartment of\nDefense ortheU.S.Govermnent.\ntpresent address: Netrix Corporation, 13595DnllesTechnol-\nogyDr.,Herndon, VA22071\nPermission tocopywithout feeallorpartofthismaterial is\ngranted provided thatthecopieearanotmadeordistributed for\ndirectcommercial advantage, theACMcopyright noticeandthe\ntitleofthepublication anditsdateappear, andnoticeisgiven\nthatcopying isbypermission oftheAssociation forComputing\nMachinery. Tocopyotherwise, ortorepublish, requires afee\nand/orspecific permission.\nSIGCOMM\u201993 -Ithaca,N.Y.,USA19193\n~1993ACM0-89791-61 9-01931000910053 ...S1.50Ateachrouter, theRouter-ID oftheDRcon-\ntinuously changes causing instability. (3)Inthe\nworstcase,whentheDRandtheBI)Rfailat\nthesametime,theDR-agreement-time isbounded\nabovebytwicetheHelloInterval. Asimulation of\ntheOSPFFlooding Protocol, using20,50and80\nrouterpoint-to-point networks, showsthreeresults:\n(1)Forthe50routernetwork, aslinkspeedexceeds\n4000Kbps,theprobability ofoverflowing thein-\nputbuffers increases causing retransmissions. The\nincrease inbootup-convergence-time fromretrans-\nmission isbounded bytwoandthreetimesthe\nRxmtInterval forlinkspeeds of4000to6000Kbps\nandabove50Mbpsrespectively. Theincrease in\nthebootup-convergence-time isduetolargenunl-\nberofunacknowledged flooding packets received\nwithin RxmtInterval. (2)For20and50routernet-\nworks, theinputbuffersizehaslittleimpact onthe\nbootup-convergence-time. Forthe80router net-\nwork,asmallchange intheinputbuffersizeclras-\ntically changes thebootup-convergence-time.\nReducing thevalueoftheRxmtInterval lowers\nbootup-convergence-time athighlinkspeeds.(3)\nthe\n53",
        "0d23f87d-e1e8-431f-9d34-25b89d1081b9": "1Introduction\nOpenShortest PathFirst\u2018(OSPF) isadynamic,\nhierarchical routing protocol designed tosupport\nrouting inTCP/IP networks [1].TheOSPFrout-\ningprotocol isacollection ofinterrelated algo-\nrithms: theHello,Election, Flooding andShortest-\nPath-First (SPF). TheHello,Election, andFlood-\ningProtocols distribute andsynchronize rout-\ninginformation within anautonomous system.\nTheShortest-Path-First algorithm computes the\nshortest-path tree.\nInthispaper, wepresent asimulation studyof\ntheElection andFlooding Protocols ofOSPF. Sec-\ntion2presents simulation results oftheElection\nandtheFlooding Protocols. Section 3contains\nsummary andconclusions.\n2OSPF Simulation\nInthissection, wepresent theresults ofthediscrete\neventsimulation oftheElection andFlooding Pro-\ntOcols.\n2.1Election Protocol\nTheElection Protocol electsaDesignated Router\n(DR)andaBackup Designated Router (BDR) to\ndistribute andsynchronize topology information\namong routers onabroadcast network. Within\nthenetwork, theDRreduces thenumber ofmes-\nsagesneeded tobroadcast topology information\nandhidestopology information fromotherrouters\nwithintheautonomous system.\nArouter iseligible toparticipate intheElec-\ntionProtocol ifitsRouter-Priority ispositive. A\nrouternominates aDRandaBDRusingtheDR\nandBDRfieldsofthehellopacket. EveryHel-\nloInterval, eachrouter Xtransmits ahellopacket\ncontaining among otherinformation itsRouter-Id,\nitsRouter-Priority andalistofRouter-Ids from\nwhomXhasreceived ahellopacket, Router Xdis-\ncoversrouter YwhenXreceives forthefirsttime\nahellopacket fromrouter Y.Router Xdetects\ntheabsence ofrouter YwhenXdoesnotreceive\nahellopacket fromrouter Yforaperiod ofRou-\nterDeadInterval. Router Xconsiders router Yas\nabidirectional neighbor whenXseesitsRouter-IdinthelistofRouter-Ids inthehellopacket sentby\nrouterY.\nArouter issaidtodeclare itselfaDR(BDR) if\nitelectsitselfDR(BDR) andinserts itsRouter-Id\nintheDR(BDR) fieldofthehellopacket. Anull\nvalueinthesetwofieldsindicates theabsence of\nDRandtheBDR.Werefertotherouterthatwins\ntheelection asthe\u201cwinning-DR\u2019).\nInitial Election Time\nLettlbethetimeatwhichthefirstrouterisbooted\nandt2bethetimeatwhichthewinning-DR elects\nitself.Theobjective ofthisexperiment istodeter-\nminetheDR-election-time, t2\u2013tl,onabroadcast\nnetwork,\nThenetwork sizesvaryfrom10to100routers\nallofwhichhaveunlimited amount ofinputand\noutput buffers. TheWaitTimer, RouterDeadIn-\ntervalandtheHelloTimer ofeachrouter areset\nto40,40and10seconds respectively. Weassume\nzeropropagation andprocessing delays. Wealso\nassume thattheElection Protocol runsinzerosec-\nonds.Initially, allrouters areeligible routers inthe\nDOWN state.Ifrouter R.wasbooted attimet.\nandthenextrouterRvwasbooted attimetgsuch\nthattuztz,thentv\u2013t$istheinter-boot-time,\nAt.Thefirstrouterisbooted attimeAtseconds,\nandtheremaining routers arebooted inincreasing\norderofRouter-Id. Theexperiment isrepeated for\nAtof7,10,22,30and40seconds.\nFigure lashowstheresultforAt=7seconds,\nandFig.lbshowstheresultforAt=30and40\nseconds. InFig.la,theDR-election-time increases\nlinearly withthenumber ofrouters. InFig.lb,\ntheDR-election-time isconstant. Toexplain the\nlinearincrease oftheDR-election-time inFig.la,\nwetracethesequence ofeventsexecuted atrouters\nR1andRzattached toabroadcast network. Then,\nwegeneralize thisexplanation toanetwork ofn\nrouters.\nAttime7seconds, whenrouterRIisbooted up,\nitbroadcasts ahellopacket containing itsRouter-\nIdandenters theWAIT stateforaperiod of40\nseconds.",
        "8511499a-2d6a-4787-a517-c6843d59bf10": "Theexperiment isrepeated for\nAtof7,10,22,30and40seconds.\nFigure lashowstheresultforAt=7seconds,\nandFig.lbshowstheresultforAt=30and40\nseconds. InFig.la,theDR-election-time increases\nlinearly withthenumber ofrouters. InFig.lb,\ntheDR-election-time isconstant. Toexplain the\nlinearincrease oftheDR-election-time inFig.la,\nwetracethesequence ofeventsexecuted atrouters\nR1andRzattached toabroadcast network. Then,\nwegeneralize thisexplanation toanetwork ofn\nrouters.\nAttime7seconds, whenrouterRIisbooted up,\nitbroadcasts ahellopacket containing itsRouter-\nIdandenters theWAIT stateforaperiod of40\nseconds. Similarly, whenrouter R2isbooted at\ntime14seconds, itbroadcasts ahellopacket and\nenterstheWAIT state.Router RIuponreceiving\nthehellopacket fromR2attime14seconds estab-\n54",
        "cd6af9c6-b34a-4579-bf49-96c01ea4b687": "lishesone-way communication withR2.Attime17\nseconds, thesecond HelloInterval, routerRIbroad-\ncastsahellopacket withtheRouter-Ids ofRIand\nR2.Uponreceiving thishellopacket, R2estab-\nlishesbidirectional communication withrouterRI.\n.Attime24seconds, whenR2broadcasts ahello\npacket, bothrouters establish bidirectional com-\nmunication becoming candidates forelection. A\nrouterexitstheWAIT stateifitsWaitTimerex-\npiresoraBackup-Seen eventistriggered.\nABackup _Seeneventistriggered atanyrouter\nRxifR.receives ahellopacket fromanother router\nRvsuchthat(1)Rvdeclares itselftobetheBDR,\nor(2)RVdeclares itselftobetheDRanddeclares\nthatithasnotelected aBDR.SinceR1and.R2are\nintheWAIT state,theycannot declare themselves\nasDRorBDR.\nAttime47seconds, theWaitTimer atRIex-\npires,andRIelectsR2astheDRbecause R2has\nahigherRouter-Id. R1broadcasts theresultofthe\nelectioninitshellopacket. ABackup _Seenevent\natR2isnottriggered because RIisnotdeclar-\ningitselftobeDRorBDR.Attime54seconds,\nwhentheWaitTimer atR2expires, R2electsit-\nselfastheDRandR1astheBDR.Atthesame\ntime,theHelloTimeratR2expires andR2broad-\ncaststheresults oftheelection. WhenRIreceives\nthehellopacket, aNeighbor_Change eventistrig-\ngeredcausing RItoruntheelection. R1selects\nR2astheDRanditselfastheBDR.Attime57\nseconds, RIdeclares itselfasaBDRtothewhole\nnetwork bybroadcasting ahellopacket. Thus,the\nDR-election-time foranetwork oftworouters is\n54\u20137=47seconds.\nTogeneralize theexplanation, consider a\nnetwork withnrouters withRouter-Ids of\nRI,R2,....Rn.Theboottimeoftheserouters are\n7,14,21,.. .,7*nseconds respectively. TheWait\nTimerateachrouterexpires at47,54,61,..., 7xn+\n40seconds respectively. Eachrouterremains inthe\nWAITstateforthewholeperiod of40seconds be-\ncausetheBackup _Seeneventcannot betriggered\nbyanyrouter. Before theWaitTimer ofrouter i\n(1<i<n\u20131)expires, router i+1isbooted,\nandbothrouters establish bidirectional communi-\ncation. WhentheWaitTimerexpires atrouter i,\nitelectstherouterwiththehighest Router-Id with\nwhomitestablished bidirectional communication.ma\n1\n700-\n[-.0\n.!\u2018w\n44al-\ng\n3rm-\n\u2019200-\n11020304Q50 607080901CCI\nNewark S-\n\u201c~-!.a\n.g~,,\nIs\n~Iriler-nca lTir@.e.3Q0r40Jcc Fi~b\n10203040 SO607060901K1\nNeNwuk Sue\nFigure 1:Election TimeforBroadcast Networks\nFinally, router Rnisbooted attime7xnsec-\nonds,Allrouters establish bidirectional communi-\ncationwithRnbefore itsWaitTimer expires. As\naresult, allrouters electRnastheDR..Attime,\n7wz+40 seconds, theWaitTimerofR.expires, and\nR.electsitselfastheDRandR.-lastheBDR.\nThus,theDR\u2013eiection \u2013time=7xn+40\u20137,\nwhere At=7.Theelection timeincreases lin-\nearlybecause aBackup_Seen eventcannot betrig-\ngeredatanyrouter. Thesameexplanation holds\nforAt=10and22seconds.\nEachrouter excluding &andR.-lrunsthe\nElection Protocol twoadditional times. 11~and\nR.-lruntheElection Protocol oneadditional\ntime.First,Rnbroadcasts ahellopacket declaring\nitselfastheDRwhichcauses aNeighbor.Change\neventatallotherrouters. Second, R._lbroad-\ncastsahellopacket declaring itselfastheBDR\nwhichcauses aNeighbor-Change eventatallother\nrouters.\nFigure lbshowsaconstant DR-election-time.",
        "c570961a-d77f-4e4d-a109-1ec463ece3cb": "Thus,theDR\u2013eiection \u2013time=7xn+40\u20137,\nwhere At=7.Theelection timeincreases lin-\nearlybecause aBackup_Seen eventcannot betrig-\ngeredatanyrouter. Thesameexplanation holds\nforAt=10and22seconds.\nEachrouter excluding &andR.-lrunsthe\nElection Protocol twoadditional times. 11~and\nR.-lruntheElection Protocol oneadditional\ntime.First,Rnbroadcasts ahellopacket declaring\nitselfastheDRwhichcauses aNeighbor.Change\neventatallotherrouters. Second, R._lbroad-\ncastsahellopacket declaring itselfastheBDR\nwhichcauses aNeighbor-Change eventatallother\nrouters.\nFigure lbshowsaconstant DR-election-time. In\nthisscenario, At=30androuter RIisbooted at\ntime30seconds. Router Rzisbooted attime60\n55",
        "8253b296-20fa-40ac-b4fb-b6f3837ab4a4": "seconds andenterstheWAIT state.RIestablishes\nbidirectional communication withR2attime80\nseconds. WhentheWaitTimer ofRIexpires at\ntime70seconds, RIelectsitselfastheDR.Since\nRIhasnobidirectional neighbors, itdoesnotelect\naBDR.Therefore, theDR-election-time is40sec-\nonds.Attime70seconds, R1broadcasts theresults\noftheelection inahellopacket whichtriggers a\nBackup .SeeneventatR2.R2exitstheWAITstate\nandelectsRIastheDR.Foreachoftheremaining\nrouters, aBackup_Seen eventistriggered uponre-\nceiving ahellopacket fromtheBDR.Theserouters\nexittheirWAIT stateandaccept theexisting DR\nandBDR.\nFigure lbalsoshows aconstant DR-election-\ntimeunderadifferent scenario, where At=40\nseconds. TheWaittimerofRIexpires attime80\nseconds whenrouter R2isbooted. SinceRland\nR2havenotyetestablished bidirectional commu-\nnication andtheWaitTimerofRIhasexpired, RI\nelectsitselfastheDR.R1doesnotelectaBDR\nsinceitishasnotestablished bidirectional com-\nmunication withanyotherrouter. Onreceiving\nthehellopacket fromRIwhichestablishes bidi-\nrectional communication, aBackup.Seen eventis\ntriggered atR2forcing R2toexititsWAIT state\nandelectRIastheDR.ABackup-Seen eventis\ntriggered attheremaining routers causing themto\nelectRIandR2astheDRandBDRrespectively.\nTheorderofhandling theevents impacts the\nperformance oftheElection Protocol. TheDead-\nRouterInterval-expiration, Wait-Timer-expiration,\nBackup_Seen andNeighbor.Change events deter-\nminethecontent ofahellopacket. Anefficient\nOSPFimplementation handles theseevents before\nithandles theHello-Timer-expiration event; oth-\nerwise, themostrecentinformation(results ofelec-\ntion,newbidirectional neighbors) willbebroadcast\nafteroneHelloInterval resulting inadegradation in\nperformance.\nToachieve theconstant DR-election-time asin\nFig.lb,(1)choose tworouters tobetheintended\nDRandBDR,andassign thempositive Router-\nPriority andthehighest twoRouter-Ids, (2)boot\ntheintended DRfirstandwaitforaperiod ofat\nleastWaitTimerbeforebooting theintended BDR,\n(3)boottheintended BDRandwaitforaperiod\nofatleastWaitTimer, and(4)boottheremainingrouters. Thisresultcanbegeneralized byassigning\ndifferent positive priorities totherouters.\nElection TimeandTopological Change\nAssume thatallrouters arebooted inincreasing or-\nderofRouter-Id andeventually reachaFULLstate\nwiththeDRandtheBDR.lettdl(t~l)bethetime\natwhichthefirstrouterdetects theabsence ofthe\nDR(BDR), andt&(t~z) bethetimeatwhichthe\nlastrouter enters theEXCHANGE-START state\nwiththenewlyelected DR(BDR). Theobjective\nofthisexperiment istodetermine theDR(BDR)-\nagreement-time, t&\u2013tdl(t~z\u2013tbl),forabroadcast\nnetworkafteratorological change.\nThetimet~lismeasured afterRouterDeadIll-\ntervalseconds haveelapsed, whereRouterDeadIn-\ntervalistheminimum period before arouter de-\ntectstheabsence ofanother router. Attimet~b,\ntheDRandtheBDRarebrought down,andthe\nDR-agreement-time andBDR-agreement-time are\nmeasured. Thisexperiment isrunwithAtequal\nto7,10,22,30and40seconds. Figures 2a-2cshow\ntheresults ofthisexperiment.\nLettd~(t~~) bethelasttimeatwhich the\nDR(BDR) broadcast ahellopacket before go-\ningdown(td~,tb~<tdb). Allrouters should\ndetect theabsence oftheDRexactly attdh+\nRouterDeadInterval andtheabsence oftheBDR\nexactly attbh+RouterDeadInterval seconds.\nHowever, arouterR.checks iftheRouterDeadIn-\ntervalhasexpired onlywhenR.\u2019sHelloTimerex-\npires.TheHelloTimerexpiration depends onthe\nboottimeofeachrouter.",
        "63e0c10f-b97b-4248-b5e6-f922d4607acd": "Attimet~b,\ntheDRandtheBDRarebrought down,andthe\nDR-agreement-time andBDR-agreement-time are\nmeasured. Thisexperiment isrunwithAtequal\nto7,10,22,30and40seconds. Figures 2a-2cshow\ntheresults ofthisexperiment.\nLettd~(t~~) bethelasttimeatwhich the\nDR(BDR) broadcast ahellopacket before go-\ningdown(td~,tb~<tdb). Allrouters should\ndetect theabsence oftheDRexactly attdh+\nRouterDeadInterval andtheabsence oftheBDR\nexactly attbh+RouterDeadInterval seconds.\nHowever, arouterR.checks iftheRouterDeadIn-\ntervalhasexpired onlywhenR.\u2019sHelloTimerex-\npires.TheHelloTimerexpiration depends onthe\nboottimeofeachrouter. Depending onitsboot\ntime,arouter belongs tooneoftengroups, G\u2019,,\nwherei=(Router \u2013Id*At)modHelloInterval.\nAllrouters inagroupdetecttheRouterDeadInter-\nvalexpiration ofanother router atthesametime.\nLettheDRandBDRbelong tothegroupti Gdand\nGbrespectively.\nTocalculate theDR(BDR)-agreement times,we\npartition thegroups intothreesets,S1,Szand\nS3whereS1isthesetofgroups whichdetect the\nabsence oftheDRandtheBDRatthesametime,\nSzisthesetofgroups whichdetecttheabsence of\ntheDRbeforetheydetecttheabsence oftheBDR\nandS3isthesetofgroups whichdetecttheabsence\noftheBDRbefore theydetect theabsence ofthe\n56",
        "e7ab3c13-726b-441d-941d-28af75d2750b": "1 BDRC.m&kOll 2\n25\n1BDR-.-3\n--,-------- ----------- ..............-------------- ..............----\ni\n10\nt.........................------------- ------------- ---------\nDRCMMMWU 3\n1\n\u2018t i\nIInmPBmI1 TimeF7aec F,,,. I\n1070304050 607080901W\nNelwaz S12C.2.0-BDR-.-3\n......................................................\n15-DRCMAQMI 2\n10-DRCXudtwn 3\n....................................................................\nti-Bswt Tlmo,=22SCGS, F,,.b\n1020304050 607080 90 ICKI\nNew-k S-\n10\nt\n-2ILI&,PBoot \u2018lhnc,10=wmuludc i..c\n107D304O5O 6070 M901W\nNelwmk Sur,\nFigure 2:Election TimeafterTopological Change\nDR.\nTodetermine inwhichsetagroupGkbelongs,\nconsider arouter RjintheDR-OTHER state\nwhichbelongs togroupGk.Lettjh bethefirst\ntimetheHelloTimerexpires atrouter Rjafterthe\nDRandBDRarebrought down(tjh ~t~b).Let\nz=ijh\u2013Qhandg=tj~\u2013t~~.Ifzandgareboth\nlessthantheHelloInterval, orbotharegreater or\nequaltotheHelloInterval, thenGkcS1;other-\nwise,ifzisgreater orequaltotheHelloInterval,\nthenGkE5\u20192;otherwise, Gk<5\u20193.\nThus,wedetermine t~landtblasfollows. t~l=\ntdh+RouterDeadInte?\u2019val+d ifGd#@;otherwise,\ntd~=tdh+RouterDeadInterval +fifGd=@\nandG~isthefirstnon-empty groupthatfollows d\nintheringofintegers modulo 10.Similarly, t~l=\ntbh+RouterDeadInterval +bifGb#~;otherwise,\ntb~=tbh+RouterDeadInterval +fifGb=~and\nGfisthefirstnon-empty groupthatfollows bin\ntheringofintegers modulo 10.\nTodetermine tdzandtbz,werelatethetimes\ntdh,tbhandtdbaccording tooneofthreeconditions:\n(1)Atisamultiple oftheHelloInterval, or(2)t&<tbh<tdb,or(3)tbh<tdh<tdband&is\nnotamultiple oftheHelloInterval. Eachcondition\ndetermines asequence ofevents toelectanewDR\nandanewBDR.\nIfcondition 1holds, allrouters belong to\ngrOUp Go~S1andtdl=tbl=tdh+\nRouterDeadIntemal. ANeighbor_Change event\nsimultaneously causes allrouters torunthe\nElection Protocol, electaDRandenterthe\nEXCHANGE-START statewiththenewDR.In\nthiscasetdz=tdlandtheDR-agreement-time is\nzeroasshown inFig.2c.AfteroneHelloInter-\nval,thenewDRbroadcasts ahellopacket which\ncauses allrouters toruntheElection Protocol,\nelectanewBDRandsimultaneously enterthe\nEXCHANGE-START statewiththenewBDR.\nHence, tbz=tbl+Hellolntewai andtheBDR-\nagreement-time is10seconds asshowninFig.2c.\nIfcondition 2holds,allgroups belong tothesets\nS1andSz,andthesetS3isempty. Eachrouterin\nS1electsanewDRandenterstheEXCHANGE-\nSTART statewiththenewDR.EachrouterinSz\npromotes thepresent BDRtobecome thenewDR\n57",
        "e87b4b96-072d-4a03-9435-3d6ff47620fa": "anddetects theabsence oftheBDRatthenextex-\npiration ofitsHelloTimer. LetT1bethefirsttime\natwhichthenewDRbroadcasts ahellopacket, and\nT2bethelasttimeatwhichanygroupinS2detects\ntheabsence ofitspromoted BDR.T\u2019landT2must\noccurwithinoneHelloInterval fromt~l.Allrouters\nareguaranteed tohaveentered theEXCHANGE-\nSTART statewiththenewDRattimemin(Tl, 7\u20192).\nThen,tdz=min(Tl, T2).AttimeT1allrouters run\ntheElection Protocol andelectanewBDR.There-\nfore,tbz=T1.Figures 2a-2bshowtheDR(BDR)-\nagreement timesforcondition 2whenN=7and\n22seconds.\nIfcondition 3holds,thenallthegroups belong\ntothesetsS1andS3,andthesetS2isempty.\nRouters inthesetS1electanewDRanden-\ntertheEXCHANGE-START statewiththenew\nDR.EachrouterinS3electsanewBDRanden-\nterstheEXCHANGE-START statewiththenew\nBDR.AfteroneHelloInterval, routers inS3de-\ntectstheabsence oftheDR,promote thenew\nBDRtothenewDRandcontinue thedatabase\nsynchronization process withthepromoted DR.\nIfthenewly elected DRisinS3,itdeclares it-\nselfasanewBDR,promotes itselfandelectsa\nnewBDR.LetT4bethetimeatwhichthenewly\nelected DRdeclared itselfasanewBDR.After\nonemoreHelloInterval, itdeclares itselfanewDR.\nThefirstdeclaration doesnotchange theiden-\ntitiesofthenewDRandnewBDR.Onreceiv-\ningthesecond declaration, allrouter agreeonthe\nnewDRandnewBDR.Ontheotherhand,ifthe\nnewlyelected DRisinS1,itelectsanewBDR\nanddeclares itselfnewDRoneHelloInterval after\n~dl.Therefore, weexpect thattheDR-agreement\ntimetobelessthanoneHelloInterval asshown\ninFigs.2a-2b. LetT3bethelasttimeatwhich\nanygroupinS3detects theabsence oftheBDR.\nTherefore, allrouters areguaranteed tohaveen-\nteredtheEXCHANGE-START statewiththenew\nDRattimemin(T1, T3).Then,tdz=min(T1, T3).\nAllrouters knowaboutthenewlyelected BDRat\ntbz=max(T1, T4+HelloInter8al) +HelloInterval.\nIntheworstcase,whentheDRandtheBDR\nfailatthesametime,theDR-agreement-time is\nbounded abovebytwicetheHelloInterval,\nInanOSPF implementation, arouter may\nchecks theexpiration ofRouterDeadInterval foraneighboring routerwhenitsHelloTimerexpires. If\nthegranularity ofchecking theRouterDeadInterval\nisfinerthantheHelloInterval, itispossible toob-\ntainonegroupofrouters whichdetecttheabsence\noftheDRandBDRatthesametimeasinFig.2c.\nInteraction ofElection andFlooding Pro-\ntocols\nTheobjective ofthisexperiment istodetermine\niftheFlooding Protocol affects theDR-election-\ntimeandDR(BDR)-agreement-time. Theexper-\nimental settings areidentical tothetwoprevious\nexperiments except that&=7andthesizeofthe\ninput-control-packet queues ofallinterfaces isset\nto10packets. Eachinterface hasoneinput-control-\npacket queuewhichcontains bothhelloandflood-\ningpackets. Ifthequeueisfull,incoming packets\naredropped.\nWeconducted threedifferent runsofthesame\nexperiment. Theresults ofthethreerunsaredif-\nferentfromeachotheranddifferent fromthere-\nsultsinFigs.laand2a.Thisbehavior results from\nthecompetition between theflooding packets and\nthehellopackets forinputbuffer. Theflooding\npackets prevented thehellopackets fromarriving\nattherouters everyHelloInterval thusincreasing\ntheelection andagreement times. Asthesizeof\nthequeues decreases, theelection andagreement\ntimesincrease.",
        "23c7c5ec-cdf6-4d62-8d69-bf775aa7d13b": "Eachinterface hasoneinput-control-\npacket queuewhichcontains bothhelloandflood-\ningpackets. Ifthequeueisfull,incoming packets\naredropped.\nWeconducted threedifferent runsofthesame\nexperiment. Theresults ofthethreerunsaredif-\nferentfromeachotheranddifferent fromthere-\nsultsinFigs.laand2a.Thisbehavior results from\nthecompetition between theflooding packets and\nthehellopackets forinputbuffer. Theflooding\npackets prevented thehellopackets fromarriving\nattherouters everyHelloInterval thusincreasing\ntheelection andagreement times. Asthesizeof\nthequeues decreases, theelection andagreement\ntimesincrease. However, whenweintroduce sepa-\nrateinputqueues forthehelloandflooding pacli-\netskeeping thetotalsizeofbothqueues to10,we\nobtain thesameresults asinFigs.laand2a.We\nprocessed thehellopackets beforeweprocessed the\nflooding packets. Westrongly recommend thatan\nOSPFimplementation should haveaseparate con-\ntrolqueueforhellopackets andshould process the\nhellopackets atahigher priority thantheother\ncentrolpackets.\nIfarouter, R,hasalimited amount ofinput\nbufferspace,weobserve anoscillatory behavior in\ntheidentity oftheDRatR.IfRdoesnotre-\nceiveahellopacket fromtheDRwithin aRou-\nterDeadInterval seconds, Rassumes thattheDR\nisdown. TheDRmaynotbedownexcept that\nitshellopackets arebeingdropped duetolack\nofbufferspace. Rrunstheelection andelectsa\nnewDRandstartsanewsynchronization process\n58",
        "d99756e3-7c71-4689-911c-700da939f51c": "withthenewDR.Uponreceiving ahellopacket\nfromtheoldDR,1?assumes thattheoldDRisup\nagain(Neighbor.Change event)andrunstheelec-\ntion.RelectstheoldDRandstartsanewdatabase\nsynchronization process.\nInnetworks withastrictperformance require-\nments, forexample convergence tooccurwithin\ntwenty seconds, itiscrucial toimpIement asep-\naratequeueforhellopackets.\n2.2Flooding Protocol\nTheFlooding Protocol isareliable information ex-\nchange mechanism whichensures thatallrouters\nwithin anareahaveidentical topology informa-\ntionforthatarea. Every pairofneighboring\nroutersexchange topology summaries tolearn\naboutthemostrecenttopology changes within the\nautonomous system. Arouterobtains thenewin-\nformation bysynchronizing itstopology database\nwithaneighboring routerusingtheFlooding Pro-\ntocol.\nInthissection, wedescribe threeexperiments\nthatmeasure thebootup-convergence-time andthe\nconvergence-time forpoint-to-point networks. The\nbootup-convergence-time istheinterval between the\ntimeallrouters andlinksinanetwork areinitially\nbrought upuntiltherouting-convergence-st ateis\nreached. Therouting-convergence-state isthestate\ninwhichallrouters reachtheFULLstateandhave\nempty retransmission andrequest lists.Lettbe\nthetimeatwhichatopological change occurs in\nanetwork thathasreached arouting-convergence-\nstate. Theconvergence-time isthetimeinterval\nfromtuntilthenextrouting-convergence-st ateis\nreached.\nWeusethreetopologies: (20,4,6),(50,6,4) and\n(80,6,5).Inthenotation (IV,d,e),IVisthenumber\nofrouters, disthenetwork diameter andeisthe\nmaximum router degree. Tominimize topology-\ninduced bias,wegenerate atopology withrandom\ninterconnections, Toexercise theFlooding Proto-\ncol,highvalues arechosen fordande.Alllinks\nhavethesamespeedchosen fromarangeof56\nKbpsthrough 2Gbps.LinkSpeed andConvergence Time\nTheobjective ofthisexperiment istodetermine\ntheimpact oflinkspeedontheconvergence-time\nandthebootup-convergence-time. Allrouters have\nunlimited amount ofinputandoutput buffers. The\nWaitTimer, RouterDeadInterval andtheHello\nTimerofeachrouter aresetto40,40and10sec-\nondsrespectively.\nInitially, allrouters areintheDOWN state\nandarebooted simultaneously. Afterthenetwork\nreaches routing- convergence-st ate,thebootup-\nconvergence-time ismeasured, andatorological\nchange isintroduced attimetobybringing down\nalink. Therouters areallowed torespond to\nthistopological change andreachtherouting-\nconvergence-state. ThelastactionoftheFlooding\nProtocol isthedeletion ofalinkstaterequest list\northereceipt ofadatabase description packet. Let\nthetimeofthelastactionbetl.Theconvergence-\ntimeismeasured asthetimeperiod tl\u2013to.\nFigures 3a-3cshowthebootup-convergence-time\nandconvergence-time overarangeoflinkspeeds\nforthe50router\u2019 network. InFigs.3a-3b, for\nlinkspeeds lessthan4000Kbps, thebootup-\nconvergence-t imefortheRxmtIntervalof5and\n10seconds are20and30seconds respectively.\nSinceallrouters arebooted atthesametime,\ntheyestablish bidirectional communication in10\nseconds. Ifalinkstateadvertisement isnotac-\nknowledged within RxmtInterval, aretransmis-\nsionoccurs. Consequently, wegetthebootup-\nconvergence-time tobethesumofoneHelloIn-\ntervalandtwicetheRxmtInterval. InFig.3b,\nforlinkspeeds from4000to6000Kbps, thein-\ncreaseinthebootup-convergence-time isbounded\nbytwicetheRxmtInterval. Forexample, the\nbootup-convergence-time forthelinkspeedof6000\nKbpsandRxmtInterval of10seconds is50seconds,\ngivinganincrease of20(50-30) seconds.",
        "a192d5aa-a320-4c80-b647-82e142ea7450": "Sinceallrouters arebooted atthesametime,\ntheyestablish bidirectional communication in10\nseconds. Ifalinkstateadvertisement isnotac-\nknowledged within RxmtInterval, aretransmis-\nsionoccurs. Consequently, wegetthebootup-\nconvergence-time tobethesumofoneHelloIn-\ntervalandtwicetheRxmtInterval. InFig.3b,\nforlinkspeeds from4000to6000Kbps, thein-\ncreaseinthebootup-convergence-time isbounded\nbytwicetheRxmtInterval. Forexample, the\nbootup-convergence-time forthelinkspeedof6000\nKbpsandRxmtInterval of10seconds is50seconds,\ngivinganincrease of20(50-30) seconds. InFig.3c,\nforlinkspeeds above 50Mbps, theincrease in\nthebootup-convergence-time isbounded bythree\ntimesRxmtInterval. Asthelinkspeedincreases,\ntheprobability ofinput-buffer-overflow increases\ncausing retransmissions because largenumbers of\nflooding packets arereceived within anRxmtInter-\nval.Whenarouter, l?=,receives aflooding packet\nfromarouter, Ry,router Rzchecks ifthispacket\n59",
        "3a75b477-86ad-42bf-8b1b-cfca338721d7": "1Net<%, 6.6\n\u201c1+Bcwmpw_-w, Rmt=\n33c!BLwulp-ckmver--m, Rxm,.0\nxC4rwnr---rww, 1mum\n1.s\n10\n5\nMa\nOm i600 8al Iwo 12CK3 1400 1600 1800 20c4\nLinksped(Kbps)(LOW)\n45.+Boomp&mwgum-nme, lhu,t=s\noBom.#2mvq-\u2019lhre> F.xmt=10\nxccuva--mnc, 1fulme\nE:~:\n10-\ns\nWI=00.s 1 1.5 2\nLmksped(*)(H@ .10,Nat<30,6, &I\n45-+Booim@unvcr3-~, Rxmt=s\noB_Cam_-h ,h,=10\n40-.-\u2014TI!W 1fuhm\n3s\n30-\n25-\n20\u2019-\n15-\ns\nF,&b\n3500 4CJXI 4500 5CUI 5S00 ww\nLmkspeed(Kllp)(?ntcJ.mdu.)\n+<20.4.6 I\nso-\n45\n40-\n33-\n30-\n2.5\nmw1\nBufferSueQ&)\n+Rxmt.3-\n40-.RxInt. s&x\nXRXM,=1OSC\u2019-J\n3s-\nxl-\n?5\nm-\n1s-\n%.=,0\nas 1 1.5 2\nLinksp2c.i(lap) Xlo$\nFigure 3:Impact ofLinkSpeed, Buffer SizeandRxmtInterval on\n60",
        "ab7212ba-9499-456b-9b46-d841a50b39bd": "acknowledges apacket onRz\u2019sretransmission list.\nTherefore, asthesizeoftheretransmission listat\nRzincreases, thetimetoacknowledge apacket in-\ncreases.\nInFigs.3a-3c,RxmtInterval doesnotaffectthe\nconvergence-time whichisbounded by10seconds.\nArouterinthisOSPFimplementation responds to\natopological change whenitsHelloTimerexpires.\nToexplain thebounding value,lett,2<tl,bethe\ntimeatwhichtheHelloTimers atallrouters expire.\nTheinterval tz\u2013tlislessthanorequaltothe\nHelloInterval, 10seconds.\nBuffer SizeandConvergence Time\nTheobjective ofthisexperiment istodetermine\ntheimpact ofinputbuffer sizeonthebootup-\nconvergence-time. Inthisexperiment, fornetworks\nof20,50and80routers, thelinkspeedisfixedat\nT1(1.544Mbps) andtheinputbuffersizeisvaried\nfrom4through 20.Theexperimental procedure is\nasdescribed above.\nTheresults ofthisexperiment areshown in\nFig.3d.Foranyofthenetworks, convergence does\nnotoccurifthebuffersizeislessthanorequalto\nthree. Thisresultimplies thatthelowerbound\noftheinputbuffer sizefortheoperation ofan\nOSPFnetwork of20ormorerouters isgreater than\nthree. Consequently, arouter requires aninput\nbuffermemory sizeofatleast4timesthemaxi-\nmumsizeofaflooding packet.\nForthe20and50router networks, thebuffer\nsizehaslittleimpact onbootup-convergence-time.\nThebootup-convergence-time increases atabuffer\nsizeof6inthe50router network andatabuffer\nsizeof7inthe20router network, Thisincrease\nresults fromtworetransmissions whichoccurafter\nthelossofapacket anditsacknowledgment. This\nretransmission occursatahigherbuffersizeforthe\n20routernetwork thanforthe50router network\nbecause the20routernetwork hasahigher router\ndegree andmustsendoutmorelink-state adver-\ntisements peroutput bufferthanthe50routernet-\nwork. The80router network demonstrates very\nnoisybehavior because thenumber oflink-state ad-\nvertisements thatmustbeflooded islarge.Clearly,\nabuffersizeof20ormoreisneeded fornetworks\nwithmorethan80routers.RxmtInterval andConvergence Time\nTheobjective ofthisexperiment istodemonstrate\ntheeffectofalowsetting oftheRxmtInterval. The\nexperimental procedure isasdescribed above. In\nthisexperiment, weusedthe50router network\nwithlinkspeeds from25to200Mbps. Output\nandinputbuffersizeisunlimited.\nTheresults ofthisexperiment areshown in\nFig.3e.Reducing thevalueoftheretransmission\ntimerlowers thebootup-convergence-time forall\nlinkspeeds. However, thereduction islargerfor\nhigher linkspeeds. Forexample, atthelinkspeed\nof100Mbps, aspeedup of14seconds isobserved\nwhentheretransmission timerisreduced from10\nto3.Thisresultverifies thesuggestion in[1]that\nthesetting oftheretransmission timercanbere-\nducedforhighspeednetworks.\nBuffer management isvitaltotheperformance\noftheFlooding Protocol; otherwise, thereispoten-\ntialforperformance degradation duetohighcon-\ntention formemory. TheFlooding Protocol inan\nOSPFimplementation mayuseinherent rate-based\ncontrol mechanisms suchas:(1)limitthenumber\nofsimultaneous synchronizations, or(2)reduce the\nvalueoftheretransmission timer. Itisalsorecom-\nmended thatalinearsearch oftheretransmission\nlistbeavoided.\n3Summary andConclusions\nOpenShortest PathFirst(OSPF) isadynamic, hi-\nerarchical routing protocol tosupport theTC!P/IP\nnetworks. Inthispaper, asimulation oftheOSPF\nElection Protocol showsthreeresults: (1)TheDes-\nignated Router(DR) canbeelected inconstant\ntime.(2)Ifarouterhasalimited number ofinput\nbuffers, acompetition forbuffers between theElec-\ntionandtheFlooding Protocols increases theelec-\ntiontimeandcauses anoscillatory behavior.",
        "181d2f41-34fa-4b75-a836-fa688a4fdf5f": "TheFlooding Protocol inan\nOSPFimplementation mayuseinherent rate-based\ncontrol mechanisms suchas:(1)limitthenumber\nofsimultaneous synchronizations, or(2)reduce the\nvalueoftheretransmission timer. Itisalsorecom-\nmended thatalinearsearch oftheretransmission\nlistbeavoided.\n3Summary andConclusions\nOpenShortest PathFirst(OSPF) isadynamic, hi-\nerarchical routing protocol tosupport theTC!P/IP\nnetworks. Inthispaper, asimulation oftheOSPF\nElection Protocol showsthreeresults: (1)TheDes-\nignated Router(DR) canbeelected inconstant\ntime.(2)Ifarouterhasalimited number ofinput\nbuffers, acompetition forbuffers between theElec-\ntionandtheFlooding Protocols increases theelec-\ntiontimeandcauses anoscillatory behavior. At\neachrouter, theRouter-ID oftheDRcontinuously\nchanges causing instability. Tosolvetheseprob-\nlems,Hellopackets mustbequeued inaseparate\ncontrol queueandprocessed atahigher priority,\n(3)Intheworstcase,whentheDRandtheBDR\nfailatthesametime,theDR-agreement-time is\nbounded abovebytwicetheHelloInterval.\nAsimulation oftheOSPF Flooding Protocol\n61",
        "f34329b3-1645-4589-acc3-4a7b80f553de": "using20,50and80router point-to-point net-\nworksshowsthreeresults: (1)Forthe50router\nnetwork, aslinkspeedexceeds 4000Kbps, the\nprobability yofoverflowing theinputbuffers in-\ncreases causing retransmissions. Theincrease in\nbootup-convergence-time fromretransmissions is\nbounded bytwoandthreetimestheRxmtInter-\nvalforlinkspeeds of4000to6000Kbpsandabove\n50Mbpsrespectively. Theincrease inthebootup-\nconvergence-time isduetolargenumber ofunac-\nknowledged flooding packets received within Rxmt-\nInterval. (2)For20and50router networks, the\ninputbuffersizehaslittleimpact onthebootup-\nconvergence-time. Forthe80router network, a\nsmallchange intheinputbuffer sizedrastically\nchange thebootup-convergence-time. (3)Reducing\nthevalueoftheRxmtInterval lowers thebootup-\nconvergence-time athighlinkspeeds.\nReferences\n[1]J.Moy.Theopenshortest pathfirst(OSPF)\nspecification. Technical Report RFC-1131,SRI\nNetwork Information Center, October 1989.\n[2]Deepinder Sidhu, Tayang Fu,Shukri Abdallah,\nRajNair,andRobColtun. Openshortest path\nfirstsimulation. underpreparation.\n62\nView publication stats",
        "b55ec74b-90a8-459f-89f7-546f88f25956": "OSPFN: An OSPF Based Routing Protocol\nfor Named Data Networking\nLan Wang\u2217, A K M Mahmudul Hoque\u2217, Cheng Yi\u2020,\nAdam Alyyan\u2217, Beichuan Zhang\u2020\nJuly 25, 2012\nAbstract\nNamed Data Networking (NDN) is a new data-centric network ar-\nchitecture. In NDN, users send Interest messages to retrieve data by\ntheir names. Since the Interest messages do not contain source or des-\ntination addresses, routers need to forward them based on the names\ncarried in the messages. In order to provide name-based routing ca-\npability in NDN, we have extended OSPF to distribute name pre\ufb01xes\nand calculate routes to name pre\ufb01xes. Our protocol OSPFN is cur-\nrently deployed in the NDN testbed. This report describes our design,\nimplementation, deployment, and future work.\n1 Introduction\nThe Named Data Networking (NDN) [2, 3] architecture represents a funda-\nmental paradigm shift from the current Internet architecture. IP identi\ufb01es\ndata using its location (an IP address). In NDN, the data consumer sends\nout an Interest packet, which identi\ufb01es the data that the consumer is seeking\nbyname . The response to an Interest packet in NDN is called a Data packet,\nwhich carries both the full name and the data itself. This departure from\nwhere data is, to what data is, de\ufb01nes NDN. As a result, NDN routing needs\nto provide routes to name pre\ufb01xes rather than address pre\ufb01xes. Moreover,\nwhen NDN routers forward Interest packets, they set up state information\n\u2217Lan Wang, A K M Mahmudul Hoque, and Adam Alyyan are with University of\nMemphis. Their email addresses are {lanwang, ahoque1, aalyyan }@memphis.edu.\n\u2020Cheng Yi and Beichuan Zhang are with University of Arizona. Their email addresses\nare yic@email.arizona.edu and bzhang@cs.arizona.edu respectively.\n1\nNDN, Technical Report NDN-0003, 2012. http://named-data.net/techreports.html",
        "738e1ae8-419b-4b92-9a48-5cc0387e40fe": "so that returning Data packets can be forwarded back to the consumers.\nThis state enables routers to explore multiple routes for each name pre\ufb01x\nwithout having loops. To fully support this multipath forwarding capabil-\nity, it would be advantageous for the routing protocol to calculate multiple\nroutes to the same name pre\ufb01x whenever possible.\nOur goal is to develop a dynamic routing protocol for NDN to support\nthe above functionality. For the long term, it is desirable to design the\nnew protocol over the NDN architecture directly, i.e., naming routers and\nmessages without using IP addresses as well as employing Interest/Data\nmessages to exchange routing information. However, because there is an\nurgent need to support all NDN research areas to use the NDN testbed\nfor prototyping and evaluation, we must quickly deploy a dynamic routing\nprotocol for the testbed. For this reason, we decided to extend an existing\nrouting protocol to provide the necessary functionality. We chose Open\nShortest Path First (OSPF) [4] because it is widely used in the Internet and\nit has high-quality open-source implementations. To reach our eventual goal\nof designing a routing protocol purely on NDN, we started with version 1.0,\nwhich is a name based extension of OSPF that runs on IP and supports\nonly single-path routing. We added the support of con\ufb01gred multipath in\nversion 2.0 and we expect to develop version 3.0, which will run on NDN\nand support automatic multipath.\nOur protocol OSPF for Named-data (OSPFN) uses Opaque Link State\nAdvertisements [1] to announce name pre\ufb01xes while ensuring backward com-\npatibility. It supports name pre\ufb01x advertisement from multiple sites (for the\nsame or di\ufb00erent pre\ufb01xes). Moreover, since OSPF provides only a single best\npath to each destination, we added a con\ufb01gured multipath feature to allow\nusers to specify which links to use when the best route fails to bring back\ndata. Even though OSPFN does not support full-\ufb02edged dynamic multipath\nrouting capability, the con\ufb01gured multipath feature has already helped us\nbetter understand the forwarding behavior of the current CCND implemen-\ntation. OSPFN is currently deployed at all the ten institutions participating\nin the NDN testbed.\nSection 2 discusses our motivation for the project and provides some\nbackground information on OSPF. We describe the OSPFN design in detail\nin section 3. In sections 4 and 5, we present the implementation and con\ufb01g-\nuration of OSPFN using a sample testbed as an example. Section 6 explains\nthe current deployment of OSPFN and outlines the tools we use to monitor\nit. Finally, in section 7, we conclude by discussing future work related to\nOSPFN.\n2",
        "c9402409-7ab5-429a-87fd-5bf4b19dfb32": "2 Motivation and Background\nNDN is a novel proposal that retrieves data based on name instead of lo-\ncation. In NDN, routers forward Interest messages by looking up their\nForwarding Information Base (FIB) using the names carried in the mes-\nsages. Although FIBs can be manually con\ufb01gured, such manipulation is\ntime-consuming and error-prone. For the NDN testbed and, more impor-\ntantly, future NDN deployment, we need a routing protocol that would\ncalculate routes to name pre\ufb01xes dynamically based on the network topol-\nogy. In order to address this issue quickly, we designed our solution as an\nextension of the current OSPF protocol. Open source code availability of\nOSPF was also an incentive to extend OSPF.\nOSPF [4] is a link state routing protocol that works within an au-\ntonomous system (AS). Each router in the system gathers link state in-\nformation about the network to build a Link State Database (LSDB). This\nLSDB is updated through the \ufb02ooding of Link State Advertisements (LSA).\nAll the routers in the network have the same copy of the LSDB. Each router\nbuilds a network topology from the LSDB and runs the Shortest Path First\nalgorithm to calculate the path(s) to each destination. Whenever there is\nany change in the network topology, the routing table is recomputed. OSPF\nis free of persistent loops due to the \ufb02ooding of link state information. It\nsupports equal-cost multipath, i.e., it produces multiple paths to the same\ndestination if they have the same lowest cost among all the available paths.\nOSPF supports Opaque LSA (OLSA) [1] to provide extensibility for fu-\nture use. OLSA consists of a standard LSA header followed by an application\nspeci\ufb01c data \ufb01eld, which can be used by any external application to extend\nOSPF. OLSAs are distributed by OSPF throughout the network. This dis-\ntribution of OLSAs in the network is limited by the \ufb02ooding scope, which\nis determined by the Opaque Type \ufb01eld in OLSA header (see Section 3 for\nmore information).\n3 Design\nRouting in NDN is di\ufb00erent from traditional IP routing in two ways: (a)\nrouting on names: data producers register name pre\ufb01xes, not address pre-\n\ufb01xes; (b) multipath: routing protocol is expected to provide multiple paths\nto each name pre\ufb01x (if such paths exist). Our current protocol \u201cOSPFN\u201d\nsupports routing on names and con\ufb01gured multipath routing.\nWe use OSPF\u2019s Opaque LSAs or OLSA [1] to announce name pre\ufb01xes.\n3",
        "3fc9b7a5-e2cd-41c3-a480-07cd5a8f755b": "OLSA allows for application speci\ufb01c information to be advertised in the\nnetwork. Legacy nodes will not use these LSAs to build their topology, but\nwill still forward them. This ensures backward compatibility with legacy\nnodes and allows new functions to be implemented among the upgraded\nnodes. Moreover, open source routing suites, such as Quagga OSPF, pro-\nvide an API that allows for easy injection and retrieval of OLSAs through\nOSPF. This \ufb02exibility and ease of use makes OLSA the perfect candidate\nfor advertising name pre\ufb01xes.\nOSPFN produces routes to name pre\ufb01xes and installs them into CCND\n(Content Centric Network Daemon) [5], which handles the forwarding of In-\nterest and Data messages. More speci\ufb01cally, each NDN router runs CCND,\nOSPFN and OSPFD (OSPF daemon) in parallel (Figure 1). OSPFN builds\nName OLSAs and injects them into the local OSPFD, which \ufb02oods the OL-\nSAs to the entire network. When the OSPFD at a node receives an OLSA,\nit delivers the OLSA to its local OSPFN. Since each LSA carries the ID of\nthe router that originated the LSA, OSPFN can obtain the router ID of a\nName OLSA and query OSPFD to retrieve the nexthop to reach the router\n(note that OSPFD still \ufb02oods its regular LSAs and computes the shortest\npath tree based on the overlay topology). OSPFN then installs the name\npre\ufb01x and its associated nexthop into the CCND FIB. In the remainder of\nthis section, we describe the format of name OLSA messages, the process\nfor route calculation, and the detailed message exchange process.\nCCND OSPFN OSPFDFIB\nROUTESOLSAQUERIESOLSA\nENTRIES\nFigure 1: Relationship between CCND, OSPFN, and OSPFD\n3.1 Name OLSA Messages\nA Name OLSA message carries a single name pre\ufb01x. Its format is shown\nin Figure 2. The majority of the \ufb01elds are assigned by OSPFD in the\nadvertising router. OLSA has three scopes for \ufb02ooding the network. We\nuse the LS Type \u201c10\u201d for area scope \ufb02ooding, which means the OSLA will\nbe \ufb02ooded only within the local area. The Opaque Type \ufb01eld can contain\na value within the range 127-255 for application speci\ufb01c use; we use 236\nfor Name OLSA. The Opaque ID is a unique value assigned by the user to\nidentify this name pre\ufb01x. The Opaque Information \ufb01eld carries a 32-bit \ufb01eld\n4",
        "2bde0e78-982a-47ec-86a6-99e1a4a22727": "for the name pre\ufb01x size, an 8-bit \ufb01eld for the name pre\ufb01x format, as well as\nthe actual name pre\ufb01x. The name pre\ufb01x format can be URI (0) or CCNB\n(1). Other formats can be de\ufb01ned in the future.\n10 - area-local scope; Opaque LSAs are not flooded beyond the local area\n11 - AS-wide scope; Opaque LSAs are flooded throughout the AS\nSpecifies the application specific type of the Opaque LSA\nType-specific ID\nRouter ID of the LSAs originator\nUsed to detect old and duplicate LSAs\nChecksum of the complete header except the LS Age field\nTotal header length\nApplication-specific data\nSize in Bytes of Name Prefix (32 bits)\nName Type (8 bits)\nName Prefix (variable size)Name LSA Opaque InformationOpaque InformationLengthLS ChecksumLS Sequence NumberAdvertising RouterOpaque IDOpaque TypeLS TypeOptionsLS Age0 8 16 24 31\nLS Age Options LS Type\nOpaque Type Opaque ID\nAdvertising Router\nLS Sequence Number\nLS Checksum Length\nOpaque Information (variable size)\nThe age of the LSA in seconds\nOptional capabilities associated with the LSA\nThe link-state type of the Opaque LSA that identifies the LSAs range of  topological \ndistribution. The three types used are as follows:\n9 - link-local scope; Opaque LSAs are not flooded beyond the local (sub)network\nFigure 2: Name OLSA Message Format\n3.2 Route Calculation\nOSPFN does not perform shortest path calculation \u2013 it queries OSPFD for\nthe nexthop to the origin router of a name pre\ufb01x. When OSPFN receives\nthe query\u2019s result, it adds a FIB entry containing the name pre\ufb01x and the re-\nturned nexthop. In the case of a name pre\ufb01x advertised by multiple routers,\nOSPFN sends a query for each of the origin routers and inserts a FIB entry\ncontaining the name pre\ufb01x and each returned nexthop.\nBecause the OSPF protocol provides only a single nexthop for each des-\ntination, except when there are equal-cost shortest paths, OSPFN by default\ngenerates one route for each single-origin name pre\ufb01x. However, one of the\nunique features of NDN is its forwarding strategy, which can explore multi-\nple paths to retrieve a piece of named data. Ideally, we should either modify\n5",
        "a07c0c4a-2ba3-4cc9-a422-6030403c2e17": "OSPF to calculate multiple best paths to each destination or let OSPFN\nmanage the topology information and perform multipath calculation. How-\never, these designs would take a long time to implement. As a poorman\u2019s\nsolution to multipath routing, OSPFN allows operators to specify a ranked\nlist of nexthops and it will insert the corresponding routes into CCND\u2019s FIB,\nso that CCND will try them when the best path fails to bring back data.\nEach interface is associated with a preference; the more preferred interfaces\nwill be tried \ufb01rst. We call this feature \u201ccon\ufb01gured multipath routing\u201d. To\nease the burden on operators, the multipath con\ufb01guration is speci\ufb01ed for\neach node, not for each name pre\ufb01x. Note that this is simply an initial or-\nder for CCND to explore; CCND\u2019s forwarding strategy will choose the best\npath based on which path retrieves the data fastest.\nWhen con\ufb01gured multipath is used, OSPFN generates a list of FIB en-\ntries for each name pre\ufb01x: the most preferred nexthops are those for the\norigin routers, ranked by their associated path costs, followed by the con\ufb01g-\nured multipath nexthops by descending order of preference. OSPFN then\ninserts the FIB entries in the reverse order, as CCND tries the last inserted\nFIB entry \ufb01rst.\n3.3 Messages Exchange Process\nWhen a router boots up, it reads the con\ufb01guration \ufb01le and creates a Name\nOLSA for each name pre\ufb01x that it wants to advertise to the network. It\nthen sends the Name OLSAs to the local OSPFD to be \ufb02ooded through\nthe area. The router may also learn the name pre\ufb01xes it should originate\nthrough other means, e.g., another protocol.\nOSPFD informs OSPFN whenever there is an update in its LSDB along\nwith the content of the LSA. After receiving an LSA from OSPFD, OSPFN\n\ufb01rst checks whether the LSA is an OLSA or not. If it is not an OLSA,\nOSPFN simply discards that LSA. Otherwise, the router checks whether\nthe OLSA is originated by itself. If not, the OLSA is processed. OSPFN\nreads the name pre\ufb01x from the Opaque LSA \ufb01eld and creates an entry in\nits own Name Pre\ufb01x table containing the name pre\ufb01x and the origin router.\nAfter that, OSPFN sends a query to OSPFD for the nexthop(s) to reach\nthe origin router(s) of each name pre\ufb01x.\nWhen OSPFD receives a query message from OSPFN, it looks up its\nrouting table for the nexthop list and associated path costs, includes them\nin a single message and then sends the message back to OSPFN. When\nOSPFN receives this message from OSPFD, it will use the nexthop list and\npath costs to update the Name Pre\ufb01x Table for all name pre\ufb01xes that have\n6",
        "296ffcc7-e87b-4405-8fcf-5d41de248bf9": "this router as their origin router. Then OSPFN will create FIB entries for\neach name pre\ufb01x and insert them into CCND. One FIB entry is created for\neach next hop for a name pre\ufb01x.\nWhen OSPFN receives any messages from OSPFD about deleting a\nName OLSA, it will delete entries for the name pre\ufb01x in its own Name\nPre\ufb01x table. OSPFN will then send messages to CCND to delete the corre-\nsponding FIB entries from CCND. Figure 3 shows the sequences of messages\nexchanged between OSPFD, OSPFN and CCND.\nOLSA from neighboring \nrouter\nCCND OSPFN OSPFD\nFIB EntriesROUTESROUTE QUERIESOLSA UPDATESOLSA\nFigure 3: Sequences of Messages exchanges among OSPFN, OSPFD and\nCCND\n4 Implementation\nOSPFN is developed based on Quagga 0.99.17 [6] and tested on Ubuntu\n10.04, 10.10, 11.04, 12.04, Fedora 9, and FreeBSD 9.0. It is implemented and\ndistributed by the University of Memphis and the University of Arizona. We\nreleased the \ufb01rst version on Oct. 18, 2011 and the second version on May 15,\n2012. Our code is open source and available at github.com. OSPFN2.0 can\nbe downloaded from https://github.com/NDN-Routing/OSPFN2.0 . Below\nwe describe several important implementation details.\n4.1 Con\ufb01guration\nTable 1 shows the con\ufb01guration commands supported in the current OSPFN\nimplementation.\n7",
        "42d66f79-9d32-4392-80bf-266bca49aa29": "ccnnametype type\nFunction specify the format of the subsequent name pre\ufb01xes\nParameter type : name pre\ufb01x format, 0 (URI, default) or 1\n(CCNB).\nccnname name prefix op id\nFunction specify a name pre\ufb01x to be originated\nParametersname prefix : name pre\ufb01x to be originated\nopid: a unique ID for this name LSA. The op id must\nbe unique among the name pre\ufb01xes advertised by the\nsame router.\nmultipath-order a.b.c.d pref order\nFunction specify the interfaces to be explored by CCND and\ntheir associated preferences\nParametersa.b.c.d : next hop address\npref order : preference of next hop\nlogdir dir\nFunction specify the directory of the log \ufb01les\nParameter dir: directory for logging\nTable 1: OSPFN Con\ufb01guration Commands\n4.2 LSA Origination\nOSPFN originates OLSAs after processing its con\ufb01guration \ufb01le. For each\nccnname command in the con\ufb01guration \ufb01le, OSPFN creates a Name OLSA\nwith LS Type 10, Opaque Type 236, and the con\ufb01gured Opaque ID. The\nOpaque Data \ufb01eld is set with the size of the name pre\ufb01x, name type from\ntheccnnametype command, and the name pre\ufb01x. OSPFN then injects this\nOLSA into OSPFD.\n4.3 Multipath Ordering\nWhen OSPFN injects routes into the CCND FIB, the best path will be\ninjected last so that CCND will try it \ufb01rst. The other interfaces will be\ninserted based on their preference speci\ufb01ed by the operator. For example,\nsuppose a router has three interfaces with the following preferences:\nmultipath-order 10.0.1.2 3\nmultipath-order 10.0.2.1 2\nmultipath-order 10.0.8.2 1\n8",
        "13d92867-1f9a-40ca-af79-30462edec65e": "If 10.0.2.1 is the best nexthop to the name pre\ufb01x P, then OSPFN will con-\nstruct the FIB entries such that CCND will \ufb01rst use 10.0.2.1 to forward\nInterest packets under P. If this interface fails to bring back data, then it\nwill try 10.0.1.2, followed by 10.0.8.2. When the best nexthop changes,\nOSPFN will adjust the FIB entries accordingly. For example, if 10.0.8.2\nbecomes the new best nexthop, then the order becomes 10.0.8.2, 10.0.1.2\nand 10.0.2.1.\n5 Example\n10.0.2.5\n10.0.2.6621\n1 1\n11RTR 1\nID - 141.225.8.1\nRTR 2\nID - 141.225.8.2RTR 3ID - 141.225.8.3\nRTR 5\nID - 141.225.8.5RTR 6ID - 141.225.8.6 RTR 4ID - 141.225.8.410.0.2.210.0.2.110.0.1.210.0.1.1 10.0.1.5\n10.0.1.6\n10.0.3.1\n10.0.3.210.0.3.5\n10.0.5.1 10.0.5.210.0.3.6\nFigure 4: Network Topology\nTo demonstrate the design operation, the sample network topology in\nFigure 4 will be used. The sample network consists of 6 NDN routers. Each\nrouter\u2019s public IP is displayed in the \ufb01gure, as well as the tunnel address\nfor each router. The cost of each link is also shown. Each NDN router has\ndirect access to the name pre\ufb01xes shown in Table 2, which also displays the\norigin router of each name pre\ufb01x. Each router is initially con\ufb01gured with\nthe name pre\ufb01xes they want to advertise using the textbfccnname command.\nOptionally, a router can specify back up paths using the multipath-order\ncommand and the logging directory using the logdir command in its con\ufb01g-\n9",
        "1df717e9-b6d1-4479-9ebb-7d3cc48e5166": "Router Name Pre\ufb01xes\nRTR1 /ndn/\ufb02ying/delta\n/ndn/\ufb02ying/aa\n/ndn/\ufb02ying/ticketprices\nRTR2 /ndn/sports/soccer\n/ndn/sports/bb\nRTR3 /ndn/lifestyle/home\n/ndn/lifestyle/cooking\nRTR4 /ndn/leisure/park\n/ndn/leisure/theater\nRTR5 /ndn/travel/Michigan\n/ndn/travel/Illinois\nRTR6 /ndn/airport/Detroit\n/ndn/airport/Chicago\n/ndn/\ufb02ying/ticketprices\nTable 2: Name Pre\ufb01xes Originated\nby Each RouterRTR1 Con\ufb01guration File\nccnname /ndn/\ufb02ying/delta 1\nccnname /ndn/\ufb02ying/aa 2\nccnname /ndn/\ufb02ying/ticketprices 3\nmultipath-order 10.0.1.2 10\nmultipath-order 10.0.1.6 20\nRTR3 Con\ufb01guration File\nccnname /ndn/lifestyle/home 1\nccnname /ndn/lifestyle/cooking 2\nmultipath-order 10.0.1.5 10\nmultipath-order 10.0.3.6 15\nmultipath-order 10.0.3.2 20\nRTR6 Con\ufb01guration File\nccnname /ndn/airport/Detroit 1\nccnname /ndn/airport/Chicago 2\nccnname /ndn/\ufb02ying/ticketprices 3\nTable 3: Router Con\ufb01guration Files\nuration \ufb01le. The con\ufb01guration \ufb01les for RTR1, RTR3, and RTR6 are shown\nbelow in Table 3. Each con\ufb01guration \ufb01le consists of the name pre\ufb01x that\nthe router is originating, and in the case of RTRs 1 and 3, the con\ufb01gured\nmultipath settings.\nThe OSPFN on each node will build a Name OLSA for each name pre\ufb01x\nin its con\ufb01guration \ufb01le to advertise to the network. It will inject the Name\nOLSAs and handle the arrival/deletion/update of Name OLSAs from other\nrouters through the API provided by OSPFD. Each node will then be able\nto build a Name Pre\ufb01x Table containing the pre\ufb01x names of all content ad-\nvertised in the network. The Name OLSAs for RTR3 are shown in Figure 5,\nwhich contains important information about the Name OLSAs such as the\ntype, size of the name pre\ufb01x, as well as the name pre\ufb01x itself. RTR3\u2019s Name\nPre\ufb01x Table is shown in Figure 6; for each name pre\ufb01x, the corresponding\norigin router is shown.\nEach NDN node will then construct FIB entries for each unique name\npre\ufb01x in its Name Pre\ufb01x Table. In the following example a FIB entry for\nRTR3 will be constructed for the name pre\ufb01x /ndn/flying/ticketprices .\nFirst the origin router (or routers) for the name pre\ufb01x is looked up in the\nName Pre\ufb01x Table, then, the next hops to the origin routers are obtained\nfrom the OSPFD Routing Table (Figure 7).\n10",
        "239f6f05-f061-4ef8-ba85-aea3ffc59ee1": "Opaque InformationAdvertising RouterOpaque TypeLS TypeRTR3 Opaque Name LSA\nOpaque InformationAdvertising RouterOpaque TypeLS TypeRTR3 Opaque Name LSA\n0 (0/1 0-indicates uri, 1-indicates ccnb)20 (Size in bytes of prefix name) 23 (Size in bytes of prefix name)\n0 (0/1 0-indicates uri, 1-indicates ccnb)\n/ndn/lifestyle/home /ndn/lifestyle/cooking141.225.8.323610\n141.225.8.323610Figure 5: Name OLSA for RTR3\nRTR3 Name Prefix Table\nName Prefix Advertising Router\n141.225.8.1 (RTR1)\n141.225.8.1 (RTR1)\n141.225.8.1 (RTR1)\n141.225.8.2 (RTR2)\n141.225.8.2 (RTR2)\n141.225.8.4 (RTR4)\n141.225.8.4 (RTR4)\n141.225.8.5 (RTR5)\n141.225.8.5 (RTR5)\n141.225.8.6 (RTR6)\n141.225.8.6 (RTR6)\n141.225.8.6 (RTR6)/ndn/flying/delta\n/ndn/flying/aa\n/ndn/flying/ticketprices\n/ndn/sports/soccer\n/ndn/sports/bb\n/ndn/leisure/park\n/ndn/leisure/theater\n/ndn/travel/Michigan\n/ndn/travel/Illinois\n/ndn/airport/Detroit\n/ndn/airport/Chicago\n/ndn/flying/ticketprices\nFigure 6: RTR3\u2019s Name Pre\ufb01x Table\nFor a name pre\ufb01x advertised by a single router, a FIB entry is con-\nstructed containing the name pre\ufb01x and the next hop to the origin router.\nThen the constructed FIB entry is inserted into the CCND FIB. If a name\npre\ufb01x is advertised by multiple routers, FIB entries are constructed for each\nnext hop to the origin routers. Then, these FIB entries are added in CCND\nFIB in decreasing order of path cost to the origin routers. Higher preference\nis given to lower cost path.\nNow if a router has been con\ufb01gured for multipath, it will construct and\ninsert FIB entries for each con\ufb01gured next hop for a name pre\ufb01x by increas-\ning order of preference, followed by any next hops for the origin routers of\nthat name pre\ufb01x by decreasing path cost. Since CCND uses the last in-\nserted FIB entry \ufb01rst, OSPFN makes sure that the origin routers\u2019 nexthops\nget higher preference than other con\ufb01gured nexthops. Partial FIB of RTR3\nwill look like Figure 8, where the next hops are ordered from lowest to high-\nest preference. To \ufb01nd RTR3\u2019s next hops for /ndn/flying/ticketprices ,\n\ufb01rstly the origin router(s) of the pre\ufb01x, i.e., RTR\u2019s 1 and 6, are looked up\n11",
        "127b2245-99de-4599-bab4-8f3e7dbdb02b": "RTR1Destination Next HopRTR3 OSPF Routing Table\n10.0.1.5 (RTR1)\nRTR2 10.0.1.5 (RTR1)\nRTR4 10.0.1.5 (RTR1)\nRTR5 10.0.3.2 (RTR5)\nRTR6 10.0.3.6 (RTR6)Figure 7: RTR3\u2019s Routing Table\nin the OSPF routing table. This yields the next hop associated with each\nrouter, 10.0.1.5 (RTR1) and 10.0.3.6 (RTR6), respectively. The path cost\nis also looked up and the lower value wins. RTR6 has a path cost of 1\nfrom RTR3, while RTR1 has a path cost of 2 from RTR3, thus RTR6 be-\ncomes the best next hop, followed by RTR1. This gives us the \ufb01rst 2 next\nhops for the pre\ufb01x. In our example, RTR3 has a backup path due to its\nmultipath con\ufb01guration, therefore the backup link is used as the next hop,\nwhich is RTR5. A similar process is performed to obtain the next hops for\n/ndn/sports/soccer.\n10.0.5.1 (RTR5)\n10.0.1.5 (RTR1)\n10.0.3.6 (RTR6)\n...\n10.0.3.6 (RTR6)\n10.0.5.1 (RTR5)\n10.0.1.5 (RTR1)\n...RTR3 FIB\nName Prefix Next Hop\n/ndn/flying/ticketprices\n/ndn/flying/ticketprices\n/ndn/flying/ticketprices\n/ndn/sports/soccer\n/ndn/sports/soccer\n/ndn/sports/soccer...\n...\nFigure 8: RTR3\u2019s FIB Table\n6 Deployment and Testbed Status Monitoring\nWe deployed the \ufb01rst version of OSPFN in Oct. 2011 and the second version\nin May 2012 over the NDN testbed. All the 10 sites on the NDN testbed have\ndeployed OSPFN 2.0 as of June 28 2012, including UCLA Remap, PARC,\nUniversity of Arizona, Colorado State University, Washington University\n(including the Supercharged PlanetLab Platform or SPP nodes), University\nof Memphis, CAIDA, UCLA, Northeastern University and UIUC. From the\n12",
        "327a8ded-8582-4ec2-ace5-c59e47baa61e": "deployment experience, we noticed that setting up and con\ufb01guring GRE\ntunnels in di\ufb00erent OSes accounted for the majority of our problems. Man-\naging private IPs is also an issue in network management. We hope to get\nrid of these problems when the next version is released, which will be a pure\nname-based design using NDN messages.\nWe have developed web-based tools to monitor which pre\ufb01xes are ad-\nvertised by OSPFN and which neighbors are advertised by OSPFD at each\nNDN hub (Figure 9). The current state of each link is also displayed along\nwith a timestamp of when the corresponding LSA was received. The times-\ntamp at the top of the page indicates the time the page was last updated.\nAnother monitoring tool we use is the CCND status web page (Figure 10),\nwhich helps us verify whether OSPFN installs routes correctly into CCND.\nFigure 9: OSPFN Status on NDN Testbed\n7 Future Work\nWe plan to continue running and maintaining OSPFN 2.0 on the NDN\ntestbed. At the same time, we would also like to ensure the long-term\nviability of NDN routing. Therefore, we have recently started developing an\nOSPF protocol over NDN. It will not rely on IP addresses, but rather, each\nrouter and interface are named. It will also automatically calculate multiple\nforwarding choices without user con\ufb01guration.\n13",
        "0f557706-63eb-4059-8cd0-f8080f7de810": "Figure 10: OSPFN routes installed into CCND\n8 Acknowledgments\nYaoqing Liu participated in the implementation of OSPFN 1.0. Gus Sanders\ndeveloped the web-based OSPFN status monitoring tool. Yifeng Li devel-\noped the CCND status webpage. We would also like to thank Lixia Zhang,\nVan Jacobson, James Thornton, Michael Plass and Syed Obaid Amin for\ntheir valuable feedback. Finally, we thank all the NDN testbed operators\nfor deploying OSPFN at their sites.\nReferences\n[1] L. Berger, I. Brystkin, A. Zinin, and R. Coltun. The OSPF opaque LSA\noption. RFC 5250 , July 2008.\n[2] V. Jacobson, D. K. Smetters, J. D. Thornton, M. F. Plass, N. H. Briggs,\nand R. L. Braynard. Networking named content. In Proceedings of ACM\nCoNEXT , 2009.\n[3] L. Zhang et al. Named data networking (NDN) project. Technical Report\nNDN-0001, PARC, October 2010.\n[4] J. Moy. OSPF version 2. RFC 2328 , Apr. 1998.\n[5] PARC. CCNx open srouce platform. http://www.ccnx.org .\n14",
        "b93a8795-e0dc-4501-bc3b-723e51332942": "[6] Quagga routing software suite. http://www.quagga.net .\n15",
        "b5f15526-b9cd-4043-9519-6dea22906bb6": "USING FORMAL METHODS TO VALIDATE THE USAGE, PROTOCOLS, AND \nFEASIBILITY IN LARGE SCALE COMPUTING SYSTEMS  \n \n \n \n \nA Dissertation  \nSubmitted to the Graduate Faculty  \nof the  \nNorth Dakota State University  \nof Agriculture and Applied Science  \n \n \n \n \nBy \n \nSaif Ur Rehman Mal ik \n \n \n \n \nIn Partial Fulfillment  \nfor the Degree of  \nDOCTOR OF PHILOSOPHY  \n \n \n \n \nMajor Department:  \nElectrical and Computer Engineering  \n \n \n \n \n \nApril 2014  \n \n \n \n \nFargo, North Dakota",
        "3d9036f5-56ec-4960-a552-cb849a5fccb4": "North Dakota State University  \nGraduate School  \n \nTitle \n  \nUsing Formal Methods to Val idate the Usage, Protocols, and Feasibility in \nLarge Scale Computing Systems    \n  \n  By   \n  \nSaif Ur Rehman Malik    \n     \n    \n  The Supervisory Committee certifies that this disquisition  complies with North Dakota State \nUniversity\u2019s regulations and meets  the accepted standards for the degree of   \n  DOCTOR OF PHILOSOPHY   \n    \n    \n  SUPERVISORY COMMITTEE:   \n    \n   Samee U. Khan   \n  Chair  \n  Sudarshan K. Srinivasan   \n  Jacob S. Glower   \n   Ying Huang   \n    \n    \n  Approved:   \n   \n 06/10/2014   Scott C. S mith   \n Date  Department Chair",
        "f62e1007-2f23-458c-8fb0-3f5a75713960": "iii \n ABSTRACT  \nA paradigm shift has occurred in the Information and Communication Technology sector. \nThe main obstacle to relegate complex and sensitive tasks is not the inadequate speed and \nunsatisfactory computin g power of the existing machines. However, the inability to design and \nimplement the systems, with a desirable degree of confidence in the correctness and reliability, \nunder different circumstances, has crept in to be the primary concerns in achieving high  \nperformance. The hardware and software systems are growing inevitably in scale and \nfunctionality, such as cloud computing systems and Data Center (DC). In the said perspective, \nthe complexity of the systems is also increasing. The likelihood of elusive er rors is directly \nproportional to the complexity of the systems that also increase the cost of errors while the \nsystems are operational. In large scale systems the density of computational devices is in order of \ntens of thousands of servers. Moreover, the e ffects of errors and miscalculations are substantial. \nFurthermore, if the specified quality of service is not delivered by the cloud service providers, \nthen the reputation may fall down and users will not use the services, resulting in huge financial \nlose. Therefore, the reliability, robustness, and availability of systems are very essential. In the \nsaid perspective, to increase the reliability and correctness of the systems, we propose the use of \nFormal Methods (FM). The FM use sound mathematical foundatio ns to prove program \ncorrectness. The aim of our research is to deploy various FM tools and techniques to formally \nanalyze the behavior and correctness of the strategies, such as routing algorithms and \nvirtualization models that are implemented in large sca le computing systems. The goal of our \nresearch is to thoroughly study the strategies, highlight the grey areas that can be further exploit \nto increase the reliability and performance, and propose a feasible solution. The large scale \ncomputing systems, spec ifically DC exhibits different architectural characteristics, such as",
        "131b3fa4-1db4-40c8-9c0f-8305d4bf1baf": "iv \n predefined complex architectural and topological pattern composed in different layers. The \naforementioned characteristics of the underlying network along with the large scale of the \nservers situate several challenges for the adoption of FMs strategies.",
        "63e9c37e-a0e7-4863-8e1a-6c36fab361e2": "v \n ACKNOWLEDGEMENTS  \nFirst of all I would like to thank Almighty Allah for giving me the strength, courage, \nhealth, and abilities to pursue my PhD and finish the disquisition.  \nMy deepest and  sincere gratitude goes to Dr. Samee U. Khan, my senior advisor for \neverything I have learned from him, and his continuous help and support during all the stages of \nthis disquisition. I would also like to thank him for all the motivation that I needed when  I was \ndown. I truly believe that without his guidance, vision, and encouragement the completion of this \ndisquisition was not possible. I thank him for believing me, when I did not had the believe on \nmyself.  \nI would also like to mention Dr. Sudarshan K. S rinivasan, my co -advisor for all the help, \nguidance, and suggestions. Special thanks to all the committee members, Dr. Jacob S. Glower \nand Ying Huang for their support, guidance and helpful recommendations. Their guidance has \nserved me well and I owe them my heartfelt appreciation.  \nThanks to the Electrical and Computer Engineering staff members Jeffrey Erickson, \nLaura D. Dallman, and Priscilla Schlenker for all the unconditional help and favor.  \nI wish to thank my family, Aijaz Hussain (Father), Anjum Syed (Mother), Fazal Ur \nRehman and Mehmood Ur Rehman (Brothers), and my sweet and sour Fatima Aijaz (Sister). \nTheir support and love was the driving force behind me. I owe them a lot and wish I could show \nthem how much I love and appreciate them. My wife, Hirra  Saif, whose encouragement and \npatience allowed me to finish this journey. She already has my heart so I will just acknowledge \nher by saying a sincere and heartfelt \u201cthanks\u201d. My two little angels Mohid and Ayaan, their \nsmiles and laughter used to loosen me  up from all the stress and worries.",
        "c7aab644-0297-4e15-a60c-518ec59cc5b9": "vi \n Finally I would like to thank my friends, here in US and in Pakistan for all the moments \nof fun, laughter, and joy.",
        "b3a04afa-24cb-462f-b87d-db6fb7e15ea8": "vii \n DEDICATION  \nI would like to dedicate this thesis to my family, especially to my mother and my wife f or \nall the inexplicable love, support, and motivation.",
        "2baa48ee-8e8b-4e21-9d66-77e154b00d94": "viii \n TABLE OF CONTENTS  \nABSTRACT  ................................ ................................ ................................ ................................ ... iii \nACKNOWLEDGEMENTS  ................................ ................................ ................................ ............  v \nDEDICATION  ................................ ................................ ................................ ..............................  vii \nLIST OF TABLES  ................................ ................................ ................................ .......................  xiii \nLIST OF FIGURES  ................................ ................................ ................................ .....................  xiv \n1. INTRODUCTION  ................................ ................................ ................................ ......................  1 \n1.1. Large Scale Computing Systems  ................................ ................................ .........................  1 \n1.2. Formal Methods  ................................ ................................ ................................ ...................  2 \n1.3. Motivation  ................................ ................................ ................................ ............................  3 \n1.4. Research Goals and Objectives  ................................ ................................ ............................  5 \n1.5. References  ................................ ................................ ................................ ............................  6 \n2. RELATED WORK  ................................ ................................ ................................ .....................  7 \n2.1. Virtual Machine (VM) Based Cloud Management Platforms and High Level  \nPetri -Nets (HLPN)  ................................ ................................ ................................ ................  7 \n2.2. Energy Efficient Data Center (DC)  ................................ ................................ ......................  8 \n2.3. Formal Verifications of Routing Protocols  ................................ ................................ ........  10 \n2.4. Thermal -Aware Resource Allocation  ................................ ................................ ................  10 \n2.5. Data Security over the Cloud  ................................ ................................ .............................  13 \n2.6. References  ................................ ................................ ................................ ..........................  15",
        "f77aaec7-472a-43d4-bcc4-20bfb7f43872": "ix \n 3. MODELING AND ANALYSIS OF STATE -OF-THE -ART VM -BASED CLOUD \nMANAGEMENT PLATFORMS  ................................ ................................ .............................  21 \n3.1. Introduction  ................................ ................................ ................................ ........................  21 \n3.2. Prelim inaries  ................................ ................................ ................................ .......................  24 \n3.2.1. High -Level Petri Nets (HLPN)  ................................ ................................ ...................  24 \n3.2.2. SMT -Lib and Z3 Solver  ................................ ................................ ..............................  26 \n3.3. Modeling and Analysis of VM -Based Cloud Management Platforms  ...............................  27 \n3.3.1. Components of Open Source Cloud  ................................ ................................ ...........  27 \n3.3.2. Eucalyptus  ................................ ................................ ................................ ...................  28 \n3.3.3. Open Nebula  ................................ ................................ ................................ ...............  34 \n3.3.4. Nimbus  ................................ ................................ ................................ ........................  42 \n3.3.5. Open Stack  ................................ ................................ ................................ ...................  49 \n3.4. Verification of Models Using SMT -Lib and Z3 Solver  ................................ .....................  49 \n3.4.1. Results  ................................ ................................ ................................ .........................  55 \n3.5. References  ................................ ................................ ................................ ..........................  57 \n4. CONVERGENCE TIME ANALYSIS OF OPEN SHORTEST PATH FIRST ROUTING \nPROTOCOL IN INTERNET SCALE NETWORKS  ................................ ..............................  62 \n4.1. Introduction  ................................ ................................ ................................ ........................  62 \n4.2. Problem Formulation  ................................ ................................ ................................ .........  63 \n4.3. Results and Discussions  ................................ ................................ ................................ ..... 66 \n4.4. References  ................................ ................................ ................................ ..........................  68",
        "bc0168bc-fe42-4461-888c-8ea09182f474": "x \n 5. MODELING AND ANALYSIS OF THE THERMAL DYNAMICS OF CYBER  \nPHYSICAL DATA CENTERS ................................ ................................ ................................  70 \n5.1. Introduction  ................................ ................................ ................................ ........................  70 \n5.2. Modeling Thermal Dynamics of Cyber Physical DC  ................................ ........................  74 \n5.3. Thermal Aware Control Strategy (TACS)  ................................ ................................ .........  81 \n5.4. Verification Using HLPN, SMT -Lib, and Z3 Solver  ................................ ........................  84 \n5.4.1. Modeling HLCC and LLCC Using HLPN  ................................ ................................ . 86 \n5.5. Results and Discussion  ................................ ................................ ................................ ...... 94 \n5.6. References  ................................ ................................ ................................ ........................  101 \n6. A METHODOLOGY FOR OSPF ROUTING PROTOCOL VERIFICATION  ...................  107 \n6.1. Introduction  ................................ ................................ ................................ ......................  107 \n6.1.1. SMT -Lib and Z3 Solver  ................................ ................................ ............................  108 \n6.2. OS PF Routing Protocol ................................ ................................ ................................ .... 109 \n6.3.  Problem Formulation  ................................ ................................ ................................ ....... 111 \n6.4. Verification of OSPF Using Proposed Method  ................................ ...............................  114 \n6.4.1. Content Verification ................................ ................................ ................................ .. 114 \n6.4.2. Route Verification  ................................ ................................ ................................ ..... 115 \n6.5. Result and Discussion  ................................ ................................ ................................ ...... 116 \n6.6. References  ................................ ................................ ................................ ........................  118 \n7. DASCE: DATA SECURITY FOR CLOUD ENVIRONMENT WITH SEMI -TRUSTED \nTHIRD PARTY  ................................ ................................ ................................ ......................  122",
        "87a939f5-9321-49b7-b7d0-4d523ef4bcf4": "xi \n 7.1. Introduction  ................................ ................................ ................................ ......................  122 \n7.2. File Assured Deletion (FADE)  ................................ ................................ ........................  125 \n7.2.1. File Upload ................................ ................................ ................................ ................  127 \n7.2.2. File Download  ................................ ................................ ................................ ...........  129 \n7.2.3. Policy Revocation  ................................ ................................ ................................ ..... 129 \n7.2.4. Policy Renewal  ................................ ................................ ................................ .........  129 \n7.3. Analysis of FADE  ................................ ................................ ................................ ............  130 \n7.3.1. File Upload ................................ ................................ ................................ ................  130 \n7.3.2. Policy Ren ewal  ................................ ................................ ................................ .........  131 \n7.3.3. Attack Verification through Scyther  ................................ ................................ .........  132 \n7.3.4. HLPN  ................................ ................................ ................................ ........................  133 \n7.3.5. SMT -Lib and Z3 Solver  ................................ ................................ ............................  133 \n7.3.6. Verification through HLPN Model  ................................ ................................ ...........  134 \n7.3.7. Formal Verification  ................................ ................................ ................................ ... 134 \n7.4. DaSCE ................................ ................................ ................................ ..............................  140 \n7.4.1. DaSCE Keys  ................................ ................................ ................................ .............  140 \n7.4.2. File Upload ................................ ................................ ................................ ................  141 \n7.4.3. File Download  ................................ ................................ ................................ ...........  143 \n7.4.4. Policy Revocation  ................................ ................................ ................................ ..... 144 \n7.4.5. Policy Renewal  ................................ ................................ ................................ .........  146",
        "00ff45f3-2f15-4e9f-86fe-03d0e224f45e": "xii \n 7.4.6. Analysis of DaSCE through the HLPN  ................................ ................................ .... 146 \n7.5. Implementation and Performance Evaluation  ................................ ................................ .. 153 \n7.5.1. File Upload/Download with a Single Key Manager  ................................ .................  154 \n7.5.2. File Upload/Download with Multiple Key Managers  ................................ ..............  155 \n7.5.3. Discussion  ................................ ................................ ................................ .................  157 \n7.6. References  ................................ ................................ ................................ ........................  159 \n8. CONCLUSIONS  ................................ ................................ ................................ ....................  163",
        "6b908853-4780-4489-a21c-fbc1cc341e1f": "xiii \n LIST OF TABLES  \nTable   Page  \n3.1. Places and Mappings of Eucalyptus \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026...  32 \n3.2. Data Types Used in the Model of Eucalyptus \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  32 \n3.3. Data Types Used in the Model of Open Nebula \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  38 \n3.4. Places Used in the Model of Open Nebula \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  39 \n3.5. Data Types Used in the Model of Nimbus \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  46 \n3.6. Places Used in the Model of Nimbus \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  47 \n3.7. Operators (Op) Used in CTL* and Description (Desc) \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026...  51 \n5.1. Data Types Used in the HLCC and LLCC Model \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u2026... 87 \n5.2. Places Used in the Model of HLCC and LLCC \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  88 \n5.3. Verification Outcomes of Scheduling Approaches \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  100 \n6.1. The OSPF Routers \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..  110 \n6.2. The OSPF Link States and Associated Routers \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..  111 \n6.3. Comparison of Update Time and Ordered List of Router for Example \u2026\u2026\u2026.  116 \n7.1. Notations and Their Meanings \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  126 \n7.2. Data Types Used in FADE HLPN Model\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026...  135 \n7.3. Mapping of Data Types and Places \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u2026\u2026\u2026\u2026  138 \n7.4. Data Types for HLPN of DaSCE \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026  148 \n7.5. Mapping of Data Types and Places for HLPN of DaSCE \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..  149",
        "7c652444-e89d-45b7-a5d6-96a958774666": "xiv \n LIST OF FIGURES  \nFigure   Page  \n3.1. An Example High -Level Petri Net \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  26 \n3.2. Eucalyptus Architectur e\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  29 \n3.3. Model of Starting a VM Instance in Eucalyptus \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026  30 \n3.4. The Architecture of Open Nebula \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  35 \n3.5. Open Nebula Model for Instantiating a VM \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..  37 \n3.6. Nimbus Workspace Components \u2026\u2026\u2026\u2026\u2026 \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026...  43 \n3.7. A Model for Nimbus.  \u2026\u2026 \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026  45 \n3.8. An Example of: (a) Kripke Structure and (b) Computational Tree \u2026\u2026\u2026\u2026\u2026  50 \n3.9. An Example CTL Operators \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u2026\u2026\u2026\u2026 ... 52 \n3.10. An Example Computational Tree of Eucalyptus \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026...  53 \n3.11. Verification Results of Eucalyptus \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026  53 \n3.12. Verification Results of Open Nebula \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026  54 \n3.13. Verification Results of Nimbus \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  54 \n3.14. Execution Time Comparison of Eucalyptus, Open Ne bula, and Nimbus \u2026\u2026.  55 \n3.15. Memory Utilization of the Systems \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026...  55 \n4.1. Sample Topology for One Thousand Routers \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026  63 \n4.2. The Effect of DRs on \u03c4.  \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  66 \n4.3. The Effect of Node and Link Failure on \u03c4.  \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026...  67 \n4.4. The Effect of Random Topological Changes on \u03c4.  \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..  68 \n5.1. An Example High -Level Petri Net \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  72",
        "2963089b-c912-4ea2-b6e2-50b195f98446": "xv \n 5.2. Three -Tier DC Architecture \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026  74 \n5.3. The Ambient Temperature Effect in DC \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026  78 \n5.4. Heat Exchange among Server Nodes\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 . 79 \n5.5. HLCC and LLCC in DC \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026  81 \n5.6. Steps Involved in Low (server) Level\u2026\u2026\u2026\u2026 \u2026\u2026\u2026\u2026 \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026  81 \n5.7. Steps Involved in High (access and aggregate) Level.  \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  82 \n5.8. An Example of: (a) Kripke Structure and (b) Computational Tree \u2026\u2026\u2026\u2026...  85 \n5.9. The HLCC and LLCC HLPN Model in DC Environment \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026  89 \n5.10. The Kripke Struct ure of HLCC and LLCC for the Verification \u2026\u2026\u2026\u2026\u2026\u2026  92 \n5.11. Computational Tree for the Kripke Structure in Fig. 5.10. \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  93 \n5.12. Comparison of A verage Thermal S ignatures of the Pods Using: (a) FCFS, (b) \nGA-based, (c) TASA, and (d) TACS.  \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u2026\u2026...   \n96 \n5.13. Comparison of Average Thermal Signature Difference between the Highest and \nLowest Servers Using: (a) FCFS, (b) GA-based, (c) TASA, and (d) \nTACS\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026...   \n \n98 \n5.14. Average Thermal S ignature Difference between the Highest and Lowest \nServers. \u2026.\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..   \n99 \n5.15. Verification Time Comparison of the Approaches \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..  100 \n6.1. OSPF Areas and Routers \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  108 \n6.2. Example Topology and Associated Delays \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  116 \n6.3. Execution Time for Verification Process.  \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..  117 \n7.1. Shamir\u2019s (k, n) Threshold Scheme in DaSCE \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  124 \n7.2. FADE (a) File Upload, (b) File Download, (c) Policy Revocation, and (d) \nPolicy Rene wal (single key manager) [7.29] \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u2026\u2026\u2026\u2026.   \n127 \n7.3. Fade File Upload with Multiple Key Managers [7.29]. \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  128",
        "1aab1e01-3f20-429a-8bc8-10df85c4925e": "xvi \n 7.4. File Download Using ABE with Multiple Key Managers  [7.29] \u2026\u2026\u2026\u2026\u2026\u2026  129 \n7.5. (a) Man-in-the-middle Attack that Causes Encryption with the Wrong Keys (b) \nExploitation of P olicy Renewal Process . \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.   \n131 \n7.6. Man-in-the-middle with Multiple Key Managers \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026  132 \n7.7. Scyther Verification of FADE \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026  132 \n7.8. FADE HLPN Model with Intruder.  \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026...  136 \n7.9. Key Management in DaS CE\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..  141 \n7.10. DaSCE File Upload with Single Key Manager.  \u2026\u2026 \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  142 \n7.11. DaSCE File Upload with Multiple Key Managers \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026..  143 \n7.12. DaSCE File Download with Multiple Key Managers \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  143 \n7.13. DaSCE Policy Renewal.  \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.  146 \n7.14. HLPN for DaSCE \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u2026 147 \n7.15. Performance of File Uploads and Downloads Operations for DaSCE \u2026\u2026\u2026 \u2026 155 \n7.16. File Uploads with Multiple Key Managers.  \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026  156 \n7.17. File Download with Multiple Key Managers \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 \u2026\u2026... ... 157 \n7.18. Total Upload/ Download Time vs . Key Establishment Time\u2026\u2026\u2026\u2026\u2026 \u2026\u2026...  158",
        "fc72f959-ca00-4660-a772-071f3b237dbe": "1 \n 1. INTRODUCTION  \n1.1. Large Scale Computing Systems  \nAs we delve deeper into the \u2018Digital Age\u2019, we witness an explosive growth in the \nvolum e, velocity, and variety of the data available on the Internet. For example, in 2012 about \n2.5 quintillion bytes of data was created on a daily basis that originated from myriad of sources \nand applications including mobile devices, sensors, individual arch ives, social networks, Internet \nof Things, enterprises, cameras, and software logs.  Such \u2018Data Explosions\u2019 has led to one of the \nmost challenging research issues of the current Information and Communication Technology \n(ICT) era: how to optimally manage (e .g., store, replicated, filter, and the like) such large amount \nof data and identify new ways to analyze large amounts of data for unlocking information ? It is \nclear that such large data streams cannot be managed by setting up on -premises enterprise \ndataba se systems , as it leads to a large up -front cost in buying and administering the hardware \nand software systems.  In the said perspective, t he emergence of technological advances, such as \nmulticore processors and networked computing environments, has helped software practitioners \nto achieve the vision of creating a software paradigm for millions of users to use as a service [1]. \nThe Large Scale Computing System s (LSCS) , such as c loud computing is one such paradigm \nwith which a shared pool of resources (networ ks, servers, storage, applications, and services) can \nbe accessed conveniently and on -demand . Moreover, the services can be rapidly provisioned or \nreleased with minimal management effort or service provider interaction [2].   \nThe LSCS , such as cloud computi ng, has been a mainstream of research in last few years. \nIn a report [ 3], the cloud computing is listed as a top research trend from the year 2006 to 2010. \nIn LSCS, substantial data analysis applications are executed that requires massive amount of",
        "e68d0b36-61cc-4a98-9617-68748280cc12": "2 \n memory,  processor cycles, and communication bandwidth. To perform substantial computations \nand meet the ever increasing demands of users, the LSCS are  equipped with an order of tens of \nthousands of servers . Amazon, Google, IBM, Facebook, and Microsoft have starte d to establish \nData Centers (DC)  that host cloud computing applications in geographically distributed locations \n[4]. To maintain and deliver the specified Quality of Service (QoS) attributes, such as \nthroughput, t he LSCS  must operate in a smooth and effici ent way  all the time . The income of the \nDC is defined by the Service Level Agreement (SLA), which outlines the amount paid by the \nusers based on the QoS they receive. The computational and operating margins of DCs depend \nhighly on the provision of the QoS.  Higher QoS attribute levels lead to higher rates that in turn \nlead to higher computations.  \n1.2. Formal Methods  \nFormal Methods (FM) used in developing computer systems are rigorous mathematically \nbased tools and techniques that describes system properties , and are used for the specification, \ndevelopment, and verification of software and hardware systems. The FM techniques have \nmatured considerably as a verification discipline in the past few decades and have become a \nmainstream technology in industrial des ign, verification methodologies, and processes. \nMoreover, t he increasing criticality and complexity of applications along with  the role of \nsoftware and hardware in those applications has led to the maturity of FM techniques.  The aim of \nsuch techniques is t o increase the quality of software by mathematically proving program \ncorrectness as opposed to using test cases.  The method or technique is considered to be \n\u201cFormal\u201d, if it is backed up by sound mathematical grounds, which is typically provided by the \nspecification language. The mathematical bases are used as a mean to precisely defin e notions, \nsuch as consistency, completeness, specification, implementation, and correctness [5]. The",
        "8adf7254-34a5-4f7c-8618-e4723b863714": "3 \n mathematical structure involved in FM  also helps in proving that if the sy stem is implemented \ncorrectly, then the specification is realizable. The specification provides a complete description \nof the behavior of a system to be developed and also includes use cases to describe user \ninteractions with the software.  In software engi neering, specification is the intermediate product \nof the software development process. Moreover, t he correctness of a system or program  can be \ndetermined using s pecification . \nThe FMs are mainly used to reveal incompleteness, ambiguity, and inconsistency i n a \nsystem. However, it is noteworthy that the use of formal methods does not miraculously \nguarantee the aforesaid results, but can be used to increase the level of confidence towards the \ncorrectness of the system. FMs can be used in different stages of so ftware development life \ncycle. The use of FMs in the early stages of development process can reveal design flaws that \notherwise might be discovered in the costly stages of testing and debugging phases. When used \nat the later stages, FMs can help in determi ning the correctness of the systems implementation.  \nMoreover, t he quality and reliability of software is increased by FM techniques using rigorous \nmathematical modeling, analysis, and verification.  \n1.3. Motivation  \nThe main obstacle to relegate complex and sensitive tasks is not the inadequate speed and \nunsatisfactory computing power of the existing machines. However, the inability to design and \nimplement the systems, with a desirable degree of confidence in the correctness and reliability, \nunder different c ircumstances, has crept in to be the primary concerns in achieving high \nperformance. The hardware and software systems are growing inevitably in scale and \nfunctionality, such as cloud computing systems. In the said perspective, the complexity of the \nsystem s is also increasing. The likelihood of elusive errors is directly proportional to the",
        "cc6dc716-6038-4940-8d35-14b65a638f45": "4 \n complexity of the systems that also increase the cost of errors while the systems are operational. \nIn large scale computing systems the density of computational devices is in order of tens of \nthousands of servers. Moreover, the effects of slightest miscalculations and errors are substantial.  \nThe methods and practices that are generally used for design validations are: (a) \nsimulation and (b) testing. The said techniques ar e useful for small scale networks. However, as \nthe complexity of the systems grow the effectiveness of the aforementioned techniques \ndecreases . Moreover, an alarmingly increasing amount of time is required to uncover the subtle \nbugs by using testing and si mulations. In testing, the program is executed with a set of inputs to \nevaluate the differences between given input and expected output. The goal in testing is to reduce \nthe frequency of failures. Testing is used to identify the presence of bugs, but it ca nnot confirm \nthe absence of bugs from the system. In large scale computing systems, such as cloud, the use of \ntesting becomes infeasible as the sizes of such systems are very large. The set of inputs in testing \nis assumed to cover all possible cases , which  involves the range of normal inputs and as well as \nexceptional scenarios . However, the aforesaid  assumptions are  not realistic. If we take even a \nsimplest of example of testing a program for adding two real numbers, then there could be \ninfinite number of use cases to test and verify the program correctness.  To perform testing and \nsimulation the working prototype of the system or program must exist. First, building a prototype \nprogram for LSCS is itself an expensive task. Second, even if the bugs are identi fied after \nbuilding a prototype, the cost of fixing bugs at later stages is very high. Therefore, testing and \nsimulations are expensive  strategies for the verification of LSCS. The inabilities of traditional \ntools and techniques to effectively substantiate  the working of LSCS have raised questions \nrelated to the reliability and robustness. In short , the problem we attempt to solve in this thesis is",
        "997de80f-5a61-4f25-960f-b974d0a9e2c4": "5 \n \u201cHow to design and implement the systems, with a desirable degree of confidence in the \ncorrectness and reliabi lity, under different circumstances ?\u201d \nThe pricing model implemented over the large scale computing systems, such as cloud is \npay-per-usage, which means that the end -users will pay only for the services usage. Therefore, \nthe specified service level agreemen t based performance must be provided to the end users to \nkeep up the reputation. If the performance requirements are not met, then the users may not use \nthe services, and the reputation may fall down resulting in a loss of customer and money. Few \nexamples to highlight the impact of performance degradation and errors are: (a) Google reported \na 20% revenue loss due to a delay of 500msecs in response time, (b) Amazon reported a sales \ndecrease of 1% due to an additional response time of 100msecs, and (c) Knight  Capital Group \nlost 440 million USD in just 45 minutes, when newly installed trading software went haywire. \nThe aforementioned examples indicate the importance and impact of the performance of the \ncloud services. Moreover , the due consideration that needs to be given to, and the benefit of, \nperformance to the cloud services are also obvious from the said examples. The traditional \nmethods, such as Testing, are expensive and become infeasible as the sizes of the computing \nsystems are large. Because FM presupp oses program semantics that is not considered in Testing  \nand Simulations , the FM techniques are considered more powerful. Moreover, through FMs, \nusers can logically analyze the system to prove properties for any possible inputs. In the said \nperspective, th e use of FM for verifying the functionality and reliability of the systems could be \nbeneficial . \n1.4. Research Goals and Objectives  \nThe objective of our research is to deploy various FM tools and techniques to formally \nanalyze the behavior and correctness o f the strategies, such as routing algorithms and",
        "42789b22-a467-4572-a601-c2b04c143f9f": "6 \n virtualization models that are implemented in large scale computing systems. The goal of our \nresearch is: (a) to thoroughly study the strategies, (b) highlight the grey areas that can be further \nexploit to i ncrease the reliability and performance, (c) and propose a feasible solution. Compared \nto conventional random networks, the large scale computing systems, specifically Data Centers \n(DC) exhibits different architectural characteristics, such as predefined c omplex architectural and \ntopological pattern composed in different layers. The aforementioned characteristics of the \nunderlying network along with the large scale of the servers situate several challenges  towards \nthe application of FMs [6].   \n1.5. Referenc es \n[1] R. Buyya, S. Y. Chee, and S. Venugopal, \u201cMarket -Oriented Cloud Computing: Vision, Hype, \nand Reality for Delivering IT Services as Computing Utilities,\u201d 10th IEEE (HPCC \u201908), pp.5 -13, \nSep. 2008.  \n[2] P. Mell and T. Grance. Definition of cloud computin g. Technical Report, NIST, 2009.  \n[3] A. Hoonlor, B. K. Szymanski, and M. J. Zaki, \u201cTrends in computer science research,\u201d \nCommunications of the ACM, vol. 56, no. 10, pp. 74 -83, 2013.  \n[4] D. Abadi, \u201cData management in the cloud: Limitations and opportunities ,\u201d IEEE Data \nEngineering, Bulletin, vol. 32, no. 1, 2009, pp.3 \u201312. \n[5] J. M. Wing, \u201cA specifier's introduction to formal methods ,\u201d Computer , vol. 23, no. 9, pp. 8-\n22, 1990.  \n[6] J. Woodcock, P. G. Larsen, J. Bicarregui, and J. Fitzgerald, \u201cFormal methods: P ractice and \nexperience,\u201d ACM Computing Surveys (CSUR), vol. 41, no. 4, 2009.",
        "f3728619-38b1-470f-a65e-3300c7beeab7": "7 \n 2. RELATED WORK  \nIn this chapter we discussed some of the work that is related to the research we have \nperformed during Ph.D.  \n2.1. Virtual Machine (VM) Based Cloud Management Platfo rms and High \nLevel Petri -Nets (HLPN)  \nVirtualization has been studied extensively in the domain of cloud computing. The \nresearch is usually focused towards the security or resource provisioning of VM. In [ 2.1], to \nmake the VM more secure, the authors have p roposed to remove the virtualization layer, while \nretaining the key features enabled by the cloud. In [ 2.2], the authors proposed HyperSafe, which \nis a lightweight approach that endows existing hypervisors with a self -protection capability to \nprovide lifet ime flow integrity. In [ 2.3], authors proposed new security architecture in a \nhypervisor -based virtualization technology to secure the cloud environment. Similarly, [ 2.4], also \ndiscussed security aspects of VMs in the cloud.  In [ 2.5], a generic model is p roposed for \nresource allocation of VMs in multi -tier distributed environment that describes every VM as a \nmulti -dimensional vector. In [ 2.6], a two level resource manager is proposed that allocate \nresources to individual containers using local controllers.  Several studies are also available, such \nas [2.7 - 2.10] that discuss and compare the cloud management platforms. The focus of the said \nstudies was on the discussion and comparison of architecture and feature set of the systems. \nHowever, little amount of work has been done in the area of modeling and analysis of cloud \nmanagement systems, specifically VM -based systems. The HLPN has been widely used for the \nmodeling of systems from various domains of computer science, such as cloud computing, web \nservice fra mework, Grid infrastructures, scheduling and load balancing. In [ 2.11], the authors",
        "e2040727-6492-476e-8dbd-a99460ae4786": "8 \n have used Colored Petri Nets (CPN) to model Open Provenance Model (OPM) for the purpose of \nModel -based Diagnosis in the Cloud (MBD). Virtualization and modeling (including formal \nanalysis and verification) are very rich research domains, when considered separately. However, \na diminutive amount of research is performed when both (modeling, including formal analysis \nand verification of virtualization) are combined.   \n2.2. Energ y Efficient Data Center (DC)  \nThe paradigm shift has occurred in the DCs, where the cost of IT equipment or hardware \nis no longer the major portion of the overall cost, instead the cost of power and cooling \ninfrastructure has crept in to be the primary cost  driver. Thermal imbalance can cause a hurdle \ntowards achieving an efficient operational DC. The presence of the hotspots creates a risk of \nredlining servers that can cause them to fail prematurely.  The power consumption and thermal \nproperties of the devi ces are directly proportional to each other. Therefore, in this section we will \ndiscuss both power and thermal strategies. Several strategies have been proposed to balance the \ntradeoff between the power, cooling, and performance. There are multiple ways to  control the \npower consumption and thermal properties of the servers, such as through active management of \nworkload hosted on the servers by using admission control strategies, load balancing, and \nworkload migration. The power consumption of the servers ca n also be tuned through physical \ncontrol, such as Dynamic Voltage and Frequency Scaling (DVFS) and on -off state control \n[2.12]-[2.14]. The DVFS has already been implemented in the operating systems, where the CPU \nutilization drives DVFS controller to adopt  the power consumption with the changing workload. \nA control -theoretic approach to DVFS is proposed in [ 2.15], where the authors have modified the \nclassical control system algorithm, Proportional Integral Derivative (PID) controller, to perform \nthe dynamic  voltage scaling. In [ 2.16], the author argues that DVFS is not the only solution for",
        "36b6749c-0fe6-406c-af01-ae62b2aa4828": "9 \n processor power management in DC workloads. They propose the use of Per -Core Power Gat -\ning (PCPG) for multi -core processors that allows the ability to cut the power suppl y to selected \ncore, allowing zero power leakage to the gated cores. A technique to control the workload \nexecution on the processor and the power consumption, given some constrained on the \ntemperature of the chip, is proposed in [ 2.17]. In [ 2.18], the autho rs proposed a method to adjust \nthe speed of multi -core processors to maximize the processing with a given set of thermal \nconstraints. They proposed two methods: (a) primal -dual interior -point and (b) dual \ndecomposition, to achieve the desired level of perf ormance under specified thermal constraints. \nA model -based system, Zephyr, is proposed in [ 2.19] that combine conventional server power \noptimization and fan power optimization to optimize overall energy efficiency. The set of blade \nservers share the coolin g capacity of the set of fans, which are controlled by the Multi -Input \nMulti -Output (MIMO) controller to optimize the aggregate fan power. All of the aforementioned \napproaches are thermally oblivious, which means that job scheduling and processing decision s \nare not aware of the heating effect in DC that may cause thermal imbalance and hotspots. \nDifferent authors have proposed different thermal aware strategies. Moore et al. [ 2.20] proposed \na temperature aware workload placement approach in DC. The aforesaid  approach is based on \nthermodynamics formulation, power, and thermal profiles of the servers. However, precise \nmeasurement of the profiles for such a large number and types of jobs is complicated. Moreover, \nthe thermal and power models are not accurate for  DC, as discussed in [ 2.21]. In another \napproach [ 2.22], modeling a thermal topology of DC is discussed that can lead to more efficient \nworkload placement. However, preserving the safe temperature and migration of the resources \nare not discussed. A DC envi ronmental control system is proposed in [ 2.23] that use a distributed \nsensors network to manipulate CRAC units. The control strategy proposed is concentrated to",
        "3dbb81f3-5a26-47de-b692-7ed47d4b6553": "10 \n enforce the thermal constraints of cyber infrastructure, while minimizing the heat dissipated b y \nthe CRAC unit. The discussion in [ 2.23] in concentrated only on the CRAC and did not \nconsidered the servers. There are other studies, such as [ 2.24-2.27] that proposed thermal \nmanagement strategies at a DC level. In [ 2.28], the authors have modeled DC as  a CPS and \nproposed a control strategy to optimizes the tradeoff between the quality of computational and \nenergy cost. However, the heat recirculation and its effect on the other neighboring nodes are not \ndiscussed.  \n2.3. Formal Verifications of Routing Pro tocols  \n  A formal verification of ad -hoc routing protocols using SPIN model checker is \nperformed in [ 2.29]. The authors of [ 2.29] used Wireless Adaptive Routing Protocol (WARP) to \nformally verify the real time aspects of the protocol. In [ 2.30], the author s studied different \nimplementations of Ad -hoc On -demand Distance Vector (AODV) routing protocol. Moreover, to \nchecks C and C++ implementations directly, the authors used their own model checker. A \ntopology approximation algorithm is proposed in [ 2.31], to tackle the problem of mobility by \nmodeling AODV using colored petri nets. In the paper [ 2.32], the authors performed \nspecification and verification of LambdaRAM, which is a wide area distributed cache for high \nperformance computing. The authors in [ 2.32] used TLV for model checking, which uses SMV \nas an input language. Xiong et al.  [2.31] have modeled AODV using colored Petri nets (CPN). \nSome other work towards the verification of routing protocols can be found in [ 2.33]-[2.35]. \n2.4. Thermal -Aware Resource Allocation  \nThe cost of IT equipment or hardware is no longer the major portion of the overall cost \ninvolves in DCs. Alternatively, the cost of power and cooling infrastructure has crept in to be the",
        "a174ee60-1bb0-47f7-9883-b5afde52c463": "11 \n primary cost driver. Uneven thermal signatures and hotspo ts within a DC can lead to hardware \nfailures and energy wastage by the Air Conditioning (AC) units. Moreover, the presence of the \nhotspots creates a risk of redlining servers that can cause premature failure. The power \nconsumption and thermal properties of  the devices are directly proportional. Therefore, in this \nsection we will discuss both the power and thermal strategies.  \nThe topic of energy efficient data centers is addressed by huge number of research \ncommunities. The energy efficiency can be achieved in a data center from many dimensions, \nsuch as from physical infrastructure perspective and from computational perspective. The \naforesaid dimensions are further explored by many researchers to propose new energy efficient \nstrategies. The energy efficiency techniques can be applied to a DC without much overhead and \ncan be broadly categorize as: (a) Dynamic Voltage/Frequency Scaling (DVFS), (b) hot and cold \naisle, (c) Dynamic Power Management (DPM), (d) resource allocation, and (e) virtualization \n[2.36].  \nAs stated above, the power consumption of the servers can be tuned through hardware \ninterfaces, such as DVFS and on -off state control [2 .12-2.14]. An integer linear programming \nmodeling approach is proposed in [2 .37] that aim to meet the real -time deadlines, while \nminimizing the hotspots and spatial temperature differences through task scheduling [ 2.38]. The \npreceding technique is designed to react when the thermal threshold is approached, instead of \navoiding it at a first place. A proactive solution is presen ted in [ 2.39] that distribute the workload \nbetween cores in a thermally sensitive manner to avoid the temperature to reach the redline \nvalue. To predict the temperature, the authors in [ 2.39] proposed a band -limited predictor that is \nbased on a band limite d property of the temperature frequency spectrum. However, in case of \nmispredictions, the overheads associated with the aforesaid solution are significantly high, as",
        "b18fe989-ea40-4d88-a7db-daddb600000f": "12 \n advocated in [ 2.40]. A scheduling policy is proposed in [ 2.41] that allocate memory bound tasks \nto slower frequency processors based on the intensity of memory and current temperature of the \nprocessor. Similarly, there are other approaches, such as in [ 2.42] and [ 2.43] that attempts to \ninsert additional cycles into the task scheduling process t o reduce the thermal signatures of the \nsystems. However, the aforesaid strategies are considered inefficient under many scenarios, \nwhere the slack is unavailable between the deadlines. Moreover, the performance is also \ndegraded when the aforesaid approache s are employed, as discussed in [ 2.40]. \nTo perform the dynamic voltage scaling a control -theoretic approach to the DVFS is \nproposed in [ 2.15], where the authors modified the classical control system algorithm, the \nProportional Integral Derivative (PID) con troller. In [ 2.16], the author argues that DVFS is not \nthe only solution for processor power management in data center workloads. The authors in \n[2.16] propose the use of Per -Core Power Gating (PCPG) for multi -core processors that allows \nthe ability to cut  the power supply to the selected core, allowing zero power leakage to the gated \ncores. All of the aforesaid techniques provide a promising control over power management. \nHowever, the said techniques can lead to significant negative impact on power managem ent as \nswitching on and off involves overheads [ 2.44]. Moreover, the approaches are thermally \noblivious, where the job scheduling and processing decisions does not account the heating effect \nin data centers that may cause thermal imbalance and hotspots.  \nA thermal aware scheduling approach, named as XInt, is proposed in [ 2.45] that \nminimizes the inlet temperatures, and leads to minimal heat recirculation and cooling cost for \ndata center operation. A similar scheduling strategy is also proposed in [ 2.22] to m inimize the \nheat recirculation. However, the aforesaid strategies did not consider the effect of scheduling on \nthe server cooling cost [ 2.46]. Another approach is proposed in [ 2.22] that create a thermal",
        "ab2528fa-d651-4370-8861-b5dee6c298c1": "13 \n topology of the DC to achieve efficient workload pla cement. However, no discussion is available \nrelated to keep the server thermal signatures under the redline values. There are other studies, \nsuch as [ 2.23-2.27] that proposed thermal management strategies using different approaches at a \nDC level. However, all of the aforesaid studies have not discussed the thermal effect of job \nallocation on a server and the raise in the temperature on other related servers as a result of \nambient effect. In this paper, we analyze a real workload of a DC, using statistical t echniques, to \nobserve the thermal impact of job allocation on the selected server and ambient effect on other \nservers. Moreover, we used the results and findings from the workload analysis, to propose a \nscheduling scheme that attempts to maintain thermal u niformity within a DC.  \n2.5. Data Security over the Cloud  \nJuels et al.  [2.47] presented a technique to secure the cloud data that provides a number \nof services, such as integrity, freshness, and availability. The authors employed a gateway \napplication in th e enterprise to manage the integrity and freshness checks for the data. The Iris \nfile system is designed to migrate organizations internal file system to the cloud. Moreover, a \nMerkle tree is used by gateway, which ensures freshness and integrity of data b y inserting file \nblocks, MAC codes, and file version numbers at different levels of the tree. The gateway \napplication also manages the cryptographic keys for confidentiality requirements. Moreover, \nRef. [2.47] proposed an auditing framework that audits the  cloud environment for ensuring the \nfreshness of the data, data retrievability, and resilience against disk failures. However, the \ntechnique heavily depends on the user\u2019s employed scheme for data confidentiality. Moreover, \ndata cannot be protected against service provider wholesale.  \nIn [2.48], the authors presented a cryptographic file system that provides confidentiality \nand integrity services to the outsourced data. The authors used hash based MAC tree for",
        "eb101985-ae38-4d73-a2b2-75b209e27011": "14 \n providing the aforesaid services. Block -wise enc ryption is used for the construction of a MAC \ntree. The file system at the client side interacts with the file system of the server and outsources \nthe encrypted blocks. Encrypted file blocks and cryptographic metadata are stored separately. \nNevertheless, t he presence of cryptographic metadata on the storage side can be a potential \nthreat.  \nThe authors in [2.49] proposed a virtual private crypto -graphic storage service to provide \nconfidentiality and integrity to user data within the cloud. The client applica tion in the proposed \nmethod has three modules: (a) data processor, (b) data verifier, and (c) token generator. The \nclient application generates a master key to be used for subsequent operations. The data \nprocessor encrypts the file to be uploaded with keys  generated from the master key and uploads \nto the cloud. The data download involves the use of token generator that generates a token for the \nuser to download data. Token also contains identity of files to be downloaded. The data verifier \nchecks for the in tegrity of the data once the data is downloaded from the cloud. Attribute Based \nEncryption (ABE) is used for encryption. However, the key in [2.49] resides at client side and \nmay be subject to a single point of failure.  \nA cloud storage system based on sec ure erasure code is presented in [2.50]. The system \nuses threshold key servers for storing a user\u2019s key generated by a system manager. User encrypts \nthe data divided into blocks and stores every block on randomly selected multiple servers. The \nsystem also provides the functionality of data forwarding by allowing any of the users to forward \nthe data to any other users without downloading. The authors used proxy re -encryption method \nfor forwarding the encrypted data. A similar scheme is presented by the same authors in [2.51] \nwith the difference that the later does not provide data forwarding. However, aforesaid schemes \nrequire heavy implementation level changes on the cloud side.",
        "0092da30-77b1-4643-bc1a-44d7369f7f9e": "15 \n  \n2.6. References  \n[2.1]  E. Keller, J. Szefer, J. Rexford, and R. B. Lee, \u201cNoHype:  virtualized cloud infrastructure \nwithout the virtualization,\u201d 37th ACM ISCA, pp. 350 \u2013361, June 2010.  \n[2.2]  P. Campegiani, F. L. Presti, \u201cA general model for virtual machines resources allocation in \nmulti -tier distributed systems,\u201d International Conference  on Autonomic and Autonomous \nSystems, pp. 162 -167, 2009.  \n[2.3]  F. Zhang, J. Chen, H. Chen, and B. Zang, \u201cCloudVisor: Retrofitting protection of virtual \nmachines in multi -tenant cloud with nested virt ualization,\u201d ACM SOSP, Cascais,  Oct. 2011.  \n[2.4] Z. Wang and X. Jiang, \u201cHyperSafe: A lightweight approach to provide lifetime \nhypervisor control -flow integrity,\u201d Symposium on Security and Privacy , pp. 380 -395, 2010.  \n[2.5]  F. Sabahi,  \u201cSecure Virtualization for Cloud Environment Using Hyperviso r-based \nTechnology\u201d,  Journal of Machine Learning and Compu ting, vol. 2, no. 1, pp. 39 -45. \n[2.6]  J. Xu, M. Zhao, J. Fortes, R. Carpenter, M. Yousif, \u201cAutonomic resource management in \nvirtualized data centers using fuzzy logic -based approaches,\u201d Journal of Cluster Computing, vol. \n11, pp. 213 \u2013227, 2008.  \n[2.7]  D. Cerbelaud, S. Garg, and J. Huylebroeck, \u201cOpening the clouds: qualitative overview of \nthe state -of-the-art open source vm -based cloud management platforms,\u201d 10th ACM/IFIP \nIntern ational Conference on Middleware, pp. 1 \u20138, 2009.  \n[2.8]  P. T. Endo, G. E. Gon\u00e7alves, J. Kelner, and D. Sadok, \u201cA Survey on Open -source Cloud \nComputing Solutions,\u201d 8th Workshop on Cloud and Grid Applications, pp. 3 -16, 2010.  \n[2.9]  B. Sotomayor, R. S. Montero , I. M. Llorente, I. Foster, \u201cVirtual Infrastructure \nManagement in Private and Hybrid Clouds,\u201d Internet Computing, vol. 13, no. 5, Oct. 2009.",
        "82546e4c-740f-4096-8715-cc81c5983a55": "16 \n [2.10]  N. Khan, A. Noraziah, E. I. Ismail, and M. M. Deris, \u201cCloud Computing: Analysis of \nVarious  Platforms,\u201d Journal of Entrepreneurship and Innovation, vol. 3, no. 2, pp. 51 -59, 2012.  \n[2.11]  Y. Li, and O. Boucelma, \u201cA CPN Provenance Model of Workflow: Towards Diagnosis in \nthe Cloud,\u201d Conference on Advances in Databases and Information Systems, pp. 5 5\u201364, 2011.  \n[2.12]   Y. Cho and N. Chang, \u201cEnergy -aware clock -frequency assignment in microprocessors \nand memory devices for dynamic voltage scaling,\u201d IEEE Transactions on Computer -Aided \nDesign of Integrated Circuits and Systems, vol. 26, no. 6, 2007, pp. 1 030\u20131040.  \n[2.13]   H. Aydin and D. Zhu, \u201cReliability -aware energy management for periodic real -time \ntasks,\u201d IEEE Transactions on Computers, vol. 58, no. 10, 2009, pp. 1382 \u20131397.  \n[2.14]   P. Choudhary and D. Marculescu, \u201cPower management of voltage/frequency island -\nbased systems using hardware -based methods,\u201d IEEE Transactions on VLSI Systems, vol. 17, \nno. 3, 2009.  \n[2.15]   A. Varma, B. Ganesh, M. Sen, S. Choudhury, L. Srinivasan, and B. Jacob, \u201cA control -\ntheoretic approach to dynamic voltage scheduling,\u201d Inter national CCASE, pp. 255 \u2013266. \n[2.16]   J. Leverich, M. Monchiero, V. Talwar, P. Ranganathan, and C. Kozyrakis, \u201cPower \nmanagement of datacenter workloads using per -core power gating,\u201d Computer Architecture \nLetters, 2009, vol. 8, no. 2, pp. 48 \u201351. \n[2.17]   Z. Jian -Hui and Y. Chun -Xin, \u201cDesign and simulation of the cpu fan and heat sinks,\u201d \nIEEE Transactions on Components and Packaging Technologies, vol. 31, no. 4, pp. 890 \u2013903. \n[2.18]   A. Mutapcic, S. Boyd, S. Murali, D. Atienza, G. Micheli, and R . Gupta, \u201cProcessor \nspeed control with thermal constraints,\u201d IEEE Transactions on Circuits and Systems,  vol. 56, no. \n9, pp. 1994 \u20132008.",
        "ac2ee865-f4f4-4af3-8aa3-f5af26f374b2": "17 \n [2.19]   N. Tolia, Z. Wang, P. Ranganathan, C. Bash, M. Marwah, and X. Zhu, \u201cUnified power \nand cooling management in serv er enclosures,\u201d in InterPACK, pp. 721 \u2013730, 2009.  \n[2.20]  J. Moore, J. Chase, P. Ranganathan, and R. Sharma, \u201cMaking scheduling \"cool\": \ntemperature -aware workload placement in data centers,\u201d In USENIX, pp. 61 -75, 2005.  \n[2.21]   Q. Tang, S. Gupta, and G. Varsa mopoulos, \u201cEnergy -efficient thermal -aware task \nscheduling for homogeneous high -performance computing data centers: A cyber -physical \napproach,\u201d IEEE Transactions on Parallel and Distributed Systems, vol. 19, no. 11, 2008, pp. \n1458 \u20131472.  \n[2.22]   J. Moore, J.  Chase, and P. Ranganathan, \u201cWeatherman: Automated, online and \npredictive thermal mapping and management for data centers,\u201d IEEE ICAC, pp. 155 -164, 2006.  \n[2.23]   C. Bash, C. Patel, and R. Sharma, \u201cDynamic thermal management of air cooled data \ncenters,\u201d The rmal and Thermomechanical Phenomena in Electronics Systems, pp. 445 \u2013452, \n2006.  \n[2.24]   L. Rao, X. Liu, L. Xie, and W. Liu, \u201cMinimizing electricity cost: Optimization of \ndistributed internet data centers in a multi -electricitymarket environment,\u201d Internatio nal \nConference on Computer Communications (INFOCOM), pp. 1 \u20139, 2010.  \n[2.25]   Q. Tang, S. Gupta, and G. Varsamopoulos, \u201cEnergy -efficient thermal -aware task \nscheduling for homogeneous high -performance computing data centers: A cyber -physical \napproach,\u201d IEEE T ransactions on Parallel and Distributed Systems , vol. 19, no. 11, 2008, pp. \n1458 \u20131472.  \n[2.26]   M. Anderson, M. Buehner, P. Young, D. Hittle, C. Anderson, J. Tu, and D. Hodgson, \n\u201cMIMO robust control for HVAC systems,\u201d IEEE Transactions on Control Systems Te chnology, \nvol. 16, no. 3, 2008, pp. 475 \u2013 483.",
        "c1918b0e-70b1-4f57-90bd-74f2312579f0": "18 \n [2.27]   M. Toulouse, G. Doljac, V. Carey, and C. Bash, \u201cExploration of a potential -flow-based \ncompact model of air -flow transport in data centers,\u201d American Society Of Mechanical \nEngineers ASME Conference, pp. 41\u201350, 2009.  \n[2.28]   L. Parolini, N. Toliaz, B. Sinopoli, and B. H. Krogh, \u201cA Cyber -Physical Systems \napproach to energy management in data centers,\u201d Conference on Cyber -Physical Systems, 2010.  \n[2.29] R. de Renesse and A. Aghvami, \u201cFormal verification of ad -hoc routing protocols using \nSPIN model checker\u201d, 12th IEEE Mediterranean Electro technical Conference , 2004, pp. 1177 \u2013\n1182.  \n[2.30]  D. Engler and M. Musuvathi, \u201cStatic analysis versus software model checking for bug \nfinding\u201d, Verification, Model Checking,  and Abstract Interpretation, 5th International \nConference , Lecture Notes in Computer Science, 2004, pp. 191 \u2013210. \n[2.31]  C. Xiong, T. Murata, and J. Tsai, \u201cModelling and simulation of routing protocol for \nmobile ad hoc networks using coloured Petri nets\u201d,  Workshop on Formal Methods Applied to \nDefence Systems in Formal Methods in Software Engineering and Defence Systems , 2002.  \n[2.32]  V. Vishwanath, L. Zuck, J. Leigh, \u201cSpecification and verification of LambdaRAM \u2013 a \nwide -area distributed cache for high perf ormance computing\u201d 6th IEEE/ACM Conference on \nFormal Methods and Models for Codesign (MEMOCODE) 2008, USA, June 2008.  \n[2.33]  S. Chiyangwa, M. Kwiatkowska, \u201cA timing analysis of AODV\u201d, Formal Methods for \nOpen Object -Based Distributed Systems: 7th IFIP WG 6.1 International Conference \n(FMOODS), (2005).  \n[2.34] D. Obradovic, Formal Analysis of Routing Protocols. PhD Thesis, University of \nPennsylvania (2002).",
        "5c657538-72c9-49bd-be7f-dd0c22c01980": "19 \n [2.35]  S. Das, D. L. Dill, \u201cCounter -example based predicate discovery in predicate abstraction\u201d, \nForma l Methods in Computer -Aided Design, Springer -Verlag , (2002).  \n[2.36]  E. Masanet, R. Brown, A. Shehabi, J. Koomey, and B. Nordman,  \u201cEstimating the energy \nuse and ef\ufb01ciency potential of U.S. data centers,\u201d Proc IEEE,  vol. 99, no. 8, 2011, pp.1440 \u2013\n1453.  \n[2.37]  E. Kursun and C. Y. Cher, \u201cTemperature variation characterization  and thermal \nmanagement of multicore architectures,\u201d IEEE Micro , vol. 29, pp.116 \u2013126, ISSN 0272 -1732.  \n[2.38]  J. X. Yang, \u201cDynamic thermal management through task scheduling,\u201d IEEE Symposium \non Performance, Analysis of Systems and Software , pp. 191 \u2013201, 200 8. \n[2.39]  R. Ayoub and K. Indukuri, \u201cTemperature aware dynamic workload scheduling in \nmultisocket CPU servers,\u201d IEEE Transactions on  \nComputer -Aided Design of Integrated Circuits and Systems , vol. 30, no. 9, pp. 1359 \u20131372, \n2011.  \n[2.40]  A. Lewis and N. F.  Tzeng, Thermal -Aware Scheduling in Multicore Systems Using \nChaotic Attractor Predictors.  \n[2.41]  A. Merkel and J. Stoess, \u201cResource -conscious scheduling for energy efficiency on \nmulticore processors,\u201d International  European conference on Computer systems,  pp. 153 \u2013166. \n2010.  \n[2.42]  J. Choi and C. Y. Cher, \u201cThermal -aware task scheduling at the system software level,\u201d \nACM Symposium on Low Power Electronics and Design , pp. 213 \u2013218, 2007.  \n[2.43]  P. Bailis and V. J. Reddi, \u201cDimentrodon: Processor -level prevent ive thermal management \nvia idle cycle injection,\u201d In Proc. of the 48th  \nDesign Automation Conference (DAC 2011) , June 2011.",
        "d0d3336c-2284-4f01-a7a4-763a3cb430ea": "20 \n [2.44]  M. Annavaram, \u201cA case for guarded power gating for multi -core processors,\u201d In HPCA , \npp. 291 -300, 2011.  \n[2.45]   Q. Tang, S. K.  Gupta, and G. Varsamopoulos, \u201cThermal -aware task scheduling for data \ncenters through minimizing heat recirculation,\u201d IEEE International Conference on Cluster \nComputing, pp. 129 -138.  \n[2.46]  R. Ayoub, S. Sharifi, and T. S. Rosing, \u201cGentlecool: Cooling awa re proactive workload \nscheduling in multi -machine systems,\u201d In Proceedings of the Conference on Design, Automation \nand Test in Europe  pp. 295 -298, 2010.  \n[2.47] A. Juels and A. Opera, \u201cNew approaches to security and availability for cloud data,\u201d \nCommunicati ons of the ACM , Vol. 56, No. 2, 2013, pp. 64 -73. \n[2.48] A. Yun, C. Shi, and Y. Kim, \u201cOn protecting integrity and confidentiality of cryptographic \nfile system for outscored storage,\u201d Proceedings of 2009 ACM workshop on cloud computing \nsecurity CCSA\u201909 , pp. 67-76, 2009.  \n[2.49] S. Kamara and K. Lauter, \u201cCryptographic cloud storage,\u201d Financial Cryptography and \nData Security,  Springer Berlin Heidelberg, 2010, pp. 136 -149.  \n[2.50] H. Lin and W. Tzeng, \u201cA secure erasure code -based cloud storage system with secure  data \nforwarding,\u201d IEEE Transactions on Parallel and Distributed Systems , vol. 23, no. 6, June 2012, \npp. 995 -1003.  \n[2.51] H. Lin and W. Tzeng, \u201cA secure decentralized erasure code for distributed network \nstorage,\u201d IEEE Transactions on Parallel and Distribu ted Systems , vol. 21, no. 11, Nov. 2010, pp. \n1586 -1594.",
        "15acc57a-4960-40ff-a2ce-8e6f12b41038": "21 \n 3. MODELING AND ANALYSIS OF STATE -OF-THE -ART \nVM-BASED CLOUD MANAGEMENT PLATFORMS  \nThis paper is published in IEEE Transactions on Cloud Computing (TCC) , vol. 1, no. 1, \npp. 50 -63, 2013. The authors of t he paper are Saif U. R. Malik, Samee U. Khan, and Sudarshan \nK. Srinivasan.  \n3.1. Introduction  \nThe vibrant underlying technology in cloud infrastructure is virtualization that contributes \ntowards the prevalent application and adaptation of cloud computing i nfrastructure [3.3]. \nVirtualization can be defined as the process of abstracting the original physical structure of \ninnumerable technologies, such as hardware platform, operating system, a storage device, or \nother network resources [3.4]. Moreover, machine s, applications, desktops, networks, and \nservices are also separated from the underlying physical constraints. The cloud takes \nvirtualization to a step further by using VMs that creates the customer independent system \nregardless of the underlying hardware in a timely manner. Every physical machine in a cloud can \nhost several VMs, which from a user\u2019s perspective is equivalent to a fully functional physical \nmachine. Moreover, VMs can be start and stop anytime without any changes to the underlying \nhardware. Fu rthermore, migration of VMs between the physical machines is also possible \nwithout much disruption. Therefore, the cloud service providers deploy services on VMs that \nallow resource provision with more flexibility [3.5, 3.51].    \nThe cloud normally involve s a large number of VM and physical machines that makes \nvirtual infrastructure management a cumbersome task. Several solutions are available to cope \nwith the aforementioned problem, such as VMware VirtualCenter, Platform Orchestration, and",
        "6859c50d-feda-4c4a-b2a1-8f8f00c60f2f": "22 \n Enomalism that p rovides an automatic monitoring and deployment of VMs in resource pools \n[3.6]. Numerous cloud providers, such as Amazon EC2 [3.7], Google App Engine [3.8], and \nScience Clouds [3.9] uses the aforementioned solutions to manage the virtual infrastructure. \nMost of the existing cloud computing management platforms are either proprietary or contains \nsoftware that are not programmable for experimentation purposes. In the said perspective, \nseveral open source VM -based cloud management platforms have been launched, such as \nEucalyptus [3.10], oVirt [3.11], and Enomaly Elastic Compute Platform (ECP) [3.12], so that \nresearchers from every field can participate towards further development of management \nplatforms in the cloud. Recently, OpenStack [3.25] has attained a sig nificant status in the field of \ncloud computing. A number of companies that includes some big names, such as IBM, Dell, \nAMD, and Intel, have joined the OpenStack project.  \nSeveral open source IaaS providers have emerged as a result of recent development in  \nopen source virtualization [3.13]. Two hypervisors: (a) Xen [3.14] and (b) KVM [3.15] are the \nmost widely used open source hypervisors in the recent IaaS providers [3.34]. In this paper, we \nhave studied and analyzed three open source state -of-the-art VM -based cloud management \nplatforms: (a) Eucalyptus, (b) Open Nebula, and (c) Nimbus. The said systems have different \ndesign interests (as advocated in [3.16]) and that is why we have selected these systems for the \nstudy. The differences in the designs make ea ch system suitable for an explicit environment. An \nimportant aspect that influences the choice of selecting a particular system for a private cloud is \nthe level of customization. Amongst all of the aforementioned three cloud platforms, Open \nNebula provides  the highest level of customizability that allow users to switch almost every \ncomponent from the underlying Virtual Machine Monitor (VMM) to the front -end. Both, the end \nuser and the administrator, relishes the available customization. The customization pr ovided by",
        "b2edd364-fc28-487c-ab26-82de0cd98112": "23 \n Open Nebula is suitable in an experimental environment, where one wants to explore every \ncomponent and crack new results from the computational perspective. Besides Open Nebula, \nNimbus also provides a high level of customization. However, the maj or portion of \ncustomization in Nimbus is available to the administrator. Nimbus is more suitable for an \nenvironment, where one is less interested in technical details of the systems, but requires a broad \nlevel of customization, such as cooperative scientif ic communities. Eucalyptus mimics the \nimplementation of Amazon EC2 and is an open source implementation of Amazon Web Service \n(AWS) API. The customization level is Eucalyptus is very low that makes it appropriate for a \nprivate company, where one needs a cl oud for own use and wants to avoid mistakes from the \nusers. The suitability of any of the cloud management platforms depends on the requirements of \nthe user or organizations.  \nNumerous studies are available, such as [3.17], [3.18], [3.19] that discuss and c ompare \nthe aforementioned cloud management platforms but the previous work largely focused on the \narchitecture and feature set of the systems. Another mutual aspect observed amongst the previous \nstudies is the high level of abstraction, while discussing th e architectures of the systems. In this \nstudy, we made an effort to diminish the level of abstraction through detailed modeling and \nformal analysis of the platforms being discussed. We have used High -Level Petri Nets (HLPN) \nand Z language for the modeling and analysis of the systems. HLPN is used to: (a) simulate the \nsystems and (b) provide mathematical representation, to analyze the behavior and structural \nproperties of the system. The model of the systems will help analyze: (a) the interconnection of \nthe components and processes, (b) the fine -grain details of the flow of information amongst the \nprocesses, and (c) how the information is processed. Moreover, we performed the verification of \nthe models in two -fold. First, we performed the automated verificati on of the models by",
        "6b4dcb30-0ab9-4563-be4e-ddc528d7cc80": "24 \n following Bounded Model Checking technique using Satisfiability Modulo Theories Library \n(SMT -Lib) and Z3 solver. To verify using SMT, the petri net models are first translated into \nSMT along with the specified properties. Then, Z3 solve r is used to check either the model \nsatisfies the properties or not. Second, to verify the feasibility of the models as the number of \nVMs scales, we model about hundred instances of VMs for each platform (Eucalyptus, Open \nNebula, and Nimbus) and verify the  correctness. The results generated reveals that the models \nare working correctly. To the best of our knowledge no work has been done to model, analyze, \nand verify the open source cloud management platforms. This research work will provide the \nbasis for th e researchers to understand the design and implementation of the state -of-the-art VM -\nbased cloud platforms. As the inception of the cloud is based on distributed computing (grid and \ncluster) and virtualization, the research is more inclined towards the com puting and storage \naspect of the cloud and another crucial aspect of cloud, the connectivity (networking), is usually \nforgotten [3.13]. This paper will focus on the intercommunication and behavior of the \ncomponents of the systems rather than the computing and performance measurements.  \n3.2. Preliminaries  \nThis section will discuss some of the tools and technologies used in this work that will \nhelp the reader to understand the topic easily.  \n3.2.1 . High -Level Petri Nets (HLPN)  \nPetri nets are graphical and mathe matical modeling tool that is applicable to many \nsystems characterized as being concurrent, asynchronous, distributed, parallel, non -deterministic, \nor stochastic [3.20]. In this paper we have used a variant of classical Petri Net model, namely, \nHigh -Level Petri Nets (HLPN). (Readers are encouraged to see [3.20], [3.21] for an elaborate \nintroduction to Petri Nets.)",
        "1dc0c39f-2d5c-4887-aaca-a04febe5b06a": "25 \n  \nDefinition 1:  HLPN [3.20], a HLPN is a 7 -tuple    (              ) where:  \n \n1. P is a set of finite places.  \n2. T is a set of finite transiti ons such that       . \n3. F is a flow relation such that    (   ) (   ). \n4.   is a mapping function that maps P to data types such that          . \n5. R define rules that maps T to predicate logic formulas such that             . \n6. L is a label that maps F to labels such that          . \n7.    is the initial marking where           . \nThe first three variables (      ) provides information about the structure of the net and \nthe next three variables (      ) provides the static semantics,  which means the information does \nnot change throughout the system.  \nThe use of HLPN is preferred over Low -level Petri Nets (LLPN) because in LLPN: (a) \nno distinction is available between the tokens, no types or just one type, (b) for transition \nenablement there is no selection of specific tokens even using flow capacity, and (c) a place may \nbe viewed as a structural variable, such as array that is not possible to depict.  \nLet   and   be the nodes of the HLPN   iff           . A node   is an input node of \nanother node   iff there is a directed arc from   to   such that (   )    . Node   is an output \nnode of   iff (   )    . For any node         , the pr e-condition is    {  (   )  } and \npost-condition is    {  (   )  }. \nIn HLPN, places can have tokens of different types and can also be a cross product of two \nor more types, such as in Fig. 3. 1 the places are mapped to the types:  (  )     ,  (  ) \n  ,  (  )  (   ),  (  )     .",
        "d45bea6b-8a60-4f10-b10a-4b684772b839": "26 \n The pre -conditions must hold for any transition to be enabled. Moreover, the variables \nfrom the incoming flows are used to enable a certain tra nsition. For example, preconditions for t1 \nwill use x and y from P1 and P2, respectively. Similarly, post -condition uses variables from \noutgoing flows for transition firing, and can be written as:  (  ) (      )   (  \n  )   (      ). \n3.2.2 . SMT -Lib and Z3  Solver  \nSatisfiability Modulo Theories (SMT) is an area of automated deduction for checking the \nsatisfiability of formulas over some theories of interest and has the roots from Boolean \nSatisfiability Solvers (SAT) [3.23]. The difference between SMT and SAT  is that SMT solvers \nchecks the satisfiability of first -order formulas containing operations from several theories, such \nas Bit -vector and arithmetic, whereas SAT solvers checks the satisfiability of propositional \nformulas [3.26]. SMT -Lib provides a common  input platform and benchmarking framework that \nhelps in the evaluation of the systems [3.27]. SMT has been used in many fields including \ndeductive software verification. Moreover, recent applications of computer science including \nplanning, model checking,  and automated test generation finding, also considers SMT as an \nimportant verification tool [3.27]. (Readers are encourage to read [3.28] for the use of SMT -Lib \nP4x\nP3P2\nP1y\nx\nyzz x yt1\nt2t3t4\nTransition\nPlace\nFlowP\nf \nFig. 3. 1. An Example High -Level Petri Net.",
        "6559ad0f-781a-423d-ad6f-5b8f7b028057": "27 \n in the verification of OSPF routing protocol [3.50].) Multiple solvers are available that supp orts \nSMT -LIB, such as Beaver, Boolector, CVC4, MathSAT5, Z3, and OpenSMT. The solver can be \ndistinguished amongst the features they provide, such as, underlying logic (example first order or \ntemporal), background theories, input formulas, and interface [3. 26].  \nWe used Z3 solver in our study, which is a high performance theorem prover developed \nat Microsoft Research. Z3 is an automated satisfiability checker. Moreover, Z3 also checks \nwhether the set of formulas are satisfiable in the built -in theories of SM T-Lib. Readers are \nencouraged to see [3.30], for the detailed information about the working and commands of Z3 \nsolver.  \n3.3. Modeling and Analysis of V M-Based Cloud Management Platforms  \nVM-based cloud management platforms offer several advantages that incl ude: (a) better \nisolation, (b) scalability, (c) availability, and (d) flexibility. Looking at the benefits provided by \nthe VM -based systems to the cloud a renewed interest of research has emerged in different \nclasses of virtualization, such as desktop, ser ver, application, storage, and network from several \nindustry giants, such as VMware, Red Hat, and Microsoft [3.32]. In this section we will discuss, \nmodel, and analyze three VM -based cloud management platforms: (a) Eucalyptus, (b) Open \nNebula, and (c) Nimb us.   \n3.3.1 . Components of Open Source Cloud  \nBefore going into the details and modeling of the systems, in this section, we will provide \na quick overview of the components of the generic open source cloud computing systems. The \ncomponents are classified as : (a) Hardware and Operating Systems (resides on the physical \nmachine and must be setup properly for any software system to work), (b) Network (includes \nDNS, DHCP, and subnet organization of the physical machines), (c) Hypervisor (includes Xen",
        "527bbbb7-194c-4814-9551-4f3842ff6d94": "28 \n and KVM, whi ch provides framework for VMs to run), (d) VM Disk Images (every cloud has a \nrepository of disk images that can be copied and used as a basis for new virtual disks), (e) \nInterface (front -end tools to request VMs and specify parameters), and (f) Cloud Frame work \n(includes Eucalyptus or any other framework). The aforementioned components generally make \nthe entire software stack for the cloud computing systems [3.34]. We used the said components \nin our model to depict the working of the systems.  \n3.3.2 . Eucalyp tus \nEucalyptus is an open source VM -based cloud computing management framework that \nenables users to run and control the instance of virtual machines deployed at several physical \nresources [3.35]. Eucalyptus was first initiated at the University of Califor nia at Santa Barbara \nand is now supported by the Eucalyptus Systems, Inc [3.36]. The emphasis of the system was to \ndevelop an architecture that will allow scientists to experiment cloud related software and \narchitecture. One of the advantages of Eucalyptus  is that it uses Amazon Web Service APIs and \nprovides the same interface as of Amazon\u2019s EC2 and Simple Storage Service (S3) in a private \ncluster. Therefore, provides a well -known tool to host and manage VMs.  \nInstallation of Eucalyptus consists of several components: (a) Cloud Controller (CLC), \n(b) Cluster Controller (CC), (c) Storage Controller (Walrus), and (d) Node Controller (NC). The \narchitecture of Eucalyptus ( Fig. 3. 2) is kept simple, flexible, and hierarchical where every \ncomponent is implemented as  a stand -alone web service. The components implemented as a web \nservices has following benefits [3.35]: (a) exposure to a well -defined WSDL document that \ncontains operations being performed and the input/output data structures and (b) web features \ncan be e xtended, such as security policies to secure the communication between components.",
        "c2ae3762-4677-40a8-9a0c-53ba72091e9d": "29 \n CLC is the entry point to the cloud that provides configuration interface for managing \ncluster and instances , Walrus configuration, and user registration. Main responsibilities of CLC \nincludes: (a) translation of user initiated commands to CC, (b) making high -level scheduling \ndecisions, and (c) management of underlying virtualized resources. CC chose the compute  node \nto provision the VM on receiving the command from the CLC. Moreover, gathering information, \nscheduling VM execution on certain NC, and virtual instance overlay network management for \nsmooth transmission of requests are the responsibilities of CC. Wal rus provides a storage service \nto store virtual machine images and user data.  Execution, termination, and inspection of VM \ninstances are performed by the NC. A query is performed by NC to discover the nodes physical \nresources, such as no. of cores, size o f memory, and state of VM instances.  \n3.3.2.1 . Modeling and Analysis  \nThe model of spawning a VM instance in Eucalyptus configuration is illustrated in Fig. \n3.3. As stated in Definition 1, the HLPN is a 7 -tuple    (              ). To begin \nmode ling the system, we first need to specify   and the associated types. As depicted in Fig. 3. 3, \nthere are 10 \nCluster A\nCC\nPrivate NetworkNCNC\nNCNCCluster B\nCC\nPrivate NetworkNCNC\nNCNCCLC and Walrus\nPublic Network \nFig. 3. 2. Eucalyptus Architecture.",
        "d7850b05-a265-4a95-9d94-fb085a545d12": "30 \nX V_Req LnR\nRR Euca2_conf\nCredCredCred\nCredAuth_F\nAuth_S\nSt_ReqRqV\nS_Req\nReq_FReq_SS_Req\nAd_ConfCo_Pa\nCo_PaCo_PaCo_PaDI\nGet_IR_Get_IpushHpvsr\nReqP_SRVNIC\nRVNIC\nCon_Cret\nPhy_HWPNIC\nPNIC\nDHCP ECCR_MACR_MAC IP_MACIP_MAC\u2019VM-Run\nSTSTCom\nCMCom\nRun_VS\n \nFig. 3. 3. Model of Starting a VM Instance in Eucalyptus.",
        "b6a4e665-3853-4b90-b3aa-4faeae378f2b": "31 \n places in the model. The names and mapping of   are shown in Table 3.1.  The types used in the \nmodel are illustrated in Table 3.2 . The next step is to define the set of rules, pre -conditions, and \npost-conditions to map to   . Before going to the next step let us have a quick overview of the \nprocess of initiating a  VM instance. To make a request for an instance of VM the user first needs \nto configure the front -end. The default front -end is euca2ools, which is similar to the front -end of \nAmazon EC2. To configure euca2ools the user must download some files along with the keys \nand instruction. Once, certain environment variables are set the euca2ools is ready to work. The \nuser then uses euca2ools to request the VM. Moreover, the user has to select a configuration for \nrequired memory, CPU, and the hard drive space from o ne of the five preset configurations set \nby the administrator, for the requested VM.  When the head node receives the request, a VM \ntemplate disk image is extracted from the disk repository and is pushed towards the compute \nnode. The disk image is padded a nd packaged to be used for the hypervisor. Eucalyptus Cloud \nController (ECC) generates a random MAC address and assigns it to VM instance.  \nThe CC setup a static entry of MAC/IP pair and passes it on to NC. The NC maps virtual \nNIC of the instance to the phy sical NIC of the node through network bridging. The instance is \ninitiated on the hypervisor and then the user can directly interact with the VM instance.  \nWe have discussed the process of instantiating the VM and now we can define formulas \n(pre and post -conditions) to map on transitions. The set of transitions \nT= {                                             }. New tokens can enter the model \nonly through       transition. The rule for the token creation can be stated as:   (   )     \n        . The next two transitions are        and       , which authenticate the \nconfiguration of euca2ools front -end. The said transitions are mapped to the formulas ( 3.1) and \n(3.2).",
        "59416f0b-35e8-422d-89d1-3adf127fb557": "32 \n  \nPlace  Mapping  Description  \n  (V_Req)   (Key\u00d7Env_Var\u00d7CPU\u00d7Mem\u00d7  Disk)  Holds environment \nvariables and user  config.  \n (Euca 2_conf)    (Key\u00d7Env_Var)  Pre-set config.  \n  (St_Req)   (CPU\u00d7Mem\u00d7Disk\u00d7Key)  Intermediate place to hold \nthe configuration values  \n  (Ad_Conf)    (CPU\u00d7Mem\u00d7Disk)  Hold admin config.  \n  (DI)   (EMI)  Holds the disk images  \n  (Hpvsr)    (CPU\u00d7Mem\u00d7D isk\u00d7EMI\u00d7 NIC\u00d7VID  \n\u00d7Key\u00d7Env_Var)  Holds user config. and \ncreates virtual NIC and \nVM ID  \n  (DHCP)    (IP \u00d7   MAC)  Holds the mappings of IPs \nto MAC  \n  (ECC)    (MAC)  Generate and hold random \nMAC for VM  \n  (Phy_HW)    (CPU\u00d7Mem\u00d7Disk\u00d7NIC)  Holds physical \nspeceficat ion of the \nsystem  \n  (VM-Run)    (CPU\u00d7Mem\u00d7Disk\u00d7EMI\u00d7NIC\u00d7VID \n\u00d7IP\u00d7MAC\u00d7Key\u00d7Env_Var)  Instance of VM is finally \ncreated alongwith the \nspecified config.  \n \n \nTypes  Description  \nKey A string type for euca 2ools key authentication  \nEnv_Var  A string type for euca2ools  environment variables authentication  \nCPU  An integer type for the number of CPU/core allocated to the VM.  \nMem  A float type for the amount of memory allocated to the VM.  \nDisk A float type for the amount of disk space allocated to the VM.  \nIP A string typ e for the IP address of VM  \nMAC  A string type for the MAC address of the VM  \nNIC A string type for NIC of the physical machine  \nVID An Integer type for VM ID  \n Table 3.1 . Places and Mappings of Eucalyptus . \nTable 3.2. Data T ypes Used in the Model of Eucalyptus.",
        "43378f97-0bef-43b2-a2b7-8fc0bd5c80d5": "33 \n  \n  (      )                 [ ]    [ ]   [ ]    [ ]   \n                                   (3.1) \n  (      )                 [ ]    [ ]   [ ]     [ ]  \n             (3.2) \nThe formula in ( 3.1) depict s the success scenario when the euca2ools is able to find both \nof the credentials (the key and environment variables) in the systems and both are set properly. \nSimilarly, in ( 3.2) if the euca2ools is unable to locate the specific environment variable or if  the \nkey is mismatched, then no further transitions will be fired. After the authentication is \nsuccessfully performed the next step is to check either the configurations provided by the user \nfor the size of memory, disk, and CPU for the requested VM are sa me as the ones set by the \nadministrator.  \n \n  (     )                       [ ]    [ ]   \n    [ ]    [ ]      [ ]    [ ]                             \n  [ ]            [ ]     [ ]    \n     [ ]     [ ]        [ ]     [ ] (3.\n3) \n (     )                     [ ]     [ ]   \n     [ ]    [ ]  [ ]       [ ]     [ ] (3.\n4) \nThe administrator configurations reside in the          and the user configurations are \nplaced in         after the transition        is fired. In ( 3.3) and ( 3.4) both of the configurations \n(user and administrator) are compared. If ( 3.3) is fired, then a disk image from a disk image \nrepository is extracted and is transferred to       along  with the configuration parameters. If \n(3.4) is fired, then no further transition will be fired because of the configurations mismatch.",
        "feb89f0f-a5ff-41d5-8bdc-a369bb449855": "34 \n Mapping is performed in ( 3.5), where a random     from     is generated and \nassigned to the VM. Moreover, physica l     from        and a virtual     from       are \nalso mapped. The relation (mapping) between virtual     and physical     is one -to-many, \nwhich means that many virtual      can be mapped to one physical     . However, the relat ion \nbetween MAC/IP pair and virtual     is one -to-one because only a single virtual     and a \nMAC/IP pair can be assigned to a single instance of VM. After all the mapping is completed, the \ninstance of the VM is created with the specified configurati on parameters placed at        . \nThe user can directly interact with the VM instance after it is created using         . \nThe design of Eucalyptus supports corporate enterprise computing settings where the \nadministration space is separated from the user space.  The users are only allowed to use the \nsystem through web interface or specified front end tools. Eucalyptus is easy to deploy on top of \nthe existing resources. Moreover, Eucalyptus is suitable for experimentation because of having \nmodular desi gn and open source in nature.  \n (        )   {      [ ]                            [ ]        \n(     [ ])   [ ] }     [ ]            [ ]    [ ]  \n                   { (   [ ]     ) }                  {  }  \n           { (   [ ]    [ ]    [ ]    [ ]  \n  [ ]    [ ]    [ ]    [   ]    [   ]     ) } (3.5) \n3.3.3 . Open Nebula  \nOpen Nebula was a research project that started in a year 2005 as a management tool for \nthe orchestration and configuratio n of VMs in datacenter [3.38], [3.39]. Open Nebula is now \navailable as an open source and can be used as a toolkit to build private, public, and hybrid \nclouds. The key technical aspect of Open Nebula is its architecture that provides a great level of",
        "71cc8d7e-caa3-46c8-b66f-c662527052d2": "35 \n custo mization and centralization. Moreover, the architecture also supports multiple storage back \nends and different hypervisors, such as Xen, VMware, and KVM [3.39]. Shared file system is \nadopted in Open Nebula for storing all functional and disk images files. The aforementioned \nexposes the underlying features of libvirt to administrators and users that involves operations, \nsuch as VM live migrations. The centralization makes administration of Open Nebula easier. \nHowever, one drawback of the default customizatio n with NFS file system is that large amount \nof space is required to hold all the files.  \nThe architecture of Open Nebula ( Fig. 3. 4) is divided into three layers: (a) Tools, (b) \nCore, an d (c) Drivers. The first layer contains management tools that can be developed using the \nOpen Nebula core interfaces, such as Command Line Interface, new Open Nebula cloud API, or \nthird party tools that can be created easily using the XML -RPC interface [3. 38]. The Open \nNebula core performs orchestration and configuration of other components. Moreover, the core \nalso has a set of components that are used to control and monitor VM, virtual networks, hosts, \nOpen Nebula CoreTools\nlibvirt API Interfaces Other Tools\n3rd party tools\nDrivers\nVirtualization Storgae Network Cloud\n \nFig. 3. 4. The Architecture of Open Nebula.",
        "e5455c4e-aa53-4e79-9aa3-040fd6cb6e89": "36 \n and storage. The drivers are pluggable modules that pr ovide a layer of abstraction over the lower \nlevel operations, such as virtualization hypervisor, cloud services, and file transfer mechanism. \nMoreover, the drivers are used by the core layer to perform certain actions, such as cancelling a \nVM. \n3.3.3.1 . Mode ling and Analysis  \nThe model for initializing the VM using typical Open Nebula configuration is \ndemonstrated in Fig. 3. 5. The first step towards modeling the system is to identify the required \ntypes,  , and mapping. The types and the descriptions are shown in Table 3.3  and the mapping of \n  to types is depicted in Table 3.4.",
        "32a813c6-af74-489a-bad6-d72373c3d5dc": "37 \nReq_Acc A_Req\nRACRRON_Interface\nCredCred\nCred\nCredA_F\nA_S\nUser AccountsReq_VMS\nUA\u2019Pa_S\nUAAd_Conf\nP\u2019Lg\nCo_PaCo_Pa\nDIGet_I\nGet_I\nP\nHpvsrDep_SS\nReq_Conf\nPhy_HWPNICdeploy\nNFSdPa\nPNICReq_ConfPaOneD\ndeployCo_Pa\nPa_F\nDHCP VMS_VS_VIP IPRMLRLnR\nLRLLogReq_VMF\nLRLR\nRA\nRA\nRA\nRACNode\nSHcSHcSSHc\nSHcDep_F\nPa\nPa\n \nFig. 3. 5. Open Nebula Model for Instantiating a VM.",
        "f85879e7-4c0f-400c-b363-05465b8773e1": "38 \n  \n \nTo use an Open Nebula cloud the user needs to have an account that Open Nebula \nprovides on demand.  After a successful sign up, t he user can login with any one of the interface \nbeing used, such as sunstone, OCCI, and EC2. The user can request a VM using a command \nonevm , which allow user to manage VMs, such as allocate, deploy, suspend, and shutdown. The \nNFS directory at the head nod e holds all the functional and disk image files. As a result of \nonevm , the VM template disk image file is copied from the disk image repository, padded to the \nrequired size and configuration, and is saved to the NFS directory.  \nAt that point, the Open Nebu la Daemon (oned), which is responsible for the control of \nVM life -cycle and to coordinate the operations of all modules, logs into the compute node. The \ncompute node provides a virtual NIC, MAC, and mapped it to physical NIC through network \nbridging. Final ly, the instance is created with the specified configurations at the hypervisor. In Types  Description  \nEmail  A string type for email authentication.  \nPass  A string type for password authentication.  \nUName  A string type for password authentication.  \nCPU  An integer type for the number of CPU/core allocated to the VM.  \nMem  A float type for the amount of memory allocated to the VM.  \nDisk A float type for the amount of disk space allocated to the VM.  \nNMI Type for the machine image.  \nSSH_Cert  A string type for the SSH login  \nSSH_Pass  String type for the SSH encrypted password.  \nIP A string type for the IP address of VM  \nMAC  A string typ e for MAC address of the VM  \nNIC A string type for NIC of the physical machine  \nVID An integer type for Virtual Machine ID  Table 3.3. Data Types Used in the Model of Open Nebula.",
        "636b9a74-0f60-4e77-b009-95f775f37449": "39 \n the previous paragraph we have provided a short overview for the process of instantiating the \nVM in a typical Open Nebula configuration. Now, we can define formulas (pre an d post -\nconditions) to map on transitions. The set of transitions \n  {                                                     }. \n \n \nPlaces  Mappings  Descriptions  \n  (     )   (Email \u00d7Pass)  Holds user requests  \n  (            )   (Email \u00d7Pass)  Holds existing users  \n  (   )   (Pass \u00d7UName \u00d7 \nCPU \u00d7Mem \u00d7Disk)  Holds user login and config.  \n  (             )   (Pass \u00d7UName)  Holds user accounts  \n  (     )   (Cert \u00d7SSH_Pass ) Holds login information for oned  \n  (  )   (NMI)  Holds the disk images  \n  (    )  (CPU \u00d7Mem \u00d7Disk \n\u00d7NMI\u00d7UName)  Holds username and user config.  \n  (    )   (Cert \u00d7SSH_Pass ) Holds oned login detail  \n  (       )   (CPU \u00d7Mem \u00d7Disk)  Holds admin config.  \n  (     )   (CPU \u00d7Mem \u00d7Disk\u00d7NMI\u00d7 \nNIC\u00d7VID\u00d7MAC)  Hold config., creates virtual NIC,  \nMAC, and VM ID  \n  (    )   (IP) Creates IP for the VM  \n  (      )   (CPU \u00d7Mem \u00d7Disk\u00d7NIC)  Holds physical specification of the \nsystem  \n  (  )  (CPU \u00d7Mem \u00d7Disk\u00d7NMI\u00d7NI\nC\u00d7VID\u00d7UName \u00d7IP) VM instance is created alongwith \nthe specified config.  \n  Table 3.4. Places Used in the Model of Open Nebula.",
        "17e3102d-077d-4510-8423-5fb68ec153cb": "40 \n New token s can only be produced by transition     and    . As seen in Fig. 3. 5, no arc \nis incident on any of the two aforementioned transitions, which is why no pre -condition exists \nand the rules for the transitions can be written as:  (   )              and  (   ) \n                The first step perform by the user is to request an account for an Open \nNebula cloud. The transitions     and     authenticate if the requested user already holds an \naccount or not. The transitions are mapped to t he following formulas:  \n (   )                   [ ]    [ ]   \n           {( [ ]  [ ])} (3.\n6) \n (   )                     [ ]    [ ]  \n             (3.\n7) \nThe accounts are created based on the email ID. If the email ID is already associated to \nan account, then the request is denied. Otherwise, the account is created and the new information \nis stored in the               . The success and failure scenario is depicted in (3.6) and (3.7), \nrespectively. The nex t step is to login to the Open Nebula cloud and request for the VM.  \n (       )           [ ]   [ ]    [ ]   [ ]   \n             [ ]     [ ]    [ ]   [ ]   [ ]   [ ]  \n  [ ]    [ ]                  [   ]     \n        { (  [ ]   [ ]   [ ]   [ ]   [ ]) } (3.8) \n (       )           [ ]    [ ]     [ ]    [ ]   \n         (3.9) \nThe user account information is stored in               . When the user logs in and \nrequest for a VM, the login credentials are match and then the command is forwarded, as shown \nin (3.8) and (3.9). If (3.8) is fired, then the disk image is copied from the disk image repository,",
        "dae3ec23-3567-4814-b8ed-d1bf86106360": "41 \n padded to correct size and configuration, and is stored in      . Moreov er, oned  will login to the \ncompute node only when (3.8) is fired. If (3.9) is fired, then the request for the VM is denied and \nno further transitions will be fired.  \nTo spawn a VM user provides a configuration file with parameters to be fed into the \nhypervi sor command line. The aforementioned allow users to request for any configuration of \nmemory, disk, and CPU. Therefore, we have performed the authentication of configuration \nparameters in (3.10) and (3.11) when the hypervisor is generating virtual NIC and M AC. In \n(3.10), if the configurations provided by the user are same as set by the administrator, then the \ncontrol is transferred back to       . Otherwise, (3.11) is fired and the system is terminated.  \n (    )               [  ]     [ ]   \n   [ ]    [ ]    [ ]    [ ] (3.10) \n (    )                  [ ]    [ ]   \n  [   ]     [ ]     [ ]     [ ] (3.11) \nThe      process  uses Secure Shell (SSH), which is an encrypted network protocol to \nsecurely send management  functions, to login to the compute node using SSH certificate and \npassword. If (3.12) is fired, then the virtual NIC and MAC from       and physical NIC \nfrom        are mapped using network bridging. The relation between virtual MAC and NIC \nis on e-to-one. The relation between the pair of MAC/NIC and physical NIC is many -to-one, \nwhich means one physical NIC can be mapped to many. Once the mapping is completed an IP \nfrom      is assigned to the VM and the instance is ready to use. If (3.13) is f ired, then the \nmodel exits because the SSH certificate or the password provided is incorrect.  \n (     )              [ ]  [ ]  \n  [ ]  [ ]                           (3.12)",
        "23581e52-f01d-4c23-ae0f-cd4e6f479c8b": "42 \n  [ ]   [ ]  [ ]   [ ]  [ ]    [ ]  [ ]     [ ]     \n{  [ ]            [ ]              [ ]        \n(  [ ]  [ ])   [ ] }   \n{            [ ]         [ ] } \n                   { ( [ ]  [ ]  [ ]  [ ]  [ ]  [ ]  [ ]) } \n           { ( [ ]  [ ]  [ ]  [ ]  [ ]  [ ]   [ ]) } \n (     )                  [ ]   [ ]  \n   [ ]    [ ] (3.13) \nThe level of customization available is Open Nebula is suitable for researchers who wish \nto combine cloud systems with other technolo gies. However, to utilize the underlying benefits of \nthe customization the user needs to have some technical expertise. Another downside of the \ncustomization is that user can make a mistake while providing configuration for a VM. The \ncentralized nature of Open Nebula makes administration easier. Moreover, higher level of \ncustomization makes Open Nebula ideal for research community.  \n3.3.4 . Nimbus  \nNimbus is an open source solution that allows clients to lease resources by deploying VM \nand providing an environ ment suitable for the user [3.40]. Nimbus is also affiliated with the \nGlobus Project [3.41] and uses Globus credential for user authentication. Nimbus also provides a \nhigh level of customization just like Open Nebula. However, the only difference is that m uch of \nthe customization in Nimbus is restricted to the administrator. Moreover, several components, \nsuch as image repository and credentials for user authentication, are kept constant. Furthermore, \nNimbus also provides an extensible implementation that su pports Web Service Resource \nFramework (WSRF), Amazon EC2, and other end user services to make a cloud easy to use. A",
        "277df7de-3659-46a5-9deb-d8c3688f3de9": "43 \n storage cloud implementation called Cumulus, which is compatible with Amazon Web Service \nS3 REST API, is included in the Nimbus and is tigh tly with other central services.  \nA toolkit is offered to deploy applications on Nimbus that consists of manager service \nhosting and image repository [3.42]. The components of Nimbus worksp ace is shown in Fig. 3. 6. \nThe Workspace Service  is a standalone VM manager that can be invoked by remote protocol \nfrontends. Currently, Nimbus supports two frontends: (a) EC2 and (b) WSRF. The storage \nservice (Cumulus) is also embedded in a Workspace servi ce and can also be installed separately. \nThe Workspace Resource Manager  deploys and manages workspace nodes. The  Workspace Pilot \nallows the integration of preconfigured resources to VMs. Moreover, the aforementioned \ncomponent also handles signals and has a dministration tools. The  Workspace Control  is \nresponsible for the management and control of VM instances, disk images, VM integration to a \nnetwork, and assigning MAC and IP addresses. The Workspace Client provides access to the \nentire feature set of WSRF a s a command line client. The aim of Cloud Client  is to speed up the \nprocess of running a VM using instance launches or one -click clusters. The clients can launch \nWorkspace Service\nWorkspace \nResource ManagerWorkspace \nPilotWorkspace \nClientCloud Client\nContext \nBroker\nContext \nClientWorkspace \nControl \nFig. 3. 6. Nimbus Workspace Components.",
        "bd096d56-cceb-4ee8-a931-2aca4acd56fd": "44 \n large virtual cluster automatically with the use of the Context Broker . The Context Client \ninteracts with Context Broker at VM startup and lives on VM.  \n3.3.4.1 . Modeling and Analysis  \nThe model for starting a VM in a typical Nimbus configuration is demonstrated in Fig. \n3.7. The first step is to identify the required   and associated types. Table 3.5 depicts the types \nused in the model and Table 3.6 explains the    and mappings.  \nThe Nimbus uses client known as Cloud Client to interact with the services over multiple \nprotocols. The users first need to download the client and configure it. The use of C loud Clients \nmakes life easy for the users. The easiest client to use is Cloud Client that makes the users up and \nrunning in a quick time. The user uses cloud clients to request a VM using explicit credentials. \nWhen the head node receives the request, then  the VM template disk image is extracted from the \nrepository and pushed to the compute node. The compute node performs the necessary padding \nand configuration to the image. Virtual MAC and NIC are provided by the compute node using \nNetwork bridging. Moreov er, the physical NIC and virtual NIC of the VM are also mapped. In \nNimbus, every compute node has a DHCP server. The MAC/IP pair is placed in the DHCP \nserver and the VM is ready to be used. The set    {                               }.",
        "3fc4d3cc-4c99-48c6-ad60-fb44295fedb1": "45 \nR Log_Req\nLnRLRLR Cl_ClientCredCredCred\nCredAcF\nAcS\nHpvsr PRI\nAC\nACCon\nDe\nDeRNRI\nNimDReq\nCo_NodeReq\nSH\nSH\nReqSH_SSH_F\nReqReq\nReqReq\nReq\nR\nGI\nGIDI\nAd_CoR\nACACPhy_HWDHCP\nRN\nCF CSVM\nSPSP\nSc\n \nFig. 3. 7. A Model for Nimbus.",
        "00f7f5bc-a977-4fe3-8e73-e782f8c52371": "46 \n  \nTypes  Description  \nUCert  A string type for cloud client authentication.  \nUKey  A string type for cloud client authentication.  \nCPU  An integer type for the number of CPU/core allocated to the  VM. \nMem  A float type for the amount of memory allocated to the VM.  \nDisk A float type for the amount of disk space allocated to the VM.  \nIP A string type for the IP address of VM  \nMAC  A string type for the MAC address of the VM  \nNIC A string type for NIC  of the virtual/physical machine  \nVID An Integer type for Virtual Machine ID  \nSSH_Cert  A string type for the login authentication of SSH Certificate.  \nSSH_Pass  A string type for the login authentication of SSH encrypted password.  \n \nThe seed point of the mo del from where new tokens are generated is through a transition \n    and the rule for the transition can be stated as:  (   )             . The \ntransitions      and     authenticate the credentials of the cloud client. The said transitions ar e \nmapped to the following rules:  \n (   )                   [ ]    [ ]    [ ]     [ ]  \n             (3.14) \n (   )                  [ ]    [ ]   \n  [ ]     [ ]  \n             (3.15) \n \n \n Table 3.5. Data Types Used in the Model of Nimbus .",
        "3c415cc7-5a51-474f-8153-99997ee09d9e": "47 \n  \nPlaces  Mappings  Descriptions  \n  (       )   (UCert\u00d7UKey\u00d7CPU\u00d7Mem\u00d7\nDisk)  Holds user credentials and config.  \n  (         )   (UCert\u00d7UKey)  Existing user details  \n  (    )  (UCert\u00d7SSH_Cert\u00d7SSH_Pass\n\u00d7CPU\u00d7  Mem\u00d7Disk)  Holds SSH login details and user config  \n  (       )  (UCert\u00d7SSH_Cert\u00d7SSH_Pass\n\u00d7CPU\u00d7 Mem\u00d7Disk)  Holds user and SSH login details and \nspecified config.  \n  (  )   (EMI)  Holds the disk images  \n  (       )  (CPU\u00d7Mem\u00d7Disk)  Holds admin configurations  \n  (     )   (UCert\u00d7CPU\u00d7Mem\u00d7Disk\u00d7  \nEMI\u00d7NIC\u00d7MAC\u00d7VID)  Hold configurations, creates virtual NIC, \nMAC, and VM ID  \n  (    )   (IP\u00d7MAC)  Hold maps of IPs to MAC  \n  (      )   (CPU\u00d7Mem\u00d7Disk \u00d7NIC)  Holds physical specefication of the \nsystem  \n  (  )  (UCert\u00d7 CPU \u00d7Mem \u00d7Disk\u00d7 \nEMI\u00d7NIC\u00d7MAC \u00d7VID\u00d7IP) VM instance is created alongwith the \nspecified config.  \n \nThe formula in ( 3.14) represents a success scenario when the cloud client successfully \nlocates both of the credentials (user certificate and user key) and both are configured. In ( 3.15), if \nthe cre dentials are mismatched, then no further transitions will be fired and the system will \nterminate. SSH protocol is used by      to login to         . The          and \n         are confirmed using rules as stated in ( 3.16) and ( 3.17). \n (    )                  [ ]    [ ]    [ ]    [ ]  \n             { (  [ ]   [ ]   [ ]   [ ]   [ ]   [ ]) } (3.16) \n (    )                 [ ]    [ ]     [ ]     [ ] (3.17) Table 3.6. Places Used i n the Model of Nimbu s.",
        "b75bf15b-91c5-4574-9ea0-e18a60da80ce": "48 \n            \nAt that point the configurations for memory, disk, and CPU provided by the user are \nmatched with the administrator configurations.  If (3.18) is fired, then the VM template disk \nimage is copied from disk image repository using a distributed storage, such as S3, padded to the \ncorrect size, configured, and is pushed to the       . If ( 3.19) is fired, then the request will be \ndenied and the system will terminate.  \n (  )              [ ]   [ ]   [ ]    [ ]    [ ]    [ ] \n                   \n         { ( [ ]  [ ]  [ ]    [ ]     \n  [ ]   [ ]   [ ]) } (3.18) \n (  )              [ ]   [ ]   \n [ ]   [ ]   [ ]   [ ]  \n       (3.19) \nIn the last transition ( 3.20), an     from      and virtual     and     from        \nare mapped one -to-one. Moreover, the physical     from        is also mapped to virtual \nNIC and the relatio n between them is many -to-one, which means that many virtual      can be \nmapped to one physical     . The VM is spawned after all the mappings are performed. Nimbus \nhas the ability to provide different resources leases to different users as a mean of  scheduling. \nThe flexibility and customization available in Nimbus makes it suitable for scientific community \nto perform experiment. Moreover, the workspace tools available in Nimbus can operate with Xen \nhypervisor and as well as with KVM.  \n \n (   )  {     [ ]           [ ]          [ ]           [ ]      (3.20)",
        "348082a1-9a14-4303-8cdd-9088d416634f": "49 \n ( [ ]  [ ])  [ ] }    [ ]  [ ] \n           { (  [ ]   [ ] ) } \n          { ( [ ]  [ ]  [ ]  [ ]  [ ]  [ ]  [ ]  [ ]) } \n                  { ( [ ]  [ ]  [ ]  [ ]  [ ]   \n [ ]  [ ]  [ ]  [ ]) } \n3.3.5 . OpenStack  \nThe OpenStack is a cloud computing project, launced in July 2010, to provide IaaS. The \nOpenStack is mainly a collection of three open source projects: (a) OpenSTack Comput e (Nova), \nto provide and manege large network of VMs, (b) OpenStack Object Storage (Swift), to provide \nredundant and scalable data storage using cluster of servers, and (c) OpenStack Image Service \n(Glance), to provide discovery, registration, and delivery service for disk images [3.60]. Similar \nto other systems, such as Eucalyptus and Open Nebula, the OpenStack supports EC2, S3, and \nRest Interfaces. The networking between the OpenSTack and Eucalypstus also has certain \nsimilarities, such as the automatic bri dge creation and IP forwarding for public IPs. Moreover, \nthe authentication process, the development operations (DevOps) deployment tools, and \nhypervisors, are same between OpenStack and Eucalyptus. Despite the widespread popularity \nand adaptation of OpenS tack, it is still in early stages and will need time to mature, as advocated \nin [3.29]. The formal analysis, modeling, and verification of the OpenStack are included as a \nfuture work in this paper.  \n3.4. Verification of Models Using SMT -Lib and Z3 Solver  \nVerification is the process of demonstrating the correctness of an underlying system. Two \nparameters are required to verify a model or a system: (a) specification and (b) properties. In this \nstudy, we use bounded model checking [3.44] technique to perform th e verification, using SMT -",
        "4ab3b0c9-845f-47f8-9f5d-a01144bc4bfd": "50 \n Lib and Z3 solver. In bounded model checking, the description of any system is verified, whether \nany of the acceptable inputs drives the system into a state where the system always terminates \nafter finite number of steps. The proc ess of bounded model checking involves several tasks: (a) \nSpecification , the description of the system that states the properties or rules, which must be \nsatisfied by the system to be deemed correct, (b) Modeling , representation of the system, and (c) \nVerification,  use a tool to check whether the specifications has been satisfied by the model.  \nDefinition 2 : Bounded Mo del Checking [3.44],  given a Kripke Structure    (       ) \nand a   bound, the bounded model checking problem is to find  {     } where:   is the finite \nset of states,    is a set of initial states,   is the set of transitions, such that       ,   is the set \nof labels. The bounded model checking problem is to find an execution path in   of length   \nthat satisfies a formula   . Kripke structure, which is a state transition graph, is used to represent \nthe behavior of the system [3.45].  In Kripke structure nodes are the set of reachable states of the \nsystem, edge represents the transitions, and label functions map nodes to the set of properties \nhold in the state. Fig. 3. 8 shows an example Kripke structure and computational tree.  \n \n{p}{p,q}\n{q}S1\nS2S3 \np,q\npp,q pq\npq\np,q p\n.\n.\n..\n.\n..\n.\n.  \n(a) (b) \nFig. 3. 8. An example of: (a) Kripke Structure and (b) Computational Tree.",
        "a24b18ad-d16c-4deb-9546-af719cb76a77": "51 \n  \n \n \n \n \n \n \nA path in a Kripke structure can be stated as an infinite sequence of states represented as \n             such that for       (       )  . The model   may produce a path set   \n                      . To describe the property of a model some formal language, such as \nCTL*, CTL, or LTL is used. As stated in section I, the  \u201c*\u201d represents that CTL* is a hybrid LTL \nand CTL. Some operators used in CTL* are shown in Table 3.7. \nTo demonstrate the use and meaning of operators an example is provided in Fig. 3. 9. The \nblack circle in Fig. 3. 10 represents a state   . Moreover,     in Fig. 3. 9(a) means, that a future \nstate   is reachable from every path. Furthermore,     in Fig. 3. 9(b) means, that state   is \nglobally reachable from every path. (Readers are encouraged to see [3.46] for more details about \nthe CTL*.) For a model t o be correct, the states must satisfy the formulas (Definition 2) under a \nspecific bound. The formulas are represented in terms of properties of the systems.  \nDefinition 3:  (SMT Solver) [3.31],  given a theory \u0490 and a formula   , the SMT Solvers \nperform a c heck whether   satisfies \u0490 or not.  \n Op Desc Op Desc  \n  For all paths    Logical AND  \n  For some paths    Logical OR  \n  Next    Negation  \n  For future paths    Implication  \n  Globally    Double implication  Table 3.7. Operators (Op) used in CTL* and Description (Desc) .",
        "090647e3-55a7-4f44-9bb2-bf17b5b41b31": "52 \n To perform the verification of the models using Z3 (an SMT Solver), we unroll the model \n  and the formula   that provides     and   , respecti vely. Moreover, the said parameters are \nthen passed to Z3 to check if         [3.56]. The solver will perform the verification and \nprovide the results as satisfiable ( sat) or un -satisfiable ( unsat ). If the answer is sat, then the \nsolver will g enerate a counter example, which depicts the violation of the property or formula  . \nMoreover, if the answer is unsat , then formula or the property   holds in   up to the bound   (in \nour case   is exec. time).  \nFor the models to be correct, the solver  should be able to find a terminating state in a \nmodel. The failure transitions in all of the models are considered as a terminator of the models. \nMoreover, the other terminating state in the models is the last state when the instance is \nsuccessfully creat ed. One property to verify the models is that, whenever a request is made for a \nVM and there are no failures, then the instance should be created . To explain the verification of \nthe models, an example computational tree of a model in Fig. 3. 3 is developed and shown in Fig. \n3.10. The tree is drawn by following the success transitions only. If we closely analyze, we can \nsee that        (the final terminating) state is reachable from every path in the tree, which \nshows that the model terminates after some  iterations. Therefore, satisfies the property. In Fig. \n3.10, the state           \n(a)   p         (b)   p \nFig. 3. 9. An Example CTL Operators.",
        "eebc27d2-b4fa-4cdc-9187-ed28c77f204f": "53 \n \nV_Req\nE2_C\nAd_Co\nnfDIVM-\nRun\nHpvsrHpvsrAd_Co\nnfSt_Req\nDI\nDHCPPhy_H\nW\nxVM-\nRun\nECCDHCP ECC\nHpvsrHpvsr\nHpvsrAd_Co\nnf\nDI\nxAd_Co\nnfDI\nHpvsrHpvsrAd_Co\nnfSt_Req\nDI\nxHpvsr\nHpvsrAd_Co\nnf\nDI\nx\nVM-\nRun\nx\nECC HpvsrVM-\nRunPhy_H\nWx\nx x xDHCPPhy_H\nWHpvsrVM-\nRun\nx x xx\nDHCPPhy_H\nWVM-\nRun\nECCDHCP ECC\nHpvsrVM-\nRun\nx\nECC HpvsrVM-\nRunPhy_H\nWx\nx x xDHCPPhy_H\nWHpvsrVM-\nRun\nx x xxx\nxx\nx\nxx \nFig. 3. 10. An Example Computational Tree of Eucalyptus.  \n \nFig. 3. 11. Verification Results of Eucalyptus.  \n050100150200250300350\n00.511.522.53\n10 20 30 40 50 60 70 80 90 100\nMemory\n Time\nNo. of VM  Verification of Eucalyptus  \nTime vs.  Memory  Memory size in MB(s)  \nExec. time  in msec(s)",
        "5e02c40c-d4d2-4b27-a01f-dd963a1a704e": "54 \n at second level shows a scenario when  the instance is already been created and user can directly \nSSH the instance.  The states labeled with \u201cx\u201d represents, that from the point forward the tree \nwill repeat the predecessor. Similar process has been followed to verify all the models of the \nsystem s in this study. We have specified the properties of the VM -based systems in a similar \npassion and verified whether the properties are satisfied by the models. The properties we have \nverified for our models are:  \n1. if a request is made and there are no failures, then the instance of VM must be created,  \n2. the instance of VM must have the same configurations as requested by the user,   \nFig. 3. 12. Verification Results of Open Ne bula.  \n \nFig. 3. 13. Verification Results of Nimbus.  \n050100150200250300350\n00.511.522.533.5\n10 20 30 40 50 60 70 80 90 100\nMemory\n TimeMemory size in MB(s)  \nExec. time  in msec(s)  Verification of Open Nebula  \nTime vs.  Memory  \nNo. of VM  \n050100150200250300350\n00.511.522.533.5\n10 20 30 40 50 60 70 80 90 100\nMemory\nTimeVerification of Nimbus  \nTime vs.  Memory  \nExec. time  in msec(s)  Memory size in MB(s)  \nNo. of VM",
        "95bd80f5-a759-43c4-b945-41edef4ef66f": "55 \n 3. the instance should be distinct.  \n3.4.1 . Results  \nTo verify, the models of the VM -based systems are translated to SMT. Moreover, the \nproperties are also translated and  specified in SMT. The model along with the properties are \ngiven to the Z3 solver to check either the model satisfies the properties or not. If there are no \nerrors, then the model specifications can be stated as correct. Note that our goal in this section is \nto verify the correctness of the models  and not to measure or analyze the performance of the  \nFig. 3.14. Execution Time Comparison of Eucalyptus, Open Nebula, and Nimbus.  \n \nFig. 3. 15. Memory Utilization of the Systems.  \n050100150200250300350\n10 20 30 40 50 60 70 80 90 100\nEucalyptus\n Open Nebula\n NimbusExec. time in msec(s)  Execution  time of Eucalyptu, Open Nebula, and Nimbus  \nNo. of VM  \n00.511.522.533.5\n10 20 30 40 50 60 70 80 90 100Eucalyptus Open Nebula\nNimbusMemory Utilization  of Eucalyptu,  \nOpen Nebula, and Nimbus  Memory size in MB(s)  \nNo. of VM",
        "e2f1406a-85ef-4d80-9649-2d74a1062af1": "56 \n systems. Fig. 3. 11 depicts the execution time and memory taken to verify the model of \nEucalyptus. We have instantiated 100 VMs to verify the properties stated a bove and to observe \nthe effect of scalability on the working of the models.  \nThe model of Eucalyptus works fine and produces results as expected. The results in Fig. \n3.11 shows that an increasing trend is followed in both, the execution time and memory, as the \nnumber of VMs increases. The increase in the values is obvious, as the number of VMs will \nincrease more time will be required by the processor to verify and more space will be needed to \nstore the variables.  \nFig. 3. 12 and 13 depicts the verification re sults for the model of Open Nebula and \nNimbus, respectively. The execution time and memory increase in both of the models as the \nnumber of VMs increases. The increase in the values has the same reason that is stated in the \nresults of Eucalyptus. Fig. 3. 14 and Fig. 3. 15 plot the execution time of all the models \n(Eucalyptus, Open Nebula, and Nimbus) and memory consumption, respectively. As seen in Fig. \n3.15 the memory consumption of Open Nebula and Nimbus has almost similar values, which is \ndue to the fact th at Eucalyptus keeps the records of environment variable and configurations. \nNote that the results indicate the time taken by Z3 solver to verify the models based on the \nspecified properties.  \nThe results in no manner characterize the performance of the mod els or the systems. \nMoreover, the goal is to demonstrate the correctness of the models and to highlight the feasibility \nof the models with respect to scalability and execution time.",
        "d8ee9eee-5e54-4535-bdbb-ec16db3e9add": "57 \n 3.5. References  \n[3.1]  R. Buyya, S. Y. Chee, and S. Venugopal, \u201cMarket -Oriented Cloud Computing: Vision, \nHype, and Reality for Delivering IT Services as Computing Utilities,\u201d 10th IEEE (HPCC \u201908), \npp.5-13, Sep. 2008.  \n[3.2]  P. Mell and T. Grance. Definition of cloud computing. Technical Report, NIST, 2009.  \n[3.3]  E. Keller, J. Szef er, J. Rexford, and R. B. Lee, \u201cNoHype: virtualized cloud infrastructure \nwithout the virtualization,\u201d 37th ACM ISCA, pp. 350 \u2013361, June 2010.  \n[3.4]  M. Eisen, Marcum Technology, Introduction to Virtualization, \u201cThe Long Island\u201d, \nChapter of the IEEE Circuits and Systems (CAS) Society, April 28th, 2011.  \n[3.5]  A. Vichos, Agent -based management of Virtual Machines for Cloud infrastructure, \nMaster\u2019s thesis, School of Informatics, University of Edinburgh, 2011.  \n[3.6]  B. Sotomayor, R. S. Montero, I. M. Llorente, an d I. Foster, \u201cCapacity Leasing in Cloud \nSystems using the OpenNebula Engine,\u201d Workshop on Cloud Computing and its Applications \n2008 (CCA08), Chicago, USA, Oct. 2008.  \n[3.7]  Amazon Elastic Compute Cloud (Amazon EC2), http://aws.amazon.com/ec2/, accessed \n10 Jan. 2013.  \n[3.8]  Google App Engine, https://developers.google.com/appengine/, 10 Jan. 2013.  \n[3.9]  Science Clouds, http://scienceclouds.org/, 10 Jan. 2013.  \n[3.10]  D.Nurmi, R.Wolski, C.Grzegorczyk, G.Obertelli, S. Soman, L.Youseff, and \nD.Zagorodnov, \u201cThe Euca lyptus Open -source Cloud Computing System,\u201d 9th IEEE/ACM \nInternational Symposium on Cluster Computing and the Grid (CCGrid 2009), Shanghai, China, \npp. 124 \u2013131, May 2009.  \n[3.11]  oVirt, http://www.ovirt.org/Home, accessed 10 Jan. 2013.",
        "d73dbbdc-3cbc-456f-a3bc-6077bb2c658e": "58 \n [3.12]  Enomaly, http: //www.enomaly.com/, accessed 10 Jan. 2013.  \n[3.13]  F. Panzieri, O. Babaoglu, S. Ferretti, V. Ghini, and M. Marzolla, \u201cDistributed Computing \nin the 21st Century: Some Aspects of Cloud Computing,\u201d in Technology -Enhanced Systems and \nTools for Collaborative Lea rning Scaffolding, Springer, pp. 393 -412, 2011.  \n[3.14]  Wojtczuk, R. (2008). Subverting the Xen hypervisor. Black Hat USA, 2008.  \n[3.15]  Habib, I. (2008). Virtualization with kvm. Linux Journal, 2008, vol. 08, no. 166.  \n[3.16]  D. Cerbelaud, S. Garg, and J. Hu ylebroeck, \u201cOpening the clouds: qualitative overview of \nthe state -of-the-art open source vm -based cloud management platforms,\u201d 10th ACM/IFIP \nInternational Conference on Middleware, pp. 1 \u20138, 2009.  \n[3.17]  P. T. Endo, G. E. Gon\u00e7alves, J. Kelner, and D. Sadok,  \u201cA Survey on Open -source Cloud \nComputing Solutions,\u201d 8th Workshop on Cloud and Grid Applications, pp. 3 -16, 2010.  \n[3.18]  B. Sotomayor, R. S. Montero, I. M. Llorente, I. Foster, \u201cVirtual Infrastructure \nManagement in Private and Hybrid Clouds,\u201d IEEE Interne t Computing, vol. 13, no. 5, pp. 14 -22, \nOct. 2009.  \n[3.19]  N. Khan, A. Noraziah, E. I. Ismail, and M. M. Deris, \u201cCloud Computing: Analysis of \nVarious Platforms,\u201d Journal of Entrepreneurship and Innovation, vol. 3, no. 2, pp. 51 -59, 2012.  \n[3.20]  T. Murata, \u201cPetri Nets: Properties, Analysis and Applications,\u201d Proc. IEEE, vol. 77, no. \n4, pp. 541 -580, Apr. 1989.  \n[3.21]  Lectures on Petri Nets I: Basic Models, Lecture Notes in Computer Science, vol. 1491, \nW. Reisig and G. Rozenberg, eds., Berlin: Springer -Verlag,  1998.  \n[3.22]  S. K. Garg, S. Versteeg, and R. Buyya, \u201cA Framework for Ranking of Cloud Computing \nServices\u201d, FGCS, vol. 29, no. 4, pp. 1012 -1023.",
        "b1e7ef2c-f107-46e7-ba2c-bfd8a0c66268": "59 \n [3.23]  L. Moura and N. Bjrner, \u201cSatisfiability Modulo Theories: An appetizer,\u201d In Marcel \nVinicius Medeiros Oliv eira and Jim Woodcock, LNCS, vol. 5902, pp. 23 -36, Springer, 2009.  \n[3.24]  B. Javadi, R. Thulasiram and R. Buyya, \u201cCharacterizing Spot Price Dynamics in Public \nCloud Environments,\u201d FGCS, vol. 29, no. 4, 2013, pp. 988 -999. \n[3.25]  OpenStack, http://www.openst ack.org/downloads/openstack -overview -datasheet.pdf, on \nJuly, 2013.  \n[3.26]  M. Frade and J. S. Pinto, \u201cVerification conditions for source -level imperative programs,\u201d \nTechnical Report DI -CCTC -08-01, University of Minho, 2008.  \n[3.27]  SMT -Lib http://smtlib.cs.u iowa.edu/, accessed Jan. 2013.  \n[3.28]  S. U. R. Malik, S. K. Srinivasan, S. U. Khan, and L. Wang, \u201cA Methodology for OSPF \nRouting Protocol Verification,\u201d ScalCom, Changzhou, China, Dec. 2012.  \n[3.29]  G. von Laszewski, J. Diaz, F. Wang, and G. C. Fox, \u201cCompa rison of multiple cloud \nframeworks,\u201d IEEE Conference on Cloud Computing, 2012, pp. 734 -741. \n[3.30]  L. de Moura and N. Bjorner, \u201cZ3: An efficient SMT solver,\u201d International Conference \n(TACAS \u201908), 2008.  \n[3.31]  L. Cordeiro, B. Fischer, and J. Marques -Silva, \u201cSMT -based bounded model checking for \nembedded ANSI -C software,\u201d ASE, pp. 137 \u2013148, 2009.  \n[3.32]  M. Rosenblum, and T. Garfinkel, \u201cVirtual machine monitors: Current technology and \nfuture trends,\u201d IEEE Computer, vol. 38, no. 5, pp. 39 \u201347, 2005.  \n[3.33]  Y. Li, and O. Boucelma, \u201cA CPN Provenance Model of Workflow: Towards Diagnosis in \nthe Cloud,\u201d Conference on Advances in Databases and Information Systems, pp. 55 \u201364, 2011.  \n[3.34]  P. Sempolinski and D. Thain, \u201cA comparison and critique of Eucalyptus, OpenNebula \nand Nimbus,\u201d Cloud -Com, pp. 417 -426, 2010.",
        "93f3c41c-f304-4961-9233-780885dcb83a": "60 \n [3.35]  D. Nurmi, R. Wolski, C. Grzegorczyk, G. Obertelli, S. Soman, L. Youseff, and D. \nZagorodnov, \u201cThe Eucalyptus open -source cloud -computing system,\u201d IEEE International \nSymposium on Cluster Computing and the Grid,  pp. 124 \u2013131, 2009.  \n[3.36]  Eucalyptus Systems home page, http://www.eucalyptus.com, accessed at 15 jan, 2013.  \n[3.37]  J. Xu, M. Zhao, J. Fortes, R. Carpenter, M. Yousif, \u201cAutonomic resource management in \nvirtualized data centers using fuzzy logic -based appr oaches,\u201d Journal of Cluster Computing, vol. \n11, pp. 213 \u2013227, 2008.  \n[3.38]  D. Milojicic, I. M. Llorente,; R. S. Montero, \u201cOpenNebula: A Cloud Management Tool,\u201d \nIEEE Internet Computing, vol. 15, no. 2, pp. 11 -14, Mar. -Apr. 2011.  \n[3.39]  Open Nebula, http://ww w.opennebula.org, 15 Jan, 2013.  \n[3.40]  Nimbus, http://www.nimbusproject.org/docs/2.10, accessed at 16 Jan, 2013.  \n[3.41]  I. Foster, and C. Kesselman, \u201cThe Globus Project: A Status Report,\u201d IEEE \nHeterogeneous Computing Workshop, pp. 4 -18, 1998.  \n[3.42]  A Surv ey of Open -Source Cloud Infrastructure using FutureGrid Testbed, T. Wu, S. N. \nBaasha, S. S. Karwa, http://salsahpc.indiana.edu/b649proj/proj7.html, accessed at 18 Jan, 2013.  \n[3.43]  P. Campegiani, F. L. Presti, \u201cA general model for virtual machines resource s allocation in \nmulti -tier distributed systems,\u201d International Conference on Autonomic and Autonomous \nSystems, pp. 162 -167, 2009.  \n[3.44]  A. Biere, A. Cimatti, E. Clarke, O. Strichman, and Y. Zhu, \u201cBounded model checking\u201d, \nAdvances in Computers, vol. 58, Ac ademic press, 2003.  \n[3.45]  Y. M. Quemener and T. Jeron, \u201cModel Checking of CL on infinite kripke structures \ndefined by simple grammers,\u201d Technical Report RR -2563, INRIA, France, 1995.",
        "761902ba-35d9-4878-865a-c26abf0ca066": "61 \n [3.46]  M. Maidl, \u201cThe common fragment of CTL and LTL,\u201d IEEE Symposium on  Foundations \nof Computer Science, 2000.  \n[3.47]  F. Zhang, J. Chen, H. Chen, and B. Zang, \u201cCloudVisor: Retrofitting protection of virtual \nmachines in multi -tenant cloud with nested virtualization,\u201d ACM SOSP, Cascais, Portugal, Oct. \n2011.  \n[3.48]  Z. Wang and X . Jiang, \u201cHyperSafe: A lightweight approach to provide lifetime \nhypervisor control -flow integrity,\u201d IEEE Symposium on Security and Privacy (SP), pp. 380 -395, \n2010.  \n[3.49]  F. Sabahi, \u201cSecure Virtualization for Cloud Environment Using Hypervisor -based \nTechno logy\u201d, International Journal of Machine Learning and Computing, vol. 2, no. 1, pp. 39 -\n45, Feb. 2012.  \n[3.50]  S. U. R. Malik, S. K. Srinivasan, and S. U. Khan, \"Convergence Time Analysis of Open \nShortest Path First Routing Protocol in Internet Scale Networks ,\" IET Electronics Letters, vol. \n48, no. 19, pp. 1188 -1190, 2012.  \n[3.51]  J. Kolodiej, S. U. Khan, E. Gelenbe, and E. -G. Talbi, \"Scalable Optimization in Grid, \nCloud, and Intelligent Network Computing,\" CCPE, vol. 25, no. 12, pp. 1719 -1721, 2013.",
        "d82e2768-10f3-466c-885d-cd9414c41d70": "62 \n 4. CONVER GENCE TIME ANALYSIS OF OPEN SHORTEST \nPATH FIRST ROUTING PROT OCOL IN INTERNET \nSCALE NETWORKS  \nThis paper is published in IET Electronics Letters , vol. 48, no. 19, pp. 1188 -1190, 2012. \nThe authors of the paper are Saif U. R. Malik, Sudarshan K. Srinivasan, an d Samee U. Khan.  \n4.1. Introduction  \nOpen Shortest Path First (OSPF) is an adaptive routing protocol to distribute routing \ninformation within a single Autonomous System (AS) [4.1]. OSPF divides the network into \nareas. Each area consists of one or more segm ents. A segment constitutes the set of routers \nconnected via a common communication channel (example Ethernet). When a failure occurs, \ntopologies are regenerated and paths are recalculated by all of the routers within that area [4.2]. \nThe time a router tak es to discover the area topology is known as the convergence time [4.1]. To \nimprove the convergence time of a segment in an area, a router is selected as a Designated \nRouter (DR) on each segment.  \nFast convergence time is required to meet network based app lication demands and \nQuality of Service (QoS) requirements of modern dynamic large -scale routing domains, such as \ndata centers. Therefore, a lot of effort and studies have been made to improve the performance of \nOSPF [4.3]. However, the convergence time an alysis of OSPF that incorporates DRs has never \nbeen studied. We address the aforementioned, by developing a novel method to compute the \nintra-area convergence time of OSPF -based networks that incorporates DRs, which is the \nprimary contribution of this lett er. Moreover, to analyze and benchmark the protocol on Internet",
        "2fba0cd1-f777-41f1-a0cc-6844d961dc89": "63 \n scale networks is another contribution of this work. We also show how to use our method to \nstudy the effect of: (a) DRs, (b) cascading failures, and (c) topological changes on the \nconvergence time of the routers within an area.  \nFor our experiments, we simulated the detailed implementation of the OSPF protocol \nbased on the specifications reported in [4.2]. To get realistic measurements we generate \ntopologies from BRITE [4.4], using Otter [4.4] (as shown in fig.1.) that represents the exact same \ncharacteristics as those of the Internet. The results and analysis provided in the letter will be \nextremely useful for network administrators seeking to deploy OSPF. Moreover, the results are \nalso useful in the behavioral analysis of OSPF and can provide the basis to reevaluate the design \nof the protocol to achieve performance optimization.  \n4.2. Problem Formulation  \nConsider a network composed of   routers. Let    be the ith router, where       . A \nlink between two routers    and    (if it exists) has a communication cost that represents the \n \nFig. 4. 1. Sample Topology for One Thousand Routers.",
        "f6a75115-dfa9-4a2d-aa66-7e8a2a6c1eef": "64 \n minimum time for transferring message from    to   , which can be represented by the following \nexpression [4.5]:  \n,),(),(\nijj i\nj is RRDRRdel\uf062\uf06e\uf02b \uf03d\n \nwhere  (      ) is the physical distance between    and    ,   is the propagation delay of the \nmedium (optical fiber in our case),   is the size of the message in kilobytes, a nd     is the \navailable bandwidth between    and    . If the routers are not directly connected, then the \ncommunication cost is the sum of the cost of all links in the shortest path from    to   . Without \nthe loss of generality, w e assume that     (     )    (       ), which is a common \nassumption in literature [4.5]. Let   be the number of segments within an area and    be the kth \nsegment in that area, where      . Let    be the set of DRs withi n an area and    is the \nconvergence time of     . If a failure occurs (could be a link or a router), the routers connected to \nthe failed link or failed router will initiate the updates.         be a router that initiates an update \nin res ponse to a failure. Let    be the set of all other routers in the area defined as     \n( {  } \n   ) {{   }   }. \n     will detect a failure, if no response is received from a neighboring router for a period \nlonger than the Dead In terval (DI).     will then update its link state and forward the updated link \nstate to the  DR of segment k (represented as   ). The link state is the description of the interface \nof the router (IP address of the interface, mask, type of networ k, routers connected to) and the \nrelationship to other routers. The DR will then flood the information to every other router in the \nsegment after receiving the update. Let     represent a router that belongs to    . The time \nfor     to receive the update ( (   ))  can be calculated as follows:  (4.1)",
        "edaa86c5-deee-4090-82f1-d1868983df5f": "65 \n (4.2) \n(4.5)  (   ) {                                                                   \n          (  )    (      )           \nwhere, \n (  )          (   )    (      )  \nWe assume that other updates, such as change in bandwidth (\u2206    ) are local and incur \nzero update time. Therefore in ( 4.2), the value of   (   ) for        , is DI. The DI of routers is \nusually four times the \u201cHello\u201d interval, which is the time between consecutive transmissions of \n\u201cHello\u201d packets that are used to indicate the liveliness of nodes. The \u201cHello\u201d interval is 10 \nseconds for broadcast and P2P netw orks, and 30 seconds for all other media [4.2]. The value \nof  (   ) for        is the sum of the time required for    to receive updates and the time \n   takes to deliver updates to     . The value of   (  )  is calcul ated in ( 4.3), which is the sum \nof   (   ) (the node sending the update to     ) and the communication cost between them, which \nis given as    (      ). Moreover, ( 4.2) and ( 4.3) are used to calculate    based on the \nfollowi ng equation:  \n       ( (  )        (      ))  \nThe last router (maximum time taken to receive an update from the corresponding     ) in \n   that receives the update, determines    . Now, using ( 4.2), (4.3), and (4.4) the convergence \ntime of an area \u03c4 can be calculated as follows:  \n         ((  ))  ((   )    (      ))  \nThe maximum    amongst all of the segments plus the time when the update is initiated \nand reaches to the respective DR determines the value of   . \n (4.3) \n(4.4)",
        "a14e0616-9dc3-4a23-a125-c8ebc67237c3": "66 \n 4.3. Results and Discussions  \nThe value of   determines the time an area requires to reach a stable (steady) state from \nan unstable state, which is caused by an update. Therefore, to avoid message losses the netwo rk \nmust converge quickly. To this end, we evaluate the effect of: (a) the number of DRs, (b) \ncascading failures, and (c) topology on the value of    .  \nWe assume optical fiber as the communication medium having propagation delay    \n                . Ethernet channels have a Maximum Transmit Unit (MTU) of 1500 bytes \n[4.1]. Also, fragmentation is usually avoided in OSPF [4.1]. Therefore, we assume the message \nsize s to be 1KB (lower than the 1500B cap, but not too low and is typically used in liter ature for \nexperimentation, such as in [4.6]). The bandwidth value      is kept constant at 100Mbps, as \nadvocated in [4.7] for the evaluation purposes. The values of  (     ) are assigned from within \nthe range of [1 -100] km.  \nFig. 4. 2 depicts the effect of the number of DRs on the value of    . To analyze the effect \non large and average scale networks, we used N= {1000, 300}. A DR can decrease the segment \n \nFig. 4. 2. The Effect of DRs on \u03c4. 010203040\n1 10 20 30 40 50 60 70 80 90 100Mean ( \u03c4) for N=1000  \nMean ( \u03c4) for N=300  \nDR Effect of DR on \u03c4 Mean ( \u03c4) ms",
        "3e2eeeba-fd25-4c37-b712-eac9e4c7c396": "67 \n convergence time from  (  ) to  ( )[4.1]. H owever, including more DRs in an area has no \neffect or in some cases may even increase the value of   . As reported in Fig. 4. 2, the mean value \nof   increases gradually as the number of DRs increases in the topology. To see why, consider a \nrouter R under DR 1. If DR 2 is added to the area and R now falls under DR 2, then DR 1 can no \nlonger directly communicate with R, but instead is obligatory to communicate via DR 2. From this \nexample we can see that including a DR can increase the length of communication path s in the \narea, thereby possibly increasing its convergence time. Therefore, the placement of DR is crucial \ntowards the value of   .  \nFig. 4. 3 depicts the effect of cascading failures of routers (also called nodes) and links \non  . The number of DRs in an area is set to one (to avoid the influence of multiple DRs on    ). \nWhen a  node fails, nearby nodes absorb the load of the failed node. The failed nodes can in turn \ncause their neighbors to fail (due to overloading) resulting in cascading failures, also known as \nterminal failure in (communication and power) networks. The degree and placement of a failed \nnode determines its effect on the value of    . If a failed node or link is in the shortest path of \n \nFig. 4. 3. The Effect of Node and Link Failure on \u03c4. 0.420.440.460.480.50.520.540.560.58\n0 5 15 25 35 50Link Failure Node FailureMean ( \u03c4) ms \nNo. of Failures  N=300  DR=1  Effect of Failures on \u03c4",
        "094deaee-1f32-4390-88d9-1c68b44db3ff": "68 \n other nodes, then   may increases. This is because updates to such routers may require a longer \npath. However, if a failed node or link is: (a) a leaf node, a node with low degree, or link on the \nedge of the topology, or (b) not included in the shortest path, then    can decrease as the failed \nnode need not be updated. Moreover, as can be seen from Fig. 4. 3, node failures can affect    \nmore adversely than link failures. Link failures directly affe ct only the two routers they are \nconnected to, but node failures affect all its neighbors which is typically more than two.  \nFig. 4. 4 illustrates the variation of   due to the changes in the topol ogy, which depicts \nthat the value of   increases as the number of routers within an area increases. However, an \ninteresting observation is that the value of   may decrease in certain cases when a router that is \nincluded in a topology changes the value of     (  ) by adding a new shortest path. To avoid \nthe influence of multiple DRs in an area on   , the number of DRs is set to one in Fig. 4. 4. \n4.4. References  \n[4.1] J. T. Moy , \u201cOSPF; Anatomy of an Internet Routing Protocol ,\u201d Addison -Wesley , 1998.   \nFig. 4. 4. The Effect of Random Topological Changes on \u03c4. 0.30.50.70.9\n100 200 300 400 500 600 700 800 900 1000Effect of Topology on \u03c4 \nMean ( \u03c4) \nN DR=1  Mean ( \u03c4) ms",
        "50d5e56e-867b-45e6-80e6-bf13779940b4": "69 \n [4.2] J. Moy, \u201cOSPF Version 2, The Internet Society OSPFv2, \u201d \nhttp://www.ietf.org/rfc/rfc2328.txt, accessed on 08 May, 2012.  \n[4.3] M, Goyal, M. Soperi, E. Baccelli, G. Choudhury, A. Shaikh, H.  Hosseini, \u201cImproving \nConvergence Speed an d Scalability in OSPF: A Survey ,\u201d IEEE Com munication Surveys and \nTutorials , 2012, vol. 14, no.2, pp. 443 -463. \n[4.4] A. Medina, A. Lakhina, I. Matta, and J.  Byers, \u201cBRITE: An Approach to Universal \nTopology Generation, \u201d MASCOTS , Ohio, 2001.  \n[4.5] S. U. Khan and I. Ahmad , \u201cA Pure Nash Equilibrium based Game Theoretical Method for \nData Replication across Multiple Servers ,\u201d IEEE Transactions on Knowledge and Data \nEngineering , vol. 21, no. 4, pp. 537 -553, 2009.  \n[4.6] B. Wang , J. Zhang , Y. Guo , and W.  Chen , \u201cFast-Converging Distance Vector Routing \nMechanism for IP Networks, \u201d Journal of Networks , 2010, vol. 05, no. 9, pp. 1069 -1075.  \n[4.7] R. S. Prasad , M. Murray , C. Dovrolis , and  K. Claffy , \u201cBandwidth Estimation: Me trics, \nMeasurement Techniques, and Tools, \u201d IEEE Network , 2003, vol. 17, no. 06, pp. 27 -35.",
        "8f32d848-234d-4453-bdc5-40779f083caa": "70 \n 5. MODELING AND ANALYSIS OF THE THERMAL \nDYNAMICS OF CYBER PHYSICAL DATA CENTERS  \nThis paper is submitted to IEEE Transactions on Cloud Computing (TCC) on Sept. 2013.  \nThe authors of the paper are Saif U. R. Malik, Kashif Bilal, Samee U. Khan, Bharadwaj \nVeeravalli, Keqin Li, and Albert Y. Zomaya,  \n5.1. Introduction  \nCloud computing is an emerging paradigm, where a shared pool of resources (networks, \nservers, storage, app lications, and services) can be accessed conveniently, on -demand, and can \nbe rapidly provisioned or released with minimal management effort or service provider \ninteraction [5.1, 5.2]. The Data Center (DC) contributes towards the prevalent application and \nadoption of cloud by providing architectural and operational foundation. Therefore, the DC \nserves as a backbone of cloud systems. To maintain a specified Quality of Service (QoS) \nattributes, such as throughput, the DCs must operate efficiently all the time.  \nThe DC hosts a large number of servers to perform substantial computation and storage. \nMoreover, to improve the services for high performance computing application, the DC has been \nincreasingly deployed. Blade servers are thin modular servers, usually dep loyed in DCs that are \ndesigned to minimize the use of physical space and energy. Because of the high energy \nrequirements of the computing and cooling devices, the DCs energy consumption can cost \nmillions of dollars. The DC run -time cost is dominated by the  cost spent on the energy \nconsumption of computing and cooling technologies [5.3]. According to a report published by \nEnvironmental Protection Agency (EPA) [5.4], the peak power consumption of DC in 2006 was \n7GW and it was expected to raise 12GW till 2011,  leading to a cost of 7.4 billion USD per year.",
        "fbee5169-4e2e-4cb7-b25d-3a6f8431bc24": "71 \n The income of the DC is defined by the Service Level Agreement (SLA), which defines the \namount paid by the users based on the QoS they receive. The computational and operating \nmargins of DCs depend highly on the provision of the QoS. Higher QoS attribute levels lead to \nhigher rates that in turn lead to higher computations. To deliver the specified level of \nperformance, the number of computational devices put in use at all levels of DC has significantly \nincreas ed. As a result, the rate at which the heat is emitted by the devices has also increased. The \ncost to stabilize the temperature in the DC has drastically increased and become almost equal to \nthe cost of operating computational systems. The increasing cost of energy consumption calls for \nnew strategies to improve the energy efficiency in DCs. Several strategies have been proposed, \nsuch as [5.5, 5.6, 5.7, and 5.8] for efficient energy consumption in the DC. In this paper, we \nmodel DC as a Cyber Physical Syste m (CPS) to capture the dynamics and evolution of the \nthermal properties presented by the DC.  \nThe software aspects, such as scheduling and computations, performed by the devices are \nmodeled as the \u201cCyber\u201d portion and the supporting infrastructure, such as power supplies and \nservers, are modeled as the \u201cPhysical\u201d portion of the CPS. Several studies are available that \nmodel DC as a CPS to achieve energy efficiency, such as [5.9 and 5.10]. The models proposed in \nthe literature are abstract in the sense that th ey lack detailed analysis of the DC and hence it \nbecomes difficult to exactly understand the dynamics of heat distribution, both from software \nand infrastructure perspective. Thus, in this paper, we provide a detailed modeling and \nformulation of the cyber and physical infrastructure, including the heat dissipation of individual \ncomponents, the heat distribution, and recirculation among the physical portion of the CPS.",
        "b1d39f2e-d6b3-4e2f-9be0-d72b24d2682e": "72 \n The physical infr astructure of the DC follows a hierarchical model, where the computing \nresources reside at the lowest layer. The network infrastructure can be considered as a multilayer \ngraph, where the servers and switches are vertices and interconnection amongst them ar e the \nedges. The servers, access switches, and aggregate switches are assembled in modules (referred \nas pod) and are arranged in three layers, namely: (a) access, (b) aggregate, and (c) server layer. \nWe perform a thorough analysis and modeling of the therm al subtleties involved at each layer. In \ndoing so, we model heat dissipation of servers, switches (access layer, aggregate layer, and core \nlayer), and the aggregate impact of each component on the overall infrastructure.  \nBy exploiting the thermal dynamics of discrete element, we propose a Thermal Aware \nControl Strategy (TACS) that uses High Level Centralized Controller (HLCC) and Low Level \nCentralized Controller (LLCC) to manage and control the thermal dynamics of CPS at different \nlevels, such as: (a) low ( server) level, (b) high (access, aggregate, and core switch) level, (c) \nintra-pod level, and (d) inter-pod level. The complete details of all levels and controllers will be \ndiscussed in later sections. We perform the simulation of our proposed strategy on a real data \ncenter workloads, obtained from Center of Computational Research, State University New York \nat Buffalo. The traces have more than 22,000 jobs and the records are of one month time. \nMoreover, we perform a comparative analysis of our proposed str ategy with one classical \nP4x\nP3P2\nP1y\nx\nyzz x yt1\nt2t3t4\nTransition\nPlace\nFlowP\nf \nFig. 5. 1. An Example High -Level Petri Net.",
        "667a3261-3ba2-4280-a33e-88af813db40d": "73 \n scheduling approach and two thermal aware approaches, namely: (a) First Come First Server \n(FCFS), (b) Genetic Algorithm based thermal aware scheduling [5.23], and (c) Thermal Aware \nScheduling Algorithm (TASA) [5.18].  \nIn this study , we also made an effort to diminish the level of abstraction through detailed \nmodeling and formal analysis of the CPS. We use High -Level Petri Nets (HLPN) and Z language \nfor the modeling and analysis of the systems. The HLPN are used to: (a) simulate and (b) \nprovide mathematical representation, and (c) analyze the behavior and structural properties of the \nsystem. Moreover, we performed the verification of the models using Satisfiability Modulo \nTheories Library (SMT -Lib) and Z3 solver. We performed the auto mated verification of the \nmodel by following Bounded Model Checking technique using SMT -lib and Z3 solver. To verify \nusing SMT, the Petri net model is first translated into SMT along with the specified properties. \nThen, Z3 solver is used to check whether t he model satisfies the properties or not. The \ncontributions of the paper are as follows:  \n\uf0b7 modeling DC as a CPS to analyze the thermal dynamics at different levels;  \n\uf0b7 formulating the thermal properties of major component involved in CPS, the effect of \ncyber ac tivities on the physical properties of the DC, and vice versa;  \n\uf0b7 proposing a Thermal Aware Control Strategy (TACS) that uses HLCC and LLCC to \nmanage, control, and coordinate between the cyber and physical portion to maintain \nunified thermal threshold range;  \n\uf0b7 conducting simulation and comparison of proposed strategy on a real data center \nworkload and;  \n\uf0b7 modeling and analyzing the CPS in HLPN, and the verification of the model using \nSMT -Lib and Z3 Solver.",
        "862748aa-eec0-4c28-91af-f2c016bcb07d": "74 \n 5.2. Modeling Thermal Dynamics of Cyber Physical DC  \nWe mod el DC as a CPS, where the logical classification is made between the \ncomputational section and supporting infrastructure. The computational section, such as \nscheduling, that participates in the distribution, processing, and flow of tasks constitutes the \nCyber portion. The supporting infrastructure, such as servers, switches, PDUs, and power \ngenerators, constitutes the Physical portion. The cyber portion performs computations or any \nother task to deliver the specified QoS attributes. In return, the physical portion emits thermal \nenergy into the DC environment that raises the temperature. In this paper, we present a \nmethodology that analyzes the collective thermal dynamics of cyber and physical portions to \nmaintain a specified range of thermal threshold in the  CPS. It is noteworthy, that we are only \ninterested in the thermal dynamics of the DC and not the performance. The DC is logically \nclassified as the combination of the cyber and physical portion:  \n     (     )   (        )  \nThe CPS is comprised of computing resources, such as servers and the network \ninfrastructure, such as switches, interconnecting all of the computing resources ( Fig. 5. 2). The \nCPS follows a hierarchical mo del, where the computing resources reside at the lowest layer as \nPod\nAccess \nLayerAggregate \nLayerCore \nLayerCore Switch (\u03b3) \nServers (S)Aggregate Switch (\u03b4) \nAccess \nSwitch (\u03b1)  \nFig. 5. 2. Three -Tier DC Archit ecture.",
        "bc9e913c-91da-432e-98c3-1661998ab956": "75 \n depicted in Fig. 5. 2. The network infrastructure can be considered as a multilayer graph [5.31]. \nThe servers, access switches, and aggregate switches are assembled in modules (referred to as \npod) and are arranged in three layers, namely: (a) access, (b) aggregate, and (c) server layer. The \ncore layer is used to connect all of the independent pods together. Note that, the cyber portion \nresides within the physical portion. Therefore, we model DC  in a unified way that can \naccommodate both, the cyber and physical section. We divided the CPS model into two logical \nsections: (a) Pods (zones) and (b) Core Layer Switches, as below:  \n          ( )      ( )  (5.1) \n \nwhere  ( ) is the s et of core layer switches and r is the total number of core switches ( ) in the \nnetwork.     ( ) is the set of pods and k is the total number of pods in the network. Each access \nlayer switch ( ) is connected to n number of servers (S) in a pod. Moreov er, every    is \nconnected to every aggregate switch ( ) in the pod. The number of nodes (including      and  ) \nin    ( ) can be calculated as:  \n    ( )  (   )          (5.2) \nwhere  (   )  represents a set of server s connected to   in     ( ). The     represents access \nlayer switches in     ( ), where m is the total number of   in     ( ). The     represents \naggregate layer switches and w is the number of   in     ( ). The components in CPS work \nindividually or cooperatively to accomplish the assigned tasks. According to the law of energy \nconservation, energy can neither be created nor destroyed but it can be converted from one form \nto another. The mechanical energy is consumed by the physical portion as they perform cyber \ntasks and almost all the power drawn by the computing devices are dissipated as heat. We model",
        "e645cf7d-bd5b-4eaf-844d-2d12829039e7": "76 \n the heat dissipation of every component within the pod, such as       and  . The heat dissipated \nby the   is represented as    and can be calculated as follows:  \n      (        )    (5.3) \nwhere,  \n      (       )    (5.4) \nThe       represents the heat d issipated as a result of the static power to keep the server \nawake, and       represents the heat dissipation when the processing is being performed. The \n      is fixed that does not change and is independent. However,       is dynam ic and is dependent \non the workload. The       represents the heat dissipated by the memory that includes energy \nconsumed during the memory refresh operations. The        is further decomposed into        that \nrepresents the heat di ssipation because of the read and write operations, and        is the heat \ndissipation as a result of the processing performed. We model switches as normal and high -end \nswitches. The switches used in the core layer are usually high -end switches an d dissipate more \nheat as compared to normal switches. We assume   and   are normal switches and   are high -\nend switches. The heat dissipated by the normal switches, such as   and   is represented as \n   and can be calculated as:  \n     (              ) , (5.5) \nwhere,  \n          , (5.6) \nand \n              . (5.7)",
        "83043c80-2786-4fce-a96a-c5ee5891b031": "77 \n The    represents the heat dissipation of the switch as a result of static power \nconsumption,    represent s the heat dissipation of the communication fabric used in the switch, \n  represents the heat dissipation of the buffer that includes     and   , representing the heat \ndissipation of ingress and egress processing unit, respectively. The   represents the heat \ndissipation during the processing that includes     and     , representing the static heat \ndissipation of switch processor, and when read and write operations are performed, respectively. \nThe     represents the heat dissipation due to the processing performed by the switch. The     \nand    are constant. However, the    and    are dynamic and depend on the workload of the \nswitch.  \nThe   has different characteristics from   and  . The   facilita tes the connection of the \nnetwork with the end node devices and for this reason it supports features, such as port security \nand VLANs. The    manages or segments the traffic from the leaf nodes into VLANs and provide \nit to the core layer. For the said reas on,   provides inter -VLANs routing functions to \ncommunicate. The    are the high speed backbone of the network, so they have a very high \nforwarding rate. Moreover, they have the capability to support link aggregation to ensure \nadequate bandwidth and traff ic routing coming from  . Furthermore,   have additional hardware \nredundancy features, such as redundant power supplies, to swap while the switch continues to \noperate. Because of the high workload carried out by   , they dissipate more heat than   and  . \nWe, represent the heat dissipation of high -end switches (core layer) as    , which can be \ncalculated using  ( 5.5), ( 5.6), and ( 5.7). However, because of the workload and hardware \nredundancy the value of    must always be greater than    . In the previous discussion, we have \nmodeled the heat dissipation of the individual nodes, as in ( 5.3) and ( 5.5), involved in the CPS. \nThe heat dissipated by all the servers in     ( ), represented as    , can be calculated as:",
        "c9b9e6b2-561e-4eff-a959-6f5fa3920007": "78 \n     \u2211\u2211(     ) \n    \n    (5.8) \nwhere the       represents the heat dissipation of    connected to   in     ( ). Moreover, the \nheat dissipation of all the   and   in     ( ), represented as     and    , respectively, can b e \ncalculated as:  \n    \u2211(   ) \n    (5.9) \n    \u2211(   ) \n    (5.10) \nwhere     and     represents the heat dissipated by access and aggregate switches in     ( ). \nSimilarly, the overall heat dissipated by the CPS,  represented as   , can be calculated as:  \n   \u2211(            )  \u2211(   ) \n    \n     (5.11) \nIt is noteworthy, that the heat calculations perf ormed at this point, do not consider the \nambient effect involved in the CPS environment. The next paragraphs will discuss the dynamics \nCRACRack Rack Rack Rack\nRack Rack Rack Rack\n \nFig. 5. 3. The Ambient Temperature Effect in DC .",
        "8eea776f-a407-4d0b-81ba-5ae79a5ade64": "79 \n of ambient temperature and its effect on the heat dissipation of an individual component. The \nambient temperature is the surrounding temperature. Figure 3 illustrates the effect of ambient \ntemperature in the CPS environment. The red and blue dotted lines in Fig. 5. 3 depict the \nmovement of hot and cold air, respectively. The hot air is exchanged amongst the racks, while \nthe c ooling is provided from the cooling devices, such as CRAC. Suppose there are    number of \nnodes that participate in the heat dissipation of CPS. Two temperatures are associated with each \nnode, the (a) input temperature (     ) and (b) output temperat ure (     ). The      represents the \ninput ambient temperature of node that includes the heat received from other thermal nodes. As \ndepicted in Fig. 5. 4, the      of s1 involves the recirculation (red dotted lines) of hot air from other \nnodes and cooling temperature (  sup) from CRAC. The heat dissipated by any node i   will \nchange the       . The      and       represent the temperature of the surroundings and not the node. \nHowever, the heat dissipated by t he node (      ) can affect the values of      and      . The input \ntemperature of a node (     ) can be calculated as:  \n       (    ) (5.12) \nwhere  \ns1 s2\ns3 s4\u03c4sup\n\u03c4ini\u03c4outi \nFig. 5. 4. Heat Exchange among  Server Nodes.",
        "d33091aa-7226-4cd3-a296-3ef540e24f2c": "80 \n      \u2211(     ) \n          (5.13) \nThe   is an air coefficient that represents the product of air density (which changes from \n1.205 kg/m3 at 20\u00b0 C to 1.067 kg/m3 at 60\u00b0 C), heat of air, and flow rate of air. The       can be \ncalculated as:  \n              (5.14) \nwhere  \n     (             ) (5.15) \nThe    represents the heat dissipation of a node i   in proportion to the power consumed \nduring the processi ng. The    can be replaced by any of the heat dissipation value of three \nnodes. For instance, if the calculating node is  , then    can be replaced with  . Suppose we \nhave the current power distribution of all the servers in    (  ), represent ed as a vector   \u20d7\u20d7 . The \ntemperature profile of all the servers, represented as a vector   \u20d7\u20d7 , can be calculated based on the \ngiven power distribution. The current temperature of    in    (  ) is denoted as        , which can \nbe calculated as,                (  )  where   (  ) represents the anticipated change in the \ntemperature cause by executing a task    on  . According to the abstract heat model of DC, as \ndiscussed in previous works [5.27] , the heat distribution and its effect on the surrounding \nmachines can be represented as cross interference coefficient matrix. We follow the same model \nand compute the heat distribution of the servers using a matrix, represented as      {    }, \nwhich denotes the thermal effect of    on    and can be populated as:  \n              \n  , \nwhere   is the thermal conductivity constant of the air and \u0125 is the hop count of     from   .",
        "1526cb1b-eac9-4da2-ad1b-7e8616a322fe": "81 \n 5.3. Thermal Aware Control Strategy (TACS)  \nWe propose a thermal aware scheduling approach that uses High Level Centralized \nController  (HLCC) and Low Level Centralized Controller (LLCC) to manage and control the \nthermal dynamics of CPS at different levels, such as: (a) low (server) level, (b) high (access and \naggregate switch) level, (c) intra-pod level, and (d) inter-pod level. The goal  is to eliminate \nPod(2)\n...LLCCPod(1)\n...LLCC\n...Pod(k)\n...LLCCCore\nHLCCResource \nManager \nFig. 5. 5. HLCC and LLCC in DC.  \n1: for i  1 to k do  \n2:                           //  also use in inter -pod migration  \n3: end for  \n4: Select     (   ) \n5: Get                    \n6: Select    , such that                                \n7: Allocate    to   ,              ( )       // \n8: If                       , then  \n9:     Migrate -task c from    to   ,              ( )          //  intra -pod migration               \n10: end if  \nFig. 5. 6. Steps Involved in Low (server) Level.",
        "f158f5bb-9453-4066-be2d-2c649f578325": "82 \n hotspots and to maintain a uniform range of thermal threshold in every pod. Whenever a new job \n(a job can have multiple tasks) is arrives to the CPS, the tasks are allocated to the specified \nserver based on the thermal signatures. The HLCC  and LLCC are proposed that perform the task \nallocation, task migration, and traffic redirection, based on the thermal analysis of the node or \nlayer. As depicted in Fig. 5. 5, there is LLCC in every pod that has the thermal information of \nall      and  . Every node in the CPS is equipped with a heat sensor that measures the \ntemperature and the temperature is updated periodically to the LLCC. In low (server) level (Fig. \n5.6), the       for all the      (  ) is measured and observed through sen sors periodically. \nWhenever the value of    ,     exceeds the maximum threshold temperature of the server \n(     ), the LLCC migrates some tasks from    to   , where    and   are connected to the same \n . \nFor the tasks to be migrated successfully to   , the constraint             , must be \nsatisfied. The    represents the anticipated increa se in the temperature as a result of task \n1: for i  1 to k do \n2:     Compute                \ud835\udc64               \n3:     If         \ud835\udc64 such that            \ud835\udf09, then  \n4:        Redirect    from    to                 (  )     \ud835\udf09 \n5:     end if \n6:     If           such that            \ud835\udf09, then  \n7:        Migrate -task c from   to   ,              ( )                         (  ) \n    \ud835\udf09          // intra -pod migrat ion \n8:     end if  \n9: end for  \nFig. 5. 7. Steps Involved in High (access and aggregate) Level.",
        "09c6c763-5a8f-4446-91a8-dde2617597aa": "83 \n migration. If the task migration is not possible amongst the serves under the   , then the servers \nbelonging to             are considered for the migration. The    and    belongs to the \nsame pod. Moreover, if there is no server available for the migration within the same pod, then \ninter-pod task migration is performed by enforcing the same constraint.  \nIn high (access and aggregate) level (Fig. 5. 7), the focus is to avoid the hotspot at acces s \nand aggregate layer of the CPS by redirecting the traffic from heavily loaded switches to the \nlighter ones. Redundant paths are available in the network infrastructure of DC that allows \nredirection of traffic from one switch to another ( Fig. 5. 2). The de cisions for the redirections are \nmade by LLCC considering the value of    for every switch. When the value     for    increases \nfrom     \ud835\udf09, then task migration is performed by LLCC in the same way was as performed in low \nlevel. The  reason for the aforesaid is a fact that there is only one path between the access and the \nservers. However, in case of  , redundant paths are available. Therefore, whenever the value of \n       \ud835\udc64, exceeds the maximum threshold temperature of the switch (    \ud835\udf09), the LLCC \ninstructs the lower level (server) to redirect the traffic from    to    where both   belongs to the \nsame pod. The redirection is allowed only if the            \ud835\udf09. If the redirection is not \npossible within the same pod, then inter -pod task migration is performed to take some load off \nfrom the switch.  \nThe high level and low level are combined together to form an intra -pod control . The \ngoal in intra -pod is to stabilize the temperature of the pod b y maintaining the thermal signatures \nof server, access, and aggregate layer. Local decisions (within the same pod), such as task \nmigration and redirection, are taken by LLCC to stabilize the temperature. However, the inter -\npod migrations are performed with  the consent of HLCC. Whenever, inter -pod actions have to be \nperformed, the LLCC requests HLCC to provide information about other pods where the tasks",
        "fcd22262-80df-48e2-910e-2436c2de7147": "84 \n can be migrated. Afterwards, the LLCC of the pods can communicate with each other to \naccomplish the task.  \nThe inter -pod control is focused on maintaining the unified thermal threshold value in all \nthe pods. The thermal signatures of nodes in CPS can evolve in order of minutes. Moreover, the \npower states of servers can change as frequent as milliseconds. There fore, the threshold \ntemperatures are not absolute values; rather it is a range within which the thermal signatures of \nthe nodes and layers should lie. In inter -pod control, the HLCC periodically monitors the average \nthermal values of each pod that it recei ves from sensors. Whenever the thermal signature of the \n   ( ) (                ) starts to exceeds the maximum thermal threshold value of the pod \n(     ), the HLCC instructs the LLCC of     ( )to migrate some tasks to    ( )         . \nThe migration can be successfu lly performed only if the             . Moreover, the server \nselection and task allocation performed in inter -pod control is same as in low level. The HLCC \nonly has the coarse -grain information of the    . The allocations of migrate d tasks to servers are \nperformed by LLCC through the use of fine -grained servers information. All of the \naforementioned controls work together to make sure that the CPS is operating under a specified \ntemperature range. More detailed information, formal ana lysis, and behavior of the HLCC and \nLLCC will be discuss in the next section, using HLPN and Z language.    \n5.4. Verification Using HLPN, SMT -Lib, and Z3 Solver  \nVerification is the process of demonstrating the correctness of an underlying system \n[5.39]. T wo parameters are required to verify a model or a system: (a) specification and (b) \nproperties. In this study, we use bounded model checking [5.40] technique to perform the \nverification, using SMT -Lib and Z3 solver. In bounded model checking, the descripti on of any",
        "56366679-b8ae-4046-b922-07f80062ce65": "85 \n system is verified, whether any of the acceptable inputs drives the system into a state where the \nsystem always terminates after finite number of steps. The process of bounded model checking \ninvolves several tasks: (a) Specification , the descript ion of the system that states the properties or \nrules, which must be satisfied by the system to be deemed correct, (b) Modeling , representation \nof the system, and (c) Verification,  use of a tool to check whether the specifications is satisfied \nby the model . \nDefinition 2 : (Bounded Model Checking) [5.40]. Formally, given a Kripke \nStructure   (       ) and a   bound, the bounded model checking problem is to \nfind {     } where:   is the finite set of states,                                ,   is the set of \ntransitions such that      , and   is the set of labels.The bo unded model checking problem \nis to find an execution path in   of length   that satisfies a formula   .  \nKripke structure is a state transition graph used to represent the behavior of the system \n[5.41]. In Kripke structure nodes are the set of reachable states of the system, edges represent the \ntransitions, and label functions map nodes to the set of properties hold in the state. Fig. 5. 8 shows \nan example Kripke structure and computational tree where: S={S1, S2, S3}, S0={S1}, \n{p}{p,q}\n{q}S1\nS2S3\n \n(a) \np,q\npp,q pq\npq\np,q p\n.\n.\n..\n.\n..\n.\n. \n(b) \nFig. 5. 8. An Example of: (a) Kripke Structure and (b) Computational Tree.",
        "64f253ac-90eb-41c9-ab7f-e7f02b0fc3f5": "86 \n R={(S1,S2),(S2,S1), (S2,S3),( S3,S3)} ,   and   are atomic propositions, and \n  {(   {   }) (   { }) (   { })}. \nA path in a Kripke structure can be stated as an infinite sequence of states represented as \n             such that for       (       )  . The model   may produce a path set   \n                      . To describe the property of a model some formal language, such as \nCTL*, CTL, or LTL is used. (Readers are encouraged to see [5.42], [5.43] for more details about \nthe CTL*.) For  a model to be correct, the states must satisfy the formulas (Definition 2) under a \nspecific bound. The formulas are represented in terms of properties of the systems.  \nDefinition 3 : (SMT Solver) [5.44]. Given a theory \u0490 and a formula   , the SMT Solvers \nperform a check whether   satisfies \u0490 or not.  \nTo perform the verification of the models using Z3 (an SMT Solver), we unroll the model \n  and the formula   that provides     and   , respectively. Moreover, the said parameters are \nthen passed to Z3 to check if         [5.26]. The solver will perform the verification and \nprovide the results as satisfiable ( sat) or un -satisfiable ( unsat ). If the answer is sat, then the \nsolver will generate a counter example, which depicts the violation of the property or formula   . \nMoreover, if the answer is unsat , then formula or the property   holds in   up to the bound   (in \nour case   is exec. time).  \n5.4.1 . Modeling HLCC and LLCC Using HLPN  \nThe HLPN model for HLCC and LLCC is shown in Fig. 5. 9. Th e first step towards \nmodeling using HLPN is to identify the required types, Places  ( ), and mapping (Definition 1). \nThe types and the d escriptions are shown in Table 5.1  and the mapping of   to types is depicted \nin Table 5.2 . The description and operatio n of the controllers are discussed in the previous",
        "e94ed99e-d7af-4e00-ba7a-d6dd93fb2e2c": "87 \n section and now we can define formulas (pre and post -conditions) to map on transitions. The set \nT contains the following transitions:  \n  {  \ud835\udc64                                               \n                                            }  \n \n \nTypes  Description  \nTask  A type for the representation of job.  \nRes-Mat Amount and type of resources available servers.  \nTh_S  A type for the thermal si gnature (Th. Sig) of the server.  \nTh_P  A type for the Th. Sig of the Pod.  \nTh_Ac  A type for the Th. Sig of the Access Switch.  \nTh_Ag  A type for the Th. Sig of the Aggregate Switch.  \nTh_Co  A type for the Th. Sig of the Core Switch.  \nRes A type to represent the resources.  \nRI A type to represent the Routing Information.  \nMax_Th_P  Max. Thermal Threshold (Th. Td) value of the Pod.  \nMax_Th_S  Max. Th. Td value of the Server.  \nMax_Th_Ac  Max. Th. Td of Access Switch.  \nMax_Th_Ag  Max. Th. Td value of Aggregate Swi tch.  \nMax_Th_Co  Maximum Thermal Threshold value of the core Switch.  \n\u0394t   Expected thermal dissipation of new task.  \n \nNew tokens can only enter the model through the transition           . As seen in Fig. \n5.9, no arc is incident on the aforementioned tran sition, which is why no pre -condition exists and \nthe rules for the transitions can be written as:  (        )             . Whenever the \nnew job arrives, the resource manager checks if the resources required by the job are available or Table 5.1. Data Types Used in the HLCC and LLCC Model .",
        "40259cca-cc3b-4469-a470-03ca733f119b": "88 \n not. The said authen tication is performed by the transitions           and           , \nmapped to the following formulas.  \n (         )        [ ]  [ ]     [ ]      \n [ ]                          (5.16) \n  (         )               [ ]    [ ]    \n      [ ]          [ ]                   \n            {( [ ]  [ ]  [ ]  [ ])} (5.17) \n \nPlaces  Mappings  \n (   )   (Task \u00d7 Res)  \n  (  )   (Task \u00d7 Res -Mat \u00d7 Th_P \u00d7 Th_S)  \n  (     )   (Th_P)  \n  (       )    (Th_P)  \n  (     )   (Th_S \u00d7 Th_Ac \u00d7 Th_Ag)  \n  (     )   (Th_Ac)  \n  (     )   (Th_Ag)  \n  (    )   (Th_S)  \n  (   )   (RI) \n  (   )   (RI) \n  (   )   (RI) \n  (     )   (Th_Co)  \n  (     )   (Task \u00d7 Res)  \n Table 5.2. Places Used in the Model of HLCC and LLCC .",
        "992dd8db-9af7-40c1-914b-0d7793b67fa1": "89 \n \n \nNJ Jobs\nJJ\nRMA\nANew \nJobsHL-CCReq-Pod-TsPTs\nPod-SenRPTsGSRPTs PTs\nVSGet-SRJob-Req-F\nJob-Req-SGS\nVS\nLL-CCRSTs\nRSTs\nSTs\nSTsReq-STs\nLSTs\nAcS AgSASTsASTs\nAgTsAgTsCNodeAsgJAsgJ\nJAsg\nJAsgReq-MReq-MMig-ReqMig-Req\nLSTsReq-Mg\nJob-Alloc\nSen-Read\nconconAcS-S\nAgS-S\nCN-SGAg\nGCsGAs\nGAgGAs\nGCsGetSR\nGetSRA\nAMigrate\nMgRCoSCss\nCTsCoTsCoTs\nconconCoS-S\nCTsCss\nLcRLcR \nFig. 5. 9. The HLCC and LLCC HLPN Model in DC Environment.",
        "8f3eb13b-2c91-4e76-8743-ce731e71aa55": "90 \n If the resources required by the job are available in the resource matrix of resource \nmanager and the thermal signature of the pod for the selected server is less than the maximum \nthermal  threshold, then the jobs are accepted and are placed in the queue, as shown in ( 5.17). \nHowever, if the resources required by the job are not found, then the job will not be accepted. \nMoreover, if the cyber portion is running in full capacity, then the job  will also be rejected, as in \n(5.16). The resource manager instructs HLCC and LLCC to provide the list of all the pods and \nservers that are suitable for the resource allocation. In response, the HLCC provides the thermal \ninformation of the pods to resource  manager, as shown in ( 5.18), and LLCC will send the list of \nall the servers that satisfy the constraint,                      , as in ( 5.19). \n  (          )       [ ]                       [ ]        \n           [ ]    {  } (5.18) \n  (       )      [ ]           [ ]          [ ]          \n  [   ]  {    [ ]     [ ]                    [ ]     [ ]} \n               {(   [ ]   [ ]   [ ]   [ ])} (5.19) \nThe HLCC acquires the     through heat sensors that are placed at each pod ( Fig. 5. 5). \nMoreover, the LLCC acquires the    and      from the heat sensors placed at every node \nwithin the pod. The HLCC and LLCC periodically read the values from the sensors, shown in \n(5.20) and ( 5.21), respectively. When the resource manager request for t he thermal \ninformation of the pods and servers, the HLCC and LLCC sends the updated values read \nfrom the sensors. The transitions         and          performs the aforementioned \nreadings for HLCC and LLCC, respectively. The rules for the transi tions are:  \n  (      )                             \n           {( )}    \n(5.20)",
        "ad79d576-aaa3-40b1-8d5f-cd7018ba4187": "91 \n   (        )                                                   \n   [ ]          [ ]          [ ]        \n                 {(    [ ]    [ ]    [ ])} (5.21) \n (   )                                             \n                [ ( )]           \n     [ ( )]        [ ]                     \n     (  ( )   ( ))    [ ( )]             \n     [ ( )]       [ ]                        (   [ ( )]    [ ( )])   \n   [ ( )]                 [ ( )]        [ ]                        \n     (   [ ( )]    [ ( )])   \n   (  ( ))      (  ( )) {(   ( )[ ]   ( )[ ])} \n     (  ( ))      (  ( ))   {(   ( ) [ ]   ( ) [ ])} (5.22) \nIf (5.17) is fired, then the job is assigned to the selected server and the resources are allocated to \nthe task, as in ( 5.22). As stated in the previous section, to maintain a specified thermal \ntemperature at different levels of CPS, the HLCC and LLCC performs task migration and traffic \nredirections based on the thermal signatures of the nodes.  The transition     performs the \nmigrations and redirection within the same pod, termed as LcMg and LcRd, respectively.  \nWhenever the therma l signatures of        and   are raised more than the specified \nmaximum thermal threshold, the ( 5.22) is fired. The ( 5.22) makes local redirection and migration \nby exploiting the functionalities of LLCC. The inter -pod migration is achieved by the mutual \ncommunication of HLCC and LLCC. When migration or redirection is not possible locally, then \nLLCC requests HLCC to provide the information about the pods where the tasks can be",
        "7820b8eb-f1be-4efe-abc5-a1083d71d6db": "92 \n migrated, as depicted in ( 5.23). Moreover, inter -pod migration is also performed  when the \nthermal signature of   exceeds the specified maximum thermal threshold, as illustrated in ( 5.24).  \n   (      )                                  [ ]         \n       (  [ ( )]                )       ( )    \n      (  [ ( )]                 )        ( )   \n     (  [ ( )]                 )        ( )      ( )             \n                 (  ( )    ( )   ( )    ( )    ( ))   \n   (  ( ))      (  ( )) {(   ( )[ ]   ( )[ ])}  \n   (  ( ))      (  ( ))   {(   ( ) [ ]   ( )[ ])} (5.23) \n (       )=                                     \n   ( )                 ( ( )  (  )     )  (  )              (5.24) \nTo explain the process of verification, a Kripke structure and an example comput ational \ntree of the HLCC and LLCC are formulated and depicted in Fig. 5. 10 and Fig. 5. 11, respectively. \nThe properties are specified in CTL*. One property to verify the models is that, there will be no \nhotspots (overheating) in CPS . If we closely analyze Fig. 5. 10 and Fig. 5. 11, we can see that \nNew Job RM\u03b3 \nProcessingPod\n\u03b1 \u03b4 SOver \nHeat\nLLCCControl \nStrategy\nAction\nCompleteHLCC\n \nFig. 5. 10. The Kripke Structure of HLCC and LLCC for the Verification.",
        "a1f526e2-34fb-4fa7-82f4-b1649ab89309": "93 \n whenever the    (OverHeat) state is reached, the control strategies perform certain actions, such \nas task migration and redirection (as discussed in above sections) to stabilize the temperature at a \ndesired level, which is    (Processing) state. For the models to b e correct, the solver should be \nable to find a terminating state in a model. The failure transitions are considered as a terminator \nof the models. Moreover, the other terminating state in the models is the last state when the jobs \nare successfully complete d. The state    (Complete) in Fig. 5. 11 is reachable from every path of \nthe tree, stating that the model will terminate after certain number of iterations. The states \nlabeled with \u201c  \u201d represents, that from the point forward the tree will repeat the predecessor. We \nhave specified the properties of the control strategies in a similar passion and verified whether \nthe properties are satisfied by the models.  \nNJ\nRM\nRM HLCCPod\nPoDPrHLCC\nRM Pr Pod HLCC Cm Pr OH\nx x xCS\nAct\nPr\nCm Pr OHCm Pr OH\nx x\nx xPoD RM Pr\nx xCm Pr OH\nCS\nAct\nPr\nCm Pr OHCm Pr OH\nx x \nFig. 5. 11. Computational Tree for the Kripke Structure in Fig. 5. 10.",
        "a9d52e14-7fc9-442e-bbd6-b62c57cc5aaa": "94 \n  \n5.5. Results and  Discussion  \nTo demonstrate the capacity of our work, we simulate the proposed strategies on a real \ndata center workload obtained from the Center of Computational Research (CCR), State \nUniversity of New York at Buffalo. All jobs submitted to the CCR are lo gged for a period of a \nmonth. The jobs and the logs from the CCR dataset are used as an input for our simulation of the \nproposed thermal aware strategy. The dataset had 22,700 jobs (127,000 tasks) recorded in one \nmonth of a time. Moreover, we also evaluate  the proposed TACS by comparing with a classical \nFirst Come First Serve (FCFS), Genetic Algorithm (GA) based thermal aware scheduling [5.23], \nand Thermal Aware Task Allocation [5.18] approaches.  \nWe perform the comparison among the mentioned strategies bas ed on the CCR dataset. \nBefore going deeper into the details of the comparison, we first briefly discuss the existing \napproaches. The FCFS (sometimes referred as first -in, first -out) is possibly the most \nstraightforward scheduling approach. The jobs are sub mitted to the scheduler, which dispatches \nthe jobs based on the order of the jobs received.  \nThe FCFS policy is intuitively fair, allowing the jobs that are submitted first to execute \nfirst. However, the policy is not preemptive and long running jobs can c ause delay to other \nfollowing jobs. The approach in [5.23] follows the steps of GA. The first step is to construct a set \nof feasible solutions, which is the task allocation to the servers. Then, the selected solution is \nmutated (randomly interchange the ta sk allocations within the solution) and mated (randomly \nselect pairs of solution and exchange the subset of two task assignment to get two new \nsolutions). The fitness function, which checks the highest inlet temperature of the selected \nassignment, is appli ed to all of the solutions that are formed as a result of mating and mutation,",
        "f560054c-9774-449b-83e8-358f7979b2e1": "95 \n including the original solution. Finally, the solution having the lowest inlet temperature value \nfrom the set of highest inlet temperature values, obtained as a result of fitnes s function, is \nselected as a final solution. The last approach is TASA proposed in [5.18], which is based on the \ntheory of coolest inlet that perform the assignment of hottest jobs to the coolest servers. The \nTASA algorithm sorts the servers in the increas ing order of the temperatures, such that the \ncoolest server is first in the order. The jobs are sorted in a similar way but in the reverse order, \nsuch that the hottest job is first in the order. The hottest job is assigned to the coolest server and \nthe the rmal map of all the servers is updated. The same process is repeated until the last job is \nallocated to the server.  \nFig. 5. 12 depicts the average thermal signatures of the servers over the period of time, \nwhen the scheduling approaches are used. The epoch  time stamp and average thermal signature \nof the servers at that particular time are plotted on x -axis and y -axis in Fig. 5. 12. There were 33 \npods in the DC and each pod has 32 servers. The thermal readings were taken after every 10 \nminutes. It can be obse rved from the Fig. 5. 12 that the spread or the difference between the \ntemperatures of the servers in the trend line of Fig. 5. 12(a), (b), (c) is very wide at many time \nstamps. The aforesaid, identify the situation when the average temperature of some serve rs is \nlower than the rest of the servers in the DC. Particularly, at time stamps 1.2357E+9, 1.2362E+9, \nand 1.2372E+9 in Fig. 5. 12 (a), (b), (c), the thermal signatures of some servers are very low as \ncompared to the rest, which shows the probable presence of the hotspots in DC. The possible \nreason for the occurrence of the hotspots in Fig. 5. 12(a) is the static assignment of tasks without \nconsidering the thermal status of the server that possibly creates a scenario when hot jobs are \nassigned to hot servers and cold jobs are assigned to cold ones.",
        "e81a0cd0-4be3-462e-ab2c-cb7d58d0f445": "96 \n  \n \n(a) \n \n(b) \n \n(c) \n \n(d) \nFig. 5. 12. Comparison of Average Thermal Signatures of the Pods Using: (a) FCFS, (b) GA -based, \n(c) TASA, and (d) TACS.  \n1.235 1.2355 1.236 1.2365 1.237 1.2375\nx 109708090100110120130140\nTimeTemperature\n  \n1.235 1.2355 1.236 1.2365 1.237 1.2375\nx 109708090100110120130140\nTimeTemperature\n  \n1.235 1.2355 1.236 1.2365 1.237 1.2375\nx 109708090100110120130140\nTimeTemperature\n  \n1.235 1.2355 1.236 1.2365 1.237 1.2375\nx 109708090100110120130140\nTimeTemperature",
        "0097dcf4-3d6c-46c1-acd2-b60561de49ff": "97 \n In Fig. 5. 12(b), the reason for the imbalance thermal signat ures is the random nature of \nthe GA based approach. The selection of the feasible solution, the mutation, and the mating \nprocess, all are based on randomization. If the same set of pods and servers are selected in the \nsolutions most of the time, then the f itness function performed on the selected solution will not \nprovide any important information that will avoid the occurrence of the hotspots. Similarly, there \nis also a possibility that the number of tasks allocated to few pods and servers are relatively l ow \nas compared to the rest of the pods and servers in the DC. The aforementioned possibilities will \nallow some servers to have high thermal signatures while others have low thermal signatures, \nwhich will ultimately cause the hotspot in the DC. In Fig. 5. 12(c), which is better than (a) and \n(b), still has low thermal signatures of some servers as compared to the rest, which results in the \noccurrence of hotspots. The reason for the aforesaid is that the hottest tasks are allocated to the \ncoolest servers regard less of the overall thermal temperature of the pod and the recirculation \neffect that can cause the hotspots.  \nIn TACS, as shown in Fig. 5. 12(d), the differences of the temperatures amongst the \nservers are low and there are no hotspots. As stated in Section s 5 and 6, the selection of the pods \nand servers to allocate the task is based on the thermal signatures. Moreover, the HLCC and \nLLCC periodically monitor the thermal signatures of the pods and servers, and perform task \nmigration or redirection to maintain  unified range of temperatures in the pods. Therefore, the \ntrend of thermal signatures followed in Fig. 5. 12(d) is more congested and unified as compared \nto the trend followed in rest of the approaches. We plot the average difference between the \nhottest an d coolest servers over the period of time (as shown in Fig. 5. 13 and 14). The larger and \nmore frequent the differences are, the higher the thermal imbalance will be. We can see that the \ndifferences in TACS (d in Fig. 5. 13) are very low and less frequent as  compared to the other",
        "216c877d-8aac-400d-bbab-470991dc8d5c": "98 \n  \n(a) \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n(b) \n \n \n(c) \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n(d) \nFig. 5. 13. Comparison o f Averag e Thermal Signature Difference b etween the Highest \nand Lowest Servers Using : (a) FCFS, (b) GA -based, (c) TASA, and (d) TACS.",
        "6a6e14a9-3691-4527-bab0-8ddf75a23ef2": "99 \n approaches tha t indicate the thermal balance achieved by using TACS. However, the other \napproaches have high differences and are occurring frequently, which indicates the thermal \nimbalance and occurrence of the hotspots.  \nAs stated in previous sections, we also perform the verification of the strategies using \nSMT -Lib and Z3 solver. To verify, the HLPN models are first translated into SMT. Moreover, \nthe properties are also specified in SMT. Then, the models along with the properties are provided \nto the Z3 solver, which checks if the properties are satisfied by the models or not. It is \nnoteworthy, that the goal of the verification is to demonstrate the correctness of the models, \nbased on the desirable properties, such as the presence of the hotspots. The results in Fig. 5. 15 \ndepict the time taken by the Z3 solver to check the satisfiability of the models, based on the \nstated property. The property we verify is that, there must be no hot spots in the DC after the task \nallocation is complete. To accommodate the random behavior of GA based scheduling, we \nperform the verification of the strategies iteratively for different number of jobs, varying from 10 \nto 100 jobs, as shown in Fig. 5. 15. Th e verification results matches with the simulation results \nand no hotspots were identified by the Z3 solver when the proposed TACS was used. However, \n \nFig. 5. 14. Average Thermal Signature Differenc e between the H ighest and Lowest Servers.  \n1.235 1.2355 1.236 1.2365 1.237 1.2375\nx 109051015202530354045\nTime StampTemperature Difference\n  \nFCFS\nGA-based\nTASA\nTACS",
        "29688276-5e86-4cfd-b0a7-8259cb490c4a": "100 \n hotspots were  identified by the solver for the other scheduling approaches at different no. of jobs, \nas sh own in Table 5.3.   \n \n \n# of Jobs  FCFS  GA-based  TASA  TACS  \n10 Unsat  Unsat  Unsat  Unsat  \n20 Unsat  Unsat  Unsat  Unsat  \n30 Unsat  Unsat  Unsat  Unsat  \n40 Unsat  Unsat  Unsat  Unsat  \n50 Unsat  Sat Unsat  Unsa t \n60 Sat Sat Unsat  Unsat  \n70 Sat Sat Unsat  Unsat  \n80 Sat Unsat  Sat Unsat  \n90 Sat Unsat  Sat Unsat  \n100 Unsat  Sat Unsat  Unsat  \n  \nFig. 5. 15. Verification Time Comparison of the Approaches.  \nTable 5.3. Verification Outcomes of S cheduling Approaches . \nNo. of JobsExec. Time (msec)\n00.050.10.150.20.250.30.350.40.450.50.550.60.65\n10 20 30 40 50 60 70 80 90 100TACS\nGA-based\nFCFS\nTASA",
        "577ec128-b6bc-4167-8725-d8ba77647e80": "101 \n We used bounded model checking technique for the verification and in our case, the \nexecution time serve as a bound over the verif ication models. As stated in Section 6, the solver \nreturns \u201csat\u201d if the stated assertion is not true, which means that the property is violated. If the \nproperty is met by the model, then the solver will return \u201cunsat\u201d, which shows that solver is \nunable to find the values for which the property is not true. The simulation and verification \nresults reveal that our strategy is consistent and provides better results as compared to the other \nscheduling approaches. The occurrence of the hotspots may cause servers to throttle down, \nincreasing the possibility of failure. We reduce the possibility of hotspots in our strategy through \nstrategic decisions performed by HLCC and LLCC based on the thermal signatures of the \ncomponents.  \n5.6. References  \n[5.1]  R. Buyya, S.Y. Ch ee, and S. Venugopal, \u201cMarket -Oriented Cloud Computing: Vision, \nHype, and Reality for Delivering IT Services as Computing Utilities,\u201d IEEE HPCC, pp. 5 -13, \n2008.  \n[5.2]  S. U. R. Malik, S. U. Khan, and S. K. Srinivasan, \"Modeling and Analysis of State -of-\nthe-art VM -based Cloud Management Platforms,\" IEEE Transactions on Cloud Computing, pp. \n50-63, 2013.  \n[5.5.3]  J. Hamilton, \u201cCost of power in large -scale data centers,\u201d \nhttp://perspectives.mvdirona.com, Nov. 2008.  \n[5.5.4]  U.S. Environmental Protection Agency (EP A). Report to congress on server and data \ncenter energy efficiency, public law 109 -431, Aug. 2007.  \n[5.5.5]  L. Wang, S. U. Khan, and J. Dayal, \"Thermal Aware Workload Placement with Task -\nTemperature Profiles in a Data Center,\" Journal of Supercomputing, vol . 61, no. 3, pp. 780 -803.",
        "e7044768-ad32-4f61-953d-31296aa0ed2c": "102 \n [5.5.6]  J. Shuja, S. A. Madani, K. Bilal, K. Hayat, S. U. Khan, and S. Sarwar, \"Energy -Efficient \nData Centers,\" Computing, vol. 94, no. 12, 2012, pp. 973 -994. \n[5.5.7]  J. Moore, J. Chase, P. Ranganathan, and R. Sharma, \u201cMaking sche duling \"cool\":  \ntemperature -aware workload placement in data centers,\u201d In USENIX, pp. 61 -75, 2005.  \n[5.5.8]  L. Ramos and R. Bianchini, \u201cC -oracle: predictive thermal management for data centers,\u201d \nSymposium on High Performance Computer Architecture, pp. 111 \u2013122, 2008.  \n[5.5.9]  L. Parolini, B. Sinopoli, B. Krogh, and W. Zhikui, \"A Cyber \u2013Physical Systems Approach \nto Data Center Modeling and Control for Energy Efficiency,\" Proceedings of the IEEE, vol. 100, \nno. 1, , 2012, pp. 254,268.  \n[5.5.10]   L. Parolini, N. Toli az, B. Sinopoli, and B. H. Krogh, \u201cA Cyber -Physical Systems \napproach to energy management in data centers,\u201d Conference on Cyber -Physical Systems, 2010.  \n[5.5.11]   Y. Cho and N. Chang, \u201cEnergy -aware clock -frequency assignment in \nmicroprocessors and memory de vices for dynamic voltage scaling,\u201d IEEE Transactions on \nComputer -Aided Design of Integrated Circuits and Systems, vol. 26, no. 6, 2007, pp. 1030 \u20131040.  \n[5.5.12]   H. Aydin and D. Zhu, \u201cReliability -aware energy management for periodic real -\ntime tasks,\u201d IEEE Transactions on Computers, vol. 58, no. 10, 2009, pp. 1382 \u20131397.  \n[5.5.13]   P. Choudhary and D. Marculescu, \u201cPower management of voltage/frequency \nisland -based systems using hardware -based methods,\u201d IEEE Transactions on VLSI Systems, vol. \n17, no. 3, 2009.  \n[5.5.14]   A. Varma, B. Ganesh, M. Sen, S. Choudhury, L. Srinivasan, and B. Jacob, \u201cA \ncontrol -theoretic approach to dynamic voltage scheduling,\u201d International CCASE, pp. 255 \u2013266, \nOct. 2003.",
        "c99f2f40-fc6b-491e-9695-aaaf85d57928": "103 \n [5.15]   J. Leverich, M. Monchiero, V. Talwar, P. Ranganathan, and C.  Kozyrakis, \u201cPower \nmanagement of datacenter workloads using per -core power gating,\u201d Computer Architecture \nLetters, 2009, vol. 8, no. 2, pp. 48 \u201351. \n[5.16]   Z. Jian -Hui and Y. Chun -Xin, \u201cDesign and simulation of the cpu fan and heat sinks,\u201d \nIEEE Transactions  on Components and Packaging Technologies, vol. 31, no. 4, 2008, pp. 890 \u2013\n903. \n[5.17]   A. Mutapcic, S. Boyd, S. Murali, D. Atienza, G. Micheli, and R. Gupta, \u201cProcessor \nspeed control with thermal constraints,\u201d IEEE Transactions on Circuits and Systems,  vol . 56, no. \n9, pp. 1994 \u20132008.  \n[5.18]   L. Wang, V. Laszewski, G. Dayal, J. He, X. Younge, and T. R. Furlani, \u201cTowards \nthermal aware workload scheduling in a data center,\u201d International Symposium on Pervasive \nSystems, Algorithms, and Networks, pp. 116 -122, 200 9.  \n[5.19]   J. Moore, J. Chase, and P. Ranganathan, \u201cWeatherman: Automated, online and \npredictive thermal mapping and management for data centers,\u201d IEEE ICAC, pp. 155 -164, 2006.  \n[5.20]   N. Tolia, Z. Wang, P. Ranganathan, C. Bash, M. Marwah, and X. Zhu, \u201cUn ified power \nand cooling management in server enclosures,\u201d in InterPACK, pp. 721 \u2013730, 2009.  \n[5.21]   C. Bash, C. Patel, and R. Sharma, \u201cDynamic thermal management of air cooled data \ncenters,\u201d Thermal and Thermomechanical Phenomena in Electronics Systems, pp.  445\u2013452, \n2006.  \n[5.22]   L. Rao, X. Liu, L. Xie, and W. Liu, \u201cMinimizing electricity cost: Optimization of \ndistributed internet data centers in a multi -electricitymarket environment,\u201d International \nConference on Computer Communications (INFOCOM), pp. 1 \u20139, 2010.",
        "105e7217-ffc2-43a7-8cfb-96996809f6ba": "104 \n [5.23]   Q. Tang, S. Gupta, and G. Varsamopoulos, \u201cEnergy -efficient thermal -aware task \nscheduling for homogeneous high -performance computing data centers: A cyber -physical \napproach,\u201d IEEE Transactions on Parallel and Distributed Systems, vol. 19, no. 1 1, 2008, pp. \n1458 \u20131472.  \n[5.24]   M. Anderson, M. Buehner, P. Young, D. Hittle, C. Anderson, J. Tu, and D. Hodgson, \n\u201cMIMO robust control for HVAC systems,\u201d IEEE Transactions on Control Systems Technology, \nvol. 16, no. 3, 2008, pp. 475 \u2013 483. \n[5.25]   M. Toulou se, G. Doljac, V. Carey, and C. Bash, \u201cExploration of a potential -flow-based \ncompact model of air -flow transport in data centers,\u201d American Society Of Mechanical \nEngineers ASME Conference, pp. 41 \u201350, 2009.  \n[5.26]   M. K. Ganai and A. Gupta, \u201cAccelerating hi gh-level bounded model checking,\u201d in \nICCAD, 2006, pp. 794 \u2013801. \n[5.27]   Q. Tang, T. Mukherjee, S.K.S. Gupta, and P. Cayton, \u201cSensor - \nBased Fast Thermal Evaluation Model for Energy Efficient High -Performance Datacenters,\u201d \nICISIP, Dec. 2006.  \n[5.28]   T. Murata , \u201cPetri Nets: Properties, Analysis and Applications,\u201d Proc. IEEE, vol. 77, no. \n4, 1989, pp. 541 -580. \n[5.29]   Lectures on Petri Nets I: Basic Models, Lecture Notes in Computer Science, vol. 1491, \nW. Reisig and G. Rozenberg, eds., Berlin: Springer -Verlag, 1 998. \n[5.30]   J. Desel and J. Esparza, \u201cFree Choice Petri Nets,\u201d Cambridge Tracts in Theoretical \nComputer Science, vol. 40, Cambridge, UK: Cambridge Univ. Press, 1995.",
        "8ab8ad68-40a2-4c56-8f44-fef70e34e64c": "105 \n [5.31]   K. Bilal, M. Manzano, S. U. Khan, E. Calle, K. Li, and A. Y. Zomaya, \"On the \nChar acterization of the Structural Robustness of Data Center Networks,\" IEEE Transactions on \nCloud Computing, vol. 1, no. 1, pp. 64 -77, 2013.  \n[5.32]   N. En and N. Srensson, \u201cAn extensible SAT -solver,\u201d Lecture Notes in Computer \nScience, vol. 2919, 2003, pp. 502 -518. \n[5.33]   C P. Gomes, H. Kautz, A. Sabharwal, and B. Selman, \u201cSatisfiability solvers,\u201d In \nHandbook of Knowledge Representation, 2007.  \n[5.34]   M. Frade and J. S. Pinto, \u201cVerification conditions for source -level imperative programs,\u201d \nTechnical Report DI -CCTC -08-01, University of Minho, 2008.  \n[5.35]   SMT -Lib http://smtlib.cs.uiowa.edu/, accessed Jan. 2013.  \n[5.36]   S. U. R. Malik, S. K. Srinivasan, S. U. Khan, and L. Wang, \u201cA Methodology for OSPF \nRouting Protocol Verification,\u201d Conference on Scalable Compu ting and Communications, Dec. \n2012.  \n[5.37]  C. Barrett, A. Stump, and C. Tinelli, \u201cThe SMT -LIB Standard: Version 2.0,\u201d 8th \nInternational Workshop on Satisfiability Modulo Theories, 2010.  \n[5.38]   L. de Moura and N. Bjorner, \u201cZ3: An efficient SMT solver,\u201d Con ference on Tools and \nAlgorithms for the Construction and Analysis of Systems, 2008.  \n[5.39]   S. Nakajima, \u201cModel -checking Verification for Reliable Web Service,\u201d OOWS, 2002.  \n[5.40]   A. Biere, A. Cimatti, E. Clarke, O. Strichman, and Y. Zhu, \u201cBounded model c hecking\u201d, \nAdvances in Computers, vol. 58, Academic press, 2003.  \n[5.41]   Y. Quemener and T. Jeron, \u201cModel Checking of CL on infinite kripke structures defined \nby simple grammers,\u201d Technical Report RR -2563, INRIA, France, 1995.",
        "00c0074c-cd60-421c-90d0-d279dc027ec6": "106 \n [5.42]   M. Maidl, \u201cThe common fragment of CTL and LTL,\u201d Symposium on Foundations of \nComputer Science, pp. 643 \u2013652, 2000.  \n[5.43]   K. Bilal, S. U. R. Malik, O. Khalid, A. Hameed, E. Alvarez, V. Wijaysekara, R. Irfan, S. \nShrestha, D. Dwivedy, M. Ali, U. S. Khan, A. Abbas, N. Jalil, and S.  U. Khan, \"A Taxonomy \nand Survey on Green Data Center Networks,\" FGCS. (Forthcoming.)  \n[5.44]   L. Cordeiro, B. Fischer, and J. Marques -Silva, \u201cSMT -based bounded model checking for \nembedded ANSI -C software,\u201d ASE, pp. 137 \u2013148, 2009.",
        "52c27e4a-d654-4953-abc0-12ec23ce570e": "107 \n 6. A METHODOLOGY FOR OSPF ROUTING PROTOCOL \nVERIFICATION  \nThis paper is presented in International Conference on Scalable Computing and \nCommunications (ScalCom) , Changzhou, China , December 2012. The authors of the paper are \nSaif U. R. Malik, Sudarshan K. Srinivasan, Samee U. Khan, an d Lizhe Wang.  \n6.1. Introduction  \nData intensive systems, such as data centers, have a real need for tens to hundreds of Gbps \nof bandwidth and deterministic Quality of Service (QoS), which is satisfied by thousands of \nservers interconnected together. Data C enters (DC) gained a great popularity for the provision of \ncomputing resources [6.3]. Amazon, Google, IBM, Facebook, and Microsoft have started to \nestablish data centers that host cloud computing applications in geographically distributed \nlocations [6.2]. DCs contains a pool of computing resources to host applications and store data, \nconnected together using communication medium, such as fiber optics. The performance and \nstability of the network depends on the performance of the routing mechanisms implement ed \nwithin the architecture [6.4]. Routing protocol plays an important role towards the performance \nrealization of large scale networks. Therefore, it is compulsory to verify the working of the \nrouting protocol to ensure reliable communication amongst the s ystems in the network.  \nOpen Shortest Path First (OSPF) is an adaptive routing protocol that is used for Internet \nProtocol (IP) networks to distribute routing information within a single Autonomous System \n(AS) [6.5]. OSPF divides the network into areas, as  shown in Fig. 6. 1 [6.1]. Each area consists of \none or more segments. A segment constitutes the set of routers connected via a common \ncommunication channel, such as Ethernet.  With the rapidly increasing and changing demands of",
        "801373ba-e06c-48a2-8dd5-852876e7def3": "108 \n QoS, modern routing domain, such as DCs need to maintain a very high level of service \navailability. Therefore, OSPF should attain fast convergence in response of topology changes, to \nmeet the demands of modern systems. Moreover, to avoid loss of messages, the information \nflowing with in the data center must be routed correctly by the OSPF. A slight misinformation \ncan cause huge packets loss depending on the size of the network. In the aforementioned aspect, \nwe have verified OSPF protocol using SMT -Lib and Z3 Solver.  \n6.1.1 . SMT -Lib and Z3 Solver  \nSatisfiability Modulo Theories (SMT) is an area of automated deduction for checking the \nsatisfiability of formulas with respect to some logical theory of interest [6.18]. SMT has been \nused in many fields includ ing deductive software verification. Moreover, recent applications of \ncomputer science including planning, model checking, and automated test generation finding, \nalso considers SMT as an important verification tool [6.19]. The solver can be distinguished \namongst the features they provide, such as, underlying logic (example first order or temporal), \nbackground theories, input formulas, and interface. The details about the features can be found in \n[6.30]. Multiple solvers are available that supports SMT -LIB, such as Beaver, Boolector, CVC4, \nMathSAT5, Z3, and OpenSMT [6.19].   \nFig. 6. 1. OSPF Areas and Routers.",
        "0264dfab-c7d2-4cf7-a8e7-9a6686f97e89": "109 \n We used Z3 solver in our study, which is a high performance theorem prover developed at \nMicrosoft Research. Z3 is an automated satisfiability checker. Moreover, Z3 also checks whether \nthe s et of formulas are satisfiable in the built -in theories of SMT -LIB. Readers are encouraged to \nsee [6.20], for the detailed information about the working and commands of Z3 solver. In this \npaper, we propose a novel method to verify the OSPF routing protocol  that incorporate \nDesignated Routers (DRs). The proposed method uses delay information of the router as a \nproperty to verify the protocol. We used the delay information to identify the occurrence of \nevents as an update is received by the corresponding DRs.  The proposed method can scale up the \nverification process by reducing the size of state space and limiting it to a single parameter. We \nused Satisfiability Modulo Theory (SMT -LIB) library and Z3 solver as a tool for the verification \npurpose. Moreover, BRI TE [6.9] topology generator is used to generate the topologies that \nrepresents characteristics similar to those of Internet. There are four steps involved in our \nverification process: (a) we have simulated the detailed implementation of OSPF protocol based  \non the specifications available in [6.12] on a small scale network, (b) we modeled the system and \nspecified the properties, (c) the model and properties in SMT -LIB are given to Z3 -Solver for \nmodel checking, and (d) execution and generation of results.  \n6.2. OSPF Routing Protocol  \nThe OSPF is a link -state routing protocol [6.6]. The link state is the description of the \ninterface of the router (IP address of the interface, mask, type of network, routers connected to) \nand the relationship to other routers. OSP F constructs a topological map of the entire network by \ngathering the link state information from available routers [6.1]. Unlike other routing protocols, \nsuch as Routing Information Protocol (RIP) that uses Bellman -ford vector based algorithms,",
        "5954a31d-68f6-41e9-a6bb-0a8ccc65aa59": "110 \n OSPF intro duces new concepts, such as areas, Variable Length Subnet Mask (VLSM), and route \nsummarization [6.14].  \nTo decrease the intra -area convergence time, a router amongst the routers is selected as a \nDR in OSPF. All other routers on a segment communicate only to  the DR, which cuts the \ninformation flow cost from  (  ) to  ( ) (instead of sending update to every router on a \nsegment the update is sent to a DR and then that DR will flood the update to all of the other \nrouters) [6.6]. Table 6.1 illustrates the type s of routers used in OSPF. The type of router is \nidentified based on the router interface and link states. Do not confuse DR with OSPF router \ntypes. A router can have some interfaces that are designated, which makes a router DR. \nMoreover, different types o f routers generate different Link State Advertisements (LSA), which \nis a way to communicate the routing topology to other router in and outside an area. Table 6.2 \ndepicts some of the basic LSAs supported by the routers. Note, that there are other LSA types  6-\n11, whose information can be found in [6.15].  \n \n \nRouter Type  Description  \nInternal  Router that has all the interfaces in single area  \nBackbone  Router that has at least one interface in backbone area  \nArea Border  Router having at least one interface in b ackbone area and \nanother in non -backbone area  \nAutonomous System Boundary  Router performing route injection from other source \n(RIP, EIGRP) into OSPF domain.  \n \n Table 6.1. The OSPF Routers.",
        "22ef2bef-7e22-49b5-90cc-c45e1f42fefa": "111 \n  \n \n \n6.3.  Problem Formulation  \nThe problem formulation is taken from our previous work in [ 6.31]. However, the \nformulation is modeled accordingly to accommodate the verification aspect of the OSPF \nprotocol. Consider a network composed of   routers. Let    be the ith router, where       . A \nlink between two routers    and    (if it exists) has a communication cost (del) that represents \nthe minimum time for transferring message from    to   , which can be represented by the \nfollowing expression [6.29, 6.31]:  \n,),(),(\nijj i\nj is RRDRRdel\uf062\uf06e\uf02b \uf03d\n LSA Type  Description  Associated Router  Scope  \n1 Describes directly attached link to a \nrouter within an area.  All routers  Intra area  \n2 Describes the number of routers \nattached in a segment. Gives \ninformation about the subnet mask of a \nsegment  DR Intra area  \n3 Describes destinations outside an area \nto flood information from one area to \nanother.  ABR  Inter area  \n4 Describes a route and information to an \nASBR outside the area.  ABR  Inter area  \n5 Defines routes to destinations external \nto OSPF domain.  ASBR  Inter area  Table 6.2. The OSPF Link States and Associated Routers.  \n(6.1)",
        "503dfd26-b198-40bb-a6ab-0803bf99ddb2": "112 \n where  (      ) is the physical distance between    and    ,   is the propagation delay of the \nmedium (optical fiber in our case),   is the size of the message in kilobytes, and     is the \navailable bandwidth between    and    . If the routers are not directly connected, then the \ncommunication cost is the sum of the cost of all links in the shortest path from    to   . Without \nthe loss of generality, we assume that     (     )    (       ), which is a comm on assumption \nin literature [6.29]. Let   be the number of segments within an area and    be the kth segment in \nthat area, where      . Let    be the set of DRs within an area and    is the convergence \ntime (time a router takes to discover the area topology) of     . If a failure occurs (could be a link \nor a router), the routers connected to the failed link or failed router wil l initiate the updates. \n        be a router that initiates an update in response to a failure. Let    be the set of all other \nrouters in the area defined as     ( {  } \n   ) {{   }   }. \nSuppose     gets an update, such as node failure.      will update its link state and forward \nthe updated link state to the DR of segment k (represented as   ). The link state is the \ndescription of the interface of the router (IP address of the interface, mask, type of network, \nrouters connected to) and  the relationship to other routers. The DR will then flood the \ninformation to every other router in the segment after receiving the update. The verification of \nthe routing protocol can be done in two aspects: (a) content verification (if the link state is being \ncalculated correctly) and (b) routing verification (if the information is propagated correctly in a \nsame order). For (a), the Link State Database (LSDB) should be same for all the routers after \nconvergence is achieved, such that       (   )     (     )      (   )    . For (b), let \n  contains the list of router that belongs to segment k in ascending order of     (      )   \n      . All the routers in a segment must receive the updates in a same order as listed in    .",
        "11d4e423-ee3f-4bf4-85ea-03b832a58154": "113 \n (6.2) Let     represent a router    that belongs to    . The time for      to receive the update \n( (   ))  can be calculated as follows [6.31]:  \n (   ) {                                                                         \n          (  )    (      )           \nwhere,  \n (  )          (   )    (      )  \nOther updates, such as change in bandwidth (\u2206    ) are assumed to be local and incur zero \nupdate time. Therefore in ( 6.2), the value of   (   ) for        , is DI. The DI of routers is \nusually four times the \u201cHello\u201d interval, which is the time between consecutive transmissions of \n\u201cHello\u201d packets that are used to indicate the liveliness of nodes. The \u201cHello\u201d i nterval is 10 \nseconds for broadcast and P2P networks, and 30 seconds for all other media [6.2]. The value \nof  (   ) for        is the sum of the time required for    to receive updates and the time \n   takes to deliver updates to     . The value of   (  )  is calculated in ( 6.3), which is the sum \nof   (   ) (the node sending the update to     ) and the communication cost between them, which \nis given as    (      ). Moreover, ( 6.2) and ( 6.3) are used to calculate    based o n the following \nexpression [6.31]:  \n       ( (  )        (      ))  \nThe last router (maximum time taken to receive an update from the corresponding     ) in \n   that receives the update, determines    . Now, using (2), (3), and (4) th e convergence time of \nan area \u03c4 can be calculated as follows:  \n         ((  ))  ((   )    (      ))  (6.3) \n(6.4) \n(6.5)",
        "355b7d7a-1495-483d-a83a-d789087bc424": "114 \n The maximum    amongst all of the segments plus the time when the update is initiated and \nreaches to the respective DR determines the v alue of  . \n6.4. Verification of OSPF Using Proposed Method  \nVerification is the process to demonstrate the correctness of the underlying system [6.16]. \nWe verify the correctness of OSPF through (a) content verification and (b) route verification as \ndiscuss ed in problem formulation. Note that our goal is to verify the correctness and not to \nmeasure the performance of the protocol. Two parameters are required for the verification of the \nsystem, namely specification and properties. We achieved verification thr ough model checking \n[6.17], using SMT -Lib and Z3 Solver. The detailed description for the possible behavior of the \nprotocol (specification) along with the desirable behavior (properties) of the protocol are \nmodeled in SMT and provided to Z3. Given the afor ementioned parameters Z3 can perform a \nverification of the model.  Z3 generates a counter example in case of an error that represents the \nstate or values for which the model is incorrect. If there are no errors, then the model \nspecifications can be fine -tuned until converged to the real system.  The proposed method can \nscale up the verification process by reducing the size of the state space and narrowing it down to \na single parameter. In the following section we will discuss content verification and route \nverification in detail.  \n6.4.1 . Content Verification  \nThe OSPF is a link state protocol and all routers in an area must have the same LSDB in \norder for the protocol to work correctly [6.1]. We assume that the DR is already being elected \nand initial LSDB syn chronization is already being achieved. In content verification, we analyze \nthe state of LSDB for all routers in an area as an update is generated and propagated by the \ncorresponding DR. For content verification, we have simulated the detailed implementati on of",
        "88dacbab-60f1-4e8e-a148-fd2d81e8a71a": "115 \n OSPF on multi -access segments having multiple DRs in one area. The system model and the \nproperty to verify are generated in SMT and are provided to Z3. The property to verify for \ncontent verification is that LSDB should be same for all the routers af ter convergence is \nachieved, such that      (   )     (     )       (   )    . Whenever an update \noccurs, the router initiating an update generates a LSA. The LSA must be propagated to all the \nrouters in an area to have the same view of the topology and to reach the stable state. The \naforementioned is necessary to avoid messag e loss and for the protocol to work properly.  \n6.4.2 . Route Verification  \nThe LSA generated by the routers in case of updates must be propagated to \ncorresponding DR, and then from DR to all other routers in a segment. We propose the use of \ndelay information of routers for route verification.  The delay of routers is calculated using (1) as \ndiscussed in problem formulation. The delay information is further utilized to order the events as \nan update occurs. Maintaining the order of the routers reduces the size o f state space while \nverifying the protocol. If no such information is available, then all scenarios have to be \nconsidered during the verification process. Suppose we have a topology as shown in Fig. 6. 2 \nbelow, with arbitrary delays. The topology has two se gments. Segment 1 ( S1) has six routers ( R0, \nR1, R2, R4, R5, R7) and R2 is the DR ( d1) of S1. Segment 2 ( S2) has three routers ( R3, R4, R6) and \nR3 is the DR ( d2) of S2. Suppose d1 receives an update and   (  )  . Then using (2) we can \ncalculate the   (   ))     . R4 is the connecting router between the two segments. Therefore, \nthe update will be propagated from S1 to S2 through R4. The  (  )      (using (3)).If we want \nto verify the routing, t hen we can compare the difference of update time of routers and DR \n(( (   )   (  ))         ) with    to verify the routing.",
        "e51270c9-c374-43d2-8b99-980f0efb9934": "116 \n We can analyze from Table 6.3 that the  values of (( (   )   (  ))         ) and \n    are identical, which indicate that the routing is done correctly and all the routers are \nreceiving the updates in a correct order and time. If the values are not identical, then the protocol \nmay ha ve a problem.  \n \n6.5. Result and Discussion  \nPerformance realization of large scale networks depends highly on the routing protocols. \nTherefore, it is compulsory to verify the working of the routing protocol to ensure reliable \ncommunication amongst the systems i n the network. To this end, we have simulated the detailed \n0.3 1 2\n3 4 50\n6 70.05\n0.37 0.34\n0.02 0.14 0.25 0.50.6 0.0010.01DR1\nDR2 \nFig. 6. 2. Example Topology and Associated Delays.  \n     ( (   )   (  ))      ( (   )   (  )) \n0.001 (R5)  0.001 -0=0.001  0.25 (R6)  0.53-0.28=0.25  \n0.01 (R4)  0.01-0=0.01  0.27 (R4)  0.55-0.28=0.27  \n0.05 (R1)  0.05-0=0.5    \n0.15 (R7)  0.15-0=0.15    \n0.35 (R0)  0.35-0=0.35    Table 6 .3. Comparison of Update Time and Ordered List of Router for Example. \nTopology.",
        "085497b9-c2f0-44b5-9bda-c5628df86e6a": "117 \n implementation of OSPF, based on the specifications reported in [6.12] for (a) content \nverification and (b) route verification. In OSPF, the routers are usually the Level3 (L3) routers. \nTherefore, we used optical fiber as a communication medium having propagation delay     \n                . Ethernet channels have the Maximum Transmit Unit (MTU) of 1500 bytes \nand in OSPF the fragmentation is usually avoided [6.1]. Therefore, the message size s is kept as \n1KB, which is neither low nor high and which is typically used in the literature for \nexperimentation (modeling, simulation, and testing). (Readers are encouraged to see the work \nreported in [6.7] and [6.8] to get and insight into the typical modelin g and simulation parameters \npertaining to the OSPF modules). Moreover, the bandwidth value of      is kept at 100Mbps, as \nadvocated in [6.9, 6.10, 6.11] for the evaluation purposes. The values of  (     ) are assigned \nfrom within the range of [1 -100] km.  \nFig. 6. 3 depicts the execution time for the content and route verification. For content \nverification the link state for all the routers in an area must be same. To verify the \naforementioned prope rty, we have modeled the simulated system in SMT and generated link \n \nFig. 6. 3. Execution Time for Verification Process.  \n050001000015000200002500030000350004000045000\n10 15 20 25 30Exec. TimeDR=02  \nNo. of Routers  Exec. Time (sec)",
        "4a893f13-4303-433e-8b52-adac128d10cb": "118 \n states for all the routers. When the convergence is achieved, then the link states of all the routers \nare compared with each other to verify the similarities.  For route verification, as d iscussed in \nabove section, the values of (( (   )   (  ))         ) and     must be identical in \norder for the protocol to work properly. The system model is verified to check if the \naforementioned property is satisfied using SMT and Z3 solver . For our implementation using \nSMT -LIB, we used QF_AUFLIA logic [6.19], which is used for closed quantifier -free linear \nformulas over the theory of integer arrays extended with free sort and function symbols.  \n6.6. References  \n[6.1] J. T. Moy, \u2018OSPF; Anatom y of an Internet Routing Protocol\u2019, Addison -Wesley, 1998.  \n[6.2] D. Abadi, \u201cData management in the cloud: Limitations and opportunities\u201d, IEEE Data \nEngineering, Bulletin , Vol. 32, No. 1, 2009, pp.3 -12. \n[6.3] D. Kliazovich, P. Bouvry, and S. U. Khan, \"DENS: Data Center Energy -Efficient Network -\nAware Scheduling,\"  ACM/IEEE International Conference on Green Computing and \nCommunications (GreenCom) , Dec. 2010, pp. 69 -75. \n[6.4] A. Shaikh, C. Isett, A. Greenberg, M. Roughan, and J. Gottlieb, \u201cA case study of OSPF \nbehavior in a large enterprise network\u201d, ACM SIGCOMM Internet Measurement Workshop , \nFrance, 2002.  \n[6.5] A. Caslow, Cisco Certification: Bridges, Routers & Switches for CCIEs. Upper Saddle \nRiver, NJ: Prentice Hall PTR, 1998, pp. 373 -410. \n[6.6] Cisco, \u2018OSPF Design Guide\u2019,  \nhttp://www.cisco.com/en/US/tech/tk365/technologies_white_paper09186a0080094e9e.shtml, \naccessed 04 May, 2012.",
        "157e5d25-665a-4765-a414-2bdcd404701a": "119 \n [6.7] I. Krinpayorm, and S. Pattaramalai, \u201cLink Recovery Comparison Between OSPF & \nEIGRP\u201d, ICICN, 2012, pp. 192 -197. \n[6.8] B. Wang, J. Zhang, Y. Guo, and W. Chen, \u201cFast -Converging Distance Vector Routing \nMechanism for IP Networks\u201d, Journal of Networks , 2010, Vol. 05, No. 9, pp. 1069 -1075.  \n[6.9] HP, \u201cBuilding Virtualization -Optimized Data Center Networks\u201d, Technical Report. 4AA3 -\n3346EN W, HP, 2011.  \n[6.10] R. S. Prasad, M. Murray, C. Dovrolis, K. Claffy, \u201cBandwidth Estimation: Metrics, \nMeasurement Techniques, and Tools\u201d, IEEE Network , 2003, Vol. 17, No. 06, pp. 27 -35.  \n[6.11] G. Wang, D. G. Andersen, M. Kaminsky, K. Papagiannaki, T. S. E . Ng, M. Kozuch  , and \nM. Ryan, \u201cc -Through: Part -time Optics in Data Centers\u201d, SIGCOMM , 2010.  \n[6.12] Moy, J. (April 1998). RFC 2328 \"OSPF Version 2,\" The Internect Society OSPFv2.  \n[6.13] G. Retvari, F. Nemeth, R. Chaparadza, and R. Szabo, \u201cOSPF for Implem enting Self -\nadaptive Routing in Autonomic Networks: A Case Study\u201d, Mid-American Association for \nComputers in Education (MACE) , 2009, pp. 72 -85. \n[6.14] D. Katz, K. Kompella, D. Yeung, \u201cTraffic Engineering (TE) Extensions to OSPF Version \n2\u201d, http://tools.iet f.org/rfc/rfc3630.txt, accessed on 02 May, 2012.  \n[6.15] RFC 2370, the OSPF Opaque LSA Option, IETF Network Working Group 1998.  \n[6.16] Verification, http://en.wikipedia.org/wiki/Verification  \n[6.17] P. Wolper. An Introduction to Model Checking, 1995.  \nhttp:// www.montefiore.ulg.ac.be/~pw/papers/papers.html,  \n[6.18] C. Barrett, R. Sebastiani, S. Seshia, and C. Tinelli. Satisfiability Modulo Theories. \nHandbook of Satisfiability, Vol. 185, chapter 26, pp. 825 -885. IOS Press, February 2009.  \n[6.19] SMT -LIB, http://ww w.smtlib.org/",
        "7d34e240-6120-4e6a-acfc-acd29b3cd64e": "120 \n [6.20] Z3,http://research.microsoft.com/en -us/um/redmond/projects/z3/  \n[6.21] R. de Renesse and A. Aghvami, \u201cFormal verification of ad -hoc routing protocols using \nSPIN model checker\u201d, 12th IEEE Mediterranean Electro technical Conference , 2004,  pp. 1177 \u2013\n1182.  \n[6.22] D. Engler and M. Musuvathi, \u201cStatic analysis versus software model checking for bug \nfinding\u201d, Verification, Model Checking, and Abstract Interpretation, 5th International \nConference , Lecture Notes in Computer Science, 2004, pp. 191 \u2013210. \n[6.23] C. Xiong, T. Murata, and J. Tsai, \u201cModelling and simulation of routing protocol for \nmobile ad hoc networks using coloured Petri nets\u201d, Workshop on Formal Methods Applied to \nDefence Systems in Formal Methods in Software Engineering and Defence Sy stems , 2002.  \n[6.24] V. Vishwanath, L. Zuck, J. Leigh, \u201cSpecification and verification of LambdaRAM \u2013 a \nwide -area distributed cache for high performance computing\u201d 6th IEEE/ACM Conference on \nFormal Methods and Models for Codesign (MEMOCODE) 2008, USA, June 2008.  \n[6.25]. S. Chiyangwa, M. Kwiatkowska, \u201cA timing analysis of AODV\u201d, Formal Methods for \nOpen Object -Based Distributed Systems: 7th IFIP WG 6.1 International Conference \n(FMOODS), (2005).  \n[6.26] D. Obradovic, Formal Analysis of Routing Protocols. PhD Th esis, University of \nPennsylvania (2002).  \n[6.27] S. Das, D. L. Dill, \u201cCounter -example based predicate discovery in predicate abstraction\u201d, \nFormal Methods in Computer -Aided Design, Springer -Verlag , (2002).  \n[6.28] A. Medina, A. Lakhina, I. Matta, and J. Byers , \u201cBRITE: An Approach to Universal \nTopology Generation\u201d, MASCOTS, Cincinnati, Ohio, 2001.",
        "6f91449c-280b-49cd-bb6a-e4f7fc43571c": "121 \n [6.29] Khan, S. U., and Ahmad, I., \u201cA Pure Nash Equilibrium based Game Theoretical Method \nfor Data Replication across Multiple Servers\u201d, IEEE TKDE,  2009, Vol. 21, No.  4, pp. 537 -553. \n[6.30] C. Barrett, A. Stump, and C. Tinelli, \u201cThe SMT -LIB Standard: Version 2.0\u201d, Proceedings \nof the 8th International Workshop on Satisfiability Modulo Theories , 2010.  \n[6.31] S. U. R. Malik, S. K. Srinivasan, and S. U. Khan , \"Convergence Time Analysis of Open \nShortest Path First Routing Protocol in Internet Scale Networks,\" IET Electronics Letters , vol. \n48, no. 19, pp. 1188 -1190, 2012.",
        "f73ca70e-456e-4aa4-816a-946c7c105e26": "122 \n 7. DASCE: DATA SECURITY FOR CLOUD ENVIRONMENT \nWITH SEMI -TRUSTED THIRD PARTY  \nThis paper is submitted  to IEEE Transactions on Cloud Computing (TCC)  and is in the \nsecond round of review . The authors of the paper are Mazhar Ali, Saif U. R. Malik, and Samee \nU. Khan.  \n7.1. Introduction  \nCloud computing has emerged as a promising computing paradigm and has shown  \ntremendous potential in managing the hardware and software resources located at third -party \nservice providers. On -demand access to the computing resources in a pay -as-you-go manner \nrelieves the customers from building and maintaining complex infrastructur es [7.1, 7.13]. Cloud \ncomputing presents every computing component as a utility, such as software, platform, and \ninfrastructure. The economy of infrastructure, maintenance, and flexibility makes cloud \ncomputing attractive for organizations and individual c ustomers [7.32]. Despite benefits, cloud \ncomputing faces certain challenges and issues that hinder widespread adoption of cloud. For \ninstance, security, performance, and quality are a few to mention [7.10, 7.27].  \nThe development and operation of data stora ge sites is ongoing process in organizations. \nOff-site data storage is a cloud application that liberates the customer from focusing on data \nstorage systems [7.10]. Representing system characteristics and capabilities as utility, causes the \nuser to focus o n aspects directly related to data (security, transmission, processing) [7.6, 7.33]. \nHowever, moving data to the cloud, administered and operated by certain vendor requires high \nlevel of trust and security. Multiple users, separated through logical barrier s of virtual machines, \nshare resources including storage space. Multi -tenancy and virtualization generate risks and",
        "12a5a85d-b6da-4da7-b741-4bba5f9af1c1": "123 \n underpins the confidence of users to adopt the cloud model [7.2, 7.3]. Armbrust et al.  [7.1] \nranked data confidentiality and auditing at num ber three in the list of top ten obstacles impeding \nwidespread cloud adoption. Data can be used by the cloud service providers without \nauthorization [7.2, 7.23, 7.4] and can be accessed by other machines in cloud [7.23, 7.3].  \nData being the principal asset  for organizations needs to be secured. Especially, when \ndata must enter a public cloud. To avoid unauthorized access to the cloud data, access control \nmechanism must be enforced [7.16, 7.17]. Moreover, data leakage and data privacy strategies \nmust be empl oyed so that only authorized users can access and utilize data. Refraining cloud \nservice providers from utilizing the customer data requires high preventive measures [7.3]. \nEncryption techniques provide a solution to ensure privacy and confidentiality of s tored data. \nHowever, key management becomes a prime issue in the case of encryption [7.28, 7.31]. \nCryptographic keys need to be stored and protected. Compromise or failure of a key storage \nfacility may lead to the loss of data. Therefore, cryptographic key s must be stored in a robust \nmanner and a single point of failure should not affect the availability of data [7.31].  \nThe security concerns of outsourcing data to public clouds, serves as our motivation to \nwork for the development of data security technique . We aim for a technique capable of \naddressing the aforementioned critical issues. We propose a data security scheme that uses key \nmanager servers for the management of cryptographic keys. Shamir\u2019s ( k, n) threshold scheme \n[7.26] is used for the management of keys that uses k shares out of n to rebuild the key. Access to \nkey and data is ensured through a policy file that states policies under which access is granted to \nthe keys. The client generates random symmetric keys for encryption and integrity function s. \nSymmetric keys are protected by the public key generated by the key manager(s) ( Fig. 7. 1). All \nof the symmetric keys are deleted from the client afterwards. Encrypted data and keys are",
        "6ddf1184-0550-47f7-b1e7-f41dceb32d4d": "124 \n \n 2, 6 \n 1, 5  \n 3 \n 4 \n2. Client:  \n\uf0b7 Breaks up symmetric key S into n shares ( S1, S2, \u2026, Sn). \n\uf0b7 Encrypts ith share with public key of ith KM  \n\uf0b7 Deletes S  \n6.  Reconstructs S from k shares  according to Shamir\u2019s  strategy.  \n3. Upload all shares of S to cloud.  \n4. Client downloads all s hares of key from  \ncloud.  \nCloud \nKey Manager 1  \nKey Manager 2  \nKey Manager n  \nFig. 7.1. Shamir\u2019s ( k, n) Threshold Scheme in DaSCE.  \n1. Client receives public keys from all Key Managers (KM).  \n5. Client:  \n\uf0b7 selects k number of KMs randomly.  \n\uf0b7 sends ith share of S to ith KM. \n\uf0b7 receives back decrypted ith share.  uploaded to the cloud. For downloading the data, client presents a p olicy file to cloud and \ndownloads the encrypted data and keys. Keys are decrypted by key manager(s). Thereafter, the \nclient decrypts the data.  \nWe review the scheme presented in [7.29], called File Assured Deletion (FADE). The \nFADE is a light -weight and sc alable technique that assures deletion of files from cloud when \nuser asks for deletion. However, during our analysis, FADE fell short on issues of security of \nkeys and authentication of participating parties. Based on our analysis and issues identified wit h \nFADE, we propose enhancements to the scheme and name it as Data Security for Cloud \nEnvironment with Semi -Trusted Third Party (DaSCE) that enhances the security of keys and \nauthentication process. Moreover, to mitigate the man -in-the-middle -attack, we inc luded \nsupplementary steps for the session key establishment process. The aforesaid steps augment the \nsecurity level and prohibit the malicious user to carry out the attack at slight performance \noverheads. However, the results from our verification analysis  revealed that DaSCE is more",
        "50c2b30d-a63b-499c-8282-b630723473c5": "125 \n secure than FADE when man -in-the-middle attack was introduced. Our major contributions \ninclude:   \n\u2022 Development of a security scheme (DaSCE) for outsourced data to cloud that uses a \ncombination of symmetric and asymmetric encrypt ion. The DaSCE ensures data \nconfidentiality at a cloud infrastructure, as long as it is in use by the client. It also \nassures that data gets deleted and becomes unrecoverable after the user deletes it from \nthe cloud.  \n\u2022 Enforcing access control to both data and key through validity of policies and mutual \nauthentication between client and key managers, and client and cloud. Digital \nsignatures and variation of Diffie -Hellman is used for mutual authentication of parties. \nSuccessful authentication and session key  establishment results in access to asymmetric \nkeys that are used in subsequent cryptographic operations.   \n\u2022 Ensuring the integrity of data by use of symmetric key and message authentication \ncode and securing symmetric keys with asymmetric keys generated by  third party key \nmanagers.  \n\u2022 Formal modeling and verification of FADE and DaSCE by using High Level Petri Nets \n(HLPN), SMT -Lib, Z3 solver, and Scyther.  \n\u2022 We implemented a prototype of DaSCE and evaluated the performance of DaSCE \nbased on time consumption para meters (file upload time, file download time, \ncryptographic operations time).  \n7.2. File Assured Deletion (FADE)  \nThe FADE protocol provides privacy, integrity, access control, and assured deletion to \noutscored data. The FADE uses both symmetric and asymmetr ic keys. Symmetric keys are",
        "502e91e6-d477-4e41-9e94-ed39a30f2887": "126 \n protected by using Shamir\u2019s ( k, n) scheme to ample the trust level in the key. The FADE works \nwith a group of key managers (KM). Following keys are used by FADE protocol. The variable K \nis termed as data key and is used to encry pt file F of the client and S as secret key that is used to \nencrypt K. The public/private key pair generated by KMs  is represented by ( ei, di) and is used to \nencrypt S. The K and S are symmetric keys. The operations supported by FADE are: (a) File \nupload, (b) File download, (c) Policy Revocation, and (d) Policy Renewal. The aforementioned \noperations are explained below. The notations used in the paper are presented in Table 7.1.  \n \nNotation  Meanings  \nKM  Key manager  \nF File \nK A symmetric key  \nS A symmetric  key. \nei Public key parameter.  \nni Public key parameter.  \ndi Private key parameter.  \nej Modified/New public key parameter.  \nnj Modified/New public key parameter.  \ndj Modified/New private key parameter.  \n{F}K File encrypted with key K. \n{K}S K encrypted  with key S. \nSe S encrypted with public key e. \nMAC  Message Authentication code  \nHMAC  Hash -based MAC  \nPi Original policy file of client  \nPj Modified policy file  \nHLPN  High Level Petri Net  \nIK Integrity key for MAC calculation  Table 7.1. Notations and Their Meanings .",
        "be1cf7d7-628d-4839-8897-4d2e2af28385": "127 \n 7.2.1 . File Upload  \nWhen data  must be uploaded to the cloud, the client requests the KM to generate a \npublic/private key pair. The said is done by sending a policy file, Pi, to the KM. The KM \ngenerates the key pair, associates that with the Pi, and sends the public part of the key ( ei, ni) to \nthe client. After receiving public key for Pi, the client performs the following cryptographic \noperations. The client encrypts F with K to generate {F} K (F encrypted with K). The K is then \nencrypted with Si to get {K} Si. Subsequently, Si is encryp ted with the public key generated by the \nKM with Pi. The Si is encrypted using asymmetric encryption ( Siei mod n ). The Pi, {F} K, {K} Si, and \n(Sie mod n ) are uploaded to the cloud afterwards. The hashed MAC (HMAC) of data file is also \nuploaded with the encry pted file. The client deletes all of the symmetric keys through secure \noverwriting. The process of file upload is shown in the Figure 2(a).  \nWhen FADE works with full quorum of KMs , Si is divided into n shares and each share is \nencrypted with a public k ey generated by one of the KMs . The key is divided based on Shamir\u2019s \nCloud Client Key manager\nPi\nei , ni\nPi, {K}Si, Siei,{F}K\n \n(a) \nCloud Client Key manager\nPi,SieiRei\nSiRPi, {K}Si, Siei,{F}K \n(b) \nClient Key manager\nPi\n[r]ABE\nHash(r)\nACKRevoke control key \nof PiCloud\n \n(c) \nCloud Client Key manager\nSiR,ej , nj\nPj, SiejPi,Siei \nPi,SieiRei,Pj \n(d) \nFig. 7. 2. FADE (a) File Upload, (b) File Download, (c) Policy Revocation, and (d) Policy \nRenewal (single key manager) [ 7.29].",
        "bbabc408-c4e3-4af4-9f8f-c485d5352ff9": "128 \n (k, n) threshold scheme. To get back the Si, k shares are needed. The FADE protocol does not \nauthenticate the client for the upload process. The process with multiple KMs  is shown in Fig. \n7.3. When data must be uploaded to the cloud, the client requests the KM to generate a \npublic/private key pair. The said is done by sending a policy file, Pi, to the KM. The KM \ngenerates the key pair, associates that with the Pi, and sends the public part  of the key ( ei, ni) to \nthe client. After receiving public key for Pi, the client performs the following cryptographic \noperations. The client encrypts F with K to generate {F} K (F encrypted with K). The K is then \nencrypted with Si to get {K} Si. Subsequentl y, Si is encrypted with the public key generated by the \nKM with Pi. The Si is encrypted using asymmetric encryption ( Siei mod n ). The Pi, {F} K, {K} Si, and \n(Sie mod n ) are uploaded to the cloud afterwards. The hashed MAC (HMAC) of data file is also \nuploaded  with the encrypted file. The client deletes all of the symmetric keys through secure \noverwriting. The process of file upload is shown in the Figure 2(a).  \nWhen FADE works with full quorum of KMs , Si is divided into n shares and each share is \nencrypted with a public key generated by one of the KMs . The key is divided based on Shamir\u2019s \n(k, n) threshold scheme. To get back the Si, k shares are needed. The FADE protocol does not \nauthenticate the client for the upload process. The process with multiple KMs  is shown in Fig. \n7.3. \nCloud Client Key manager 1\nPi\nei1 , ni1\nPi, {K}Si, Si1ei1,\u2026..,SiNeiN,{F}KKey manager N \nPi\neiN , niN \nFig. 7. 3. Fade File Upload with Multiple Key Managers [7.29].",
        "50ee80d9-ba2b-4bb2-b87d-fb7be1089a49": "129 \n 7.2.2 . File Download  \nThe client requests the cloud for file and encrypted keys to download. The client checks \nfor the integrity of the fil e through the HMAC.  Afterwards, the client generates a secret number \nR and calculates Rei and then generates SieRei = (S iR)ei. The (SiR)ei  is then sent to KM for \ndecryption. The KM decrypts (SiR)ei with corresponding di and sends back SiR. At this point,  \nABE comes into the play.  The KM sends SiR with ABE, where the attributes used for ABE are \nbased on Pi. The client extracts Si from the received message and decrypts K that is used to \ndecrypt F. The process is highlighted in Fig. 7. 2(b). Similarly, the fi le download with multiple \nKMs  takes place according to the flow of messages shown in Fig. 7. 4. \n7.2.3 . Policy Revocation  \nIf Pi needs to be revoked, the client requests the KM by sending the Pi. The KM generates \na random number r and sends r to the client after encryption with ABE. The authentic client \ndecrypts r, calculates the hash value, and sends back to the KM. After verification the KM \nrevokes Pi and acknow ledges the client as depicted in Fig. 7. 2 (c).  \n7.2.4 . Policy Renewal  \nIf Pi needs to be renewed as Pj, the client downloads all of the keys and sends Pi and \nencrypted Si to the KM along with Pj. The KM decrypts Si. Moreover, the KM sends new public \nCloud Client Key manager1\nPi,Si1ei1Rei1\n[Si1R]ABEPi, {K}Si, Si1ei1,\u2026..,SiNeiN,{F}K\nPi,SiNeiNReiN\n[SiNR]ABEKey manager N \nFig. 7. 4. File Download Using ABE with Multiple Key Managers [7.29].",
        "6bf67dd4-d336-41e7-90b6-0f1aaa861277": "130 \n key para meters ( ej, nj) to the client as outlined in Fig. 7. 2 (d). We will now formally analyze \nFADE in the following section.  \n7.3. Analysis of FADE  \nThe FADE is a light weight protocol that does not require heavy modifications in cloud \narchitecture. The analysis o f FADE identified the following issues.  \n7.3.1 . File Upload  \nIn file upload process of FADE we assume that there is a man -in-the-middle (intruder) \nbetween client and KM. The intruder can intercept Pi and send Pj (modified Pi) to KM. In the \nsecond step, the KM sends ( ei, ni). The intruder intercepts ( ei, ni) and sends the client modified \nparameters ( ej, nj). The client encrypts the keys with ( ej, nj) and uploads to the cloud. The client \ncannot verify that the received ( ej, nj) is from KM or any other entity. The aforesaid issue is \nhighlighted in Fig. 7. 5 (a).  \nIn the original file upload process of FADE, independence of Step 1 and Step 2 allows \nthe intruder to carry out the attack. The policies received by the KM are neither from the client \nnor does the client receive keys from the KM. However, both assume a valid data exchange with \neach other. As a result, the client encrypts the Si with the ( ej, nj). The encryption of data with the \nintruder\u2019s generated keys may result in any of the following scenarios:  \n7.3.1.1 . Intruder Fetches the Data during  Download Process  \nDuring the download process, the intruder can intercept the data. As Si is encrypted with \n(ej, nj) that is generated by the intruder; therefore, after reviving  Siej intruder can recover Si by \ndecryption w ith a corresponding dj as: Si = (S iej)dj mod n . Once Si is decrypted, the intruder can \neasily decrypt K and gather F.",
        "4436051d-9593-4750-a6c8-0a053042e4cf": "131 \n 7.3.1.2 . Intruder Stays Aside during Download Operation  \nThe client downloads the data from the cloud and sends Si to the KM for decrypti on. As Si \nwas encrypted by the public key that was originally generated by the intruder, the KM will not be \nable to decrypt the correct Si. Therefore, access to the data will be denied. The denial of access \nwill result in the loss of data. The KM generates  the keys based on ABE having policies defined \nin Pi. During the attack, the KM generates the keys with Pj (modified Pi). Therefore, even the \nattributes will not correspond to the original policies. Same attack flow can be modeled for \nmultiple KMs  as shown  in Fig. 7. 6. As highlighted in Fig. 7. 6, all Si\u2019s are encrypted with keys \ngenerated by the intruder and the corresponding di\u2019s are held by the intruder. Therefore, the \nintruder can generate Si. However, intruder must intercept k portions of Si. \n7.3.2 . Policy Renewal  \nFig. 7. 5 (b) shows how the intruder can exploit th e policy renewal process of FADE for \ndenying access of data to a legitimate user. It is noteworthy to mention that the exploitation is \nonly possible if initially the attack depicted in Fig. 7. 5 (a) is already carried out. The client after \ndownloading Si from the cloud sends Si along with Pi to the KM. The intruder intercepts the data, \ndecrypts Si with the corresponding private key, generates a new pair of public/private key, and \nCloud Client Key manager\nPi\nej , nj\nPi,{F}K,{K}Si,SiejPj\nei , niIntruder \n(a) \nCloud Client Key manager\nPi, Siei\nSiR,ej , nj\nPj, SiejPi, SieiRiei\n,Pj \n(b) \nFig. 7. 5. (a) Man -in-the-middle Attack that Causes Encryption with the Wrong Keys (b) \nExploitation of Policy Renewal Process.",
        "c3987031-7bae-425d-bcfe-7a9989dee614": "132 \n sends it to the client. The client performs cryptographic operations (as it did  earlier) and uploads \nthe data and keys to the cloud.  \n7.3.3 . Attack Verification through Scyther  \nIn this section, we verify the a ttack defined in the previous section using Scyther, which \nis a graphical tool for analysis, verification, and falsification of security protocols [7.5]. We \nCloud Client Key manager 1\nPj\nei1 , ni1\nPi, {K}Si, Si1ej1,..,SiNejN,{F}KKey manager N \nPi (for KM1)\neiN , niNIntruder\nPi (for KM N)\nPj\nej1 , nj1\nejN , njN \nFig. 7. 6. Man -in-the-middle with Multiple Key Managers.  \n \nFig. 7. 7. Scyther Verification of FADE.",
        "f0dc7427-dbfa-4067-962f-ffa72b76a019": "133 \n modeled FADE in Scyther and verified whether Si and F remain secret under the setup or \notherwise. T he verification is performed by a \u201cclaim\u201d (see Fig. 7. 7) that Si remains secret during \nthe process. The Scyther verified the validity of the claim and reported the attack that was \ndiscussed in Section 4.1.   \nIn Scyther, Charlie plays a role of a client, Bo b as the KM, Alice as the cloud, and Eve as \nthe intruder. The Run# 1 of the Scyther is not an intercepted run while Run#2 is a run where \nintruder plays the part. Eve intercepts the Pi and sends Charlie the generated public key pk(Eve). \nLater on Eve can use  corresponding private key sk(Eve) to decrypt the secret key of Charlie \n(sk(Charlie )). In this model, sk(Charlie ) is the same key as Si, in the explained model. Our claim \nthat Si will remain secret is falsified by Scyther by producing the counter attack.  \n7.3.4. HLPN  \nPetri Nets provide graphical and mathematical representation of the system and can be \napplied to variety of systems for instance stochastic, deterministic, and asynchronous \ncomputations [7.24]. A HLPN is a 7 -tuple   (               ), where P is set of places; T \nrefers to the set of transitions such that       ; Flow relations are defined by F such that   \n(   ) (   );   maps places P to the data types. Rules for transitions are defined by Rn; L \nis a label on F and M0 represents the initial marking [7.24]. In the above definition, the structure \nof the Petri Net is given by P, T, and F; whereas, (       ) provide the static semantics of the \nPetri Net model.  \n7.3.5 . SMT -Lib and Z3 Solver  \nSMT has roots in Boolean Satisfiability Solvers (SAT) [7.11, 7.12, and 7.22]. SMT -Lib \nprovides a common input platform and benchmarking framework that helps in the evaluation of \nthe systems. We use Z3 solver with SMT -Lib that is a theorem prover developed at M icrosoft",
        "16fa0aaa-531b-422e-9606-5d0b99425736": "134 \n Research. Z3 is an automated satisfiability checker. In addition, Z3 determines whether the set of \nformulae are satisfiable in the built -in theorems of SMT -Lib [7.21].  \n7.3.6 . Verification through HLPN Model  \nIn this section, we formally analyze th e man -in-the-middle attack on FADE protocol. We \nuse High Level Petri Nets (HLPN) and Z language [7.8, 7.11, 7.12, 7.22, 7.24, and 7.25] to \nperform formal analysis. HLPN define mathematical properties for the system and simulate the \nsystem to analyze the be havior. We verify HLPN model of FADE using Satisfiability Modulo \nTheories Library (SMT -Lib) and Z3 solver. To verify the model, the Petri Net model is first \ntranslated into SMT along with the specified properties. Subsequently, Z3 solver is used to \ndetermi ne whether or not the properties hold.  \n7.3.7 . Formal Verification  \nThe verification process checks for the correctness of the system. In model checking: (a) \ndescription of the system is provided stating properties or rules of the system, (b) system is \nrepresented by a model, and (c) some verification tool is used to check whether the model holds \nthe specified properties or not. In this paper we use the bounded model checking to verify the \nman-in-the-middle attack on FADE.  \nThe HLPN model for FADE is given i n Fig. 7. 8. The model is given with the intruder \nbetween the client and KM. The data types used in the model and their mappings are shown in \nTable 7.2  and Table 7.3 , respectively. All the rectangular black boxes in HLPN are transitions \nand belong to the se t T. The circles are places and belong to the set P.",
        "4b3ce2bc-4be2-4ae0-8d71-a54d12af45fc": "135 \n  \n  \n Types  Description  \nPolicy  A string type for describing file access policy.  \nFile A string type holding data to be protected.  \nK A string type representing symmetric key.  \nS A string type represent ing symmetric key.  \ne Public Key parameter.  \nn Public Key parameter.  \nd Private Key parameter.  \n{F} K File encrypted with key K. \n{K} S K encrypted with key S.  \nSe S encrypted with public key e.  Table 7.2. Data Types Used in FADE HLPN Model.",
        "9bbe6002-47d6-49ab-9976-dbcd1b6e9a51": "136  \na1 X1 c1Send_Pi\nX7\nX17\nX16Pi\nX3Rcv_Pi\nI1 X4Pi\nX5Gen_fake\nI2X6Send_Pj\nc2 X8Pj\nX9Rcv_Pj\nX10b1\nX11\nGen_Keys\nb2 X13Send_Key\nc3 X14 X15 Rcv_KeyX18\nSend_fake_Keyc4 X19 X20X12\nRcv_fake_Key\nX21\na2X2\nX22X23\na3\nX25Encr_data\nSnd_data_to_cloud\nKey Manager Client IntruderX24\nX26\n \nFig. 7. 8. FADE HLPN Model w ith Intruder.",
        "4f6f3f90-43e9-4671-8de8-1dd3056591b1": "137 \n The process starts with the client sending Pi to the KM. The file is intercepted by the \nintruder. The file sending and receiving is performed on transitions Send_P i and Rcv_P i. Rule \n(7.1) and Rule ( 7.2) are mapped to the aforesaid transitio ns. \n (       )                          [ ]  \n         {  }, (7.1) \n (     )                            \n         {  }. (7.2) \nThe intruder generates Pj and se nds it to the KM. The transition Gen_fake  is fired upon \ninterception of original Pi. Following are the three transition and the corresponding rules.  \n (       )               [ ]       \n    [ ]         [ ]      \n    [ ]            [ ]   [ ]   [ ]   [ ]  \n         {     [ ]   [ ]   [ ]   [ ]}, (7.3) \n (      )      [ ]               \n       [ ]  \n         {  }, (7.4) \n (     )                                \n           {   }. (7.5) \nThe keys generated and sent by KM are intercepted by the intruder. The Following rules \n(7.6) and ( 7.7) capture the above three transitions.",
        "f4af1c4c-49a4-4ee4-a8d0-cbc362c76dbd": "138 \n  \nTypes  Description  \n (a1)   (Policy \u00d7 File \u00d7 K \u00d7 S)  \n (c1)   (Policy)  \n (I1)   (Policy)  \n (I2)   (Policy \u00d7Policy \u00d7 e \u00d7 n \u00d7 d \u00d7 e \u00d7 n ) \n (c2)   (Policy)  \n (b1)   (Policy)  \n (b2)   (Policy \u00d7 e \u00d7 n \u00d7 d ) \n (c3)   (e \u00d7 n)  \n (c4)   (e \u00d7 n)  \n (a2)   (e \u00d7 n)  \n (a3)   (Policy \u00d7{F} K \u00d7 {K} S \u00d7 Se)  \n (        )                  [ ]           [ ]           [ ]        \n     [ ]            [ ]         [ ]     [ ]    [ ]    [ ]  \n           {   [ ]    [ ]    [ ]    [ ]},  \n(7.6) \n (        )       [ ]           [ ]                  \n   [ ]     [ ]    [ ]    [ ]  \n           {   [ ]    [ ]}, (7.7) \n (       )                  [ ]           [ ]           [ ]      \n   \n     [ ]      \n       [ ]      \n       [ ]      \n       [ ]      \n   [ ]     [ ]    [ ]  \n          {   [ ]    [ ]    [ ]    [ ]    [ ]    [ ]    [ ]}. (7.8) \nThe intruder generates and sends ( ej, nj) to the client as depicted in ( 7.9) and ( 7.10). \n (             )       [ ]           [ ]                  \n   [ ]     [ ]    [ ]    [ ]            {   [ ]    [ ]},  \n(9) Table 7.3. Mapping of Data Types and Places.",
        "13b921b1-1909-47f7-bac4-75d2e04848e3": "139 \n (            )                  [ ]       \n   [ ]     [ ]    [ ]    [ ]  \n           {   [ ]    [ ]}, (7.10) \nThe client performs the cryptographic operations with ( ej, nj) and sends all the encrypted data to \nthe cloud. This is represented by the following rules.  \n (         )                                             \n   [ ]     \n  [ ]     [ ]     [ ]    (   [ ])     [ ]\n     [ ]    (   [ ]  \n   [ ]    [ ]    (   [ ]    [ ])  \n           {   [ ]    [ ]    [ ]    [ ]}, (7.11) \n \n (                 )                           [ ]    [ ]  \n   [ ]    [ ]    [ ]    [ ]     [ ]    [ ]  \n           {   [ ]    [ ]    [ ]    [ ]}. (7.12) \nIn the above, Encr_data  is the most crucial transition. Security of data and the keys are \nhighly dependent on this transition. If the encryption is performed by using ( ej, nj), then the data \nsecurity is compromised. In this context, the pro perty that we verified using SMT -Lib and Z3 is \nthat: if the intruder is present, then the encryption operation is performed using the wrong keys. \nThe property of the model is described using a formal language called Computational Tree Logic \n(CTL*). The CTL * uses numerous temporal operators to represent various operations [7.7, 7.20]. \nFor instance, A represents \u201cfor all paths\u201d, G denotes \u201cglobally\u201d, and F characterizes \u201cfuture \nstate\u201d. The property specified in CTL* using temporal operators is given as:    (        ). \nAfter translating the above model into SMT -Lib, we performed bounded checking using Z3 \nsolver. The mentioned property was satisfied by the solver in 310 msec.",
        "2107cdb3-8d25-4ac4-b503-8bc275b81ec7": "140 \n 7.4. DaSCE  \nFrom Section 4, it is evident that the security of Si in FADE depends on the key exchange \nbetween the client and the KM. If the key exchange is compromised, then Si is compromised, that \nin turn, leaks all the keys and the data.  We observed that the reason for the said attack is the \nindependence of communication steps betwee n the client and the KM that allows the attacker to \nlaunch the attack and subvert the whole process. In this section, we propose improvements in the \ncommunication process between (a) client and the KM, and (b) client and the cloud. Our \nproposed changes lin k the communication steps so as to avoid attacker to overtake the process.  \nWe use the station -to-station (STS) protocol [7.9] and digital signature for authentication and \nsession key establishment before any other exchange takes place. The keys generated by the KMs  \nand policy files are exchanged using session keys. Some modifications are required in the \nsubsequent operations of the protocol as the session keys are introduced to the FADE. The \nfollowing subsections discuss the proposed mechanisms.  \n7.4.1 . DaSCE Keys  \nThe DaSCE makes use of both symmetric and asymmetric keys. The confidentiality and \nintegrity services for data are provided through symmetric keys that are secured by using \nasymmetric keys. Asymmetric key pairs are generated by third party KMs. Ou t of the key pair, \nonly public key is transmitted to the client. For secure transmission of keys, a session key is \nestablished between client and KM through STS protocol. To avoid man -in-the-middle attack, \nboth client and KM are authenticated by use of dig ital signatures. As a new session key is used \nfor every communication session between client and KM, the session key is exchanged through",
        "50c7dee1-c9f2-4c6e-bffe-764d635072ad": "141 \n key exchange process and is not randomly generated. This also avoids weakness of randomly \ngenerated keys. The symmetr ic keys are generated once for data encryption by client and \nencrypted by another symmetric key named Si. The Si is finally protected by the public key \nreceived from KM. The encrypted keys are stored at cloud and client deletes the local copies of \nthe keys . For decryption purpose, client establishes a session with KM and sends Si to KM after \nmasking with random number R. The KM decrypts Si and sends back to client. The client \nunmasks Si to get the symmetric keys. Fig. 7. 9 depicts the key management process.  \n7.4.2 . File Upload  \nFor the establishment of session key, we assume that the parameters required are fixed \nand publically available to all of the users. We call these parameters as \u03b1 and p where, \u03b1 is a \nlarge number known as the primitive root and p is a large prime number. The process comprises \nof following steps.  \n\uf0b7 The client generates a random number x and calculates \u03b1x mod p  and sends to the KM.  \n\uf0b7 The KM generates a random number y and calculates \u03b1y mod p . The KM also calculates \n(\u03b1x)y as a session key, EK, between client and KM.  \n 4, 6 \n  1, 2, 3  \n 5 \n5. Client sends encrypted \nkeys to the cloud.  \n4. Client  performs encryption operations \nover data and symmetric keys  \n6. Deletes local copies of keys.  \nCloud  \nKey Manager  \nFig. 7.9. Key Management in \nDaSCE . \n1. Client initiates session establishment \nand requests for asymmetric keys.  \n2. Client and KM authenticate each \nother and establish session.  \n3. KM generates asymmetric keys and \nsends public part to client  \nClient",
        "d32a181b-3680-41bd-a487-aa19f768f126": "142 \n \uf0b7 The KM generates digital signature over { \u03b1y, \u03b1x} (S KM{\u03b1y, \u03b1x}) and encrypts it with the \ngenerated session key to generate EK(S KM{\u03b1y, \u03b1x}).  \n\uf0b7 The KM sends ( \u03b1y , EK(SKM{\u03b1y, \u03b1x})) to the client.  \n\uf0b7 The client verifies the signature using the public key of the KM and calculates the session \nkey as ( \u03b1y)x.  \n\uf0b7 The client calculates EK(SCli{ \u03b1x , \u03b1y }) and encrypts Pi with EK and sends both of the \ncalculated values to the  KM. The sent message contains EK(SCli{ \u03b1x , \u03b1y }), EK(Pi). \n\uf0b7 The KM verifies the signature of the client. Upon successful verification, the KM \ndecrypts Pi and generates ( ei, ni) with Pi. The KM stores the decrypted Pi. \n\uf0b7 The KM encrypts ( ei, ni) with the EK to generate ( EK(ei, ni)), which is sent to the client.  \n\uf0b7 The client encrypts the file  F with key K, calculates MAC with IK; and encrypts K and IK \nwith Si. Afterwards Si is encrypted with ei. Subsequently, the client sends all the \nencrypted data to cloud.  \n\uf0b7 The client erases all of the keys except public key parameters received from the KM.  \nThe file upload process is shown in Fig. 7. 10. The calculations for session key include mod p \noperation which is not shown in the figure for clarity.  \nCloud Client Key manager\n\u03b1x\nEk(ei,ni)\nPi, {K}si,{IK}Si, Siei,{F}K\u03b1 y,Ek(SKM{\u03b1y,\u03b1x})\nEK(SCli{\u03b1x,\u03b1y}),EK(Pi)\n \nFig. 7. 10. DaSCE File Upload with Single Key Manager.",
        "4eafe9b3-0f3a-4040-b675-4384cfcaaccb": "143 \n Similarly, the file u pload process with multiple KMs  is shown in Fig. 7. 11. With multiple \nKMs , Si is divided into n shares and each share is encrypted with the key from one of the \nmanagers according to ( k, n)-threshold scheme. The interdependencies between file upload steps \ncircumvent the man -in-the-middle attack. If higher level of security is required, then session key \ncan also be established between the client and the cloud to keep the Pi exchange secure.  \n7.4.3 . File Download  \nThe file download process of DaSCE is depicted i n Fig. 7. 12. The process starts with the \nCloud Client Key manager 1\n\u03b1x\nEk1(ei1,ni1)\nPi, {K}si,{IK}Si, Si1ei1,\u2026,SiNeiN,{F}K\u03b1 y1,Ek1(SKM1{\u03b1y1,\u03b1x})\nEK1(SCli{\u03b1x,\u03b1y1}),EK1(Pi)\u03b1x\n\u03b1 yN,EkN(SKMN{\u03b1yN,\u03b1x})Key manager N\nEKN(SCli{\u03b1x,\u03b1yN}),EKN(Pi)\nEkN(eiN,niN) \n \nFig. 7. 11. DaSCE File Upload with Multiple Key Managers . \nCloud Client Key manager 1\n\u03b1x\nEk1(Si1R)Pi, {K}si,{IK}Si, Si1ei1,\u2026,SiNeiN,{F}K\n\u03b1 y1,Ek1(SKM1{\u03b1y1,\u03b1x})\nEK1(SCli{\u03b1x,\u03b1y1}),Si1ei1Rei1, Ek1(Pi)\u03b1x\n\u03b1 yN,EkN(SKMN{\u03b1yN,\u03b1x})Key manager N\nEKN(SCli{\u03b1x,\u03b1yN}),Si1eiNReiN, EkN(Pi)\nEkN(SiNR)\n \nFig. 7. 12. DaSCE File Download with Multiple Key Managers.",
        "94ae4a8b-f07b-47c3-8d5c-6a338a63568f": "144 \n client downloading the data from the cloud. To decrypt F, we need K that is encrypted with Si. \nThe Si is encrypted with ( ei, ni) received from KM. The client establishes the session key with the \nKMs  and during the p rocess both the client and the KMs  authenticate each other through digital \nsignatures. The process of key establishment and authentication is the same as discussed in \nSection 5.2. In the third step, after verifying the authenticity of the KMs , the client g enerates a \nrandom number R and encrypts it with the public key of the corresponding KM. The client then \ncalculates SieiRei and sends it along with its own signature and encrypted Pi. We combine these \nsteps to minimize the communication overhead. The KM after verifying the digital signature of \nthe client decrypts Pi and checks whether the policy still holds or otherwise. If the policy is valid, \nthen the KM decrypts SieiRei with the corresponding di to generate SiR. The purpose of R is to \nmask the actual valu e of Si. The KM encrypts SiR with the session key, which is sent to the client.  \nIt is noteworthy to mention that in FADE, SiR is returned by applying ABE. However, in \nthe DaSCE, we do not use ABE, instead session key is used to send SiR to the legitimate user. \nTherefore, the access control is being managed by the aforementioned technique. The client after \nreceiving SiR extracts Si from SiR. It is important to remember that with multiple KMs , a share of \nSi will be received from at least k KMs . Consequently k number of Sis will be used to generate Si. \nThe client decrypts K and IK using Si. It verifies the integrity of F using IK and decrypts F upon \nsuccessful verification.  \n7.4.4 . Policy Revocation  \nThe same process of key establishment, as discussed in Section  5.2, is used for the policy \nrevocation in DaSCE. The client encrypts Pi with the session key and sends to KM. The KM after \nperforming decryption on Pi revokes the keys generated with Pi. The deleted keys include the \nprivate key di and associated prime num bers pi and qi. It also sends acknowledgement to the \nclient.",
        "91ea0206-039b-47e8-87be-5347491698da": "145 \n When di associated with Pi is deleted, the corresponding Si cannot be decrypted. This \nresults in logical deletion of F as K cannot be decrypted without Si. Therefore, we say that F is \nassuredly d eleted. It is noteworthy that assured deletion does not correspond to the physical \ndeletion of data. It is difficult to get the assurance of file deletion from the system outside the \nadministrative control of data owner. For assured deletion we used the co ncept introduced in \n[7.34] and [7.35], where the inaccessibility of data is assured by deleting certain important \ninformation from the system. The DaSCE ensures the inaccessibility of the keys to make the data \nunrecoverable. Therefore, the main security pr operty of file assured deletion is that even if a KM \ndoes not remove the key from its storage, the data files remain encrypted and unrecoverable. The \nconcept of file assured deletion is also termed as self -destructing data in the literature. For details \nabout file assured deletion, readers are encouraged to see [7.34] and [7.35].  \nTo boost the level of trust in the proposed scheme, the key generation and management is \nnot dependent on a single KM. Shamir\u2019s secret sharing scheme is applied to counter any \nmalicious KM. Any malicious KM cannot get hold of Si independently. At least k number of KMs  \nneeds to be compromised in order to get access of enough di\u2019s that can be used to decrypt Si. It is \nalso noteworthy that for decryption process Si is sent to KM. Howev er, Si is not sent in plain as \ndiscussed in Section 5.3. The Si is masked by multiplication with R. Therefore, even if malicious \nKM keeps the resultant decrypted information, the extraction of Si will remain a challenge. \nTherefore, aforementioned case of m alicious KM seems hard to be translated into successful \nattack. If we build a case of a malicious user that somehow has got hold of some other user\u2019s \nencrypted Si, the malicious user has to go through the authentication process of at least k number \nof KMs  to decrypt the Si. We will see in Section 5.6 that KMs  do not give access to the \nunauthorized users.",
        "c2fa870c-d46c-4caf-94a5-13d710315bb5": "146 \n 7.4.5 . Policy Renewal  \nThe policy renewal does not involve any operation on F. The client dow nloads Si and Pi; \nestablishes session key with the KM; and sends Pi, SieiRei, and Pj to KM by session key \nencryption. The KM decrypts SieiRei to obtain SiR and generates new public/private key pair for \nPj. Therefore, the KM sends SiR and new public paramet ers ( ej, nj) to the client. The client \nextracts Si and re -encrypts it with ( ej, nj). Finally, the client sends Pj and encrypted Si to the \ncloud. Fig. 7. 13 shows the process with single KM. The Pi in Fig. 7. 12 is older policy file while \nPj is the newer poli cy file.  \n7.4.6 . Analysis of DaSCE through the HLPN  \nWe use HLPN to verify that man -in-the-middle cannot forge the encryption keys \nexchanged between the client and the KM.  If the intruder intercepts the messages, then the \nsystem would be able to identify th e attack. The HLPN model for DaSCE is shown in Fig. \n7.14.We assume an intruder between the client and the KM to check the behavior of the protocol \nin the attack scenario. The lines in Fig. 7. 14 connecting ( c1, c2) and ( c3, c4) would be the \ninformation flow  of Xa and Xb, respectively,  if there is no intruder between the client and KM. \nDue to the space limitation and for simplicity we have not given the HLPN of the whole process. \nCloud Client Key manager\n\u03b1x\nEk(SiR, ej,nj)\nPj, Siej\u03b1 y,Ek(SKM{\u03b1y,\u03b1x})\nEK(SCli{\u03b1x,\u03b1y}),EK(Pi, Pj, Siei)Pi, Siei \nFig. 7. 13. DaSCE Policy Renewal.",
        "9f2e29d1-7081-4749-ae57-ac7fb27c6334": "147  \nx\n c1Send _M1Rcv_M1\nI1\nI4Send _M1'\nc2Rcv_M1'\nb1\n b2\nEncryt _M2\nc3Rcv_M2\nc4\na2X2\na4 M1\nKey Manager\n Client\n Intruder\na1\nz\nM1'\nI2\ny\nb3\nSend _M2\nI3I_Cmpt _KIC\nM2'_Sign\nI5\nSend _M2' Rcv_M2'\na3\nSuccess\na6\nI6\nX47\nX48X29\nI7Encryt _M2\n'\nb4X23M2_SignCmpt _KIKM\nCmpt K IC_Decr  \nI_Cmpt K IKM\nX46\na5\n \nFig. 7. 14. HLPN for DaSCE .",
        "7984dba6-a5c9-4ab7-b92c-6f0155e9c8a6": "148 \n  The Fig. 7. 14 only  depicts the process of KM authentication. Nevertheless, the next step \nregarding authentication of client before exchanging keys will be the replication of the steps. \nTherefore, next step will have similar verification results. The associated data types an d the \nmappings of places to data types are shown in Table 7.4 and Table 7.5, respectively.  We assume \nan intruder between the client and the KM to check the behavior of the protocol in the attack \nscenario. The lines in Fig. 7. 14 connecting ( c1, c2) and ( c3, c4) would be the information flow of \nXa and Xb, respectively,  if there is no intruder between the client and KM. Due to the space \nlimitation and for simplicity we have not given the HLPN of the whole process.  \n \nTypes  Description  \nX Big integer type rando m number for client  \n\u0391 Big integer type number  \nZ Big integer type random number for intruder  \nY Big integer type random number for key manager  \nM1 Big integer type number representing \u03b1 power x \nM1\u2019 Big integer type number representing \u03b1 power z \nM2 Big i nteger type number representing \u03b1 power y \ndi Private key of entity i from { Cli, Clo, KM} \nei Public key of entity i from { Cli, Clo, KM} \nKIKM Session key between Intruder and Key Manager  \nKIC Session key between Intruder and Client  \n\u03b3s {M2, M1\u2019}dKM [M2 and M1\u2019 signed with dKM].  \n\u03b3a { \u03b3s } KIKM [\u03b3s  encrypted with KIKM] \nM2\u2019 M1\u2019,( \u03b3a )KIC  [M1\u2019 and \u03b3a encrypted with KIC] \n\u03b3i { M1\u2019, M1}di [M1\u2019and M1 signed with di].  \n\u03b3b { \u03b3i } KIC [\u03b3i  encrypted with KIC] \nEM Error Message (Message not coming from valid KM) Table 7.4. Data Types for HLPN of DaSCE",
        "071904fe-b3b1-4e66-964b-aa26a3eb8381": "149 \n  \n \nTypes  Description  Types  Description  \n (x)  (x)  (b4)  (M2\u00d7\u03b3a) \n (a1)  (M1)  (c3)  (M2\u00d7\u03b3a) \n (c1)  (M1)  (I4)  (M2\u00d7\u03b3a) \n (I1)  (M1)  (I5)  (KIKM) \n (I2)  (M1\u2019\u00d7 KIC)  (I6)  (M1\u2019\u00d7di\u00d7\u03b3i\u00d7 KIKM \u00d7 KIC) \n (I3)  (M1\u2019)  (I7)  (M1\u2019\u00d7 \u03b3b) \n (c2)  (M1\u2019)  (c4)  (M1\u2019\u00d7 \u03b3b) \n (b1)  (M1\u2019)  (a2)  (M1\u2019\u00d7 \u03b3b) \n (b2)  (M2\u00d7 KIKM)  (a3)  (KIC\u00d7 \u03b3b) \n (b3)  (M2\u00d7dKM\u00d7\u03b3s\u00d7 KIKM)  (a4)  (KIC\u00d7 \u03b3b\u00d7eKM) \n \n \nThe process starts with the client requiring an upload of data to the cloud. The client generates a \nrandom numbe r x, calculates its parameters (as explained in Section 5.2), and sends to KM. \nHowever, the intruder intercepts the messages. The aforementioned process is carried out at \ntransitions M1, Send_M 1, and Rcv_M 1. The rules for these transitions are:  \n (  )                        \ud835\udc64(    )  \n         {  }, (7.13) \n (       )                          \n         {  }, (7.14) \n (      )                          \n         {  }. (7.15)  Table 7.5. Mapping of Data Types and Places for HLPN of DaSCE.",
        "21fbb35b-df08-40c8-a02c-dab8a90fde45": "150 \n The transition I_Cmpt_K IC is fired when the intruder successfully intercepts the message \nthat is originated for the KM. The intruder generates its own random number z and calculates a \nkey between the client and itself. The intruder also generates fake message for the KM at \ntransition M1\u2019and sends it to the KM through transition Send_ M 1\u2019. Rules ( 7.16) \u2013 (7.19) are \nmapped to following transitions.  \n (          )                                [ ]   \ud835\udc64(    )  \n   [ ]   \ud835\udc64(     )  \n           {   [ ]    [ ]}, (7.16) \n (     )                                           {   }, (7.17) \n (        )                                \n           {   }, (7.18) \n (       )                                \n           {   }. (7.19) \nThe KM assuming that the message comes fro m the client, calculates the session key by \nthe parameters sent by the intruder. The KM also signs the received and generated parameters by \nthe private key and sends to the client that is actually received by intruder. Following transitions \nand rules corre spond to the explained steps.  \n (          )                                  [ ]   \ud835\udc64(     )  \n   [ ]   \ud835\udc64(       )  \n           {   [ ]    [ ]}  (7.20) \n (       )                                  [ ]    [ ] \n    [ ]     (   [ ]    )    [ ]    [ ]  \n           {   [ ]    [ ]    [ ]}, (7.21)",
        "40a29e82-0a7d-472b-b06e-e298f837d1dd": "151 \n  (         )                         [ ]    [ ]  \n   [ ]        (   [ ]    [ ])            {   [ ]    [ ]    [ ]}, (7.22) \n \n (       )                               \n           {   },  \n(7.23) \n (      )                                \n           {   }. (7.24) \nAfter receiving the message from the KM, the intruder generates the session key between \nthe KM and itself. At this stage, the intruder sets up the keys with both the client and the KM. \nThe intruder prepares a response for the client and sends the prepared response. The response \nincludes the signed parameters. The intruder uses its private key for the signing purpose. The \nclient accepts the response thinking it to be from KM. The following rules highlight the process.  \n (           )                                    \ud835\udc64(   [ ]   )  \n           {   }, (7.25) \n (        )                                         \n   [ ]    [ ]     [ ]     (   [ ]    )     [ ]        [ ]    [ ]  \n           {   [ ]    [ ]    [ ]    [ ]}, (7.26) \n (        )                          [ ]    [ ]  \n   [ ]        (   [ ]    [ ])  \n           {   [ ]    [ ]}, (7.27) \n (        )                                \n           {   }, (7.28) \n (       )                                (7.29)",
        "55200727-22a4-42cd-9d48-20f7e984c114": "152 \n            {   }. \nThe client after receiving the response completes the process of generating the session \nkey. However, the key generated is between the client and the intruder, instead of being betwe en \nthe client and the KM. Following this, the client decrypts the received parameters and verifies the \ndigital signature over them. The verification is performed using a public key of the KM as the \nclient is supposedly interacting with the KM. The verifica tion mechanism gives the false result \nand the client terminates the process. However, if there is no intruder and the communication \ntakes place between the client and KM, then valid signatures will result in information flow \ntowards the place a6 and commun ication will proceed. Following are the transitions and rules for \naforesaid process at the client end.  \n (             )                                \n   [ ]   \ud835\udc64(   [ ]    )     [ ]        (   [ ]    [ ])  \n           {   [ ]    [ ]}, (7.30) \n (           )                                     (   [ ])  \n           {   }. (7.31) \nThe following properties are verifi ed using the SMT -Lib and Z3 solver.  \n\uf0b7 During communication, if state I1 (see Fig. 7. 14, intruder side) is achieved (that means \nthe intruder intercepts communication), then the control will terminate at state a5 \nwhich represents a failure to authenticate the  KM and the process terminates. The \nproperty in CTL* is represented as    (        ) \n\uf0b7 If there is no intruder and communication progresses on normal course (through lines \nXa and Xb in Fig. 7. 13), then the control will flow until it reaches a6, which represents",
        "871fce18-2985-425e-bdc8-1153cdc284c6": "153 \n success for authentication and secure exchange of the require d key. CTL* property is \n   (     (      )) \nBoth of the properties are verified in SMT -Lib using Z3 solver that approximately took \n321 msec.  \n7.5. Implementation and Performance Evaluation  \nWe used C# for implementing a working prototype of DaSCE. The  .Net cryptographic \npackages were used for the involved cryptographic operations. Large prime numbers were \nhandled by using the BigInt class. Policies were uploaded as a separate file to the cloud and the \nKM. The system consists of two servers (the cloud a nd the KM) and a client (work station). \nMultiple policies were combined using OR and/or AND operations. The policy and data files \nwere not merged into a single file, to keep the policy renewal operation light weight. According \nto the processes described in  Section 5, we also implemented the client side software functions, \nsuch as file upload, download, revocation, and renewal.  \nIn our prototype, the client interacts with the KM (s) and the cloud for setting up the keys, \nand uploading/downloading data. The KM sets up the keys, revokes, and/or renews policies and \nmanages the keys accordingly. We evaluated the DaSCE on the basis of: (a) Key(s) \nestablishment time, (b) Key Transmission time, (c) File transmission time, and (d) \nCryptographic operations time. It is  noteworthy to mention that the time required for key \nestablishment is the time for setting up a session key between the involved parties. The \ncryptographic operations time is the time taken by AES and MAC operations. Above given \nparameters collectively ma ke up total file upload/download time. Moreover, the aforesaid \nparameters are evaluated using single KM and multiple KMs .",
        "b66cebe3-2091-4e1c-9524-bdcf3e0be33a": "154 \n 7.5.1 . File Upload/Download with a Single Key Manager  \nWe used files of nine different sizes (0.3 KB, 1 KB, 10 KB, 30 KB, 50 KB, 100 K B, 500 \nKB, 1 MB, and 10 MB) to measure the time consumption in file upload and download process. \nThe results are provided in Fig. 7. 15. In general, the file transmission time increased with the \nincrease in file size. However, in some cases the change in fi le transmission time was small that \nmay be caused due to network conditions at various times. Nevertheless, file transmission time \nwas dependent on the network. In file upload case, cryptographic operations time varied between \n0.037 sec and 0.201 sec. The cryptographic operations time increased with the increase in the file \nsize. In the case of 10 MB file, the cryptographic operations time makes 2.35% of total file \nupload time and 2.45% of file transmission time. The time for session key establishment almos t \nremained constant (having slight changes). The largest time taken during the key establishment \nwas noted to be 0.0898 sec that constituted 2.67% of the total upload time. The percentage for \nkey establishment time was 2.39% for 10 MB file. Similarly, in c ase of file download operations \nthe cryptographic operations time varied from 0.039 sec to 0.211 sec. The cryptographic \noperations time was dependent on the size of the file; therefore, it increased with the larger file \nsize. However, it made lower percent age of total upload time and file transmission time. The key \nestablishment time does not depend on the file size; therefore, it remains almost constant. Slight \nchanges were possibly due to network transmission conditions. The DaSCE and FADE takes \nsame amou nt of time for cryptographic operations. However, unlike FADE, we perform \nadditional steps for key establishment in DaSCE that makes an additional overheads. Therefore, \nkey establishment process increases the time consumption of DaSCE as compared to the \nprotocols that run without establishing the session keys. It is noteworthy that the increase in time \nconsumption upturns the security level for policy files, symmetric, and asymmetric keys used in",
        "f697a72b-6633-43bd-a130-63236a8cc41a": "155 \n the DaSCE. In the following section we will see the impact of  key establishment time with \nincrease in number of KMs.  \n7.5.2 . File Upload/Download with Multiple Key Managers  \nWe evaluated the performance of DaSCE by using multiple KMs. The file sizes we used \nwere 0.3 KB, 1 KB, 10 KB, 50 KB, 100 KB, 500 KB, and 1MB. The number of KMs  used was \none, three, five, seven, fifteen, 25, and 50. Fig. 7. 16 revealed the key establishment time and the \ncryptographic operation time for the aforeme ntioned files sizes and the KMs . The key \nestablishment time increased with the increase in the number of KMs . This is because the client \nhad to complete all the message passing steps necessary to establish the key with all the KMs . \n \n(a) \n \n(b) \nFig. 7. 15 Performance of File Uploads and Downloads Operations for DaSCE . \n1 10 100 1,000 10,0000.010.1110\nFile Size (KB)Time (sec)\n  \nKeyEstablishment\nCryptoOp\nFileTransmission\nKeyTransmission\n1 10 100 1,000 10,0000.010.1110100\nFile Size (KB)Time (Sec)\n  \nKeyEstablishment\nKey Transmission\nCryptoOp\nFile Transmission",
        "d8a2051d-d359-4cf4-8925-a62353ca97aa": "156 \n The key establishment ti me varies between 0.069 (single KM) seconds and 0.24 seconds (50 \nKMs). It must be noted that there was slight increase in the key establishment up to ten KMs. \nHowever, with higher number of KMs the increase followed a higher trend. As discussed earlier, \nthe increase in time consumption due to key establishment augments the security level. \nTherefore, we say that user has to select the number of KMs judicially. A balance between \ntolerate able time consumption and security level in needed while deciding the nu mber of KMs. \nIn the coming discussion we will also see that the key establishment time constitutes low \npercentage of total time.  \n \n(a) Cryptographic operations  \n \n(b) Key establishment  \nFig. 7. 16 File Uploads with Multiple Key Managers.  \n5 10 15 20 25 30 35 40 45 500.030.040.050.060.070.080.090.1\nNumber of key managersCrypto operations time (sec)\n  \n0.3 KB\n1 KB\n10 KB\n50 KB\n100 KB\n500 KB\n1000 KB\n5 10 15 20 25 30 35 40 45 500.060.080.10.120.140.160.180.20.220.240.26\nNumber of key managersKey establishment time (sec)\n  0.3 KB\n1 KB\n10 KB\n50 KB\n100 KB\n500 KB\n1000 KB",
        "e72a911b-5dde-43c6-8058-0e31524bac9c": "157 \n The cryptographic operation time remained constant for the file of same size as final symmetric \nencryption is done on client with generated keys (symmetric key, K). Fig. 7. 17 depicts the key \nestablishment time and cryptographic operation time taken by file download with mu ltiple KMs . \nIt must be noted that the key establishment constituted a low percentage of the total \nconsumed time, see Fig. 7. 17. Fig. 7. 18 contains time comparisons of total upload/download \ntime with key establishment and other constituent times for single key managers with different \nfile sizes. It can be noted that as the amount of data increases, the percentage of key \nestablishment time decreases to less significant number as compared to the total upload and \ndownload time, for the file (see Fig. 7. 18). The refore, an increase in number of key managers \nwill increase the security as well as the time consumption due to key establishment.   \n7.5.3 . Discussion  \nWe p resent DaSCE that augments the security level by introducing additional steps for \nthe key establishment process. Because of the mutual exclusion of communication events \nbetween the client and the KM, FADE fell short on issues of securing the keys and  \n(a) Cryptographic operations   \n(b) Key establishment  \n(c)  \nFig. 7. 17 File Download with Multiple Key Managers.  \n5 10 15 20 25 30 35 40 45 500.030.040.050.060.070.080.090.1\nNumber of key managersCrypto operations time (sec)\n  \n0.3 KB\n1 KB\n10 KB\n50 KB\n100 KB\n500 KB\n1000 KB\n5 10 15 20 25 30 35 40 45 500.060.080.10.120.140.160.180.20.220.24\nNumber of key managersKey establishment time (sec)\n  \n0.3 KB\n1 KB\n10 KB\n50 KB\n100 KB\n500 KB\n1000 KB",
        "c4c5fd13-8c15-47b3-90d3-36127c1a689b": "158 \n 0.000.050.100.150.200.25\n0123456789\n1 2 3 4 5 6 7 8 9FT TUT\nKE KT\nCO\n                0.3       1           10          30          50        100         500      1000     10000  Time (sec)  Time (sec)  \nFile Size (KB)  0.000.050.100.150.200.25\n02468101214161820\n1 2 3 4 5 6 7 8 9FT TDT\nKE KT\nCO\n0.3           1          10     30          50         100       500      1000    10000  Time (sec)  Time (sec)  \nFile Size (KB)  authe ntication of participating parties. The DaSCE resolves the aforesaid issues by introducing \ndigital signature for the authentication and session key establishment process before any other \nexchange takes place. Moreover, the concept of \u201cassured file deletion \u201d is used to make the file \ninaccessible or unrecoverable by deleting important information ( di). Comparing the \nperformance of FADE and DaSCE, FADE has less performance overheads as compared to \nDaSCE. However, unlike FADE, the DaSCE provides high security s tandards and does not \ncompromise the keys under man -in-the-middle attack. It is noteworthy that DaSCE does not \nintroduce substantial performance and monetary overhead that can lead to higher management \ncost. However, as compared to FADE, the performance ov erhead of DaSCE are slightly higher \nbecause of the supplementary steps taken to increase the level of security for the keys that \nupturns the security level for policy files, symmetric, and asymmetric keys used in the DaSCE.  \n  (a) Upload time  (b) Down load t ime \nFig. 7. 18 Total Upload/ Download Time vs Key Establishment  Time. KE = Key Establishment \nTime, Kt= Key Transmission Time, CO = Cryptographic Operations Time, FT= File \nTransmission Time, TUT= Total Upload Time, TDT= Total Download Time.",
        "e6243a37-3830-4c48-b703-a9b628b8e66c": "159 \n  \n7.6. Reference s \n[7.1] M. Armbrust, A. Fox, R. Griffith, A.D. Joseph, R. Ktaz, A. Konwinski, G. Lee, D. \nPatterson, A. Rabkin, I. Stoics, and M. Zaharia, \u201cA View of Cloud Computing,\u201d \nCommunications of the ACM , Vol. 53, No. 4, 2010, pp. 50 -58.  \n[7.2] M. S. Blumenthal, \u201cIs Security Lost in the Clouds?\u201d Communications and Strategies , No. \n81, 2011, pp. 69 -86. \n[7.3] C.Cachinand M.Schunter, \"A cloud you can trust,\"   IEEE  Spectrum , Vol. 48, No. 12, \n2011,pp. 28 -51. \n[7.4] R. Chow, P. Golle, M. Jakobsson, E. Shi, J. Staddon, R. Masu oka, and J. Molina, \n\"Controlling data in the cloud: outsourcing computation without outsourcing control,\" In \nProceedings of the ACM workshop on Cloud computing security ,pp. 85 -90, 2009.  \n[7.5] C. Cremers, \"The Scyther Tool: Verification, falsification, and analysis of security \nprotocols.\" In Computer Aided Verification, Springer Berlin Heidelberg , 2008, pp. 414 -418. \n[7.6]  Cloud Security Alliance \nhttps://downloads.cloudsecurityalliance.org/initiatives/cdg/CSA_CCAQIS_Survey.pdf (accessed \nMarch 24, 2013).  \n[7.7]  D.R. Dams, \u201cFlat fragments of CTL and CTL*: spreading the expressive and distinguishing \npowers,\u201d Logic Journal of IGPL , Vol. 17, No. 1, 1999, pp. 55 -78. \n[7.8] J. Desel and J.Esparza, \u201cFree Choice Petri Nets,\u201d Cambridge Tracts in Theoretical \nComputer Scien ce, Vol. 40, Cambridge, UK: Cambridge Univ. Press, 1995.  \n[7.9] W. Diffie, P. C. V. Oorschot, and M. J. Wiener, \u201cAuthentication and authenticated key \nexchanges,\u201d Designs, Codes and Cryptography,  Vol. 2, No. 2, 1992, pp. 107 -125.",
        "3dc26266-c565-4d91-8927-2a41c9c24e95": "160 \n [7.10] T. Dillon, C. Wu, and  E. Chang, \u201cCloud Computing: Issues and Challenges,\u201d In \nproceedings of 24th International Conference on Advanced Information Networking and \nApplications , pp. 27 -33, 2010.  \n[7.11] N. En and N. Srensson, \u201cAn extensible SAT -solver,\u201d Lecture Notes in Computer S cience , \nvol. 2919, Springer, 2003, pp. 502 -518. \n[7.12] C P. Gomes, H. Kautz, A. Sabharwal, and B. Selman, \u201cSatisfia -bility solvers,\u201d In \nHandbook of Knowledge Representation, Elsevier , 2007.  \n[7.13] A. N. Khan, M. L. Mat Kiah, S. U. Khan, and S. A. Madani, \u201c Towards secure mobile \ncloud computing: a survey,\u201d  Future Generation Computer Systems , Vol. 29, No. 5, 2013, pp. \n1278 -1299.  \n[7.14] A. Juels and A. Opera, \u201cNew approaches to security and availability for cloud data,\u201d \nCommunications of the ACM , Vol. 56, No. 2 , 2013, pp. 64 -73. \n[7.15] S. Kamara and K. Lauter, \u201cCryptographic cloud storage,\u201d Financial Cryptography and \nData Security,  Springer Berlin Heidelberg, 2010, pp. 136 -149.  \n[7.16] M. Kaufman,\u201dData security in the world of cloud computing,\u201d  IEEE Security and  \nPrivacy , Vol. 7, No. 4, 2009, pp. 61 -64. \n[7.17] K. M. Khan, and Q. Malluhi, \"Establishing trust in cloud computing,\"  IT \nprofessional , Vol. 12, No. 5, 2010,pp. 20 -27. \n[7.18] H. Lin and W. Tzeng, \u201cA secure decentralized erasure code for distributed network \nstorage,\u201d IEEE Transactions on Parallel and Distributed Systems , vol. 21, no. 11, Nov. 2010, pp. \n1586 -1594.",
        "5b1ba475-3f90-4018-88cc-0527f922e0a3": "161 \n [7.19] H. Lin and W. Tzeng, \u201cA secure erasure code -based cloud storage system with secure data \nforwarding,\u201d IEEE Transactions on Parallel and Distri buted Systems , vol. 23, no. 6, June 2012, \npp. 995 -1003.  \n[7.20] M. Maidl, \u201cThe common fragment of CTL and LTL,\u201d IEEE symposium on foundations of \ncomputer science , pp. 643 -652, 2000.  \n[7.21] S. U. R. Malik, S. K. Srinivasan, S. U. Khan, and L. Wang, \u201cA Method ology for OSPF \nRouting Protocol Verification,\u201d 12th International Conference on Scalable Computing and \nCommunications (ScalCom) , Changzhou, China, Dec. 2012.  \n[7.22] L. Moura and N. Bjrner, \u201cSatisfiability Modulo Theories: An appetizer,\u201d Lecture Notes in \nComputer Science , Vol. 5902, Springer, 2009, pp. 23 -36. \n[7.23] M. Mowbray, and S. Pearson, \"A client -based privacy manager for cloud computing,\" In \nProceedings of the Fourth International (ICST) Conference on COMmunication System \nsoftWAre and middleware , ACM , p. 5, 2009.  \n[7.24] T. Murata, \u201cPetri Nets: Properties, Analysis and Applications,\u201d Proc. IEEE , Vol. 77, No. \n4, pp. 541 -580, Apr. 1989.  \n[7.25] W. Reisig and G. Rozenberg, \u201cLectures on Petri Nets I: Basic Models,\u201d Lecture Notes in \nCom -puter Science , Berlin: Springer -Verlag, Vol. 1491, 1998.  \n[7.26] A. Shamir, \u201cHow to Share a Secret,\u201d Comm. ACM , Vol. 22, No. 11, Nov. 1979, pp. 612 -\n613.  \n[7.27] D. Sun, G. Chang, L. Sun, and X. Wang, \u201cSurveying and Analyzing Security, Privacy and \nTrust Issues in Cloud Comp uting Environments,\u201d Procedia Engineering , Vol. 15,  2011, pp. \n2852 \u2013 2856.",
        "5492d27d-9368-4738-9304-1d91102e2065": "162 \n [7.28]   H. Takabi, J. B. D. Joshi, and G. J. Ahn, \"Security and privacy challenges in cloud \ncomputing environments,\"  IEEE Security and Privacy , Vol. 8, No. 6, 2010,pp. 24 -31. \n[7.29] Y. Tang, P. P. Lee, J. C. S. Lui, and R. Perlman, \u201cSecure Overlay Cloud Storage with \nAccess Control and Assured Deletion,\u201d IEEE Transactions on Dependable and Secure \nComputing , Vol. 9, No. 6, Nov. 2012, pp. 903 -916.  \n[7.30] A. Yun, C. Shi, and Y. Kim, \u201c On protecting integrity and confidentiality of cryptographic \nfile system for outscored storage,\u201d Proceedings of 2009 ACM workshop on cloud computing \nsecurity CCSA\u201909 , pp. 67 -76, 2009.  \n[7.31] W. Jansen and T. Grance, \"Guidelines on security and privacy in public cloud \ncomputing,\"  NIST special publication, 800-144, 2011.  \n[7.32] R. Buyya, C. S. Yeo, S. Venugopal, J. Broberg, and I. Brandic, \u201cCloud computing and \nemerging IT platforms: Vision, hype, and reality for delivering computing as the 5th \nutility,\u201d  Futu re Generation computer systems , Vol. 25, No. 6, 2009, pp. 599 -616. \n[7.33] A. R. Khan, M. Othman, S. A. Madani, and S. U. Khan, \u201cA survey of mobile cloud \ncomputing application models,\u201d IEEE Communications Surveys and Tutorials , 2013, 1 -21. \n[7.34] R. Perlman , \u201cFile system design with assured delete,\u201d In Third IEEE International  \nSecurity in Storage Workshop , pp. 6, 2005.  \n[7.35] R. Geambasu, T. Kohno, A. A. Levy, and H. M. Levy, \u201cVanish: Increasing Data Privacy \nwith Self -Destructing Data,\u201d In USENIX Security S ymposium , pp. 299 -316. 2009.",
        "1bd81e41-46d0-4d41-b5ee-77d2b7e281ac": "163 \n 8. CONCLUSIONS  \nLarge scale computing systems  are growing exponentially , such as cloud and DC,  to \naccommodate the escalating demands of user and applications. Similarly, as the size and \ncomplexity of the DC increases the concerns  related to reliability, energy consumption, security, \navailability, and performance are also growing. Google reported a 20% revenue loss due to a \ndelay of 500msecs in response time and Amazon reported a sales decrease of 1% due to an \nadditional response t ime of 100msecs. The said examples indicate the importance and impact of \nthe slightest inaccuracy in large -scale computing systems. In the said perspective, the use of FMs \nfor verifying the functionality and reliability of the systems is compulsory. In our  research, we \nfocused on the application of FMs tools and techniques to investigate about the reliability and \ncorrectness of different applications running in large scale computing systems.  \nIn Chapter 3, we have studied and analyzed three state -of-the-art VM-based open source \ncloud management platforms:  (a) Eucalyptus, (b) Open Nebula, and (c) Nimbus. To model the \nsystems with the advantage of providing a firm mathematical representation and to analyze the \nstructural and behavioral properties, we used High -Level Petri Nets (HLPN). Moreover, the \nmodels are verified using SMT -Lib and Z3 solver. We used Model Checking approach to verify \nour models. Several properties are specified (using the specification and details available in \ndocumentation) and if the model s satisfy those properties, then the model is declared correct. The \nverification results revealed  that the models are correct and feasible as the numbers of Virtual \nMachines (VM) grow. This paper provides an in -depth formal analysis, modeling, and \nverifica tion of the systems that will be helpful for the research community to further explore and \nunderstand the systems. Moreover, the paper also provides a strong foundation for new \nresearchers to apprehend the meticulous knowledge of the systems. In future, we  will analyze,",
        "4b5b3aba-ee16-4622-afc5-ca3e76fc3ea8": "164 \n model, and verify some other cloud management platforms, such as OpenStack, oVirt, and ECP. \nMoreover, we will also perform a detailed feasibility analysis of the aforesaid platforms under \ndifferent SLA constraints.  \nOSPF is one of the most wi dely used IGP over the Internet today. The primary goal of \nOSPF is to provide fast convergence and load balancing to the network. In Chapter 4 , we provide \nthe intra  area convergence time analysis of OSPF based on the: (a) DR, (b) cascading failures, \nand (c) topology, on a broadcast and NBMA segments. We simulated the detailed \nimplementation of OSPF protocol built on the specifications available in  RFC 2328 . The BRITE \ntopology generator was used for the interconnections among the routers to get more realisti c \nresults. The results from our simulation reveal ed that the convergence time of an area depends \nsignificantly on: (a) the number of DRs, (b) the placement of DRs, (c) interconnection amongst \nthe routers, and (d) the number of routers, in a topology.  Moreo ver, the results also exposed the \nfact that having more DR in an area can improve the convergence time of the specified segment. \nHowever, the overall convergence time of the area will decrease.  \nIn Chapter 5 , we modeled DC as a CPS to capture the thermal ev olution and dynamics \npresented by DC components.  We model ed DC as a Cyber Physical System (CPS) to capture the \ndynamics and evolution of the thermal properties exhibited by the DC. All software aspects, such \nas scheduling, load balancing, and all the compu tations performed by the devices were  \nconsidered as the \u201cCyber\u201d component. The supported infrastructure, such as servers, switches, \nand power supplies were modeled as the \u201cPhysical\u201d component of the CPS. We modeled the heat \ndissipation of the major compone nts of DC, such as servers and switches, and utilized the \ninformation to propose a thermal aware scheduling approach. Our proposed strategy was testified \nand demonstrated by executing on a real DC workload having more than 22,000 jobs, obtained",
        "5a22068a-3dff-4f46-964e-7106e3b9d1d1": "165 \n from the CC R, State University of New York, at Buffalo . Moreover, we also performed a \ncomparison of our proposed strategy with  three existing strategies, FCFS, TASA, and GA -based . \nFurthermore, we performed formal analysis, modeling, and verification using HLPN, SMT -Lib, \nand Z3 solver. We investigated the impact of all of the scheduling approaches  on the overall \nthermal signature and thermal uniformity among the pods within a DC. Our analysis revealed \nthat the scheduling heuristics exhibit non -uniformity in thermal signatures among the pods. Such \nuneven thermal signatures lead to hotspots within the data center. The finding and results from \nthe analysis were used to mitigate the ambient effect caused by the job allocation. The simulation \nresults revealed that our propos ed strategy maintains better thermal balance within the pods of \nDCs as compared to the other approaches. The formal v erification performed using SMT -Lib and \nZ3 solver, matches the simulation results, where hotspots were identified in all of the studied \napproach es.  \nFormal analysis of routing protocols is compulsory for a secure and efficient performance \nof modern large scale networks. In the said perspective , in Chapter 6, we proposed a novel \nmethod to verify the properties of OSPF protocol us ing delay info rmation of the routers. We \nhave verified the protocol in two parts: (a) content verification and (b) route verification. For (a), \nwe verify the property that the LSDB for all the routers in an area must be identical. For (b), we \nuses delay information to o rder the events and then verify if the events are occurring in the same \norder. The aforementioned properties are verified using SMT -LIB and Z3 solver. We simulated \nthe detailed implementation of OSPF and BRITE topology generator was used for the generation  \nof realistic topological interconnections. The proposed method can scale up the verification by \nreducing the state space and narrowing it down to a single parameter.",
        "fa3e1310-13e3-45b2-8dd3-afca1efd614d": "166 \n In Chapter 7, w e proposed the DaSCE protocol, a cloud storage security system that \nprovid e key management, access control, and file assured deletion. Assured deletion was based \non policies associated with the data file uploaded to the cloud. On the revocation of policies, \naccess keys were deleted by the KMs  that result in halting of the access  to the data. Therefore, \nthe files were logically deleted from the cloud. The key management was accomplished using ( k, \nn) threshold secret sharing mechanism. We modeled and analyzed FADE. The analysis \nhighlighted some issues in key management of FADE. The DaSCE improved the key \nmanagement and authentication processes. The working of the DaSCE protocol was formally \nanalyzed using HLPN, SMT -Lib, and Z3 solver. The performance of the DaSCE was evaluated \nbased on the time consumption during file upload and dow nload. The results revealed that the \nDaSCE protocol can be practically used for clouds for security of outsourced data."
    },
    "relevant_docs": {
        "1e61e4b1-0686-4ebb-b32e-c3bc9b62a11a": [
            "e059ca6f-68f8-40e1-a89f-0fbc4ad05e97"
        ],
        "6ade1c68-7361-45ed-8cd0-cb32a1a82dec": [
            "e059ca6f-68f8-40e1-a89f-0fbc4ad05e97"
        ],
        "89307f36-e5cc-4eac-b857-a4e9e381f8ac": [
            "cfd52154-2e0e-47ae-8957-7e036f75aa8c"
        ],
        "a92efa9c-3830-49b0-8969-ee292710adc9": [
            "cfd52154-2e0e-47ae-8957-7e036f75aa8c"
        ],
        "1eb597ba-34d6-460a-ac24-3fa73308df48": [
            "b01f000b-896f-49f6-8110-0765a9d3ecbb"
        ],
        "7b2d96fb-9d3d-4114-9ca0-d7214137535f": [
            "b01f000b-896f-49f6-8110-0765a9d3ecbb"
        ],
        "fd0a1b66-100d-43a0-abe1-cab7283cb997": [
            "c3cefdf1-d539-4b7a-a10f-7e8ed303f649"
        ],
        "366a195f-b9f6-4485-b024-6e451577cb8a": [
            "c3cefdf1-d539-4b7a-a10f-7e8ed303f649"
        ],
        "32647c20-6477-4cf6-b18f-997959f1e912": [
            "8f29b5c2-3715-44d0-a5cc-cdd4d5c64475"
        ],
        "24fa4312-a1e0-4a6f-bea0-4524bd81782d": [
            "8f29b5c2-3715-44d0-a5cc-cdd4d5c64475"
        ],
        "51802372-a88a-4299-835b-852b25ac91f3": [
            "b704195b-71e1-4c7d-bdfb-160844d0d65f"
        ],
        "93629649-71d5-4ebb-ae88-1c5a3fe6724e": [
            "b704195b-71e1-4c7d-bdfb-160844d0d65f"
        ],
        "0a3545d8-78cb-4761-9a7e-c6d36e97e948": [
            "3344ec8e-f59e-43a6-8080-70d6b9912db6"
        ],
        "cf9ee608-c4a0-4c68-925f-461d35795405": [
            "3344ec8e-f59e-43a6-8080-70d6b9912db6"
        ],
        "64cd2cc7-c579-4fe0-ae57-1fe99cd767b7": [
            "2704e5d3-cb35-46bc-ac66-493efa5973c9"
        ],
        "f1553833-acdc-402e-8345-20e49cd09d99": [
            "2704e5d3-cb35-46bc-ac66-493efa5973c9"
        ],
        "18de72a1-ad6d-4184-9394-1dcbb06dfecf": [
            "460ea788-4b77-42f5-a3dd-54b2e0113882"
        ],
        "97f8bdfd-f191-4fdd-b5ee-96e55e5ad394": [
            "460ea788-4b77-42f5-a3dd-54b2e0113882"
        ],
        "234c722e-f49e-4dc0-99c5-695bda74dce3": [
            "460ea788-4b77-42f5-a3dd-54b2e0113882"
        ],
        "593f03a1-8272-4ac1-b0c6-2e5cbe6afc00": [
            "460ea788-4b77-42f5-a3dd-54b2e0113882"
        ],
        "5b0766d0-7344-4266-a2d7-73614167bfd4": [
            "460ea788-4b77-42f5-a3dd-54b2e0113882"
        ],
        "2ccd26f4-c8ce-4e3d-b52c-324274f5003d": [
            "460ea788-4b77-42f5-a3dd-54b2e0113882"
        ],
        "42ff2536-7eac-4010-beea-deb198f6064b": [
            "460ea788-4b77-42f5-a3dd-54b2e0113882"
        ],
        "e4beb525-87c2-4fc0-a53e-2ea57a1da02e": [
            "460ea788-4b77-42f5-a3dd-54b2e0113882"
        ],
        "ffb5f0da-0bee-4d58-ac9b-b132cf538906": [
            "460ea788-4b77-42f5-a3dd-54b2e0113882"
        ],
        "d03608ec-da36-4e95-80ee-9ffd7ac3961a": [
            "460ea788-4b77-42f5-a3dd-54b2e0113882"
        ],
        "9cd6fc03-34cd-414f-9450-98b411863aab": [
            "460ea788-4b77-42f5-a3dd-54b2e0113882"
        ],
        "9936d0eb-732a-410a-b680-081c89de662c": [
            "460ea788-4b77-42f5-a3dd-54b2e0113882"
        ],
        "78d3319e-b58d-4de4-ac0f-d9e670893d27": [
            "460ea788-4b77-42f5-a3dd-54b2e0113882"
        ],
        "29e5e739-e149-4b4c-9e2c-08a8d6e70f31": [
            "460ea788-4b77-42f5-a3dd-54b2e0113882"
        ],
        "69e6a12c-edfa-4653-a561-282aade72bc7": [
            "460ea788-4b77-42f5-a3dd-54b2e0113882"
        ],
        "623a553d-e63f-4220-8ad2-61ee2cf646b5": [
            "f832b692-0b51-48a3-a2dd-10ea992ef043"
        ],
        "c7635775-bec6-411f-9965-98de5fb05657": [
            "f832b692-0b51-48a3-a2dd-10ea992ef043"
        ],
        "853eb0fd-3789-4557-9628-f057a2352a67": [
            "8299134c-34d1-4dd8-82d9-7d09dccedc2d"
        ],
        "103a8a8b-d0bc-409c-a29a-231aaa7140fe": [
            "8299134c-34d1-4dd8-82d9-7d09dccedc2d"
        ],
        "7512ae68-f53a-4d4d-aed5-9ab5a7eaf23f": [
            "7c11f596-4b82-4a1d-8343-42827e1067d2"
        ],
        "8c758379-5389-43f2-a7dd-17498ae05794": [
            "7c11f596-4b82-4a1d-8343-42827e1067d2"
        ],
        "97d914d6-d64d-4a15-a928-068663b65926": [
            "7c11f596-4b82-4a1d-8343-42827e1067d2"
        ],
        "dacc2d0b-ced3-4679-9336-aea71c5bd876": [
            "7c11f596-4b82-4a1d-8343-42827e1067d2"
        ],
        "a4572fd6-a129-4375-93dd-4478f937580d": [
            "7c11f596-4b82-4a1d-8343-42827e1067d2"
        ],
        "16bdc312-8c0f-4a9f-b7c3-868f6dee91b0": [
            "7c11f596-4b82-4a1d-8343-42827e1067d2"
        ],
        "fdc59e0f-e092-490c-8978-9c654ccfaf98": [
            "7c11f596-4b82-4a1d-8343-42827e1067d2"
        ],
        "f0c41336-7743-4906-9437-dd6bbc3270d2": [
            "7c11f596-4b82-4a1d-8343-42827e1067d2"
        ],
        "48c5a95d-8d4b-4c61-bd17-fadddf394280": [
            "7c11f596-4b82-4a1d-8343-42827e1067d2"
        ],
        "4f4b345f-b375-4056-b6f9-3df28fe3f765": [
            "7c11f596-4b82-4a1d-8343-42827e1067d2"
        ],
        "856e480a-9e73-4907-bfad-6ce1d3cff840": [
            "7c11f596-4b82-4a1d-8343-42827e1067d2"
        ],
        "72f7ee5d-16bc-4378-acc3-0203bfeee02d": [
            "7c11f596-4b82-4a1d-8343-42827e1067d2"
        ],
        "9a95a93c-f6f6-4866-81bb-45eea72182d2": [
            "7c11f596-4b82-4a1d-8343-42827e1067d2"
        ],
        "5fcdb447-ba68-4f25-8be6-c477b80ae75e": [
            "7c11f596-4b82-4a1d-8343-42827e1067d2"
        ],
        "23383196-f382-4ee3-a17f-98fb80749f0d": [
            "7c11f596-4b82-4a1d-8343-42827e1067d2"
        ],
        "6ac60f86-358f-47b2-b621-b34896cea119": [
            "7c11f596-4b82-4a1d-8343-42827e1067d2"
        ],
        "00b26c03-29bc-474a-948f-6d43fa0ef83f": [
            "7c11f596-4b82-4a1d-8343-42827e1067d2"
        ],
        "ed3660fe-e020-422d-a111-25dddec321f5": [
            "676f490a-cd7d-45ea-809f-07088a4b4a4c"
        ],
        "935b32b7-7c39-4405-8317-9140298285b1": [
            "676f490a-cd7d-45ea-809f-07088a4b4a4c"
        ],
        "9a4ff02a-e9e8-45de-8bdf-394c3ec6e4d1": [
            "9f1c3c00-02d0-4b16-9249-71a5963cc4ef"
        ],
        "2445024b-c994-4a2d-89e1-2dc370b1ceef": [
            "9f1c3c00-02d0-4b16-9249-71a5963cc4ef"
        ],
        "e3d3d04e-3bec-45c2-89ef-31daa5eb6843": [
            "73fd2f91-f1fa-4acf-a1f0-1cb158ef1121"
        ],
        "2cc9954c-bad7-461e-8faa-553c503e184a": [
            "73fd2f91-f1fa-4acf-a1f0-1cb158ef1121"
        ],
        "ac9ea415-b841-4dc0-b95d-92e55447f0dd": [
            "56e8e9bc-b888-4447-adeb-f5ada09dea2e"
        ],
        "8c344a06-8a9e-4577-9489-bde2f216f300": [
            "56e8e9bc-b888-4447-adeb-f5ada09dea2e"
        ],
        "2b933df9-2ef3-4cb2-8e7a-60d1bdd379c3": [
            "6f55c23a-920a-418f-8ff1-e56318457e40"
        ],
        "6372e709-331c-4abb-b961-c80beccbb2b6": [
            "6f55c23a-920a-418f-8ff1-e56318457e40"
        ],
        "878f6246-b1a0-4e4f-bb70-e7a8e2d20167": [
            "183f614b-7d53-45f0-b364-7b04b613983f"
        ],
        "4b51c63a-0e7a-4b1a-8d73-4bca18509274": [
            "183f614b-7d53-45f0-b364-7b04b613983f"
        ],
        "e8591df4-ac89-4366-b8c0-ae9f47dfbddb": [
            "183f614b-7d53-45f0-b364-7b04b613983f"
        ],
        "911a79b0-ad1b-43ea-8fa1-47255915a685": [
            "183f614b-7d53-45f0-b364-7b04b613983f"
        ],
        "26a09799-7aef-4893-8aa5-da0dff73f069": [
            "183f614b-7d53-45f0-b364-7b04b613983f"
        ],
        "68cde1a5-63e9-4464-bd30-7a4990673147": [
            "183f614b-7d53-45f0-b364-7b04b613983f"
        ],
        "c0003cad-b12d-4f57-b8af-d43a66e1c805": [
            "183f614b-7d53-45f0-b364-7b04b613983f"
        ],
        "2767e1ac-964f-43c1-8d9d-2ffd8cb8443d": [
            "183f614b-7d53-45f0-b364-7b04b613983f"
        ],
        "57570a8e-9019-4525-86f3-201cdd0bf7e0": [
            "183f614b-7d53-45f0-b364-7b04b613983f"
        ],
        "b79d2c1e-4647-4447-9f42-ed68fc8c1aa5": [
            "183f614b-7d53-45f0-b364-7b04b613983f"
        ],
        "cdfb0cd7-a8dd-4466-b3f1-2337bdfc6dad": [
            "183f614b-7d53-45f0-b364-7b04b613983f"
        ],
        "0888c79f-c7b3-4446-8cd0-9c3f3d7e6c74": [
            "5335ac65-8395-482b-840e-4aa343749499"
        ],
        "6bb8b6aa-9f25-4a57-a36c-bed8b26d7371": [
            "5335ac65-8395-482b-840e-4aa343749499"
        ],
        "b3d04345-7341-4368-b480-1405543378da": [
            "d2e26c86-be2e-4156-931c-db14b7bf4e56"
        ],
        "78d7fa45-2c15-4be9-b15d-69dcfb2a3740": [
            "d2e26c86-be2e-4156-931c-db14b7bf4e56"
        ],
        "502ccbdd-e184-4f8a-98f1-5f8cf3ad3813": [
            "fab4eb76-963a-4612-8425-0d8c1675359e"
        ],
        "74f710df-d9b6-48bb-b1c2-89057ff5002f": [
            "fab4eb76-963a-4612-8425-0d8c1675359e"
        ],
        "ead8aa95-9cd6-4c15-9df9-f76c32db0b21": [
            "74096a6d-0fe3-4c4c-8ed0-19bfc017d581"
        ],
        "a4d1680a-0043-4b73-b643-7628f8147582": [
            "74096a6d-0fe3-4c4c-8ed0-19bfc017d581"
        ],
        "d654bc14-ce20-4e4e-a43b-17873442eb10": [
            "1e1fffdd-90da-418c-914c-cff4281d7231"
        ],
        "c35b7c0f-1c35-48ce-8065-cd50e281f033": [
            "1e1fffdd-90da-418c-914c-cff4281d7231"
        ],
        "59781c51-8661-445a-a321-40e23a20213a": [
            "d900cea1-a30d-419d-823d-4525d30a5c1f"
        ],
        "0d40bef1-2688-4206-a0eb-8b29bb871486": [
            "d900cea1-a30d-419d-823d-4525d30a5c1f"
        ],
        "5e652742-c089-491b-9ec6-5958b35041ec": [
            "3881bb5f-cafe-41fa-8037-f77679a69672"
        ],
        "3ba58de6-4a57-445a-acf5-5031482998fb": [
            "3881bb5f-cafe-41fa-8037-f77679a69672"
        ],
        "36f8b89c-fbe2-49d6-a210-52373459d13e": [
            "0337ffbd-c0c1-4b24-9db0-f766de60a037"
        ],
        "8235b226-98d1-4636-ba3b-3bbdbb5714a5": [
            "0337ffbd-c0c1-4b24-9db0-f766de60a037"
        ],
        "d2c2ebd1-3867-4049-891e-0f65f1faf24a": [
            "55c9fffc-8c90-4af5-b320-5709b3ec99da"
        ],
        "9efb8f8a-a34d-419f-a12a-c6805412c9f7": [
            "55c9fffc-8c90-4af5-b320-5709b3ec99da"
        ],
        "75491da8-e197-4636-a66f-6f8df382eec3": [
            "55c9fffc-8c90-4af5-b320-5709b3ec99da"
        ],
        "84b1a581-713a-437b-a8c6-b6586af155dc": [
            "55c9fffc-8c90-4af5-b320-5709b3ec99da"
        ],
        "71d09897-dada-4f79-a723-0ae9519ef5f6": [
            "1d54a7c3-ea6a-4663-bf91-ea98ae7c007b"
        ],
        "467e7bac-331b-4f45-a219-60f75f8c8958": [
            "1d54a7c3-ea6a-4663-bf91-ea98ae7c007b"
        ],
        "7f8da190-2cac-43ca-940b-4b68bdca7373": [
            "7cb101e1-000e-41ec-85ac-b42e2bf55e93"
        ],
        "759fed7c-f0f6-4f79-927d-7f32a1067875": [
            "7cb101e1-000e-41ec-85ac-b42e2bf55e93"
        ],
        "5c8e37ab-4dc0-46a3-a26f-1cc14f1fbcc5": [
            "28cae7fb-c59a-4b93-b782-3796ef679e0c"
        ],
        "0e4e88a1-b0a0-43fb-9130-c21766b0870d": [
            "28cae7fb-c59a-4b93-b782-3796ef679e0c"
        ],
        "d593501e-a7b6-4438-9e1c-6e1a017dd0ce": [
            "57e9bd9a-6c56-4713-8486-6557fb6e158e"
        ],
        "9b734235-4522-4dee-a405-7c8a511d829e": [
            "57e9bd9a-6c56-4713-8486-6557fb6e158e"
        ],
        "e7aa5566-87ae-47cd-9f21-5579b59faa8e": [
            "594898f4-07a3-4374-a961-7f7de139c313"
        ],
        "962c9508-b04d-42c4-a652-5f61989de254": [
            "594898f4-07a3-4374-a961-7f7de139c313"
        ],
        "5327de1f-374c-42ec-bad0-3b5e6a13b286": [
            "3786ca3d-19a2-4054-8852-63b8f22d6bde"
        ],
        "b8b07c7c-3618-42c9-979d-e31c006c4b8e": [
            "3786ca3d-19a2-4054-8852-63b8f22d6bde"
        ],
        "5a90084e-ae33-4af5-8782-a71db64c6219": [
            "a1ff3bd1-6900-47f9-af2b-d200047a4a3c"
        ],
        "a47c5bd4-c422-474a-be4b-6374c1496a74": [
            "a1ff3bd1-6900-47f9-af2b-d200047a4a3c"
        ],
        "aacc5d2a-9c2d-4bd1-b368-929645e5a75e": [
            "a1ff3bd1-6900-47f9-af2b-d200047a4a3c"
        ],
        "df27b136-5e06-439c-a6c1-e02c264a1d68": [
            "a1ff3bd1-6900-47f9-af2b-d200047a4a3c"
        ],
        "a5609f3d-c8e2-4c11-8049-336004736c03": [
            "06697d20-1264-4677-905b-023f109814ae"
        ],
        "c641236f-c3b0-48fb-add1-23d5714572a2": [
            "06697d20-1264-4677-905b-023f109814ae"
        ],
        "bbec2f1f-5f0b-4549-9669-24d71e27d865": [
            "0b64b757-92e2-4892-b789-f712c15c3ee7"
        ],
        "07876773-1050-4bb2-af66-99a87aa76d2f": [
            "0b64b757-92e2-4892-b789-f712c15c3ee7"
        ],
        "289a0d1e-a4f2-41ae-8552-30baa9d998f6": [
            "da1b96d5-b98f-467e-90ee-ecbc0cdf85fb"
        ],
        "7a33b7f9-d57c-4543-9801-e4e4c260eb00": [
            "da1b96d5-b98f-467e-90ee-ecbc0cdf85fb"
        ],
        "8594b166-a101-4278-8e8f-cedd2adb7eb2": [
            "0e179d24-5ad9-42db-b276-851190177cc7"
        ],
        "96c39784-2171-4278-a389-a6e65a947410": [
            "0e179d24-5ad9-42db-b276-851190177cc7"
        ],
        "90af3d01-f8bb-4f6b-81c0-2f6da7c7b110": [
            "a3d09338-8c62-496d-8d8a-7f3bd23fd432"
        ],
        "a4bab7a9-30af-4de3-a148-020e949a803f": [
            "a3d09338-8c62-496d-8d8a-7f3bd23fd432"
        ],
        "5849f636-9e3c-4a6d-a755-48f0ed0291ea": [
            "457a56fb-a69f-427f-a896-cf6eea32f23c"
        ],
        "3c257651-8907-45f2-98eb-75ce12e4e6f5": [
            "457a56fb-a69f-427f-a896-cf6eea32f23c"
        ],
        "e23a8cab-4d84-492c-a2bc-2f58416f3329": [
            "0bd7f6e8-a3cc-4298-8b7d-c85418e69762"
        ],
        "f9b8303a-f06b-442e-b3f1-43de33630f81": [
            "0bd7f6e8-a3cc-4298-8b7d-c85418e69762"
        ],
        "68b721a1-8084-4a2f-9858-dbe7e1c213bf": [
            "54e76777-78e6-4bde-ace0-442410e0c2e2"
        ],
        "11e16c78-7926-4204-8dc2-dfda4dfa330e": [
            "54e76777-78e6-4bde-ace0-442410e0c2e2"
        ],
        "7ebec2a5-304a-403e-9d5d-5d003d6a49e5": [
            "5ef1b8a6-d6dd-4545-abed-f9027c9cdc3c"
        ],
        "261ee342-d078-4155-ae6b-6eef6eb292ae": [
            "5ef1b8a6-d6dd-4545-abed-f9027c9cdc3c"
        ],
        "56c13886-fe01-443d-9097-e24fe6f917b0": [
            "e56d886a-c173-4e08-9fbd-b3b809e3cc5e"
        ],
        "5ac6aded-20d7-49eb-8198-c70cecc3aebf": [
            "e56d886a-c173-4e08-9fbd-b3b809e3cc5e"
        ],
        "0ae9be3e-f348-46ac-b93d-65f422b4b4c0": [
            "c78aac73-f86d-4dbc-9e6b-2aaa79545870"
        ],
        "d827b355-f4e1-4756-8307-9b7ed16fde34": [
            "c78aac73-f86d-4dbc-9e6b-2aaa79545870"
        ],
        "19d5f404-fadf-4516-9e2f-2140708535a6": [
            "aa6b6dc0-ee2b-417a-9231-f7333c440c81"
        ],
        "82b51aac-e38f-469a-9fce-b8f004acd236": [
            "aa6b6dc0-ee2b-417a-9231-f7333c440c81"
        ],
        "9db5e1b3-7c15-4ae6-8908-369604bf80a8": [
            "c7fdad92-9924-40b3-bc3f-43af4d713fcc"
        ],
        "a3ccc0e1-0b4d-4852-96b3-3dd512d5484f": [
            "c7fdad92-9924-40b3-bc3f-43af4d713fcc"
        ],
        "90bd31d0-b1c1-4291-bdea-7a24118c1480": [
            "ecc8e331-0557-4427-8c4c-b2690b3d2547"
        ],
        "18081dc4-1251-4477-88c8-a258a7b84aa1": [
            "ecc8e331-0557-4427-8c4c-b2690b3d2547"
        ],
        "83a09872-92b0-47b6-9cad-852ec29edef1": [
            "26c9bb27-e420-4c01-955b-91b1acd0a8d3"
        ],
        "278dad65-eb3b-4a2a-9870-acdc0fa3c956": [
            "26c9bb27-e420-4c01-955b-91b1acd0a8d3"
        ],
        "4a441ca5-71b9-4f9e-a853-78b4079832f7": [
            "2a17ef30-76be-46f9-a036-76ace23d8a90"
        ],
        "e6365fd3-a12d-463e-b12f-6face42dce8a": [
            "2a17ef30-76be-46f9-a036-76ace23d8a90"
        ],
        "b5e369fa-7959-4a75-8bcc-1d7ee6f8e984": [
            "9bd8f278-a0d3-4f45-bab5-cf69a5351ec2"
        ],
        "5cb371ed-67e1-4c8b-bfc2-0f01db0cf239": [
            "9bd8f278-a0d3-4f45-bab5-cf69a5351ec2"
        ],
        "a522c089-10ec-484d-9182-7d51e027123e": [
            "b987f623-fe8f-4734-ac85-a5887ade048c"
        ],
        "2ba018cb-e357-42c9-8a6d-8b380df8801c": [
            "b987f623-fe8f-4734-ac85-a5887ade048c"
        ],
        "fc84b904-d8c2-42dc-9101-83c24fc57939": [
            "1ce4bd60-c58e-4d40-9455-dbfdc9c6e829"
        ],
        "cde32a8f-e856-43c8-a89a-8e51a6f9cd63": [
            "1ce4bd60-c58e-4d40-9455-dbfdc9c6e829"
        ],
        "3b120e89-f0e1-4dbe-b45f-8f90bc21c39b": [
            "5347c18d-096e-4b67-956b-237974fe5030"
        ],
        "17b1de02-ef80-4feb-8aa3-fd8c77671932": [
            "5347c18d-096e-4b67-956b-237974fe5030"
        ],
        "5f97f7cf-29b7-4ea4-9734-f46d71d7f7b0": [
            "6931094d-3451-4b08-8324-e63e852e4a75"
        ],
        "46aa4ffa-8133-4c7e-a3cf-283a0ea67a92": [
            "6931094d-3451-4b08-8324-e63e852e4a75"
        ],
        "dc7c9424-1c49-42b6-aa66-96fc0ae94c61": [
            "6931094d-3451-4b08-8324-e63e852e4a75"
        ],
        "8947b9ef-ac5d-43fd-af6a-fbcfd668623c": [
            "6931094d-3451-4b08-8324-e63e852e4a75"
        ],
        "91201d36-0815-434a-b1e6-b39c5757eb19": [
            "b503ed5a-cac0-48cc-8059-33d228c7e259"
        ],
        "3b8d5854-b938-4913-b897-c2d1ad140745": [
            "b503ed5a-cac0-48cc-8059-33d228c7e259"
        ],
        "6b79e391-49d0-4b6c-88ae-ed13449f88d4": [
            "c3a05cc5-dd76-4e94-ac4b-283522045418"
        ],
        "7a54ffff-c14c-48d6-aecd-4d88a4878f09": [
            "c3a05cc5-dd76-4e94-ac4b-283522045418"
        ],
        "c8546bf2-194f-48e9-9a4c-d69be8f8bb54": [
            "994f1f2a-f9bd-424f-8ab3-6dad1667b2ad"
        ],
        "2b411aaf-d6e5-4691-904c-93c62d64fef6": [
            "994f1f2a-f9bd-424f-8ab3-6dad1667b2ad"
        ],
        "1bf1975e-fd0f-48ce-868c-54b4842cf37e": [
            "df467158-7a5d-4a8d-ad42-d2f783bc48f9"
        ],
        "4bf5b785-7114-453c-8ac8-202e7192baec": [
            "df467158-7a5d-4a8d-ad42-d2f783bc48f9"
        ],
        "3194f4f3-8759-42ca-99bc-71c858a212df": [
            "3fbb2af9-9a9d-4932-bed2-32b3d3028dd5"
        ],
        "62a17930-ee3a-40bf-b181-29a018c54932": [
            "3fbb2af9-9a9d-4932-bed2-32b3d3028dd5"
        ],
        "582fd7eb-e189-4d37-81b1-e1a4dc811449": [
            "0ad6e2b7-64d8-4791-9484-94aa7669a3e9"
        ],
        "ae9e5571-7aa8-4efd-99a4-12055ef7bee9": [
            "0ad6e2b7-64d8-4791-9484-94aa7669a3e9"
        ],
        "a30f8ce3-4ea8-4854-b4b2-dcb4cb2742ee": [
            "c60668c4-89b6-4394-84e3-294b970f1461"
        ],
        "bf1882e1-63eb-4fa1-b08a-99b3f417f59f": [
            "c60668c4-89b6-4394-84e3-294b970f1461"
        ],
        "d2a8311c-c580-4fd3-9866-c00d5129f522": [
            "596861a6-b8ce-492f-aa86-8d2353246142"
        ],
        "4aa0b005-06a6-4415-9bd7-e6d787b2440f": [
            "596861a6-b8ce-492f-aa86-8d2353246142"
        ],
        "05088305-0d54-4fbb-ae1d-d1a7c3f7c7aa": [
            "ab839713-dfe7-4a7a-bf56-4460a4f1d30f"
        ],
        "f31b8c5a-ef55-43b8-91ad-db6c9c46be87": [
            "ab839713-dfe7-4a7a-bf56-4460a4f1d30f"
        ],
        "c214fcec-337f-4933-9742-630bb2c09155": [
            "46b8411d-04ec-4326-a040-5e3156793d06"
        ],
        "2314f425-a627-48a2-b48e-2b01903dcd25": [
            "46b8411d-04ec-4326-a040-5e3156793d06"
        ],
        "4922438f-4610-4e88-8b0a-49b55d489914": [
            "dc4ad265-b452-4ad9-bf6f-d699d0aa77e4"
        ],
        "3cba72fa-aeca-4aa6-a63e-516d6e4ca919": [
            "dc4ad265-b452-4ad9-bf6f-d699d0aa77e4"
        ],
        "0fb86b40-5393-4902-8d4f-f29c32813677": [
            "6a155254-9020-4f76-979a-4c08cf444dd9"
        ],
        "b9e99113-2360-40c2-a822-6604e548f14a": [
            "6a155254-9020-4f76-979a-4c08cf444dd9"
        ],
        "6ecdb836-95d0-4375-9088-44c55847c8a3": [
            "0eb4d343-1adc-4091-ba8a-2d36186fd63d"
        ],
        "8176a837-a0fb-412a-bdd0-ed0dedaf0785": [
            "0eb4d343-1adc-4091-ba8a-2d36186fd63d"
        ],
        "089523dc-4de5-4afa-b369-82b59c5de113": [
            "dd165495-17e1-479c-8a95-72e2b0fdb101"
        ],
        "d262e851-0335-4a91-82b1-8d04769bab43": [
            "dd165495-17e1-479c-8a95-72e2b0fdb101"
        ],
        "123af272-78ef-44aa-9a03-37d7c8dcc809": [
            "8d995c96-1077-4e51-8210-f0886b30a10e"
        ],
        "2c986d7c-b61b-4b7b-b9f9-17cdd377c26e": [
            "8d995c96-1077-4e51-8210-f0886b30a10e"
        ],
        "60ea8683-651c-492e-ba20-5e398247853e": [
            "f18ebf19-1411-4044-b70c-3b48dea821b9"
        ],
        "8da323da-3021-4ea5-a495-1877dbbc2c86": [
            "f18ebf19-1411-4044-b70c-3b48dea821b9"
        ],
        "e87d8d58-8cbd-4f8f-9418-6ee57a474cd1": [
            "7afa8c85-c920-4893-84fb-2dc99a9898fc"
        ],
        "b1fd5c04-18b4-4a13-9f75-c2d7cd60c248": [
            "7afa8c85-c920-4893-84fb-2dc99a9898fc"
        ],
        "9da4a5d4-9f2a-4d2f-a8b2-20f96f2f25ef": [
            "f5ace1c7-6725-4a29-90e8-3ef44837dfa2"
        ],
        "58921d72-03e8-4f0a-8b30-c6071c343cdc": [
            "f5ace1c7-6725-4a29-90e8-3ef44837dfa2"
        ],
        "bbdfcc95-3955-49b9-a837-8ecfc847df11": [
            "f5ace1c7-6725-4a29-90e8-3ef44837dfa2"
        ],
        "2224c368-b2e1-4c10-aeb8-e0a32ad940f3": [
            "f5ace1c7-6725-4a29-90e8-3ef44837dfa2"
        ],
        "ff45c228-9a63-4996-84bc-d193240d820b": [
            "f5ace1c7-6725-4a29-90e8-3ef44837dfa2"
        ],
        "3940060c-94ed-4b78-a8bc-558ffc392f93": [
            "f5ace1c7-6725-4a29-90e8-3ef44837dfa2"
        ],
        "5ec200ed-e8ba-448e-b87f-7e17d0e8467d": [
            "f5ace1c7-6725-4a29-90e8-3ef44837dfa2"
        ],
        "9691a64d-9025-455a-adbc-7f0ab4f3c812": [
            "f5ace1c7-6725-4a29-90e8-3ef44837dfa2"
        ],
        "f9271e34-833b-4ae1-a813-acae1fce0d92": [
            "f5ace1c7-6725-4a29-90e8-3ef44837dfa2"
        ],
        "bbd60dca-7fb7-4ffa-bb55-013ecfc18985": [
            "f5ace1c7-6725-4a29-90e8-3ef44837dfa2"
        ],
        "5a4d8bf1-eb4c-4fa2-9d45-50110004d0ab": [
            "f5ace1c7-6725-4a29-90e8-3ef44837dfa2"
        ],
        "c4f64928-eb18-4eec-afbc-cb5880ed94e2": [
            "f5ace1c7-6725-4a29-90e8-3ef44837dfa2"
        ],
        "48ba0c3b-842f-4c9d-a8a1-d2c7bb34c7ec": [
            "1e829879-5017-439a-ad7f-1f400c07556a"
        ],
        "8bbfe068-4c89-42a0-8c13-d4356fbf62fd": [
            "1e829879-5017-439a-ad7f-1f400c07556a"
        ],
        "b1ae8714-c77f-46b0-837e-deba13c4c41e": [
            "1e829879-5017-439a-ad7f-1f400c07556a"
        ],
        "40b20b13-203c-486b-a433-628695078815": [
            "1e829879-5017-439a-ad7f-1f400c07556a"
        ],
        "9646665c-2346-4f54-8aec-25db00c3a58e": [
            "1e829879-5017-439a-ad7f-1f400c07556a"
        ],
        "cdb90d17-c6f5-4d15-86d0-169905a5f824": [
            "1e829879-5017-439a-ad7f-1f400c07556a"
        ],
        "bbd379f6-ad28-4b53-92ea-4801e8d45b03": [
            "1e829879-5017-439a-ad7f-1f400c07556a"
        ],
        "763c1419-4a9d-4fbe-aca7-694f274a586d": [
            "54b1cd73-c451-425e-9f42-7c74dede07f0"
        ],
        "77e2b8d7-dda5-4259-ba1b-9897aeef9226": [
            "54b1cd73-c451-425e-9f42-7c74dede07f0"
        ],
        "4bb5940a-bd54-4bda-baf5-7f68432dab68": [
            "54b1cd73-c451-425e-9f42-7c74dede07f0"
        ],
        "9d32e722-e508-46f5-8234-662f8fb02676": [
            "54b1cd73-c451-425e-9f42-7c74dede07f0"
        ],
        "3bcacfed-2d25-4b04-9f21-a17747399e7d": [
            "f4ce4e33-65f3-411b-ba7b-dc0e5fdd5f7b"
        ],
        "24d58e0b-8c60-4832-b79d-02d9d42b55c5": [
            "f4ce4e33-65f3-411b-ba7b-dc0e5fdd5f7b"
        ],
        "d34665a1-5162-4246-8dd0-37c75e620027": [
            "684f19ee-ff44-40b5-b1ce-6568d6033ede"
        ],
        "d9b47ac3-1a95-49c1-b4a3-5fc22efc81b4": [
            "684f19ee-ff44-40b5-b1ce-6568d6033ede"
        ],
        "2b5e7321-89f8-4e4c-9b33-b9bbfd04e06a": [
            "9a57fb0f-5b88-46cc-8d7a-c8f960573ccf"
        ],
        "2497a541-e895-4469-bb4c-505bbd0c754b": [
            "9a57fb0f-5b88-46cc-8d7a-c8f960573ccf"
        ],
        "60e0b45c-b038-4a41-afe1-ede5fced9c8d": [
            "7191bb72-0ab9-46d6-a975-a5edb15796b7"
        ],
        "6907791f-75f6-47b6-9045-d461759d587d": [
            "7191bb72-0ab9-46d6-a975-a5edb15796b7"
        ],
        "bbe78248-cdbf-4fb2-a6d8-46088de5e180": [
            "f59604d1-6dbc-4d76-9a61-43b03efbcda6"
        ],
        "eb2b887a-5144-4941-be1d-0a815acc7f57": [
            "f59604d1-6dbc-4d76-9a61-43b03efbcda6"
        ],
        "0003e7b1-28f2-4a96-81cb-5058a04eef16": [
            "ed197c58-4b28-4204-9c30-02d749f37c1b"
        ],
        "e4484e67-c14b-47f7-9cc4-d316e8d68e5d": [
            "ed197c58-4b28-4204-9c30-02d749f37c1b"
        ],
        "4e2dbc8d-1de2-4b09-ad04-eb5ac6abf069": [
            "3250ede7-36be-43e8-84b7-b22eda9f8a4f"
        ],
        "453916e5-29a2-462b-b8d5-4c324f8210db": [
            "3250ede7-36be-43e8-84b7-b22eda9f8a4f"
        ],
        "0c243e42-dbf2-4ec5-99c8-40a027ca0290": [
            "c17329ac-cd10-4813-b900-da1d7f32dcf8"
        ],
        "aca889cb-bcb9-468c-83c5-da428d2a59de": [
            "c17329ac-cd10-4813-b900-da1d7f32dcf8"
        ],
        "3e2c20e7-2fef-4332-9cb8-bbf1ed2d9049": [
            "ad046186-2182-4899-930a-e07af48e36a0"
        ],
        "ede3cc89-217c-4c69-a4c9-55e806164660": [
            "ad046186-2182-4899-930a-e07af48e36a0"
        ],
        "8c5d2c31-b174-472a-baa8-2666d587538d": [
            "f35406df-a018-43ee-b4e7-89381bd155a6"
        ],
        "9c085fb9-0cec-4db8-af81-094082ed5f25": [
            "f35406df-a018-43ee-b4e7-89381bd155a6"
        ],
        "d8a38706-7c9b-4aa2-92cf-ddd90953d03b": [
            "6204fcae-41ec-446a-9853-1f50082dfae5"
        ],
        "3235fbfa-1e51-4dba-9030-88aaa4d7c02c": [
            "6204fcae-41ec-446a-9853-1f50082dfae5"
        ],
        "99027409-b4ff-45f8-83a6-81c0d51d8e5a": [
            "53922f0f-01ba-4da7-bb52-f4f37ac28e0f"
        ],
        "8fd4e7d3-2c42-45e6-b51b-6f03fe3b7f92": [
            "53922f0f-01ba-4da7-bb52-f4f37ac28e0f"
        ],
        "3e3718f5-b706-4b8b-899a-7fe9fc51bf81": [
            "c12764fb-6749-4df1-a15f-22f55ebd0f37"
        ],
        "4a625920-fbdf-4fd3-a425-2adbda505051": [
            "c12764fb-6749-4df1-a15f-22f55ebd0f37"
        ],
        "217a678f-42c0-424b-bde7-901d283f4e08": [
            "86adcd82-4c68-4c63-b4bb-206ff06ad96f"
        ],
        "c152e2e3-0ac8-4ef1-9c90-7efae4190bea": [
            "86adcd82-4c68-4c63-b4bb-206ff06ad96f"
        ],
        "b323f89a-ee99-46c1-8103-2ebcb62dd059": [
            "d1f82766-acd6-4b7a-858c-fabe503485c5"
        ],
        "5555b633-42e5-43b7-b8e0-eda0acd253fc": [
            "d1f82766-acd6-4b7a-858c-fabe503485c5"
        ],
        "58605ff6-fe14-4aa0-be9a-da81e3432fdb": [
            "3aeb8028-603b-4db9-8d3e-2a7c189de7aa"
        ],
        "dd50eb3b-93da-44f8-b097-969141cefa8e": [
            "3aeb8028-603b-4db9-8d3e-2a7c189de7aa"
        ],
        "8a055518-1395-4b55-ac59-fc3345f01e43": [
            "76fa883a-28e2-467c-89cd-2bcadf701ef9"
        ],
        "01ee4530-cbd0-41dd-bf05-d21ed95bddeb": [
            "76fa883a-28e2-467c-89cd-2bcadf701ef9"
        ],
        "c387499c-0624-4430-a987-40fcc1c140e6": [
            "aaaa60cc-dd29-4166-b312-b4e0b0590b13"
        ],
        "81f98ffb-67d1-409f-86d9-3f604767689e": [
            "aaaa60cc-dd29-4166-b312-b4e0b0590b13"
        ],
        "cc990f80-00c9-4741-a664-33d5794acfe5": [
            "3e55558a-214b-4235-99c3-a12466d93265"
        ],
        "d9ecd4a3-e099-4f38-9201-8228877a4ee9": [
            "3e55558a-214b-4235-99c3-a12466d93265"
        ],
        "3f689149-2bed-4c46-9754-15c401b20fdb": [
            "ea73d67b-08bf-47c9-b845-82fa3dff9036"
        ],
        "a7e6d76e-4195-4e41-95ec-69613aac603d": [
            "ea73d67b-08bf-47c9-b845-82fa3dff9036"
        ],
        "17fdb4b8-418e-4797-a225-c5b394061bdd": [
            "c523b970-24cb-4163-9c07-fdc26d89a706"
        ],
        "28746ab1-0730-44bf-a193-7ef54e517e8f": [
            "c523b970-24cb-4163-9c07-fdc26d89a706"
        ],
        "d0a23101-5be2-4af6-873b-5ff9edeba8d3": [
            "19ea4a41-bfa2-44df-9268-c2485a317633"
        ],
        "d1e6da97-74ff-4f89-8cb8-662b260ba0c2": [
            "19ea4a41-bfa2-44df-9268-c2485a317633"
        ],
        "1b51905a-d2fe-4858-a2c6-4cdf3a16d05c": [
            "22e315a8-1632-4265-954a-040df98f7546"
        ],
        "09b0a602-b715-4d0d-8b76-93c9fa5919c6": [
            "22e315a8-1632-4265-954a-040df98f7546"
        ],
        "dd537ec2-f371-43ec-b630-3df4e518e01a": [
            "d68f466a-7e75-42c1-812b-866d50240e92"
        ],
        "80da634e-a59a-4770-8aca-0badb80c0618": [
            "d68f466a-7e75-42c1-812b-866d50240e92"
        ],
        "b7662bb3-4d96-4570-9f78-3b64a6e1e8be": [
            "5430e322-2d68-4dad-9186-04de71bac353"
        ],
        "71b2ded8-f974-46ad-bcc5-b916f2f90757": [
            "5430e322-2d68-4dad-9186-04de71bac353"
        ],
        "3e2adf7d-740a-487d-95a4-df564e6b6741": [
            "30621477-8322-46a0-81f1-59e1f6625281"
        ],
        "d1b2c6d4-eb3b-4906-856a-112d6f05c644": [
            "30621477-8322-46a0-81f1-59e1f6625281"
        ],
        "f905939c-94e1-44f9-96c4-576216f11086": [
            "eda95720-ac63-4cf4-ad2d-9158b02866da"
        ],
        "12d3219a-5256-4b18-bc14-580aa2ccaf7d": [
            "eda95720-ac63-4cf4-ad2d-9158b02866da"
        ],
        "6dc99a10-bbc9-4e10-8673-e05a582a2871": [
            "eda95720-ac63-4cf4-ad2d-9158b02866da"
        ],
        "3d22fa07-90c5-4475-98e4-3033e87c88c6": [
            "eda95720-ac63-4cf4-ad2d-9158b02866da"
        ],
        "f4fde016-8813-4d68-ad58-adeb9bca1cb2": [
            "59a0c6f3-5723-46d7-b421-644d76654378"
        ],
        "e83c82e9-3b30-48e0-8a89-4380b8b786d6": [
            "59a0c6f3-5723-46d7-b421-644d76654378"
        ],
        "9fd23b96-148a-4550-89d2-8a2286c15c53": [
            "46c5e60c-808f-419a-b630-2448ee207c2b"
        ],
        "112404a9-e243-436b-8339-869c0dd5589d": [
            "46c5e60c-808f-419a-b630-2448ee207c2b"
        ],
        "496b6b5f-20d7-494b-852b-b7e8e8db6744": [
            "cc83f5fe-6b59-4f54-b4b8-2e3eba1b8578"
        ],
        "1cf46653-efd2-49c4-a8a9-805d5d89c986": [
            "cc83f5fe-6b59-4f54-b4b8-2e3eba1b8578"
        ],
        "a0b54ae6-d747-476a-ae5b-fe2f12ba0337": [
            "621593db-de87-4dda-9a91-4fc838def3ae"
        ],
        "4541b23f-42e6-4ef3-8c09-056b37514a29": [
            "621593db-de87-4dda-9a91-4fc838def3ae"
        ],
        "d919ecff-fae1-4f74-9ccc-244993b37be1": [
            "fcb989c9-8bf7-45b2-b0cf-7a3a83bf0e1c"
        ],
        "fbf34e02-bb54-439c-b91a-f974a008e2d1": [
            "fcb989c9-8bf7-45b2-b0cf-7a3a83bf0e1c"
        ],
        "5a3862f8-4fb7-43e8-b927-1c9cf719b07d": [
            "5bd27c87-c93a-4208-b5c0-00786c678d24"
        ],
        "da2f9bdf-5f75-4afd-8afd-26d30ce5f252": [
            "5bd27c87-c93a-4208-b5c0-00786c678d24"
        ],
        "2ce66d93-40fd-4aaa-8427-60c03783c98d": [
            "ca94c742-4363-4a75-ae7a-d363f3061389"
        ],
        "a42be183-8ec2-4cac-9a07-a2b18ece9f43": [
            "ca94c742-4363-4a75-ae7a-d363f3061389"
        ],
        "635f6dfe-64d9-438d-9512-5072b875d84f": [
            "d5cca10e-ff13-4cd5-b3f6-a27cd9e10309"
        ],
        "53c916f4-affc-4746-8f9f-137992c2c610": [
            "d5cca10e-ff13-4cd5-b3f6-a27cd9e10309"
        ],
        "e85adbd3-7fce-49e6-bf9c-8ee3e505e225": [
            "289ba189-5aff-45fe-b350-70946517f908"
        ],
        "e08f576c-bbe9-48d2-afd9-d84838622c37": [
            "289ba189-5aff-45fe-b350-70946517f908"
        ],
        "4adb085d-5a44-4a29-95b9-a2d5abc5df60": [
            "289ba189-5aff-45fe-b350-70946517f908"
        ],
        "0a933e59-c806-4d39-9ac9-ba91b1f8a65a": [
            "289ba189-5aff-45fe-b350-70946517f908"
        ],
        "6738471e-8fcd-4264-95ab-eabeb3bd1bb4": [
            "dd56fdfa-5f78-4ee1-a26c-29dd997a8db9"
        ],
        "9552bb42-b39d-46a4-8f8a-ba7a53023655": [
            "dd56fdfa-5f78-4ee1-a26c-29dd997a8db9"
        ],
        "3af78b8c-9a38-4427-9fc0-b707dfcdff56": [
            "42762868-e9d7-4774-ac88-4f231c5cd459"
        ],
        "51fc4258-abf9-4b6f-b01d-0cff59461f6b": [
            "42762868-e9d7-4774-ac88-4f231c5cd459"
        ],
        "32bdd9ef-6389-4847-9edb-cf6663ccd08a": [
            "ded747b5-0b63-4413-a4cc-6c6647298677"
        ],
        "051af2a0-55dd-4313-9021-95eb76c222da": [
            "ded747b5-0b63-4413-a4cc-6c6647298677"
        ],
        "7d661e7a-da31-41fa-83dd-9374e3169844": [
            "5fd5568d-5686-4275-92fc-79475717248a"
        ],
        "ce5ef6a4-c301-4e23-ab1d-118f35ede43e": [
            "5fd5568d-5686-4275-92fc-79475717248a"
        ],
        "89179b0e-47b7-45bf-87bf-dd372d9bbbde": [
            "73f0476e-8265-4f2b-ac51-461db997c4c3"
        ],
        "367ebc98-58de-4f94-ab8e-5f8506b6e7ec": [
            "73f0476e-8265-4f2b-ac51-461db997c4c3"
        ],
        "c7a38c66-13d8-4b3d-8c94-00091a73039b": [
            "35ba7061-6a45-49e0-8bd8-0b54fbd93310"
        ],
        "d6e95737-9b4a-47b0-bf60-5df74e9460f5": [
            "35ba7061-6a45-49e0-8bd8-0b54fbd93310"
        ],
        "23e8bac8-2e1e-4c05-b816-2a78f46a61a7": [
            "35ba7061-6a45-49e0-8bd8-0b54fbd93310"
        ],
        "4ccaf587-39c3-4244-b36b-46cd98ba3de8": [
            "35ba7061-6a45-49e0-8bd8-0b54fbd93310"
        ],
        "f78b1a12-373e-461d-bf5f-e8331eb064ca": [
            "35ba7061-6a45-49e0-8bd8-0b54fbd93310"
        ],
        "7c6a03e2-058f-46c3-b684-a93fd2e27592": [
            "35ba7061-6a45-49e0-8bd8-0b54fbd93310"
        ],
        "0056fc82-5385-4bfd-a556-05b7a6481d03": [
            "cb906cf2-dadf-4ae6-803e-9f7c66a5f4cd"
        ],
        "bd3cad47-df5f-4460-b83b-fb9dd27f04b7": [
            "cb906cf2-dadf-4ae6-803e-9f7c66a5f4cd"
        ],
        "688e2961-70f5-4d34-8d97-4a0bd13ac167": [
            "a94f3cf8-8025-4b7a-b6f7-bb1a5ec993e1"
        ],
        "39fde691-7710-4b79-948b-7f678e1e48f8": [
            "a94f3cf8-8025-4b7a-b6f7-bb1a5ec993e1"
        ],
        "ebb0ec25-351b-4bfd-84aa-d3495fa20a53": [
            "5d565405-3b0a-4a41-adc6-e2abc90e180d"
        ],
        "0d0188bd-126c-49a6-a6dd-41bc651f4dc8": [
            "5d565405-3b0a-4a41-adc6-e2abc90e180d"
        ],
        "9cf1879c-0606-438a-8fd9-3170645a6ad1": [
            "2694cc1a-59dd-4609-9b9d-fa7a7d1af825"
        ],
        "8879e33a-f641-4e0a-b1b2-76ff806f7bef": [
            "2694cc1a-59dd-4609-9b9d-fa7a7d1af825"
        ],
        "13f059fe-96a5-4570-9cf9-78ddf18491c3": [
            "57521df6-21f8-425f-ad01-8ac51f1edceb"
        ],
        "b7227782-f2ba-42ee-ba6e-73af4de483d5": [
            "57521df6-21f8-425f-ad01-8ac51f1edceb"
        ],
        "335c5815-0111-44ce-a402-3254769f7b8c": [
            "353e98ea-9433-4c5c-8ba5-39147764aafd"
        ],
        "292ffb77-53c9-4ef0-8eb8-ee11467d15c5": [
            "353e98ea-9433-4c5c-8ba5-39147764aafd"
        ],
        "3a0806a7-489e-45e5-84a0-5456b7a738a6": [
            "f78b8519-6943-4440-9ede-3808c5df507a"
        ],
        "57b30ed5-9c96-4459-9253-32beb5114d69": [
            "f78b8519-6943-4440-9ede-3808c5df507a"
        ],
        "8bb5ed3e-6072-409d-b822-e56c8763b8d9": [
            "02b8ebc4-7be1-4a94-84a7-7385fe051bb4"
        ],
        "3593f8b2-8203-4bc1-a0fb-096142b7ab3b": [
            "02b8ebc4-7be1-4a94-84a7-7385fe051bb4"
        ],
        "0e3f476a-c6af-486e-a465-5524b59d4bfd": [
            "90565d20-e301-49a6-8424-3c3e5453cfc1"
        ],
        "40e6f46f-2c5b-4d15-ae41-ba1c95cff895": [
            "90565d20-e301-49a6-8424-3c3e5453cfc1"
        ],
        "01adbc4e-252c-430f-bf6a-d776f0fe7275": [
            "5cbf8552-aed8-4230-94dd-810dc1dcc83d"
        ],
        "98c18ed4-93a2-446f-9b73-10cb78dd4ff2": [
            "5cbf8552-aed8-4230-94dd-810dc1dcc83d"
        ],
        "a3d10776-4ddc-4bd8-9701-56bebb552a5d": [
            "1e6272ff-4de0-434a-8394-acb70dfb88dc"
        ],
        "98388a21-1cc6-478a-b6f1-ee698a3bfa69": [
            "1e6272ff-4de0-434a-8394-acb70dfb88dc"
        ],
        "7ea42f88-8dc7-42ce-bdbf-8de83c1b7051": [
            "07627eaf-90ab-47b8-af0a-a40f63db1927"
        ],
        "d106b518-a285-4a2e-89f6-c030ac19cd99": [
            "07627eaf-90ab-47b8-af0a-a40f63db1927"
        ],
        "c4370c4b-f5e6-438d-974a-85a0fce4ed09": [
            "935cdc02-6664-4d96-8deb-426d769bb3bc"
        ],
        "7bfb6396-7df6-4f97-ac1f-488b66ac5764": [
            "935cdc02-6664-4d96-8deb-426d769bb3bc"
        ],
        "da40fb7d-1e3e-4a1d-a71d-4eff9dce4b5f": [
            "be81b602-0e1e-4762-bab9-522e34414dbb"
        ],
        "c9dba5db-da14-418f-acc9-674737c31ae7": [
            "be81b602-0e1e-4762-bab9-522e34414dbb"
        ],
        "f6210e1a-21a2-4416-ae7f-d6d00d96c062": [
            "b539c14b-c87a-4fce-bd80-c83f11f0796a"
        ],
        "13fbf865-8df0-4156-8e49-db08e22dd4ba": [
            "b539c14b-c87a-4fce-bd80-c83f11f0796a"
        ],
        "eb4f460f-ef23-4a07-bd87-ccb137b12db6": [
            "09753125-ff11-4f85-868c-caf3627506fe"
        ],
        "bfd64467-3c81-4051-b6e1-50d888e15586": [
            "09753125-ff11-4f85-868c-caf3627506fe"
        ],
        "3b7b7ad5-878e-42ee-bbf3-fe4ee77b2b16": [
            "a368d172-d9ba-4349-abca-37c13bbe3ba8"
        ],
        "c701709b-3d0a-4328-be19-5c41b7eeeaa3": [
            "a368d172-d9ba-4349-abca-37c13bbe3ba8"
        ],
        "f3571b26-611f-4038-9567-dfc8e1495124": [
            "95b3d21b-3101-44c7-99c3-f2711c16a1a5"
        ],
        "dd26471d-2482-44ba-90e3-46599cc3c285": [
            "95b3d21b-3101-44c7-99c3-f2711c16a1a5"
        ],
        "e6430aba-5ba0-4cee-a805-8b7d77e4ca38": [
            "9130d4c4-8c0d-425e-9c0b-77d6188b785c"
        ],
        "35605ec7-2a8d-4f28-bf19-95a7b4ce53b5": [
            "9130d4c4-8c0d-425e-9c0b-77d6188b785c"
        ],
        "8b519f61-ab35-49dd-8bd4-2cb29c0e3a96": [
            "f34b1abb-36c2-4092-830f-b80b9d20ef30"
        ],
        "3b38d58a-0535-4ce4-86ed-5f2c4ddb3981": [
            "f34b1abb-36c2-4092-830f-b80b9d20ef30"
        ],
        "38487bcf-449e-4c67-bf68-833cf971e22a": [
            "183f7d89-9e6d-4565-8249-12f87bbfad75"
        ],
        "14c008d0-ba36-4edd-a5af-597aea31901b": [
            "183f7d89-9e6d-4565-8249-12f87bbfad75"
        ],
        "0b758329-9526-460c-86e2-7b412fa5c4d3": [
            "e7eb56fa-c5cf-478a-9eb9-d55164bfa018"
        ],
        "994cf186-2816-4175-8a11-3a94f731c746": [
            "e7eb56fa-c5cf-478a-9eb9-d55164bfa018"
        ],
        "e5d7f970-e41a-4487-aacd-c03f254a0b94": [
            "e7eb56fa-c5cf-478a-9eb9-d55164bfa018"
        ],
        "8d7909bd-785f-4461-adcb-3e7124821de6": [
            "e7eb56fa-c5cf-478a-9eb9-d55164bfa018"
        ],
        "2dd62846-8fd2-4700-9abb-45b104bc18f5": [
            "b51ed3cb-5576-4524-890f-b54382c225a3"
        ],
        "2e22b0bd-56fd-49e2-a84f-3caf0ee964a6": [
            "b51ed3cb-5576-4524-890f-b54382c225a3"
        ],
        "62e69db1-51ca-475e-9e97-76ce50bb29bc": [
            "f995bc47-75b4-4081-afff-c49e8ab2222f"
        ],
        "3218648a-dd3d-4777-b315-41b7c51e26e4": [
            "f995bc47-75b4-4081-afff-c49e8ab2222f"
        ],
        "19995468-3824-465f-83f0-86a64ce21ea6": [
            "f995bc47-75b4-4081-afff-c49e8ab2222f"
        ],
        "e8f07706-71ad-4682-8047-6c3173ee7fdb": [
            "f995bc47-75b4-4081-afff-c49e8ab2222f"
        ],
        "3c8691bd-238e-432a-8226-72ac7350d1a2": [
            "f995bc47-75b4-4081-afff-c49e8ab2222f"
        ],
        "1b1b6fd5-9ede-452e-9023-dbf4f9ad76d5": [
            "f995bc47-75b4-4081-afff-c49e8ab2222f"
        ],
        "5114a797-222a-474e-ab1f-05cb3380d627": [
            "b1354fff-e257-4b2d-88f2-15b7271e9b49"
        ],
        "5a226878-aeb8-4b08-9cd0-3e208439b593": [
            "b1354fff-e257-4b2d-88f2-15b7271e9b49"
        ],
        "6cbdf729-137c-4b7f-9bfd-0de6f0e18a1e": [
            "f4ecf83a-c527-491b-b2c1-8db85d0271aa"
        ],
        "3e30a800-c66b-42c9-ac26-a0958504990d": [
            "f4ecf83a-c527-491b-b2c1-8db85d0271aa"
        ],
        "35db3f37-5ff4-4b3b-afbe-5eaa16531b8c": [
            "52f52946-5510-4699-b5cc-954211bbdfd8"
        ],
        "1e903fc7-2bb9-44ca-be9d-cab899a1fee3": [
            "52f52946-5510-4699-b5cc-954211bbdfd8"
        ],
        "a6f0b08d-671f-48e6-80a7-a79bfeef400f": [
            "b38f5e4f-0086-439d-8d9c-ff3c30586ec1"
        ],
        "d5ea9011-bf19-462d-b581-4314844c96ed": [
            "b38f5e4f-0086-439d-8d9c-ff3c30586ec1"
        ],
        "b6a5a657-6525-4ee5-b5e2-15beab3d2597": [
            "ead97d8a-4153-45bc-b4e6-65d4ea31f00a"
        ],
        "30e6ae2b-f89a-4533-855a-b7a4eb3bc367": [
            "ead97d8a-4153-45bc-b4e6-65d4ea31f00a"
        ],
        "76fb5a5c-b6b0-4378-872a-625dcdc8dd20": [
            "d6abc09f-38d1-4923-b834-6815d454253f"
        ],
        "90652c82-c2b8-49d4-a0c7-78192c6853f7": [
            "d6abc09f-38d1-4923-b834-6815d454253f"
        ],
        "77e28150-faf9-47fd-a941-8f4b56f8e85d": [
            "dd00f6b4-e8bf-430e-8f58-3fca15d49531"
        ],
        "210036ec-bf9e-4932-82e3-5f9793e34b22": [
            "dd00f6b4-e8bf-430e-8f58-3fca15d49531"
        ],
        "518db412-017b-4d81-9156-dfe01dea28bb": [
            "80880a8e-87b8-45e0-800d-46df68370cc8"
        ],
        "6300592f-6f0e-423d-9e5b-27004dfccdf9": [
            "80880a8e-87b8-45e0-800d-46df68370cc8"
        ],
        "14b9b7c2-4115-4245-8489-dfed4aed2514": [
            "a1a48333-69bd-41da-9746-bb94c3c50509"
        ],
        "6533b69c-b47a-4f09-bd5f-dfa96b04017e": [
            "a1a48333-69bd-41da-9746-bb94c3c50509"
        ],
        "cadb59fc-22c4-4de9-a5cd-76b9a9234a4f": [
            "a8730c09-e1e3-472f-afb6-67d736100291"
        ],
        "5b4dba7b-a299-4b74-b906-877a7afd5514": [
            "a8730c09-e1e3-472f-afb6-67d736100291"
        ],
        "155934cd-58bb-4a6d-8bc0-9fc7fcde3501": [
            "3c104931-855b-4075-b563-6226b20aaf88"
        ],
        "83aff24b-ff12-45b0-af3e-4ff9c55cce95": [
            "3c104931-855b-4075-b563-6226b20aaf88"
        ],
        "8da15bcc-7df6-43b1-8e64-94adef4e6389": [
            "c5561581-1da4-4fb4-b668-9056165ea6fc"
        ],
        "43cacd43-60a9-4548-9dc3-61f25366c11c": [
            "c5561581-1da4-4fb4-b668-9056165ea6fc"
        ],
        "b17958d4-d809-49bc-867f-f5492456165f": [
            "3a651b56-6e31-4b8f-91a4-942c7843771c"
        ],
        "ec430744-c080-470c-afd4-cb34d7dbd994": [
            "3a651b56-6e31-4b8f-91a4-942c7843771c"
        ],
        "4adb17ae-3012-482c-9881-d404117e1601": [
            "36f006b9-e882-4094-bff1-08602fb14904"
        ],
        "8633341d-b6e3-47f1-b9e1-bbc5fdcd49b5": [
            "36f006b9-e882-4094-bff1-08602fb14904"
        ],
        "573fe038-c9d4-428a-a15a-468eb892c0b5": [
            "5c7eeea4-9d09-4662-b470-9bfa6456e207"
        ],
        "a5edb149-de0b-4bab-b465-216b1ee78ac9": [
            "5c7eeea4-9d09-4662-b470-9bfa6456e207"
        ],
        "a7d26aa2-be9e-49e7-a11f-b7b1c9e5e68d": [
            "8bfd1b07-487a-4b69-b411-4fb73ffb41bf"
        ],
        "a951250d-240d-4f4a-9cd3-b4f06c54c4a9": [
            "8bfd1b07-487a-4b69-b411-4fb73ffb41bf"
        ],
        "e8ebdfe3-6332-4953-acec-6e44904761cb": [
            "924e0483-565c-4a35-87b4-c8061c2081e6"
        ],
        "d6b1a917-775b-438c-99db-a52a1e1fb934": [
            "924e0483-565c-4a35-87b4-c8061c2081e6"
        ],
        "79fc1834-cc72-46b7-9663-23375e6308bd": [
            "6c783e3d-52aa-4440-a747-006442707a55"
        ],
        "57f3bfbd-24fe-4be2-8a8e-3ff39b8dcda6": [
            "6c783e3d-52aa-4440-a747-006442707a55"
        ],
        "32418495-071a-460a-a0c8-870a1042eaed": [
            "fd5a5977-07d7-4f01-8f6f-65238451bf91"
        ],
        "c1bdae16-512e-402d-9b5c-7fa0fa332da9": [
            "fd5a5977-07d7-4f01-8f6f-65238451bf91"
        ],
        "a5deecf4-38f8-4820-ab5f-704b7c174b54": [
            "379a0d24-d19c-4898-92d9-862492e8d073"
        ],
        "43e670bb-2100-479e-ae5f-3030021c1125": [
            "379a0d24-d19c-4898-92d9-862492e8d073"
        ],
        "eed8f507-7e9e-4eb3-b895-c5d1aba9b75c": [
            "f59dac1f-87fa-4aaa-ace9-4fb05b9dd3a6"
        ],
        "161bb523-6309-4e38-ac1a-12fb0c215f90": [
            "f59dac1f-87fa-4aaa-ace9-4fb05b9dd3a6"
        ],
        "f20be62b-4c54-4eb3-ac4b-7ba1f674eaf5": [
            "69cc7703-68cc-448a-8e88-db41f62bb1b2"
        ],
        "1fe61e23-510b-415c-bee3-edbb5683e92e": [
            "69cc7703-68cc-448a-8e88-db41f62bb1b2"
        ],
        "abd6b8a0-230c-454b-a0ec-53deb24ab9da": [
            "b7f79520-7876-4d27-97bc-b68077bdfd52"
        ],
        "e6af83ab-d47a-44d2-8433-68b92df76ba9": [
            "b7f79520-7876-4d27-97bc-b68077bdfd52"
        ],
        "4a09e87e-5141-4b7c-a9eb-22fd5d495976": [
            "7b9c34e1-ebb1-4d51-aa6d-9e44cb111727"
        ],
        "9bef8302-f510-4a18-907e-533fe3544099": [
            "7b9c34e1-ebb1-4d51-aa6d-9e44cb111727"
        ],
        "c5b1691c-0b95-491f-911d-9c76788f46c5": [
            "1148cf71-2212-449a-ac88-aff57b0c80a7"
        ],
        "8e1438ea-8478-4ea5-908f-c4f609a74a0a": [
            "1148cf71-2212-449a-ac88-aff57b0c80a7"
        ],
        "ae9a4fd6-1198-4ade-be1b-97750d05924c": [
            "6f13b03a-f4a6-4156-82b2-dad340473866"
        ],
        "0f915868-c19e-4c32-9db4-60d1c2130193": [
            "6f13b03a-f4a6-4156-82b2-dad340473866"
        ],
        "cd038bee-9b34-4270-976b-8c944ff87d2a": [
            "bac754dc-7a4c-4833-8729-658b43964b38"
        ],
        "6f063d6c-79be-42b5-9458-c7f6ccfe56ff": [
            "bac754dc-7a4c-4833-8729-658b43964b38"
        ],
        "a61d2798-1e14-4453-a531-ef46037d91c4": [
            "2bdbd844-0c5e-4e63-b90f-e908c455a284"
        ],
        "283a2cfc-cb70-4e61-8cc7-4a2ec0f66cde": [
            "2bdbd844-0c5e-4e63-b90f-e908c455a284"
        ],
        "71c0e0fc-b545-41b3-89cf-84c7d89b6949": [
            "ac88eac6-f774-4702-a1d3-15395740fc55"
        ],
        "3674eb6e-a4c4-44dc-9f81-302a9297e41b": [
            "ac88eac6-f774-4702-a1d3-15395740fc55"
        ],
        "d684933d-6a29-4921-8a7e-b01b1689f403": [
            "14ccd281-d5dd-4531-ac55-2eb1e4dfcca7"
        ],
        "712b8b3b-54be-4571-8b34-d2b0cffc53a5": [
            "14ccd281-d5dd-4531-ac55-2eb1e4dfcca7"
        ],
        "20261996-32ca-4b2d-bf7a-c71faf223209": [
            "a8b1e6df-995d-47dc-aab7-5d183fca4c40"
        ],
        "66d63d7c-0e5d-49b0-b7f7-504172e4a6d6": [
            "a8b1e6df-995d-47dc-aab7-5d183fca4c40"
        ],
        "b2422cd8-6f0a-49e1-9212-08b6b209a3e7": [
            "e8c467a4-215a-4807-b8c8-b49e08ed511c"
        ],
        "ea751496-e431-4103-8570-80cc50a953f6": [
            "e8c467a4-215a-4807-b8c8-b49e08ed511c"
        ],
        "682860e5-fde0-4fd8-a9f3-1dd0d945e091": [
            "53a4527c-1f55-4390-95f5-158841bd365a"
        ],
        "12ecc499-3a01-46ed-a8f6-3769b850ac1d": [
            "53a4527c-1f55-4390-95f5-158841bd365a"
        ],
        "882f9fb9-5a80-4dfc-bd5f-ec560d61351b": [
            "f19ef160-306a-48ef-93e0-2cb2b84b09c3"
        ],
        "6f3587aa-d975-454b-aed0-b056c2aa2c37": [
            "f19ef160-306a-48ef-93e0-2cb2b84b09c3"
        ],
        "a0b2d141-1178-4342-9ea8-bbbd0709ecfe": [
            "e3025df4-b7f5-4f46-9dbe-dc66c349f38e"
        ],
        "df6dad3c-089b-4ac7-bae5-c8b5ba78380f": [
            "e3025df4-b7f5-4f46-9dbe-dc66c349f38e"
        ],
        "aaa56857-7cda-4694-bee9-27ab9b5776d1": [
            "540411d4-1283-45ec-9ea3-34cc57561f0d"
        ],
        "3ced0319-a0b4-4fbe-9361-f2b5b04c03df": [
            "540411d4-1283-45ec-9ea3-34cc57561f0d"
        ],
        "cbb61f47-50e2-4100-829f-f1a760bd6a14": [
            "6522bfe0-d185-47a2-8c02-ef5cf23d0d36"
        ],
        "1fc05942-2915-4732-9fbc-e0fb0e063b80": [
            "6522bfe0-d185-47a2-8c02-ef5cf23d0d36"
        ],
        "8fc36ae4-9d08-42a0-b446-6c1301ce60df": [
            "4dc65933-6f66-4312-b238-8699d7e02b90"
        ],
        "63a6827f-01cb-419a-bb33-26de997547ee": [
            "4dc65933-6f66-4312-b238-8699d7e02b90"
        ],
        "1a76de35-3e74-41a2-ba0c-487b93c44a18": [
            "d2826d46-851b-4fc9-8665-3277fef115aa"
        ],
        "5cd56606-19dd-47b9-8db0-26b7a5da246e": [
            "d2826d46-851b-4fc9-8665-3277fef115aa"
        ],
        "4b8b8535-08df-45f4-b2af-1779671fed09": [
            "35487a84-1e61-4266-80e2-4a0610da7820"
        ],
        "395985b1-a7e7-4721-b5f7-b9d676c78ed0": [
            "35487a84-1e61-4266-80e2-4a0610da7820"
        ],
        "0b53ff64-bffc-4d27-b860-3be0c639d25f": [
            "20fbbf82-4928-4c0e-bcc1-9c07634e1115"
        ],
        "72423db9-3a07-4751-a1d7-9aa9e9ba7a66": [
            "20fbbf82-4928-4c0e-bcc1-9c07634e1115"
        ],
        "be1a1af8-7a8c-4f4f-a9ee-d6576f77c652": [
            "00695278-6d4b-4ddc-bd3e-734f4c23d26c"
        ],
        "a170e665-1af3-4aee-9c4f-898ea09ffe76": [
            "00695278-6d4b-4ddc-bd3e-734f4c23d26c"
        ],
        "eb72ee93-0593-421a-8f7e-beb51a65096b": [
            "2379da91-057c-4fe3-b79c-0e1d40ddefe1"
        ],
        "3cbd805c-3bbd-4948-a012-3e4491b5b5c5": [
            "2379da91-057c-4fe3-b79c-0e1d40ddefe1"
        ],
        "b4e18c33-391d-4f3f-81f2-b048a01939f8": [
            "2379da91-057c-4fe3-b79c-0e1d40ddefe1"
        ],
        "d221fdc5-6dbf-4e52-bb81-816e16eb2065": [
            "2379da91-057c-4fe3-b79c-0e1d40ddefe1"
        ],
        "2e452ced-1101-40ff-9c08-083056561d1f": [
            "14afcb92-7a29-481f-974b-06a1dfba841a"
        ],
        "f99920f2-3a7e-49a2-9f44-9f7d5ea46002": [
            "14afcb92-7a29-481f-974b-06a1dfba841a"
        ],
        "b6fc8cea-4eb6-41c1-b79d-3c139b15f95f": [
            "4b44d7c5-9050-4399-8efb-1c2ba24daacb"
        ],
        "5508b6be-7ea4-4093-bd87-97b7de55ac06": [
            "4b44d7c5-9050-4399-8efb-1c2ba24daacb"
        ],
        "af95052e-eff0-4183-9a5f-740ca9f494e0": [
            "373b0a59-2390-4a9f-a035-0d5b87c54255"
        ],
        "fbbe8136-75d9-4dea-9a83-273012e39769": [
            "373b0a59-2390-4a9f-a035-0d5b87c54255"
        ],
        "0300da28-75fc-4fae-8ef1-2562670634f6": [
            "10414561-9108-4a2d-a6c6-f77fdd7bd2f1"
        ],
        "2cbc52b4-3a03-497e-8ea9-a90f3a70d372": [
            "10414561-9108-4a2d-a6c6-f77fdd7bd2f1"
        ],
        "21e0ab05-6e52-4fc3-9916-6964c780b1aa": [
            "2b7c1cac-ca9c-46d9-b1fb-75b8a7f9fda2"
        ],
        "21b9a062-ecb7-450f-8084-e1826d687cae": [
            "2b7c1cac-ca9c-46d9-b1fb-75b8a7f9fda2"
        ],
        "92f4ac79-491e-4e14-bc85-5c3aba39d737": [
            "f818c815-d774-4abe-9739-347f99c5d6ef"
        ],
        "1606fca3-fe51-498a-b531-b35bd2f70721": [
            "f818c815-d774-4abe-9739-347f99c5d6ef"
        ],
        "fe2c88ad-fec1-4cd0-941d-937c4d4578ac": [
            "b538ce56-0435-404f-b0b4-93594b0b1be3"
        ],
        "0db29dd0-7949-4ced-b028-a33fe06da6a1": [
            "b538ce56-0435-404f-b0b4-93594b0b1be3"
        ],
        "3a10f24f-2cb4-4cb4-a2a6-3fe14d0c2e48": [
            "2f8c2fad-4c7f-456f-8de3-9eaeec712c53"
        ],
        "43a405c3-0eae-445f-b296-8c45ed465c47": [
            "2f8c2fad-4c7f-456f-8de3-9eaeec712c53"
        ],
        "dc46d860-2acd-4f7f-8bdd-b46766e7406d": [
            "541645df-b8f8-46e8-812b-6722352a0fb7"
        ],
        "e6812490-2c3b-428e-88b6-279c3a308977": [
            "541645df-b8f8-46e8-812b-6722352a0fb7"
        ],
        "55ef3119-d2c9-406d-86e8-fe3d540162a5": [
            "97258932-13c5-458c-a03f-7beb014c02fb"
        ],
        "99cd4b0b-f891-432a-ac21-b1cad25e5ed3": [
            "97258932-13c5-458c-a03f-7beb014c02fb"
        ],
        "035e5920-4a9a-48de-baca-19b0fea7d6ef": [
            "0cf719de-55df-46a5-b56f-18b166e44a3e"
        ],
        "d687237b-a99a-4a7f-9d38-7e7bba6d65ee": [
            "0cf719de-55df-46a5-b56f-18b166e44a3e"
        ],
        "9dabc77f-fc62-4ba1-985c-d80a2deabbef": [
            "4f54aa77-3345-4edf-a490-c13a5666f25e"
        ],
        "2d9cbe80-69ad-4f69-b795-3621389a565d": [
            "4f54aa77-3345-4edf-a490-c13a5666f25e"
        ],
        "5875f835-e0c1-498d-a026-8a47f6b1d6b9": [
            "42d1c2a5-0d75-494e-9c3b-7a1621f1b8df"
        ],
        "1b92ca28-df9c-43dd-b82d-09d00068b8e8": [
            "42d1c2a5-0d75-494e-9c3b-7a1621f1b8df"
        ],
        "5e70d45b-1092-4883-a23b-af23a89ae5fa": [
            "b488e4ca-66d9-406f-9a62-6e2aeceebeeb"
        ],
        "0831e87b-abc5-4f74-ab5c-7fd16c12ca0c": [
            "b488e4ca-66d9-406f-9a62-6e2aeceebeeb"
        ],
        "792db2ab-eebf-44ab-99d3-5664024b5eb8": [
            "e6b116b4-bd85-4e30-80af-e99170788197"
        ],
        "cd4accd7-5daa-4911-a8d7-5466e106926d": [
            "e6b116b4-bd85-4e30-80af-e99170788197"
        ],
        "71b3d528-24a6-4c6c-94f7-83d582c7eb7d": [
            "927a28c7-976d-4cb9-a53d-378557422f17"
        ],
        "d4fe13f7-9edb-447b-94e1-9290c7f7ff24": [
            "927a28c7-976d-4cb9-a53d-378557422f17"
        ],
        "9fcecfb9-8a20-4b93-8304-03f0fbf58c2c": [
            "977d083d-0256-4034-a497-6a696a6ed5a7"
        ],
        "37e3dce5-fb29-4585-8ab8-c5f0916ab1da": [
            "977d083d-0256-4034-a497-6a696a6ed5a7"
        ],
        "b5eb53e9-eddd-4a8a-8b08-9ad1ecd30403": [
            "9e1796d6-5549-4fde-85a0-d33685b92440"
        ],
        "6e759648-bc64-4de4-839b-15b0c0d06bb9": [
            "9e1796d6-5549-4fde-85a0-d33685b92440"
        ],
        "6f02f038-7109-4098-b815-f0e1395efa7f": [
            "9de78514-936d-4a78-bcc2-d974a9796ca9"
        ],
        "48000718-1258-43c9-8678-ab95cbc39c1a": [
            "9de78514-936d-4a78-bcc2-d974a9796ca9"
        ],
        "0a296783-5cff-4c0f-b17f-b8eb133b575f": [
            "3f9be3c6-8555-481a-8662-56de95093293"
        ],
        "981ed5da-c824-4752-ac03-7e6b5c3aaca6": [
            "3f9be3c6-8555-481a-8662-56de95093293"
        ],
        "b1d79023-34cc-4b60-8d95-b26903e39ade": [
            "0b441016-499a-4bc6-94da-95d3437d0287"
        ],
        "9b8782e7-b039-4f31-a90b-a2512eb778d6": [
            "0b441016-499a-4bc6-94da-95d3437d0287"
        ],
        "12baaaf4-acd2-4f31-a952-2c623d1c4069": [
            "be5df929-359b-4932-80d6-76212dc9efdb"
        ],
        "341166f8-cfce-4553-b17b-74d3c3e78c16": [
            "be5df929-359b-4932-80d6-76212dc9efdb"
        ],
        "867665a2-962e-49ee-8c67-e949b8e89755": [
            "ab8c9d7d-94ca-425b-b2fe-f4d5c3acc6b0"
        ],
        "fa84d115-b715-4cd2-ab69-9729219497b0": [
            "ab8c9d7d-94ca-425b-b2fe-f4d5c3acc6b0"
        ],
        "8e2ccba7-54a0-42a9-8966-66d2819a895c": [
            "4e0547ab-0f86-4387-8001-0550f4078680"
        ],
        "3866ab58-832d-4d05-9508-c5f3740afe84": [
            "4e0547ab-0f86-4387-8001-0550f4078680"
        ],
        "9f6962a4-df6d-4c97-a8b8-0cd390e6b196": [
            "2b03a612-f21d-44e7-8094-16e00887b1f9"
        ],
        "e45b3e29-249e-4e71-96ef-0c89568e68be": [
            "2b03a612-f21d-44e7-8094-16e00887b1f9"
        ],
        "5d374ac5-0f16-4f99-ab89-8ce45fac69c4": [
            "90ffee9c-e46f-483e-b7a6-3d2551b090b2"
        ],
        "4a77cb8a-b82c-4546-95e9-c6223227c176": [
            "90ffee9c-e46f-483e-b7a6-3d2551b090b2"
        ],
        "723f93b8-753a-42e4-bb6e-c6be3412d9ad": [
            "90ffee9c-e46f-483e-b7a6-3d2551b090b2"
        ],
        "65b7ed7b-edbd-4ca1-b920-0f45ef7e5554": [
            "90ffee9c-e46f-483e-b7a6-3d2551b090b2"
        ],
        "6a46b7f5-424e-49c1-ad83-af2f726c591a": [
            "90ffee9c-e46f-483e-b7a6-3d2551b090b2"
        ],
        "8694e722-0b5a-449e-9164-2d1bb0a9be11": [
            "90ffee9c-e46f-483e-b7a6-3d2551b090b2"
        ],
        "147d0808-734c-4a6f-a6df-5ab08f215e1c": [
            "90ffee9c-e46f-483e-b7a6-3d2551b090b2"
        ],
        "46ced9d8-202b-407d-bec6-14ca05289944": [
            "90ffee9c-e46f-483e-b7a6-3d2551b090b2"
        ],
        "f4f50171-6710-4570-85ee-7d23aedf4a2e": [
            "90ffee9c-e46f-483e-b7a6-3d2551b090b2"
        ],
        "daf64b18-550e-4930-ab49-b14c43fa08ca": [
            "90ffee9c-e46f-483e-b7a6-3d2551b090b2"
        ],
        "e626b28e-72fa-4f0c-89e1-16f87651a3e0": [
            "90ffee9c-e46f-483e-b7a6-3d2551b090b2"
        ],
        "da89f413-addf-490a-a09a-a3aa55b3d778": [
            "774aaaa5-83f6-42a4-b576-d5ebfb164086"
        ],
        "b3f01c9f-1f75-4bbc-adbb-aac761f7c20b": [
            "774aaaa5-83f6-42a4-b576-d5ebfb164086"
        ],
        "551e71a4-18fd-445a-83b6-180c9051f11c": [
            "3c0b245b-78a6-42bb-b3ac-30205a6212cc"
        ],
        "132d461c-af45-4b89-916f-9f39e4e9ce64": [
            "3c0b245b-78a6-42bb-b3ac-30205a6212cc"
        ],
        "9e137f01-4170-4c6a-bafd-ac179d16d290": [
            "f50f90d3-d607-4a82-97e5-84ef91d5d96f"
        ],
        "cf1cdadf-9cdc-473e-bcf3-66c5051690be": [
            "f50f90d3-d607-4a82-97e5-84ef91d5d96f"
        ],
        "3a86ae7a-c5de-4d73-a58a-dc525a0e9a10": [
            "6a5d7097-9575-4c1a-ad65-7602e7353b3c"
        ],
        "5dc4cfdb-b376-493c-b548-3d126485115f": [
            "6a5d7097-9575-4c1a-ad65-7602e7353b3c"
        ],
        "4e4420da-4dcc-423d-945e-e82a26788a3b": [
            "02379cf2-e8d9-4889-81dc-f2f65b6a45d5"
        ],
        "85d181b9-1515-4bce-ac55-ddf4da7d3d6e": [
            "02379cf2-e8d9-4889-81dc-f2f65b6a45d5"
        ],
        "9fb1e5d4-6054-4615-9f06-8c617b0ada1d": [
            "a093a308-04fc-49d5-92d7-c8bf2ab7470a"
        ],
        "3c4bcff5-bef0-4d9d-8cd0-046c517427c2": [
            "a093a308-04fc-49d5-92d7-c8bf2ab7470a"
        ],
        "97a98d37-1985-4696-924e-b3980fb88766": [
            "f5f8dd89-2b8e-4b3c-9e10-55b2d5897ba3"
        ],
        "f891c581-9c4c-4488-bbcd-55ac54424f8f": [
            "f5f8dd89-2b8e-4b3c-9e10-55b2d5897ba3"
        ],
        "cc455fd8-bd41-4e08-8b5f-f00883f86c85": [
            "231c4607-f88a-4d00-b3fa-4c8f85ff6f7e"
        ],
        "78a1e42c-164f-43ba-8361-d4148138781e": [
            "231c4607-f88a-4d00-b3fa-4c8f85ff6f7e"
        ],
        "88b225c5-d27f-4eda-a085-8781443ad3b2": [
            "c1cb6863-eec7-4f8d-8da3-31a346ca9278"
        ],
        "0effb9c5-8a6c-4c84-8c32-da5fc6b00b06": [
            "c1cb6863-eec7-4f8d-8da3-31a346ca9278"
        ],
        "83b18947-58bb-4223-99b3-6df4a772f626": [
            "c1cb6863-eec7-4f8d-8da3-31a346ca9278"
        ],
        "0910a629-b7f7-4b86-924f-f08d6cad929a": [
            "c1cb6863-eec7-4f8d-8da3-31a346ca9278"
        ],
        "b1c4df72-8232-4984-b183-28f6b0b507c6": [
            "eaca21b7-f0e9-426f-a8dd-d003fb30690b"
        ],
        "79224256-ee09-4297-91fe-010b0b63aa30": [
            "eaca21b7-f0e9-426f-a8dd-d003fb30690b"
        ],
        "fea867b5-2055-4b85-917d-82c09a5dd063": [
            "d7ec7266-c7b3-4437-9218-36254e549262"
        ],
        "8263b1be-9b50-4c08-9317-5d926786df4f": [
            "d7ec7266-c7b3-4437-9218-36254e549262"
        ],
        "11b56239-8ebe-41a1-b7bb-74a095973616": [
            "008065c9-876f-433e-99a2-66fee3bf07f6"
        ],
        "28cb42fa-fc67-4116-8037-676fbb518c94": [
            "008065c9-876f-433e-99a2-66fee3bf07f6"
        ],
        "bb17fd12-c1f5-4ce2-b754-3b136d03bf7e": [
            "03c46091-c875-4274-8fd9-8b2d013acbbe"
        ],
        "d620827a-39b6-4848-ae76-84b5ab6ba668": [
            "03c46091-c875-4274-8fd9-8b2d013acbbe"
        ],
        "f4ab4c1a-9a72-46ba-ab05-03544afadeba": [
            "c87438ef-e6b5-47d4-aade-08837ccf18d1"
        ],
        "c0af2c13-444f-4f91-a8f2-7d379800b337": [
            "c87438ef-e6b5-47d4-aade-08837ccf18d1"
        ],
        "cbaea85a-593f-4700-9a30-52fecb7c8994": [
            "3ddc19b8-3e13-4ca7-8030-89e97d12c3db"
        ],
        "8b35bb2a-7692-47bf-a67b-7fc3897976c0": [
            "3ddc19b8-3e13-4ca7-8030-89e97d12c3db"
        ],
        "7b677b76-07ea-4ba6-b4c2-bce9d1c62521": [
            "f9052634-3d77-4110-9dff-e2a3b2caa10b"
        ],
        "b8b42760-cc5d-48a5-9452-7f59b10c5a01": [
            "f9052634-3d77-4110-9dff-e2a3b2caa10b"
        ],
        "8b2eb898-189e-4093-b324-a24d6bee89f5": [
            "93fa711c-79a3-4bcb-8f4f-b05f35c0004e"
        ],
        "51fca553-7aa6-4060-8657-55cd902b11ca": [
            "93fa711c-79a3-4bcb-8f4f-b05f35c0004e"
        ],
        "194c1bd2-e9be-4ded-b23a-7c1b812e739f": [
            "bbfa8744-b4e7-473f-b693-43102367ce7f"
        ],
        "7b58ad2e-d864-42c4-80c1-fcd70c6b2958": [
            "bbfa8744-b4e7-473f-b693-43102367ce7f"
        ],
        "f784326b-002a-440f-861e-b2e9d68f6829": [
            "bbfa8744-b4e7-473f-b693-43102367ce7f"
        ],
        "34b68b00-33dc-48eb-81df-2961eddda15d": [
            "0dc535c7-6638-4afe-9efb-816f9687bc2e"
        ],
        "b7cf53db-5283-4f84-be95-536323b23f25": [
            "0dc535c7-6638-4afe-9efb-816f9687bc2e"
        ],
        "8cd84934-cd7c-493c-93a3-70b284aa0d74": [
            "cb6ab055-78d6-452d-8c16-dcbecb1234af"
        ],
        "bd91ec72-f4c4-4ab7-a009-7ad24b79a75a": [
            "cb6ab055-78d6-452d-8c16-dcbecb1234af"
        ],
        "d5f0aba7-ab51-407e-af1f-c0a187c9949e": [
            "5870a6c5-c628-4cf8-8822-39fb902b18a0"
        ],
        "7c97312a-b0e4-48cd-9882-dbeecc8d7901": [
            "5870a6c5-c628-4cf8-8822-39fb902b18a0"
        ],
        "d0b00060-bcc7-4bb2-bd4c-a68bcf5f1ebb": [
            "2dc0f606-cd58-42c0-8f8e-4bf2f7ab67ac"
        ],
        "722f871b-9eba-4359-b8a7-b38eb1d01392": [
            "2dc0f606-cd58-42c0-8f8e-4bf2f7ab67ac"
        ],
        "93f66db9-01a6-4358-b609-282db0c13279": [
            "167664b7-6fde-4e26-a8d0-4a8e1ca7bb34"
        ],
        "52f6581f-fef7-49b1-b545-1732fdbb7e61": [
            "167664b7-6fde-4e26-a8d0-4a8e1ca7bb34"
        ],
        "23ea4d23-5ef4-4d24-af35-03e04cbe6f1e": [
            "b7955461-ccba-48a4-b6dd-ccb1babee16c"
        ],
        "413f0565-fda9-4833-a90e-6e711461c71d": [
            "b7955461-ccba-48a4-b6dd-ccb1babee16c"
        ],
        "ca67238f-c119-4049-8bf0-0b48b7be9c47": [
            "90cb2eaa-3ee4-4f7d-a322-f2c2ef30520d"
        ],
        "c907928e-a9a2-4782-90bf-75a63392dd36": [
            "90cb2eaa-3ee4-4f7d-a322-f2c2ef30520d"
        ],
        "a2302a3d-8447-41b9-9816-057e38d8d2b9": [
            "90cb2eaa-3ee4-4f7d-a322-f2c2ef30520d"
        ],
        "8fda367a-f8de-42cd-b7ae-1a9a5c0b9d3a": [
            "90cb2eaa-3ee4-4f7d-a322-f2c2ef30520d"
        ],
        "96f1cba9-cdc7-4397-9ea6-58b9826cd468": [
            "90cb2eaa-3ee4-4f7d-a322-f2c2ef30520d"
        ],
        "9d355b30-a8be-4fdc-89e1-50cd731fdfbd": [
            "90cb2eaa-3ee4-4f7d-a322-f2c2ef30520d"
        ],
        "b5f5af9f-4654-4852-9444-f74e2d0bdea2": [
            "90cb2eaa-3ee4-4f7d-a322-f2c2ef30520d"
        ],
        "8466c760-652f-44e1-be2d-c203b3816dcd": [
            "90cb2eaa-3ee4-4f7d-a322-f2c2ef30520d"
        ],
        "fb3fa327-144c-41c4-ad38-704e8d69be26": [
            "90cb2eaa-3ee4-4f7d-a322-f2c2ef30520d"
        ],
        "eb90e368-9d7f-4fa7-9195-ec32f0dfac84": [
            "90cb2eaa-3ee4-4f7d-a322-f2c2ef30520d"
        ],
        "04da4ac3-06f8-4025-8dea-904c495f0c68": [
            "90cb2eaa-3ee4-4f7d-a322-f2c2ef30520d"
        ],
        "43323c5b-7f2d-459f-bbf9-c88e74ce393b": [
            "e5054df0-5af9-4dfe-a5b0-0fb31e94874e"
        ],
        "f096e252-5f57-4987-ac26-364be3dc9520": [
            "e5054df0-5af9-4dfe-a5b0-0fb31e94874e"
        ],
        "d4f474af-4d52-4964-a595-5b1bc6e64a47": [
            "d3e50ee4-c947-4b73-8473-66cb14a16d00"
        ],
        "bce98077-c4b6-4647-afc2-bfd28e912aec": [
            "d3e50ee4-c947-4b73-8473-66cb14a16d00"
        ],
        "5880dc77-5012-4d42-afe5-20cd647bb8d6": [
            "bd86b24f-8eb4-447c-a08e-e15433cf30f7"
        ],
        "5b17ee06-a45b-44fa-9c74-a0639feac1e5": [
            "bd86b24f-8eb4-447c-a08e-e15433cf30f7"
        ],
        "da2af809-b5d3-4af5-803b-60b4c6a4fda7": [
            "ac5a9572-36de-49ad-955b-4242ffbebff6"
        ],
        "bdfa2ad6-ca93-417d-b53a-2847217bb561": [
            "ac5a9572-36de-49ad-955b-4242ffbebff6"
        ],
        "7757f4eb-e9c1-4cc6-8a58-73183f5bee2e": [
            "2c7ef212-e10e-41c9-802b-a8a94b192db9"
        ],
        "d6c95dec-b952-43f3-a7bb-4e8bd81b3e73": [
            "2c7ef212-e10e-41c9-802b-a8a94b192db9"
        ],
        "49c7469f-654a-4ab0-bc41-a7d27d9709d9": [
            "2c7ef212-e10e-41c9-802b-a8a94b192db9"
        ],
        "578a218f-3f9a-47b0-bb3e-3f5c323babf5": [
            "2c7ef212-e10e-41c9-802b-a8a94b192db9"
        ],
        "e8d70e47-0e99-48a0-84f2-77dcf992258d": [
            "ad352e42-79f6-4006-b94a-7fe431fe40e2"
        ],
        "8e09b5e8-661d-4bb6-bcde-3f278d584ecf": [
            "ad352e42-79f6-4006-b94a-7fe431fe40e2"
        ],
        "01a89be2-5a41-4308-a0f2-dc87d2ebba8c": [
            "64655093-1dfb-4395-874d-0225d075b505"
        ],
        "5185071a-b4c8-4dd4-b465-2e710131a1d7": [
            "64655093-1dfb-4395-874d-0225d075b505"
        ],
        "353e9526-927e-4b52-a181-de6b1ba13926": [
            "4a302145-1027-409a-b7d2-3f11ef844d8e"
        ],
        "bc6e8f78-254e-4f77-8e3f-cbad621f4043": [
            "4a302145-1027-409a-b7d2-3f11ef844d8e"
        ],
        "91a81f0b-561c-4b0f-9a7c-f94a4fe182ac": [
            "71a1d6d4-0057-44be-8809-2f5521fd6264"
        ],
        "f581e6a6-cca6-45da-8d47-1fdf8f33efb1": [
            "71a1d6d4-0057-44be-8809-2f5521fd6264"
        ],
        "bd9a0689-dd5a-4884-8b89-87c5c6686dfb": [
            "d45bb600-f55a-4083-a4cd-2b6065df5f96"
        ],
        "dd9d3c64-61fa-45fd-b2c3-051e86f66df5": [
            "d45bb600-f55a-4083-a4cd-2b6065df5f96"
        ],
        "5fda714f-747c-468f-97e5-30dcf8669253": [
            "23337812-9e76-4c30-9051-8a369aefb2ee"
        ],
        "b78c9ffb-90b2-4356-ac4d-6ad3d444dfde": [
            "23337812-9e76-4c30-9051-8a369aefb2ee"
        ],
        "0899ff0f-4732-4a9c-a237-6f86bffa5081": [
            "b3201c4b-6e10-4484-a6dd-92f7e1416494"
        ],
        "77ff658a-5fdd-4a9c-877c-02f3e054a11e": [
            "b3201c4b-6e10-4484-a6dd-92f7e1416494"
        ],
        "a463e25c-3218-4429-a5dc-2f6137459bea": [
            "cecb99a2-6a96-43cf-b44d-002bf14e46fb"
        ],
        "4c27907e-8857-4d9a-b74b-187033ba9068": [
            "cecb99a2-6a96-43cf-b44d-002bf14e46fb"
        ],
        "3cfe20b3-b76e-4507-b88e-1e80761dd0bb": [
            "49e914e1-e521-45b6-8ed9-5990bf6e53e8"
        ],
        "4daaa740-7f7f-4d5f-9d06-16ec86f9c56c": [
            "49e914e1-e521-45b6-8ed9-5990bf6e53e8"
        ],
        "a6b7ef51-f899-450b-9fcc-63db3ddd80c7": [
            "7bc1c9a5-90c9-4a89-8986-57ffbfcf9aa1"
        ],
        "cd718422-999c-4e7a-bc27-e228709c7fb0": [
            "7bc1c9a5-90c9-4a89-8986-57ffbfcf9aa1"
        ],
        "85f5c867-7e04-4469-b702-0ede0576a65d": [
            "04457966-9a78-4398-8895-68c9e319d887"
        ],
        "8d0dec25-655e-457f-baaa-f7fa5e03ec5d": [
            "04457966-9a78-4398-8895-68c9e319d887"
        ],
        "41c329d9-aa1e-4f06-9954-ded71e5c2db3": [
            "ae5a02d8-af66-4da0-ab14-12162d43e5db"
        ],
        "16925f07-795e-4d05-8870-3545e6144413": [
            "ae5a02d8-af66-4da0-ab14-12162d43e5db"
        ],
        "3c3fcd96-d022-43e5-9809-8c3ff893009c": [
            "a57583e6-233a-4502-962d-29bffb14aaac"
        ],
        "bf9dbe6c-be00-4487-881c-6f6a44c44ec6": [
            "a57583e6-233a-4502-962d-29bffb14aaac"
        ],
        "721f241e-3487-4aff-87c7-1029046d7346": [
            "daef6735-d862-45ed-ba9e-5593287bcfb2"
        ],
        "8a5dd72f-92aa-48ef-a0bb-be3b8d41c695": [
            "daef6735-d862-45ed-ba9e-5593287bcfb2"
        ],
        "b6b13f6d-7ff5-4241-bbd1-c795e1fe9701": [
            "5eb548a2-c01c-43b2-a9e6-b617dbad27ca"
        ],
        "6ce63b8b-13f7-4ba1-abf5-cb605506eb81": [
            "5eb548a2-c01c-43b2-a9e6-b617dbad27ca"
        ],
        "79eefa17-6114-4056-8fd1-d247427eba03": [
            "2e7abcfe-bd44-4343-b599-964f9b63c984"
        ],
        "6185be28-be61-491a-8634-8525734b5a00": [
            "2e7abcfe-bd44-4343-b599-964f9b63c984"
        ],
        "c0050614-d341-4348-a054-505e44774425": [
            "dde2b537-52ca-4d26-836c-1ea3c73120ad"
        ],
        "5ad103c6-50c9-469e-9f81-05a2159ba88e": [
            "dde2b537-52ca-4d26-836c-1ea3c73120ad"
        ],
        "816b2965-378c-42c7-b256-2ad8d88f4f35": [
            "e610d100-cd70-4cf1-b47a-d8979d8fd2a2"
        ],
        "20304700-f261-4d5b-a446-3131d8af6fa8": [
            "e610d100-cd70-4cf1-b47a-d8979d8fd2a2"
        ],
        "383686eb-4a3b-45ee-b95d-412b2e2be3af": [
            "d0c3ae7a-e714-4adb-af64-637eb2a14759"
        ],
        "1ba4ab8f-3b16-4843-a633-6704f9644b39": [
            "d0c3ae7a-e714-4adb-af64-637eb2a14759"
        ],
        "2ef6e18b-151b-4fdd-9b5e-d0ac77e560da": [
            "27cc131d-e18e-47ee-bb4b-89ee9c9f52a2"
        ],
        "148b3760-053e-448d-98cb-11548a0753fa": [
            "27cc131d-e18e-47ee-bb4b-89ee9c9f52a2"
        ],
        "86a94374-5257-4dcd-8c54-3f6a3dbd673e": [
            "b761e8ba-fa56-4f3d-9bff-e4d88c83b1a7"
        ],
        "a3550532-3966-4d34-a288-28801e593941": [
            "b761e8ba-fa56-4f3d-9bff-e4d88c83b1a7"
        ],
        "f6d9dec8-60a4-4feb-abd9-27bc7bf64a80": [
            "d4e5d28a-e589-496f-bb35-525a7db6da55"
        ],
        "f96a1341-5515-4d4b-ae58-72c83f7f5cfc": [
            "d4e5d28a-e589-496f-bb35-525a7db6da55"
        ],
        "24528bf8-319b-43e3-9514-d9e655dcff8b": [
            "27e2b7e1-cbde-476a-a5d3-8fb1fedb9ed9"
        ],
        "249941fb-1bf9-461a-85e7-43ee27f879b5": [
            "27e2b7e1-cbde-476a-a5d3-8fb1fedb9ed9"
        ],
        "d8d950af-b5d0-421d-a9dd-bc28f8bbfe0e": [
            "92dd37bf-af3e-48be-bcdd-108df6a877f0"
        ],
        "27799913-a335-4ef3-89ab-d6ea7055cc12": [
            "92dd37bf-af3e-48be-bcdd-108df6a877f0"
        ],
        "0b6df22f-b4a5-4830-9d8a-2134fc9aac70": [
            "92dd37bf-af3e-48be-bcdd-108df6a877f0"
        ],
        "12d9cd92-ddb6-4f3f-a190-7b08dd2a1fca": [
            "92dd37bf-af3e-48be-bcdd-108df6a877f0"
        ],
        "2f195be7-9f01-4fee-966e-9a48c730e42e": [
            "92dd37bf-af3e-48be-bcdd-108df6a877f0"
        ],
        "240a2094-bc62-4663-87e3-a6c218b15ac6": [
            "92dd37bf-af3e-48be-bcdd-108df6a877f0"
        ],
        "6fdc3381-d49e-48c7-a1ae-f0a00024bdc5": [
            "1a8c1aa2-896f-49fc-b042-a6bdb78d7e77"
        ],
        "d193d13b-f9f5-4ddd-bfaf-e6298ccfcf0a": [
            "1a8c1aa2-896f-49fc-b042-a6bdb78d7e77"
        ],
        "807d607d-2557-4d0e-b291-e16e66cc7487": [
            "e32a91ab-aade-4cdb-b029-54fe0f4f8549"
        ],
        "ebc80bfb-0e5f-4680-999e-54b05b1142c3": [
            "e32a91ab-aade-4cdb-b029-54fe0f4f8549"
        ],
        "6505a24e-9ddb-4137-9972-2577d1d2da3d": [
            "c4d19ae7-443a-4426-ba96-466e2aa4bc1d"
        ],
        "b724217f-6b08-4cd1-a693-734ea1902b54": [
            "c4d19ae7-443a-4426-ba96-466e2aa4bc1d"
        ],
        "4cce0f27-0a37-4d12-95f2-18dc8556aa1f": [
            "c4d19ae7-443a-4426-ba96-466e2aa4bc1d"
        ],
        "3fddd47e-73ce-468d-a58e-e9347cb89da5": [
            "c4d19ae7-443a-4426-ba96-466e2aa4bc1d"
        ],
        "75d0391c-f0ba-453b-a21f-8446c92ccf53": [
            "056f2a6b-9e9f-4c1e-870c-91c013a950c1"
        ],
        "14b037d8-59ec-4508-bea8-cd5f996b0d79": [
            "056f2a6b-9e9f-4c1e-870c-91c013a950c1"
        ],
        "9c4a246d-968d-4dfe-97d9-0de839e4ccb9": [
            "531b93cf-3480-4d76-ade9-91a965ed4971"
        ],
        "afda0fed-0f9a-4ea3-b72c-bd56df6bb873": [
            "531b93cf-3480-4d76-ade9-91a965ed4971"
        ],
        "9ee5675e-8e9a-4f2d-a6e2-acd821b79254": [
            "e3530751-1715-44f8-bac2-56c4468e2197"
        ],
        "bf94c668-e6ef-4a39-8cbc-17aec15bf83b": [
            "e3530751-1715-44f8-bac2-56c4468e2197"
        ],
        "b524d429-9f2d-48d3-bead-7e0d14c32192": [
            "ad6c2f83-78d3-4df6-83b6-8977bacc71a9"
        ],
        "d2f5b46b-901a-487b-a3a9-3f7e5fdeb2d8": [
            "ad6c2f83-78d3-4df6-83b6-8977bacc71a9"
        ],
        "e6618314-92b9-46e1-ae26-bc6c78f57931": [
            "5e01f252-e318-4fd8-a9b4-fd56945e8494"
        ],
        "decd65ab-d964-4cde-aa5a-1b1e89e48826": [
            "5e01f252-e318-4fd8-a9b4-fd56945e8494"
        ],
        "a7c16ff8-6024-4f3a-83a6-121fad675da9": [
            "9e21c9ce-0bcc-4e82-bdbb-550e765b2cbe"
        ],
        "bc9dd419-09ca-4c77-841c-f3bfcc56593e": [
            "9e21c9ce-0bcc-4e82-bdbb-550e765b2cbe"
        ],
        "db7d2173-a7ce-438e-8450-7b0ee6461bc2": [
            "2dd656f9-017a-47cf-99fd-cc5107477575"
        ],
        "ae63f5ee-17ef-496e-8a04-c199a852027d": [
            "2dd656f9-017a-47cf-99fd-cc5107477575"
        ],
        "d693f81f-1515-46ad-a901-6f63eb4bc159": [
            "0f2a486e-cb75-40b8-aeee-c928f2ba78fb"
        ],
        "7e470645-112b-4d23-935c-7402b07490b1": [
            "0f2a486e-cb75-40b8-aeee-c928f2ba78fb"
        ],
        "36a0687c-f3b1-485e-a536-20a840d93dd4": [
            "45689d76-dd98-4835-aa92-f84da339235b"
        ],
        "40657792-b9bb-4101-9702-93952bb36390": [
            "45689d76-dd98-4835-aa92-f84da339235b"
        ],
        "bd4ff663-3f75-4a13-8c9c-b4450c46fc58": [
            "6faef32f-79a3-442e-b1bb-dc0c02d1554b"
        ],
        "173de5dc-62e6-4d60-80bc-ed37de07d3ec": [
            "6faef32f-79a3-442e-b1bb-dc0c02d1554b"
        ],
        "519aac52-d3d7-4458-b73b-511017f7992b": [
            "6faef32f-79a3-442e-b1bb-dc0c02d1554b"
        ],
        "3a42e6a1-3c7f-4c98-955c-23cdee6c99ee": [
            "6faef32f-79a3-442e-b1bb-dc0c02d1554b"
        ],
        "a182caec-3f49-4f44-8f00-a30f5cda2854": [
            "136b4833-82c1-4fb4-8b7e-6457b8df9572"
        ],
        "3bcf80cf-d1e2-44f7-853f-8758b54f4c32": [
            "136b4833-82c1-4fb4-8b7e-6457b8df9572"
        ],
        "0227c4e7-9f1d-455e-9293-4d4c4ae113cd": [
            "6bd66045-8417-4978-9834-9ad3f2a8609c"
        ],
        "64c6ac9c-cce9-42cc-ab27-d93cfee11fd7": [
            "6bd66045-8417-4978-9834-9ad3f2a8609c"
        ],
        "2f3cbf11-e959-4f9e-98b7-1d8db6754a17": [
            "b6b71187-8bfc-45e0-ad18-ca8e973b5ad5"
        ],
        "a461ae08-aa6b-4e72-a323-45ac2a8fa31e": [
            "b6b71187-8bfc-45e0-ad18-ca8e973b5ad5"
        ],
        "28fb33a0-e526-4d3d-9151-d6cc30720d67": [
            "f6827075-1136-4f22-831d-d25e9f8d4fba"
        ],
        "a6d35e7d-f526-4511-8888-0701c15bcf38": [
            "f6827075-1136-4f22-831d-d25e9f8d4fba"
        ],
        "58e077c6-2828-4439-b1b1-f9ba60f8800a": [
            "274b9900-8d41-4b35-af0a-87763580faa1"
        ],
        "bf20350c-7617-490d-a3a6-45e57be2035f": [
            "274b9900-8d41-4b35-af0a-87763580faa1"
        ],
        "1a878ce1-6666-4e44-bf5f-d5148d4be694": [
            "e5ac5443-5caf-419f-9ee4-cf0f0071da47"
        ],
        "64e6dcce-e1c4-4b6b-9b06-b1b553bb2602": [
            "e5ac5443-5caf-419f-9ee4-cf0f0071da47"
        ],
        "fb3ac206-2fc9-4b23-91b0-df339f7db647": [
            "46593cb8-3b36-44bc-869a-3ac2f81e9955"
        ],
        "bfab05bb-769f-45b3-8a1b-816d60f5afab": [
            "46593cb8-3b36-44bc-869a-3ac2f81e9955"
        ],
        "cf700707-3ade-4d6c-a059-7c92ff02945d": [
            "84c7b420-0064-4a86-a532-cc42568112b7"
        ],
        "e5d55d8b-2db3-430c-a5c9-1fa3b6133e5c": [
            "84c7b420-0064-4a86-a532-cc42568112b7"
        ],
        "30e0207a-4e43-44b0-8b56-c2e0f9ffa063": [
            "84c7b420-0064-4a86-a532-cc42568112b7"
        ],
        "bb2865ed-c3d3-4467-9e5a-5c9caf591954": [
            "84c7b420-0064-4a86-a532-cc42568112b7"
        ],
        "11bca7e3-c03f-426f-a156-9843c7db73d6": [
            "84c7b420-0064-4a86-a532-cc42568112b7"
        ],
        "487582c7-be35-4b3a-ad75-dd95d2541973": [
            "a67019e4-f04a-413b-92b3-1c4df0745da9"
        ],
        "8f1cec9a-c973-41a5-9f3c-be39d0f68008": [
            "a67019e4-f04a-413b-92b3-1c4df0745da9"
        ],
        "1d21a61e-b605-4020-85b9-db4ad10213af": [
            "1dbeb54a-3995-48bb-98bf-5b6510daadc6"
        ],
        "bd93580b-0199-4976-845c-bd1dfb9ca349": [
            "1dbeb54a-3995-48bb-98bf-5b6510daadc6"
        ],
        "9e0940de-6769-4add-9165-c98ce6e277d5": [
            "32761176-6ce9-40ea-8b64-a3b0a88129f3"
        ],
        "b686c679-cedf-4608-8dcf-1f720dba026e": [
            "32761176-6ce9-40ea-8b64-a3b0a88129f3"
        ],
        "883b9c65-4923-44e6-a75e-d67ea4489c81": [
            "0a8aec8b-e3af-43dd-a60d-c20da7a4f854"
        ],
        "72dc0381-f7a7-4786-bc4a-43072be2349d": [
            "0a8aec8b-e3af-43dd-a60d-c20da7a4f854"
        ],
        "f50c295d-f1c4-4cfd-9f0f-bf8ff72cdccd": [
            "128a1d9f-946a-4599-ae99-b3189b4d7c78"
        ],
        "d78e0f76-8daf-490f-81d1-dd2d6262f010": [
            "128a1d9f-946a-4599-ae99-b3189b4d7c78"
        ],
        "01181f58-5d61-4c22-8ad7-2a850bf2e6c6": [
            "977fee4d-0f92-49b1-83a3-039def33f7d7"
        ],
        "f4364d61-aab3-43d9-a07d-08c3f3f0c079": [
            "977fee4d-0f92-49b1-83a3-039def33f7d7"
        ],
        "0fd5c2dc-22c3-4e78-a9d5-db13ddbf72ae": [
            "672c0122-c006-4227-acab-e4e1e3ed5227"
        ],
        "93e807cb-1b38-46a5-919e-7e12f6d8f63d": [
            "672c0122-c006-4227-acab-e4e1e3ed5227"
        ],
        "52cae49a-8d04-4428-ba98-071bf1b57232": [
            "b6ca70a7-930e-4a86-a77e-7316860b5062"
        ],
        "d7438e3a-64f9-4825-8f23-d90949b4ebc8": [
            "b6ca70a7-930e-4a86-a77e-7316860b5062"
        ],
        "effa3ef4-334c-4198-b2c6-268a04038898": [
            "00aeb626-8241-4a3e-b73c-7eff0ea6ce7d"
        ],
        "c2ba37d4-7993-438c-9615-a1adf33f4027": [
            "00aeb626-8241-4a3e-b73c-7eff0ea6ce7d"
        ],
        "20cee6ec-f972-496f-b7e7-b2bebded032d": [
            "b591b346-e29c-4bae-8d74-0d3605479677"
        ],
        "a0583f76-7f6d-4635-8451-d30c714b145c": [
            "b591b346-e29c-4bae-8d74-0d3605479677"
        ],
        "b9279487-0e2d-420e-b76a-ffcb5011e270": [
            "6db4b33e-fc51-4b99-845d-74a0a26410cc"
        ],
        "56ca4805-4c72-4480-828d-7ac00007fc8f": [
            "6db4b33e-fc51-4b99-845d-74a0a26410cc"
        ],
        "0e13d31c-1472-47f9-aee7-088e828c9b20": [
            "3abc788d-6b3b-4a7d-ae23-f8fb5ceae910"
        ],
        "7fb2f3df-dbb2-4cf9-a344-0ae17303acc1": [
            "3abc788d-6b3b-4a7d-ae23-f8fb5ceae910"
        ],
        "e9898f30-e879-4d41-a015-cc97d4160f3c": [
            "783d6a02-6940-4aa1-ad49-74217165d0e0"
        ],
        "ea847545-206a-4aff-9102-753770365c53": [
            "783d6a02-6940-4aa1-ad49-74217165d0e0"
        ],
        "3ed1a451-271a-49b0-a874-5c6c061b491c": [
            "d2a6ea06-5d94-449c-bc34-0d4069f74781"
        ],
        "00e93cf2-2349-4f7e-afe9-cf86b4a61ff5": [
            "d2a6ea06-5d94-449c-bc34-0d4069f74781"
        ],
        "f016a476-326a-4e30-914f-3519fb709f0c": [
            "817b64a0-cd54-42df-892e-8bf93e6c0ec2"
        ],
        "45c82a06-032e-439a-ab37-2f72476aa7d5": [
            "817b64a0-cd54-42df-892e-8bf93e6c0ec2"
        ],
        "f76ff15a-0e13-4900-ade1-593decadae37": [
            "5147596e-1323-4097-8899-97b1aa12651b"
        ],
        "a3767102-93a8-4c6b-9941-ae3e4bea0b00": [
            "5147596e-1323-4097-8899-97b1aa12651b"
        ],
        "094a885e-6fb0-4479-b40c-fad706fa514c": [
            "b6f5ead8-2681-4bfc-ac61-db0b16bf956a"
        ],
        "982b5b36-9fef-4680-afc1-e5df8784e8a7": [
            "b6f5ead8-2681-4bfc-ac61-db0b16bf956a"
        ],
        "3e92001d-eba9-437c-9ae9-bf0e073e7ef1": [
            "9a300ff5-85c5-48ad-bda4-21ae78e10185"
        ],
        "58e5e91f-1547-4303-9e6f-6a5a2095659e": [
            "9a300ff5-85c5-48ad-bda4-21ae78e10185"
        ],
        "11099a12-0bed-4629-9dfd-4c13dc7b5a03": [
            "87ab430a-815a-4c1f-9a26-ce5e380609b2"
        ],
        "7c3dfb0b-76be-4208-b400-05b50dbca41e": [
            "87ab430a-815a-4c1f-9a26-ce5e380609b2"
        ],
        "9d7fb753-c341-41a2-9660-83f0c092b98e": [
            "d81342b3-ad97-4a19-a330-25d64e607a84"
        ],
        "cd6f2ff3-a78c-483d-aa52-3cc8e7ab4d0d": [
            "d81342b3-ad97-4a19-a330-25d64e607a84"
        ],
        "e37ed638-dc8f-438f-b2f4-9890e34ac405": [
            "58370cc5-3939-4cc1-96d6-311dc06dc07b"
        ],
        "bc3e2925-5119-47b9-8ce5-637e3f1d6411": [
            "58370cc5-3939-4cc1-96d6-311dc06dc07b"
        ],
        "c15b3710-255f-4e4a-8493-e57a216c1220": [
            "62bd4da0-5ffe-4c2c-98e0-1ff01fb079d8"
        ],
        "51fe61f3-22fa-47dc-8103-8fcffe3aee1d": [
            "62bd4da0-5ffe-4c2c-98e0-1ff01fb079d8"
        ],
        "e25d112b-0cde-4cdb-a318-11b3b07255bd": [
            "5ab1c9f7-0f35-4073-aa8b-f4efab93d16c"
        ],
        "7038f624-4ad5-4ebd-bc56-0026da47581b": [
            "5ab1c9f7-0f35-4073-aa8b-f4efab93d16c"
        ],
        "949c9348-27f3-4682-8b4c-b68077cb27ff": [
            "101c550c-0dab-488a-85da-87bf526bd94b"
        ],
        "14f15eda-b68d-499a-9888-e223a766a769": [
            "101c550c-0dab-488a-85da-87bf526bd94b"
        ],
        "a3f365c5-63ae-49c9-9906-9771e5ca56a2": [
            "18983a12-28da-4fac-a057-859be9c7e6ac"
        ],
        "ef37e007-d4e8-4c5b-94fa-3befd23153c2": [
            "18983a12-28da-4fac-a057-859be9c7e6ac"
        ],
        "80d32328-107e-4d26-b277-b22cdcd87066": [
            "32e660e7-c321-4191-8231-d80bbab933c4"
        ],
        "689bfb47-ff17-43ac-b047-860737e7e005": [
            "32e660e7-c321-4191-8231-d80bbab933c4"
        ],
        "ab929301-db39-4259-bd66-6e2879a68317": [
            "26aae293-3610-434b-9ee2-93183a1ee7ef"
        ],
        "0c82697f-2182-4cc3-8558-a81f71ea7197": [
            "26aae293-3610-434b-9ee2-93183a1ee7ef"
        ],
        "97a82a2c-d5d3-4bc3-bf5e-4edfdad7e125": [
            "538834c7-7f65-412b-9df7-49d93ff14a73"
        ],
        "7225ba8c-c051-4801-b379-167b254a41e0": [
            "538834c7-7f65-412b-9df7-49d93ff14a73"
        ],
        "b0b8c6d1-fcca-43c7-aeb9-3234c4a085a3": [
            "7b01f80f-f160-4c35-9648-773834480ad6"
        ],
        "d6f460be-8ff0-4e6c-9841-8fd749dbb517": [
            "7b01f80f-f160-4c35-9648-773834480ad6"
        ],
        "a8d624bc-9c8b-4afd-b131-59846904fc63": [
            "720cde39-09eb-43ef-b17d-4a9b99b303b0"
        ],
        "a3840f06-0aaf-4c97-bf26-3d212db80f70": [
            "720cde39-09eb-43ef-b17d-4a9b99b303b0"
        ],
        "5a27c4a3-a0a7-45b2-840b-cf57f1ba8821": [
            "a13adfe2-e3e8-4c6c-8888-c13d53169b0e"
        ],
        "8ad4d377-a7fe-4938-b786-ffb07fca6081": [
            "a13adfe2-e3e8-4c6c-8888-c13d53169b0e"
        ],
        "115d34e6-8d20-4980-87a1-85e0ef559a76": [
            "3794048a-9a81-4ae4-9224-ee5ca274b56d"
        ],
        "d28968db-bedb-4f51-97cc-b6d76770fe48": [
            "86e443ce-b9a4-4ecd-8cec-b56bcf5cbc78"
        ],
        "bb7d239c-c741-4dfb-a4d0-764ef4a26723": [
            "86e443ce-b9a4-4ecd-8cec-b56bcf5cbc78"
        ],
        "d402bb33-ff4b-4cc3-b704-ae20d944bdff": [
            "86e443ce-b9a4-4ecd-8cec-b56bcf5cbc78"
        ],
        "c0d2a03e-6bf2-459e-8d42-f37e1e67a748": [
            "86e443ce-b9a4-4ecd-8cec-b56bcf5cbc78"
        ],
        "10436c41-9007-43a6-9acd-9b3c2f464b5b": [
            "c282983e-28f4-4160-83cf-8504677b34b5"
        ],
        "a8dfeefd-1632-4a12-92cc-836ebfdd0407": [
            "c282983e-28f4-4160-83cf-8504677b34b5"
        ],
        "66301e41-8144-4c16-8159-87b7e065eb1c": [
            "5d348473-7c1d-4b2a-bd30-230eb1627ec5"
        ],
        "3b9ca290-1045-4149-bb69-1330ec40734a": [
            "5d348473-7c1d-4b2a-bd30-230eb1627ec5"
        ],
        "6d7165bc-f4cf-4abe-8e86-dec4dd7cfe9e": [
            "49145fae-62cb-448c-ac68-3b18c5f0f7bf"
        ],
        "e980dc8b-93a7-44de-8239-04247392050c": [
            "49145fae-62cb-448c-ac68-3b18c5f0f7bf"
        ],
        "2c851534-d495-400e-ba42-a2f6299a463d": [
            "49145fae-62cb-448c-ac68-3b18c5f0f7bf"
        ],
        "f0312b24-531f-4ae3-a467-d42898724b69": [
            "49145fae-62cb-448c-ac68-3b18c5f0f7bf"
        ],
        "aba37a44-6f43-4231-bb20-d8bbacebdb46": [
            "49145fae-62cb-448c-ac68-3b18c5f0f7bf"
        ],
        "4db18b1f-9396-4d5b-8d32-09afb8c973be": [
            "c6fc302d-4fa6-4982-b076-8e792fed08e5"
        ],
        "7a52fcb2-a1e4-47a1-808f-693c91fd32c8": [
            "c6fc302d-4fa6-4982-b076-8e792fed08e5"
        ],
        "eacda8ee-1ca7-456d-9727-1b13c26939f3": [
            "d9711661-a563-4bef-ad75-c7fed5874f8a"
        ],
        "7bf21773-722c-4e9a-a007-1721fc47f9ed": [
            "d9711661-a563-4bef-ad75-c7fed5874f8a"
        ],
        "d2a67a1a-7ff9-4dad-9845-3460344b2627": [
            "82c1c553-d949-4459-89f4-f8b9094fc0bb"
        ],
        "f18e582e-f2d3-413f-962f-f808806ba8ef": [
            "82c1c553-d949-4459-89f4-f8b9094fc0bb"
        ],
        "1d74a408-fb55-4a00-acdc-bb986ed0f88e": [
            "3d25406d-5ce6-4c0e-a80b-96b2ea4274bd"
        ],
        "8d698b46-e6a6-4fd7-b1f1-09bf77ba2abb": [
            "3d25406d-5ce6-4c0e-a80b-96b2ea4274bd"
        ],
        "c35e69bd-7022-409d-93f7-64701db4aca7": [
            "c3a00615-44c7-49be-9e3f-b15a96cb79cd"
        ],
        "afc7b183-a38f-48c8-9d81-aec3a0c426d6": [
            "7d39bc00-9461-4652-b518-ebbdbd6bdadd"
        ],
        "b3969a00-19b5-45a6-8ee1-23dec7f87437": [
            "7d39bc00-9461-4652-b518-ebbdbd6bdadd"
        ],
        "b1d97bbe-7bac-446c-982d-e12f63ef3f7e": [
            "7d39bc00-9461-4652-b518-ebbdbd6bdadd"
        ],
        "5ce912b6-bc8b-4427-bc5d-b7a7f16e91ba": [
            "7d39bc00-9461-4652-b518-ebbdbd6bdadd"
        ],
        "84fab205-2f69-4bc2-9f89-c33600a18058": [
            "7d39bc00-9461-4652-b518-ebbdbd6bdadd"
        ],
        "9e4cdcf0-94c7-450b-9026-7d6d2c74cfad": [
            "7d39bc00-9461-4652-b518-ebbdbd6bdadd"
        ],
        "15c36943-d3d8-4ff7-8157-306e420d9a9a": [
            "7d39bc00-9461-4652-b518-ebbdbd6bdadd"
        ],
        "67f17d70-8bf5-49c5-891e-05561361e4db": [
            "7d39bc00-9461-4652-b518-ebbdbd6bdadd"
        ],
        "8fbab345-e1dc-4d15-813d-c4488dbcf76c": [
            "7d39bc00-9461-4652-b518-ebbdbd6bdadd"
        ],
        "43008b17-cc96-44ff-baea-89de2ff5e9e8": [
            "7d39bc00-9461-4652-b518-ebbdbd6bdadd"
        ],
        "8837ba36-9bc8-4215-a0b7-ab9fef82bfe8": [
            "7d39bc00-9461-4652-b518-ebbdbd6bdadd"
        ],
        "b1a5ffe7-ee3a-4755-b86b-83528ba1ff0f": [
            "6056ee81-dd7a-40a0-93cd-7e19aecdc47b"
        ],
        "f344a8e6-e690-4132-93ac-289bfade9fde": [
            "6056ee81-dd7a-40a0-93cd-7e19aecdc47b"
        ],
        "b4f24663-84d7-41fa-9093-fe9d1b913df6": [
            "74ae176b-bb9b-43d9-a597-85edc7666a1c"
        ],
        "4a597577-633c-4e56-b568-abec02992eb4": [
            "74ae176b-bb9b-43d9-a597-85edc7666a1c"
        ],
        "2241011c-d228-4161-bcf8-babee4a793d6": [
            "4406240b-c1fb-4090-8322-c969fd4fea14"
        ],
        "8dd220eb-d0e0-41f4-96d7-38d74d34d4d0": [
            "4406240b-c1fb-4090-8322-c969fd4fea14"
        ],
        "129f5fd1-58a2-4b05-a906-25e6fb2a5678": [
            "141d8a7e-5c78-459a-999d-dd63cdf77152"
        ],
        "4c017b30-f705-49da-8a97-836558e22f0f": [
            "141d8a7e-5c78-459a-999d-dd63cdf77152"
        ],
        "ab318786-8998-438b-9343-9abf021704e0": [
            "d6960dfa-b08c-4fdb-b3b8-6dfac2c38573"
        ],
        "e9ccf607-b51a-4c24-9a9a-998c6fcb34f6": [
            "d6960dfa-b08c-4fdb-b3b8-6dfac2c38573"
        ],
        "a8f4e212-c5ca-43b5-ab41-5fd1469bdbfc": [
            "62f41c1b-8846-4493-83fc-734aaecf829c"
        ],
        "7d90057b-aa77-40e9-a7c5-7d76a42ff7ec": [
            "62f41c1b-8846-4493-83fc-734aaecf829c"
        ],
        "8e00b5f0-5bb5-43a2-9425-6ff09939afc4": [
            "e5650b40-34c8-4173-9704-6420a28cfd8b"
        ],
        "3c4c3ae2-c18e-4d30-b537-ec92a1099b73": [
            "e5650b40-34c8-4173-9704-6420a28cfd8b"
        ],
        "e6a535de-d7e3-4bcd-8b20-cdc6da403fd0": [
            "e17241ad-8cc4-4cde-9f3c-fe221bbdac46"
        ],
        "e89e855d-1c81-48db-a884-a6c230ede8da": [
            "e17241ad-8cc4-4cde-9f3c-fe221bbdac46"
        ],
        "1b39459a-65da-43be-aed4-78929c5aae70": [
            "a1c71c5d-d992-4827-9fb1-de3ec48d050a"
        ],
        "49bbf805-104a-434e-aba8-71dfccaf9016": [
            "a1c71c5d-d992-4827-9fb1-de3ec48d050a"
        ],
        "2ec8df78-6faa-4f96-9018-6e3ea3c37066": [
            "3a68c8d0-ddec-4e91-a90f-0f836951b3d2"
        ],
        "8f97892c-a542-470e-8ee6-d07c51e959ea": [
            "3a68c8d0-ddec-4e91-a90f-0f836951b3d2"
        ],
        "3b229b2f-30a5-4c9d-aaaa-f79c05aa2639": [
            "80c474f0-b49d-4382-a866-6488805694ab"
        ],
        "e01a6c68-0403-4754-b02c-b7bc0da20ff8": [
            "80c474f0-b49d-4382-a866-6488805694ab"
        ],
        "746535e6-04e1-4350-91b2-00402f8c91b9": [
            "ccaa054a-273b-435c-8e7e-4289f562c09b"
        ],
        "40e8d5ed-1b77-4400-a4ec-693a3d142491": [
            "ccaa054a-273b-435c-8e7e-4289f562c09b"
        ],
        "0c55d994-2416-4e30-ba48-75a70fb65ff1": [
            "06ce722c-38bd-4953-b51a-937f6eb312e2"
        ],
        "af5d69e5-7656-46af-ad09-70711446fafc": [
            "06ce722c-38bd-4953-b51a-937f6eb312e2"
        ],
        "e1d1c27c-6bb7-4008-98dd-7a446a4412b1": [
            "9dd5f8fc-8f35-4751-92fc-2db51c9f9b2e"
        ],
        "8ba2c5bf-3593-4585-a067-4c118dc8c5e9": [
            "9dd5f8fc-8f35-4751-92fc-2db51c9f9b2e"
        ],
        "96d98267-5c62-4da5-a27f-a2287e113f1b": [
            "d910381d-278d-4909-8857-4b3d437e87a9"
        ],
        "9d24feb3-acbc-4345-9e7a-4c660688c05e": [
            "d910381d-278d-4909-8857-4b3d437e87a9"
        ],
        "b7256d95-fff9-4f4c-8cdd-c6746b5681cd": [
            "9040878b-4cc1-4b79-9bb0-98a701ea677f"
        ],
        "3d75f182-8b02-4093-8d74-42d59b2ea822": [
            "9040878b-4cc1-4b79-9bb0-98a701ea677f"
        ],
        "7aa0cb7d-037c-4ece-944f-6270abf52952": [
            "9040878b-4cc1-4b79-9bb0-98a701ea677f"
        ],
        "cfc24d9b-c309-4068-9cdd-3eae56aee260": [
            "9040878b-4cc1-4b79-9bb0-98a701ea677f"
        ],
        "5d10761a-cc46-425b-998d-b9297aa28983": [
            "e7b0dfdf-751a-4c69-8131-944762504344"
        ],
        "2b8e31fc-8463-4eab-be6f-8bc2723e02fb": [
            "e7b0dfdf-751a-4c69-8131-944762504344"
        ],
        "5c954cf1-965a-4c09-af79-ef62488916e5": [
            "4de01670-64f4-45f3-a8b4-3350870760ff"
        ],
        "c035de54-84db-4ef8-bb77-f90f16d8be2c": [
            "4de01670-64f4-45f3-a8b4-3350870760ff"
        ],
        "28ad8e3f-bc24-4f9c-a815-1330c1e0fbfa": [
            "938a0625-f2c5-41ab-8e99-07a14598f827"
        ],
        "f83db60a-690f-4725-91d0-64b6aa362be7": [
            "938a0625-f2c5-41ab-8e99-07a14598f827"
        ],
        "f99323dd-1e12-4edf-8ca2-51043f534222": [
            "7fa4f34f-cc44-4334-8d17-7c6adaf90aa4"
        ],
        "f9517af6-f0d3-4507-a357-286a84b6997d": [
            "7fa4f34f-cc44-4334-8d17-7c6adaf90aa4"
        ],
        "259d35f9-2e7b-4ece-8a58-a9e40b33439c": [
            "53e3bc52-1441-46ff-bc39-7973fcdc4dc6"
        ],
        "e1e136c1-8b33-4a5c-869e-3209e6f96b19": [
            "53e3bc52-1441-46ff-bc39-7973fcdc4dc6"
        ],
        "beb183c5-f504-4953-b905-3d7bb4e5492c": [
            "17cfa016-5656-4b11-8d5f-ae675f81fbef"
        ],
        "fe1cc54d-7b10-4544-8877-16112cfaf163": [
            "17cfa016-5656-4b11-8d5f-ae675f81fbef"
        ],
        "d38a8f13-5c6c-46ce-a1ff-212cadb31ade": [
            "cda90f05-0443-4567-9115-d7e39190ff8f"
        ],
        "ee642274-b570-4654-9927-0886e2b14919": [
            "cda90f05-0443-4567-9115-d7e39190ff8f"
        ],
        "b6a0eb45-9d46-4639-91f2-0d79218b5c85": [
            "d3150e6d-a31d-4681-9808-76ab7f4b5394"
        ],
        "c2f5d027-387e-4f51-a5a1-39fbb8fbb5a0": [
            "d3150e6d-a31d-4681-9808-76ab7f4b5394"
        ],
        "2fe08f9b-6087-43ca-ba8f-81bc25dd8bf8": [
            "d3150e6d-a31d-4681-9808-76ab7f4b5394"
        ],
        "725653bc-e74a-4ea9-9545-1712bf2c5b7b": [
            "d3150e6d-a31d-4681-9808-76ab7f4b5394"
        ],
        "1881d9e8-0abf-4b3a-8dfb-c37b341ea2ee": [
            "ead8c39e-e03a-4ded-a2e3-663d6c79243c"
        ],
        "1a866fdb-b28c-43d1-ae03-d505fb70efa5": [
            "ead8c39e-e03a-4ded-a2e3-663d6c79243c"
        ],
        "4ccd3186-5653-4d74-a1e9-cdd08ae54d58": [
            "22140315-b266-4da1-ac02-6be64ad0087b"
        ],
        "7f73d65c-98c3-4cb2-92bc-b6717d22ed26": [
            "22140315-b266-4da1-ac02-6be64ad0087b"
        ],
        "93354e97-d9c1-4b97-ab18-4c46a0eee4dd": [
            "04f98476-4675-4a0e-844d-c36877679153"
        ],
        "e078dca2-9d8a-483c-9384-080a4182bf1f": [
            "04f98476-4675-4a0e-844d-c36877679153"
        ],
        "909157e4-9682-450d-abae-3abc93c81deb": [
            "18d6c5da-3969-445c-972e-8f452423e274"
        ],
        "2b5fc739-03a5-4fe6-ba17-e5354faaa6a3": [
            "18d6c5da-3969-445c-972e-8f452423e274"
        ],
        "22e7fe77-45e9-428d-b58d-6ef81dccf2df": [
            "872412a6-6279-40df-8979-11cd183f8fdb"
        ],
        "e0d17a53-e094-4715-8b24-6cee94fbcc79": [
            "872412a6-6279-40df-8979-11cd183f8fdb"
        ],
        "3cdf2036-cd87-4979-9fe0-896d17d5b422": [
            "872412a6-6279-40df-8979-11cd183f8fdb"
        ],
        "62767d8c-9b57-43a7-bc16-2ec8dbfb0689": [
            "0af0d044-a79f-4a47-9021-ce3f08883d46"
        ],
        "9cda8b36-b6bd-425e-a8e2-cd820a59bd53": [
            "0af0d044-a79f-4a47-9021-ce3f08883d46"
        ],
        "34e1523c-7145-4b22-b774-114ebb107cfc": [
            "4c6fb98d-014a-46d8-8475-cfe0d2465f4a"
        ],
        "c95cd4b8-3ea0-47e0-bf32-07cb72d3aed3": [
            "4c6fb98d-014a-46d8-8475-cfe0d2465f4a"
        ],
        "0c262bc8-81cf-4fdb-86d0-de0e4ac33140": [
            "4c6fb98d-014a-46d8-8475-cfe0d2465f4a"
        ],
        "0ddaf29b-fb6a-429b-8bba-048e32e5b4aa": [
            "4c6fb98d-014a-46d8-8475-cfe0d2465f4a"
        ],
        "91ac4799-9bd2-4e4c-bd6f-e8762cc0e110": [
            "41c1c4fc-554a-468d-95a4-73ab82ae2013"
        ],
        "0c79a483-2347-46c0-a21a-d603a7defece": [
            "41c1c4fc-554a-468d-95a4-73ab82ae2013"
        ],
        "335e5177-95aa-41f6-9ec9-73df19c4ac09": [
            "099ca442-e918-4e18-94b7-95f647a6cd7a"
        ],
        "dfa77c42-d78d-4ef3-a2cb-4b04a711b2cf": [
            "099ca442-e918-4e18-94b7-95f647a6cd7a"
        ],
        "500d3931-76ea-4e80-bb8b-ead8dca34bf3": [
            "2d1e17d2-8ce2-4267-acdb-f94db0d20195"
        ],
        "32bcebe9-8f04-468b-bf13-4cb7a9276f8f": [
            "2d1e17d2-8ce2-4267-acdb-f94db0d20195"
        ],
        "52c69ad7-5573-4a40-a234-6e075aefa5ff": [
            "cca49b46-e55f-4a76-a80f-5dadbf06b8db"
        ],
        "d083bca4-0e3b-4489-b458-c58e63299688": [
            "cca49b46-e55f-4a76-a80f-5dadbf06b8db"
        ],
        "a929d46f-7836-4e40-8a2c-407a17a52951": [
            "4f71df2c-e87a-4bf6-9050-b9f6fa54e603"
        ],
        "290b80ee-f406-4bd4-9388-da3169c62479": [
            "4f71df2c-e87a-4bf6-9050-b9f6fa54e603"
        ],
        "73212af9-f6f7-4576-87b3-c4f478fa2113": [
            "7d049cca-08b2-440e-bae9-76d078a147ff"
        ],
        "17145c41-0ba4-4da5-ab75-bb349379d3a7": [
            "7d049cca-08b2-440e-bae9-76d078a147ff"
        ],
        "fdd647e3-6117-4b90-9c69-a007a9f96285": [
            "1d8ef19a-6103-445c-a73c-8889fd0851f8"
        ],
        "e7fdfb11-f3e4-4f54-be3e-c46085d40a7e": [
            "1d8ef19a-6103-445c-a73c-8889fd0851f8"
        ],
        "9cf45ecc-3b73-473d-a1ac-dec89ceadca9": [
            "56b188a1-7d9b-47cf-a0da-5cd52d6bd574"
        ],
        "d6a625e0-bbd3-403f-852d-68b49a6b5273": [
            "56b188a1-7d9b-47cf-a0da-5cd52d6bd574"
        ],
        "cce00f13-0c7d-40e1-8c94-b99153f787ce": [
            "f15dfdfe-28ee-487f-bdc8-424d858a1944"
        ],
        "4ff63fec-26ef-43ec-85d7-84fd6500cd21": [
            "f15dfdfe-28ee-487f-bdc8-424d858a1944"
        ],
        "4a015f50-ba99-4382-b06a-4eb5ea032924": [
            "924f200e-aa0c-4b0b-b90a-ff4cf83adeac"
        ],
        "8e44d2e7-d80e-4669-b72f-344e38ec2888": [
            "924f200e-aa0c-4b0b-b90a-ff4cf83adeac"
        ],
        "b90db959-2793-489a-9a2b-f31148ec7d8e": [
            "b27bb312-64b6-4550-98d4-dfeeff624848"
        ],
        "9a4be212-b2f0-4517-a5f3-758db181304e": [
            "b27bb312-64b6-4550-98d4-dfeeff624848"
        ],
        "38895151-3dbf-472d-9bcd-e90a7141008d": [
            "2e06b55b-41db-43e9-b3b8-90b7de6e7cba"
        ],
        "a7736d76-85a0-4a04-a9a8-e90a8985eec9": [
            "2e06b55b-41db-43e9-b3b8-90b7de6e7cba"
        ],
        "c5b6e0e2-43ee-4504-89fa-86940ef6c5cf": [
            "0d23f87d-e1e8-431f-9d34-25b89d1081b9"
        ],
        "41e18579-253c-4b02-98fb-80fb08fccce6": [
            "0d23f87d-e1e8-431f-9d34-25b89d1081b9"
        ],
        "ab4a3b25-a099-4db7-af91-dfa1657f04bc": [
            "0d23f87d-e1e8-431f-9d34-25b89d1081b9"
        ],
        "08bd24ee-4ec1-4644-b5c9-40cffb19003c": [
            "0d23f87d-e1e8-431f-9d34-25b89d1081b9"
        ],
        "72078218-cdcd-453b-8a39-3464297ddb2b": [
            "8511499a-2d6a-4787-a517-c6843d59bf10"
        ],
        "5f654de5-4804-42a3-b8dc-52298f1836f4": [
            "8511499a-2d6a-4787-a517-c6843d59bf10"
        ],
        "3d63a315-5cdf-4259-bf1a-03d9ea676637": [
            "cd6af9c6-b34a-4579-bf49-96c01ea4b687"
        ],
        "7ea031e3-c84e-4e35-84ae-93a652ebdcdd": [
            "cd6af9c6-b34a-4579-bf49-96c01ea4b687"
        ],
        "64354722-feea-4096-bce5-23d01d5fcd15": [
            "c570961a-d77f-4e4d-a109-1ec463ece3cb"
        ],
        "8a10e710-fea1-4be3-a4c4-fea11d205fac": [
            "c570961a-d77f-4e4d-a109-1ec463ece3cb"
        ],
        "2e221f40-2e23-453d-a549-c13f083fbe62": [
            "8253b296-20fa-40ac-b4fb-b6f3837ab4a4"
        ],
        "d364485c-9609-4b40-ade7-732ba2e7942d": [
            "8253b296-20fa-40ac-b4fb-b6f3837ab4a4"
        ],
        "9ad992f3-7781-41f1-a958-8de2fbe9ded6": [
            "63e0c10f-b97b-4248-b5e6-f922d4607acd"
        ],
        "ce75fee7-19f2-4e60-926f-5ab8d64dfcab": [
            "63e0c10f-b97b-4248-b5e6-f922d4607acd"
        ],
        "30c024b2-4f1f-459b-82f8-6c5b7dbd827d": [
            "e7ab3c13-726b-441d-941d-28af75d2750b"
        ],
        "5be7dd83-2541-4656-9b3f-93f251c96e43": [
            "e7ab3c13-726b-441d-941d-28af75d2750b"
        ],
        "da40c5ed-f896-44ca-bf04-0357df685275": [
            "e87b4b96-072d-4a03-9435-3d6ff47620fa"
        ],
        "f1977ef3-aece-4dda-8c73-d474cd057129": [
            "e87b4b96-072d-4a03-9435-3d6ff47620fa"
        ],
        "71ee8d69-8ea3-4ac3-93fa-476ce9cbdd0b": [
            "23c7c5ec-cdf6-4d62-8d69-bf775aa7d13b"
        ],
        "f2e42b3e-5b1e-435e-af90-5b9a3b9283fc": [
            "23c7c5ec-cdf6-4d62-8d69-bf775aa7d13b"
        ],
        "31822edd-6bd6-4a75-bcc4-5d456c89d5d2": [
            "d99756e3-7c71-4689-911c-700da939f51c"
        ],
        "4974f98b-293a-41ce-80b9-7c4debc60e05": [
            "d99756e3-7c71-4689-911c-700da939f51c"
        ],
        "27a140ae-7b9c-4115-9739-4c83b85e612f": [
            "d99756e3-7c71-4689-911c-700da939f51c"
        ],
        "8304f9cf-5517-4175-9718-7c22b92ca840": [
            "d99756e3-7c71-4689-911c-700da939f51c"
        ],
        "1a09ea0a-4c0f-46c0-aac6-4e8164b2f404": [
            "d99756e3-7c71-4689-911c-700da939f51c"
        ],
        "17729bf7-9aa7-4d6e-b464-2a2cb4332f3d": [
            "d99756e3-7c71-4689-911c-700da939f51c"
        ],
        "1f39f043-94ca-4097-aace-c579c9a4bf49": [
            "d99756e3-7c71-4689-911c-700da939f51c"
        ],
        "d97704fe-b23a-4872-bef3-25be6b9f813a": [
            "a192d5aa-a320-4c80-b647-82e142ea7450"
        ],
        "2bfe5768-c5f3-4e81-99cf-cad1ae25dae2": [
            "a192d5aa-a320-4c80-b647-82e142ea7450"
        ],
        "562dd263-af21-48ed-8974-f4a7a5a0db85": [
            "3a75b477-86ad-42bf-8b1b-cfca338721d7"
        ],
        "4426cb23-e455-4b5d-82fc-926b56a485f5": [
            "3a75b477-86ad-42bf-8b1b-cfca338721d7"
        ],
        "ad33dfa6-3eee-4a73-9da8-7f03e23f256d": [
            "ab7212ba-9499-456b-9b46-d841a50b39bd"
        ],
        "b2ca4b70-a636-441b-a070-e80732daaec2": [
            "ab7212ba-9499-456b-9b46-d841a50b39bd"
        ],
        "bdc40123-40b6-46af-9b7f-efa9c7df353c": [
            "181d2f41-34fa-4b75-a836-fa688a4fdf5f"
        ],
        "5a064192-33a3-476f-99f3-d073a97c1eb2": [
            "181d2f41-34fa-4b75-a836-fa688a4fdf5f"
        ],
        "f1402dce-6943-47bf-8a19-bfeb2937b5c8": [
            "f34329b3-1645-4589-acc3-4a7b80f553de"
        ],
        "9e8495b8-7401-4ac4-b082-cf1509187d37": [
            "f34329b3-1645-4589-acc3-4a7b80f553de"
        ],
        "dc97e01f-72b8-4211-b117-2a5cffc09837": [
            "b55ec74b-90a8-459f-89f7-546f88f25956"
        ],
        "a50acbc8-7a55-4c2c-a072-2ddf9d768ef6": [
            "b55ec74b-90a8-459f-89f7-546f88f25956"
        ],
        "07e4a3e7-a24b-46dc-80a4-cb8531d44bcf": [
            "738e1ae8-419b-4b92-9a48-5cc0387e40fe"
        ],
        "a41c81c4-ac4e-4ca3-aace-904c4f1f7f21": [
            "738e1ae8-419b-4b92-9a48-5cc0387e40fe"
        ],
        "c54245ec-977b-48e5-b311-54f4fa5baf79": [
            "c9402409-7ab5-429a-87fd-5bf4b19dfb32"
        ],
        "a7772540-d529-4061-8bab-884d93d76bbd": [
            "c9402409-7ab5-429a-87fd-5bf4b19dfb32"
        ],
        "3d8f774d-334e-4d79-8710-9f44cd0a1db6": [
            "c9402409-7ab5-429a-87fd-5bf4b19dfb32"
        ],
        "1fac3620-6c09-4f0d-85cf-464674fefff1": [
            "c9402409-7ab5-429a-87fd-5bf4b19dfb32"
        ],
        "88f58782-2c10-4dec-8d7a-45fd6e8f077a": [
            "3fc9b7a5-e2cd-41c3-a480-07cd5a8f755b"
        ],
        "fc363be3-83b4-4605-9571-dfc7fe876bac": [
            "3fc9b7a5-e2cd-41c3-a480-07cd5a8f755b"
        ],
        "9f736258-a026-4e2a-a973-66971bc8b3ee": [
            "2bde0e78-982a-47ec-86a6-99e1a4a22727"
        ],
        "d17176aa-1277-4d1f-872b-559220cdb3bd": [
            "2bde0e78-982a-47ec-86a6-99e1a4a22727"
        ],
        "18c570e7-af9d-4a7b-883b-53c09ba57a2c": [
            "a07c0c4a-2ba3-4cc9-a422-6030403c2e17"
        ],
        "c321535c-d587-45cc-8803-56a8ec3c7cbe": [
            "a07c0c4a-2ba3-4cc9-a422-6030403c2e17"
        ],
        "4908fe15-ee1c-4087-a5e2-a4ab141c6497": [
            "296ffcc7-e87b-4405-8fcf-5d41de248bf9"
        ],
        "61045ada-129f-4a82-a147-87bac1d1456b": [
            "296ffcc7-e87b-4405-8fcf-5d41de248bf9"
        ],
        "864ba43a-cb20-47a0-b5d8-36cd6952f796": [
            "42d66f79-9d32-4392-80bf-266bca49aa29"
        ],
        "6c2e793f-a6c1-4ac5-b7eb-392c9c0618f2": [
            "42d66f79-9d32-4392-80bf-266bca49aa29"
        ],
        "960db0e5-82c9-4b19-b289-39fcc1b9f115": [
            "42d66f79-9d32-4392-80bf-266bca49aa29"
        ],
        "3555f344-9c87-4313-80db-7fb4360d62c2": [
            "42d66f79-9d32-4392-80bf-266bca49aa29"
        ],
        "9176bea0-1fad-45ce-8a87-4e462e87204e": [
            "13d92867-1f9a-40ca-af79-30462edec65e"
        ],
        "4a9ddb9b-ccbe-48ce-8272-7ee2521981ba": [
            "13d92867-1f9a-40ca-af79-30462edec65e"
        ],
        "b6e81128-30dd-4e6b-b8ec-5a911abe3373": [
            "1df717e9-b6d1-4479-9ebb-7d3cc48e5166"
        ],
        "cd3c2445-10f7-4da9-839d-17fe34660cbf": [
            "1df717e9-b6d1-4479-9ebb-7d3cc48e5166"
        ],
        "272ca934-fb55-4f7a-a9ce-b9c00938f87f": [
            "239f6f05-f061-4ef8-ba85-aea3ffc59ee1"
        ],
        "7bcdf0bb-9ab6-45af-96b9-0344a1ab0bc3": [
            "239f6f05-f061-4ef8-ba85-aea3ffc59ee1"
        ],
        "d2893a41-9e9b-45d1-aca5-ef081d8514f1": [
            "127b2245-99de-4599-bab4-8f3e7dbdb02b"
        ],
        "8efc48d2-4118-4286-b382-74001e493e14": [
            "127b2245-99de-4599-bab4-8f3e7dbdb02b"
        ],
        "45a4a65a-9c0e-4064-9a96-bba5e94ca70d": [
            "327a8ded-8582-4ec2-ace5-c59e47baa61e"
        ],
        "f93f8d34-bcdb-4035-bd3b-debbe9f2bce7": [
            "327a8ded-8582-4ec2-ace5-c59e47baa61e"
        ],
        "857e30f8-69ca-42e8-adc0-516ff1126f63": [
            "0f557706-63eb-4059-8cd0-f8080f7de810"
        ],
        "17216c61-5120-4c6b-95d1-c8c74c0a4b92": [
            "0f557706-63eb-4059-8cd0-f8080f7de810"
        ],
        "79c328c2-2915-4b62-baa0-88ed40a31bdd": [
            "b93a8795-e0dc-4501-bc3b-723e51332942"
        ],
        "86e22a6f-a99a-4aa6-b383-aa439b7c6bbe": [
            "b93a8795-e0dc-4501-bc3b-723e51332942"
        ],
        "e91ca712-5530-4065-96c4-c2d933e075e8": [
            "b5f15526-b9cd-4043-9519-6dea22906bb6"
        ],
        "f42d9100-9e64-43b1-b495-6e7efa8af9ab": [
            "b5f15526-b9cd-4043-9519-6dea22906bb6"
        ],
        "4a3bf7e4-52db-4be0-a72b-d6bca7c15a04": [
            "3d9036f5-56ec-4960-a552-cb849a5fccb4"
        ],
        "e1d522b8-7a71-403c-bc00-32e1e1db452a": [
            "3d9036f5-56ec-4960-a552-cb849a5fccb4"
        ],
        "1cdf7938-4a21-4272-b6be-afa0a8c65e8a": [
            "f62e1007-2f23-458c-8fb0-3f5a75713960"
        ],
        "b5d408fb-88d8-4e6c-9d5c-b6f339a6197e": [
            "f62e1007-2f23-458c-8fb0-3f5a75713960"
        ],
        "3396c8a8-abe4-4950-a868-33ee14cb39f8": [
            "131b3fa4-1db4-40c8-9c0f-8305d4bf1baf"
        ],
        "c4b425ad-af6a-4877-9f65-fdde703317e0": [
            "131b3fa4-1db4-40c8-9c0f-8305d4bf1baf"
        ],
        "43e60763-e3ca-48eb-b06a-a28fa649c019": [
            "63e9c37e-a0e7-4863-8e1a-6c36fab361e2"
        ],
        "b00f32c0-92b8-4ce5-bc21-152999a649e0": [
            "63e9c37e-a0e7-4863-8e1a-6c36fab361e2"
        ],
        "0fead5c5-b30f-4380-8744-86a79b6e8813": [
            "c7aab644-0297-4e15-a60c-518ec59cc5b9"
        ],
        "b3c0c9d5-486e-472d-bc69-4d57d283b8bf": [
            "c7aab644-0297-4e15-a60c-518ec59cc5b9"
        ],
        "a21b234c-90da-4099-9bcd-e6408e613d22": [
            "b3a04afa-24cb-462f-b87d-db6fb7e15ea8"
        ],
        "b250f7da-678c-443d-91f7-c4fb3ca508db": [
            "b3a04afa-24cb-462f-b87d-db6fb7e15ea8"
        ],
        "409d3eab-0558-4bbc-9568-103bfc58a5c8": [
            "2baa48ee-8e8b-4e21-9d66-77e154b00d94"
        ],
        "6fad823a-de51-4757-8815-0990574c18be": [
            "2baa48ee-8e8b-4e21-9d66-77e154b00d94"
        ],
        "49bc6863-4de0-44c1-a840-c22d2749e5d9": [
            "f77aaec7-472a-43d4-bcc4-20bfb7f43872"
        ],
        "8dedaa02-5d96-449d-98a1-0b2d68c4edbd": [
            "f77aaec7-472a-43d4-bcc4-20bfb7f43872"
        ],
        "1ece225b-ef55-4776-9f86-fdf22a58bed2": [
            "f77aaec7-472a-43d4-bcc4-20bfb7f43872"
        ],
        "b479057a-6101-4124-b756-6875bde4b30b": [
            "f77aaec7-472a-43d4-bcc4-20bfb7f43872"
        ],
        "e2183ebe-e965-44ce-b08b-41ae6b69bedd": [
            "bc0168bc-fe42-4461-888c-8ea09182f474"
        ],
        "6c0da8be-2b92-47a8-8387-4d897996b0c2": [
            "bc0168bc-fe42-4461-888c-8ea09182f474"
        ],
        "d7670e41-6bc2-4dcd-b1a0-cc9688f20171": [
            "bc0168bc-fe42-4461-888c-8ea09182f474"
        ],
        "6f1c80ac-70c0-4a11-ac05-0e9496423fdf": [
            "bc0168bc-fe42-4461-888c-8ea09182f474"
        ],
        "deab3f9f-9aad-436e-9a20-683027547d2d": [
            "87a939f5-9321-49b7-b7d0-4d523ef4bcf4"
        ],
        "f6fa6f94-0795-4b32-906e-464577fb85ce": [
            "87a939f5-9321-49b7-b7d0-4d523ef4bcf4"
        ],
        "8f8ce3a0-9979-4c62-a9fe-0a4cce34fd86": [
            "00ff45f3-2f15-4e9f-86fe-03d0e224f45e"
        ],
        "b8ef5050-4b26-4b96-91d4-b943d67227c0": [
            "00ff45f3-2f15-4e9f-86fe-03d0e224f45e"
        ],
        "b8f1b36b-4100-4220-8655-b55c2f842c68": [
            "6b908853-4780-4489-a21c-fbc1cc341e1f"
        ],
        "74377276-b42c-415d-90a2-a1af7f234ad8": [
            "6b908853-4780-4489-a21c-fbc1cc341e1f"
        ],
        "44a3fa6a-1e36-497d-ad43-59036448b87d": [
            "7c652444-e89d-45b7-a5d6-96a958774666"
        ],
        "b5b20fd0-2110-42b5-b0be-e01da6a8d848": [
            "7c652444-e89d-45b7-a5d6-96a958774666"
        ],
        "8e8b521e-8bd5-477c-b1e0-a7889d153708": [
            "2963089b-c912-4ea2-b6e2-50b195f98446"
        ],
        "e5a58f9b-6ea8-4d17-8a39-8a1b95339a3a": [
            "2963089b-c912-4ea2-b6e2-50b195f98446"
        ],
        "3856d338-a8a7-4f38-9872-7f312d970ad9": [
            "1aab1e01-3f20-429a-8bc8-10df85c4925e"
        ],
        "cf8881ce-b716-4a3b-89ba-3d68855a4a1d": [
            "1aab1e01-3f20-429a-8bc8-10df85c4925e"
        ],
        "7f929528-78b8-4794-8f7b-4b0fdc46db13": [
            "fc72f959-ca00-4660-a772-071f3b237dbe"
        ],
        "477e78b8-e70e-4987-b6ff-b40e883da1bf": [
            "fc72f959-ca00-4660-a772-071f3b237dbe"
        ],
        "679cbb12-280d-4f11-860a-880e6deb5587": [
            "e68d0b36-61cc-4a98-9617-68748280cc12"
        ],
        "bf04dd2f-e03b-404a-afa9-169be83bc357": [
            "e68d0b36-61cc-4a98-9617-68748280cc12"
        ],
        "44587ba5-e18a-4d8d-9d80-710d559d68c2": [
            "8adf7254-34a5-4f7c-8618-e4723b863714"
        ],
        "53384072-b3b2-4e12-9e5b-bf70063aaa7c": [
            "8adf7254-34a5-4f7c-8618-e4723b863714"
        ],
        "3c1bfbae-e0c3-4d6d-9fbc-b686b9663eb0": [
            "cc6dc716-6038-4940-8d35-14b65a638f45"
        ],
        "014688b1-7bc0-46b1-b5b5-1b1f1e381a0d": [
            "cc6dc716-6038-4940-8d35-14b65a638f45"
        ],
        "65bb0ca5-651e-4ed7-9b13-c7d561c81f05": [
            "997de80f-5a61-4f25-960f-b974d0a9e2c4"
        ],
        "4054d659-3854-4f8c-a14e-f6d8f8284fd4": [
            "997de80f-5a61-4f25-960f-b974d0a9e2c4"
        ],
        "6b3d1ed5-5cd9-43da-97bb-b3ebe136edda": [
            "42789b22-a467-4572-a601-c2b04c143f9f"
        ],
        "8086c488-fc6a-4d1a-8a2b-c68eefcfc51f": [
            "42789b22-a467-4572-a601-c2b04c143f9f"
        ],
        "f4036a73-6ff1-4f9e-bba4-fae702d69a71": [
            "f3728619-38b1-470f-a65e-3300c7beeab7"
        ],
        "cae21cdb-2124-4249-9428-ac082b68973a": [
            "f3728619-38b1-470f-a65e-3300c7beeab7"
        ],
        "be00db16-c2bc-4412-9c2a-187edabbe51b": [
            "f3728619-38b1-470f-a65e-3300c7beeab7"
        ],
        "879e0c9d-03da-43ca-8ae3-fb9c37cc6a98": [
            "e2040727-6492-476e-8dbd-a99460ae4786"
        ],
        "3fafeac4-c486-40a8-a7fc-03909b875212": [
            "e2040727-6492-476e-8dbd-a99460ae4786"
        ],
        "653582c8-8fc2-461d-8393-20cb60f57011": [
            "36b6749c-0fe6-406c-af01-ae62b2aa4828"
        ],
        "30dd1c0b-a690-41e3-9b74-31d215d08769": [
            "36b6749c-0fe6-406c-af01-ae62b2aa4828"
        ],
        "4445ecf4-940a-4b13-af51-0eccdd390428": [
            "3dbb81f3-5a26-47de-b692-7ed47d4b6553"
        ],
        "bb8d22f0-9e43-419a-8454-778d997b6ae3": [
            "3dbb81f3-5a26-47de-b692-7ed47d4b6553"
        ],
        "1d5dbeef-c908-4718-8a34-7ef6271aa8b2": [
            "a174ee60-1bb0-47f7-9883-b5afde52c463"
        ],
        "3194fd2c-69af-4b71-a73b-3c1a81f3d946": [
            "a174ee60-1bb0-47f7-9883-b5afde52c463"
        ],
        "0729235a-a44b-492d-a695-b359e428d7e8": [
            "b18fe989-ea40-4d88-a7db-daddb600000f"
        ],
        "f0697950-5f8d-4b94-bc66-24eafd06cc90": [
            "b18fe989-ea40-4d88-a7db-daddb600000f"
        ],
        "16b8c82a-8cf5-4c17-91d2-2277a5f6c2de": [
            "ab2528fa-d651-4370-8861-b5dee6c298c1"
        ],
        "e019ede9-5924-4f71-84a1-83c963fff8c1": [
            "ab2528fa-d651-4370-8861-b5dee6c298c1"
        ],
        "d3e6f806-6956-48ec-a0d2-4f7f3781e865": [
            "eb101985-ae38-4d73-a2b2-75b209e27011"
        ],
        "db462824-3ec1-4f14-81b0-9965c0b16005": [
            "eb101985-ae38-4d73-a2b2-75b209e27011"
        ],
        "31f87fd5-b594-438b-922f-6957ba07155d": [
            "0092da30-77b1-4643-bc1a-44d7369f7f9e"
        ],
        "2cd6c144-50fc-4217-b002-0eab8796dbe4": [
            "0092da30-77b1-4643-bc1a-44d7369f7f9e"
        ],
        "f41ea412-17fd-4c53-93c0-d5c2f196474a": [
            "82546e4c-740f-4096-8715-cc81c5983a55"
        ],
        "73bb06bc-f4c4-4248-b8ec-56e50182679d": [
            "82546e4c-740f-4096-8715-cc81c5983a55"
        ],
        "3bc49f86-b09b-4a06-844e-a63ed1fc3d35": [
            "ac2ee865-f4f4-4af3-8aa3-f5af26f374b2"
        ],
        "117bb55a-72af-4b26-b7a7-c2021cdb5642": [
            "ac2ee865-f4f4-4af3-8aa3-f5af26f374b2"
        ],
        "84ec869c-ca06-48f3-b379-bc4024ad49e7": [
            "c1918b0e-70b1-4f57-90bd-74f2312579f0"
        ],
        "ff7d592f-78b2-472b-becd-d80b1789e540": [
            "c1918b0e-70b1-4f57-90bd-74f2312579f0"
        ],
        "d6cbab92-c4d0-4214-ace3-c780545460e9": [
            "5c657538-72c9-49bd-be7f-dd0c22c01980"
        ],
        "53f32be0-5a56-42f9-8007-7e841d73d1e2": [
            "5c657538-72c9-49bd-be7f-dd0c22c01980"
        ],
        "130c7641-5c5c-4442-aae9-55f6cc4965de": [
            "d0d3336c-2284-4f01-a7a4-763a3cb430ea"
        ],
        "d8ed530a-a249-4355-8634-c97d501b801f": [
            "d0d3336c-2284-4f01-a7a4-763a3cb430ea"
        ],
        "6401ef7d-55bf-421e-a534-bae6b168cbea": [
            "15acc57a-4960-40ff-a2ce-8e6f12b41038"
        ],
        "b2829e98-0ef0-463c-8668-9947eb417be9": [
            "15acc57a-4960-40ff-a2ce-8e6f12b41038"
        ],
        "fd2a69d0-5a34-491e-ae5c-ed91092ce7ea": [
            "6859c50d-feda-4c4a-b2a1-8f8f00c60f2f"
        ],
        "ce92c70b-7386-4249-9fe0-d99743f2a0eb": [
            "6859c50d-feda-4c4a-b2a1-8f8f00c60f2f"
        ],
        "18f47bb6-2a4d-4277-95d2-31042665de74": [
            "b2edd364-fc28-487c-ab26-82de0cd98112"
        ],
        "98094c8a-dfdc-4c4b-9c9b-ce36e1f2b56b": [
            "b2edd364-fc28-487c-ab26-82de0cd98112"
        ],
        "26c7562c-5b36-4b18-83d8-558d07a9d5ab": [
            "6b4dcb30-0ab9-4563-be4e-ddc528d7cc80"
        ],
        "452efbcd-7a84-444d-b011-24f1e9d96849": [
            "6b4dcb30-0ab9-4563-be4e-ddc528d7cc80"
        ],
        "da8376a8-6c3f-4570-82fa-fb82b5ec3902": [
            "6b4dcb30-0ab9-4563-be4e-ddc528d7cc80"
        ],
        "1bbd0e27-452a-47fc-8c58-58df66999033": [
            "6b4dcb30-0ab9-4563-be4e-ddc528d7cc80"
        ],
        "b80ca22f-b6b9-4049-a258-7f2506bf5efd": [
            "6b4dcb30-0ab9-4563-be4e-ddc528d7cc80"
        ],
        "093a4c16-500c-40c8-8c08-c8076d9e3a12": [
            "1dc0c39f-2d5c-4887-aaca-a04febe5b06a"
        ],
        "3abec855-e638-472b-a698-c3577f74ebe8": [
            "1dc0c39f-2d5c-4887-aaca-a04febe5b06a"
        ],
        "cd032469-df02-4c4b-9271-9ddc29712d78": [
            "d45bea6b-8a60-4f10-b10a-4b684772b839"
        ],
        "df7c71ca-3182-4ca3-b47e-e91018879d6b": [
            "d45bea6b-8a60-4f10-b10a-4b684772b839"
        ],
        "7fd69fa0-27ee-4574-a00f-16b24a9f5f7b": [
            "d45bea6b-8a60-4f10-b10a-4b684772b839"
        ],
        "8c5b5428-5880-4b21-a2b8-206d601cd941": [
            "d45bea6b-8a60-4f10-b10a-4b684772b839"
        ],
        "1df7c700-557e-454a-a742-e542b0fc5d67": [
            "6559ad0f-781a-423d-ad6f-5b8f7b028057"
        ],
        "6243ef2d-5bc0-4599-815e-556c74933eb1": [
            "6559ad0f-781a-423d-ad6f-5b8f7b028057"
        ],
        "c680c59c-89d4-4bad-9636-9f42a276e805": [
            "527bbbb7-194c-4814-9551-4f3842ff6d94"
        ],
        "4061c46b-cd10-40be-8f3b-163858da37e2": [
            "527bbbb7-194c-4814-9551-4f3842ff6d94"
        ],
        "c4548951-fb42-45ca-8f13-5226a693e2a4": [
            "c2ae3762-4677-40a8-9a0c-53ba72091e9d"
        ],
        "cc48f69d-6b8e-445f-b93c-78475a9caef0": [
            "c2ae3762-4677-40a8-9a0c-53ba72091e9d"
        ],
        "e64bc1d7-e442-457b-9d05-d8e515a073d9": [
            "d7850b05-a265-4a95-9d94-fb085a545d12"
        ],
        "514dbad0-9266-4291-affd-d553ccf8d351": [
            "d7850b05-a265-4a95-9d94-fb085a545d12"
        ],
        "92918bcb-b58c-4765-937a-bf2c1eb4c430": [
            "b6a4e665-3853-4b90-b3aa-4faeae378f2b"
        ],
        "9f3df87c-0fc0-4dfa-8a8e-c45302d49d7c": [
            "b6a4e665-3853-4b90-b3aa-4faeae378f2b"
        ],
        "080226f3-c60f-4618-9a9e-3c931532354d": [
            "59416f0b-35e8-422d-89d1-3adf127fb557"
        ],
        "6f9b2c78-026e-4dbe-8a88-0f88db7c3ef3": [
            "59416f0b-35e8-422d-89d1-3adf127fb557"
        ],
        "1d7cd445-6001-4fca-90c1-f6eea400d1db": [
            "43378f97-0bef-43b2-a2b7-8fc0bd5c80d5"
        ],
        "bf50f1d1-1237-40ba-88f4-2867fc5330ca": [
            "43378f97-0bef-43b2-a2b7-8fc0bd5c80d5"
        ],
        "42b41406-7c03-473b-bebd-c3d6a842e606": [
            "feb89f0f-a5ff-41d5-8bdc-a369bb449855"
        ],
        "ea3322cc-7307-4751-9ce2-601013ab341e": [
            "feb89f0f-a5ff-41d5-8bdc-a369bb449855"
        ],
        "546b1d6a-68de-4e71-8221-f52f5d2afb56": [
            "feb89f0f-a5ff-41d5-8bdc-a369bb449855"
        ],
        "000c7177-cba0-4cca-8ead-aa889e648203": [
            "feb89f0f-a5ff-41d5-8bdc-a369bb449855"
        ],
        "db6166b3-dfdf-4aa8-9d6b-fe1ca544d75d": [
            "feb89f0f-a5ff-41d5-8bdc-a369bb449855"
        ],
        "f38ef170-49a6-4c13-9290-96a66a1b38d8": [
            "feb89f0f-a5ff-41d5-8bdc-a369bb449855"
        ],
        "9dab0487-366c-4ad3-af8d-a0cf04e95cdd": [
            "71cc8d7e-caa3-46c8-b66f-c662527052d2"
        ],
        "04d889f2-c4aa-4b38-8df2-0b8416ee5885": [
            "71cc8d7e-caa3-46c8-b66f-c662527052d2"
        ],
        "b25def79-e99c-4055-a05e-28c1730b9524": [
            "e5455c4e-aa53-4e79-9aa3-040fd6cb6e89"
        ],
        "b32248e2-153f-41bd-b5f2-1671d1d959e3": [
            "e5455c4e-aa53-4e79-9aa3-040fd6cb6e89"
        ],
        "20fed2ab-2e02-4cda-95c9-2b55e31ade99": [
            "32a813c6-af74-489a-bad6-d72373c3d5dc"
        ],
        "7c587b1e-86c6-43e5-8928-ffbf6f8d0824": [
            "32a813c6-af74-489a-bad6-d72373c3d5dc"
        ],
        "c94c0872-e4bd-4ea5-9cef-7ee2384b6e92": [
            "f85879e7-4c0f-400c-b363-05465b8773e1"
        ],
        "17d56ffc-e527-42a1-acb3-9b214712737d": [
            "f85879e7-4c0f-400c-b363-05465b8773e1"
        ],
        "12778c51-262a-4fe9-a625-c430cf283a06": [
            "636b9a74-0f60-4e77-b009-95f775f37449"
        ],
        "e3ae8798-73d8-4ba9-b995-babda9e86495": [
            "636b9a74-0f60-4e77-b009-95f775f37449"
        ],
        "659158bc-6c7a-44e5-803e-8356b54a7ed3": [
            "17e3102d-077d-4510-8423-5fb68ec153cb"
        ],
        "2eaa9690-fc94-45e1-8422-f6f7727082d1": [
            "17e3102d-077d-4510-8423-5fb68ec153cb"
        ],
        "b22a67d1-a94d-4116-b027-f48daa3dbee1": [
            "dae3ec23-3567-4814-b8ed-d1bf86106360"
        ],
        "659ba4c3-4cc4-4b66-b88d-e99d5e3730be": [
            "dae3ec23-3567-4814-b8ed-d1bf86106360"
        ],
        "62c806d5-0ca8-48de-9f1d-e35a41590342": [
            "dae3ec23-3567-4814-b8ed-d1bf86106360"
        ],
        "80995f57-f414-4b7a-9ae3-534c9247b837": [
            "dae3ec23-3567-4814-b8ed-d1bf86106360"
        ],
        "98c131ad-6432-4a6b-8898-eb75ca95a9f9": [
            "23581e52-f01d-4c23-ae0f-cd4e6f479c8b"
        ],
        "b8a18c33-e3b2-46bc-bda8-a5d4519b87d3": [
            "23581e52-f01d-4c23-ae0f-cd4e6f479c8b"
        ],
        "5ad2046f-381f-4f75-b0d6-3ebc9f78a2b0": [
            "277df7de-3659-46a5-9deb-d8c3688f3de9"
        ],
        "2c66bb92-e696-4991-8d46-e5f01d29ea5f": [
            "277df7de-3659-46a5-9deb-d8c3688f3de9"
        ],
        "0527773d-ec0c-4027-bcf8-1ad27a982a85": [
            "bd096d56-cceb-4ee8-a931-2aca4acd56fd"
        ],
        "4654b939-187d-4bf3-af23-32f31ea14130": [
            "bd096d56-cceb-4ee8-a931-2aca4acd56fd"
        ],
        "33afca21-c207-4819-b2cd-1488f7030585": [
            "3fc4d3cc-4c99-48c6-ad60-fb44295fedb1"
        ],
        "014667ca-f969-4602-ae05-697f3e3606d7": [
            "3fc4d3cc-4c99-48c6-ad60-fb44295fedb1"
        ],
        "1c28a71c-4300-4f67-acd5-6010764c5af7": [
            "00f7f5bc-a977-4fe3-8e73-e782f8c52371"
        ],
        "deb71f43-81a1-4a67-87ef-16f2d6dee4f8": [
            "00f7f5bc-a977-4fe3-8e73-e782f8c52371"
        ],
        "8326df2c-02d1-40c5-9193-81b8e2ffaff6": [
            "3c415cc7-5a51-474f-8153-99997ee09d9e"
        ],
        "03606ddd-65ac-44b9-9837-4bbdfe931f60": [
            "3c415cc7-5a51-474f-8153-99997ee09d9e"
        ],
        "258d8a32-d92c-43f2-8c06-e1da705741fd": [
            "b75bf15b-91c5-4574-9ea0-e18a60da80ce"
        ],
        "2230b5da-1bfb-4a9c-8982-7471b8ba0244": [
            "b75bf15b-91c5-4574-9ea0-e18a60da80ce"
        ],
        "a4728498-0c2d-4b98-aa1b-b6f772174f3e": [
            "348082a1-9a14-4303-8cdd-9088d416634f"
        ],
        "8fec4d5a-2d87-46d5-8b57-93f3bc86331d": [
            "348082a1-9a14-4303-8cdd-9088d416634f"
        ],
        "324e5f73-235d-446e-a836-81fec3452fac": [
            "348082a1-9a14-4303-8cdd-9088d416634f"
        ],
        "71f116b1-74eb-419b-b986-529a1f581dcc": [
            "4ab3b0c9-845f-47f8-9f5d-a01144bc4bfd"
        ],
        "383332c8-7cdf-4140-b757-0651e7580422": [
            "4ab3b0c9-845f-47f8-9f5d-a01144bc4bfd"
        ],
        "995d020b-400b-492a-a0d4-5985ebbd10e1": [
            "a24b18ad-d16c-4deb-9546-af719cb76a77"
        ],
        "2d5c19e4-485f-46c3-86db-53af6db6bfde": [
            "a24b18ad-d16c-4deb-9546-af719cb76a77"
        ],
        "698898ca-d072-4c80-a2c2-92d484d0d5be": [
            "090647e3-55a7-4f44-9bb2-bf17b5b41b31"
        ],
        "498cc1f8-105f-411a-878a-fd1172fe3c77": [
            "090647e3-55a7-4f44-9bb2-bf17b5b41b31"
        ],
        "639c604e-b55f-4d26-b49a-d72ee7a4b5ad": [
            "eebc27d2-b4fa-4cdc-9187-ed28c77f204f"
        ],
        "3ccfc67e-e982-4692-9839-e3920a32c090": [
            "eebc27d2-b4fa-4cdc-9187-ed28c77f204f"
        ],
        "c7d4595c-c59f-493b-9842-239bf44c5a38": [
            "5e02c40c-d4d2-4b27-a01f-dd963a1a704e"
        ],
        "f54fb02f-2be1-4999-adac-aa2861ada487": [
            "5e02c40c-d4d2-4b27-a01f-dd963a1a704e"
        ],
        "6bd7ce88-d4c4-4a39-942d-1c47474920cb": [
            "95bd80f5-a759-43c4-b945-41edef4ef66f"
        ],
        "bef15a0e-65e7-4abb-80fe-b94bcbbe789c": [
            "95bd80f5-a759-43c4-b945-41edef4ef66f"
        ],
        "d6ee61a2-421b-436f-b21e-d9ee2fd78ae3": [
            "95bd80f5-a759-43c4-b945-41edef4ef66f"
        ],
        "5fa3ca37-7019-434c-b966-c52d3fe05d10": [
            "95bd80f5-a759-43c4-b945-41edef4ef66f"
        ],
        "9808b92f-367a-4267-8c66-6e2a9985ae3b": [
            "95bd80f5-a759-43c4-b945-41edef4ef66f"
        ],
        "dcbd5fd6-060a-47e5-a4db-31b2c1cc1c88": [
            "e2f1406a-85ef-4d80-9649-2d74a1062af1"
        ],
        "c057c252-4609-40ad-aca6-411f15654712": [
            "e2f1406a-85ef-4d80-9649-2d74a1062af1"
        ],
        "eabdf043-8fe3-42a2-8b55-98972050a3a0": [
            "d8ee9eee-5e54-4535-bdbb-ec16db3e9add"
        ],
        "51a0482a-5ee0-4491-b827-b6c035edfb19": [
            "d8ee9eee-5e54-4535-bdbb-ec16db3e9add"
        ],
        "136b7a60-113d-446e-9294-8110463d55ba": [
            "d73dbbdc-3cbc-456f-a3bc-6077bb2c658e"
        ],
        "1d09645b-fa90-4b56-8c1e-ab3fc89158e0": [
            "d73dbbdc-3cbc-456f-a3bc-6077bb2c658e"
        ],
        "6882f56c-48c7-44e3-b4d5-f02c2218ffa1": [
            "b1e7ef2c-f107-46e7-ba2c-bfd8a0c66268"
        ],
        "787e70fd-9af7-4319-927e-2aa715eb869a": [
            "b1e7ef2c-f107-46e7-ba2c-bfd8a0c66268"
        ],
        "9545c45b-d645-41a9-8f41-c774cbcbc0d2": [
            "b1e7ef2c-f107-46e7-ba2c-bfd8a0c66268"
        ],
        "110d38a2-f0d8-45cd-ade3-c53afecc95c3": [
            "b1e7ef2c-f107-46e7-ba2c-bfd8a0c66268"
        ],
        "f9eb60a4-5ae2-4175-97a3-8c8efc23319e": [
            "b1e7ef2c-f107-46e7-ba2c-bfd8a0c66268"
        ],
        "6fc2227b-1bf9-4303-a28a-6037e739d2ed": [
            "b1e7ef2c-f107-46e7-ba2c-bfd8a0c66268"
        ],
        "51b90b5c-e754-4aa0-929c-1c209b365c26": [
            "b1e7ef2c-f107-46e7-ba2c-bfd8a0c66268"
        ],
        "4d440058-a5c3-46f5-ae6b-85b84c190907": [
            "93f3c41c-f304-4961-9233-780885dcb83a"
        ],
        "c4dc50b1-87dd-483d-8683-0ea7e5a045f8": [
            "93f3c41c-f304-4961-9233-780885dcb83a"
        ],
        "5c4ee090-61e9-46ea-a702-3156cf215ca7": [
            "761902ba-35d9-4878-865a-c26abf0ca066"
        ],
        "ccf78c2e-d436-4f1a-94d5-bad7e5f3cd92": [
            "761902ba-35d9-4878-865a-c26abf0ca066"
        ],
        "6b5bbb23-188c-4536-a4ec-cce7629a7eb8": [
            "d82e2768-10f3-466c-885d-cd9414c41d70"
        ],
        "102cac21-3633-4982-bd9a-4d99c344c279": [
            "d82e2768-10f3-466c-885d-cd9414c41d70"
        ],
        "78305255-f976-45bc-89f2-dc0d157efbf3": [
            "2fba0cd1-f777-41f1-a0cc-6844d961dc89"
        ],
        "2b547285-9d5d-4d84-b008-697e8e80294c": [
            "2fba0cd1-f777-41f1-a0cc-6844d961dc89"
        ],
        "a94eb26e-7a90-4ca1-933e-b5fcf57d0e8e": [
            "f6a75115-dfa9-4a2d-aa66-7e8a2a6c1eef"
        ],
        "5b37e94a-c6b0-4b3f-b0b6-38a5b3927f72": [
            "f6a75115-dfa9-4a2d-aa66-7e8a2a6c1eef"
        ],
        "bb138150-aa08-4ec1-81c0-2cbb5de8fc27": [
            "edaa86c5-deee-4090-82f1-d1868983df5f"
        ],
        "e01b61be-58b1-41c5-8b5e-27d1873a0874": [
            "edaa86c5-deee-4090-82f1-d1868983df5f"
        ],
        "e69dd5f9-eaba-4f71-8ed9-f3b06124877e": [
            "a14e0616-9dc3-4a23-a125-c8ebc67237c3"
        ],
        "cc94fe56-b068-4bbd-a7b2-185a6e76d508": [
            "a14e0616-9dc3-4a23-a125-c8ebc67237c3"
        ],
        "30202fe1-7016-418e-9ece-c4de3ac56f4b": [
            "3e2eeeba-fd25-4c37-b712-eac9e4c7c396"
        ],
        "2fae0d90-11bb-4eae-a319-9a7ed7d9a21e": [
            "3e2eeeba-fd25-4c37-b712-eac9e4c7c396"
        ],
        "796a3300-e19d-4f80-b5ce-6a31e585eac0": [
            "094deaee-1f32-4390-88d9-1c68b44db3ff"
        ],
        "df1ddab1-adef-47ee-89ce-6541f6843c73": [
            "094deaee-1f32-4390-88d9-1c68b44db3ff"
        ],
        "74adcd14-fa81-4635-8032-2007e1651c23": [
            "50d5e56e-867b-45e6-80e6-bf13779940b4"
        ],
        "b3c8bc11-3e0c-4083-9a90-f405c44fe18f": [
            "50d5e56e-867b-45e6-80e6-bf13779940b4"
        ],
        "a2ba177e-e5d9-49b2-af05-fc4729712ce0": [
            "8f32d848-234d-4453-bdc5-40779f083caa"
        ],
        "be604d5f-da42-47ed-ac9b-3ed142c9a575": [
            "8f32d848-234d-4453-bdc5-40779f083caa"
        ],
        "e48c38dc-f4c8-4057-b708-c3c145c93a05": [
            "fbee5169-4e2e-4cb7-b25d-3a6f8431bc24"
        ],
        "26cee446-37ce-44c4-981f-60b9ebb2dac8": [
            "fbee5169-4e2e-4cb7-b25d-3a6f8431bc24"
        ],
        "954e0d86-8816-43be-8297-33bc08b5e5b7": [
            "b1d39f2e-d6b3-4e2f-9be0-d72b24d2682e"
        ],
        "02e8cd32-45e3-4a11-8d1c-894b62a7c8cf": [
            "b1d39f2e-d6b3-4e2f-9be0-d72b24d2682e"
        ],
        "25571f11-fcc4-4332-b961-f6a2a265e349": [
            "667a3261-3ba2-4280-a33e-88af813db40d"
        ],
        "b04791cc-c761-4258-ad24-935734df6a06": [
            "667a3261-3ba2-4280-a33e-88af813db40d"
        ],
        "b5afc8f6-cd82-43fc-8589-86cefd21b906": [
            "862748aa-eec0-4c28-91af-f2c016bcb07d"
        ],
        "f8d5080d-7473-4003-93d3-3c4ac2a21a8c": [
            "862748aa-eec0-4c28-91af-f2c016bcb07d"
        ],
        "ad42bc74-1508-428f-8a4d-4a2e55581955": [
            "bc9e913c-91da-432e-98c3-1661998ab956"
        ],
        "570a86d1-92a1-42f7-bfd6-e07cec0ea399": [
            "bc9e913c-91da-432e-98c3-1661998ab956"
        ],
        "97f05c45-3aba-4dd6-a282-1dd792742959": [
            "e645cf7d-bd5b-4eaf-844d-2d12829039e7"
        ],
        "c5754cda-ff1b-454d-9955-6d4c84087277": [
            "e645cf7d-bd5b-4eaf-844d-2d12829039e7"
        ],
        "aac4b800-1662-4715-94d2-4a523579514f": [
            "83043c80-2786-4fce-a96a-c5ee5891b031"
        ],
        "8f79ca87-6bfc-4dd4-a0b0-d98083d5a146": [
            "83043c80-2786-4fce-a96a-c5ee5891b031"
        ],
        "0d2ffafc-1abc-4ac9-9517-1dbde9b6bc7a": [
            "c9b9e6b2-561e-4eff-a959-6f5fa3920007"
        ],
        "cc0e70f0-c114-4a6e-9cc3-fb5f91aa66a1": [
            "c9b9e6b2-561e-4eff-a959-6f5fa3920007"
        ],
        "bb9158ee-5f6f-4928-ad86-83420d93b38f": [
            "c9b9e6b2-561e-4eff-a959-6f5fa3920007"
        ],
        "00b918aa-4c53-4b43-88c2-ce0313e3b5c9": [
            "c9b9e6b2-561e-4eff-a959-6f5fa3920007"
        ],
        "9601d47b-cbee-4a27-83ca-46466ffdbc09": [
            "8eea776f-a407-4d0b-81ba-5ae79a5ade64"
        ],
        "c00567f8-a4a3-49f8-bb93-82d9dcdd0be5": [
            "8eea776f-a407-4d0b-81ba-5ae79a5ade64"
        ],
        "10e6776d-4470-455e-8fe8-411603b3d819": [
            "d33091aa-7226-4cd3-a296-3ef540e24f2c"
        ],
        "198a8780-b5e0-4e46-8321-7d141022e906": [
            "d33091aa-7226-4cd3-a296-3ef540e24f2c"
        ],
        "be0c31eb-5b44-4aff-8ddc-df8cb04efdaf": [
            "1526cb1b-eac9-4da2-ad1b-7e8616a322fe"
        ],
        "16fe6010-18de-40d0-a39a-266ded8092ed": [
            "1526cb1b-eac9-4da2-ad1b-7e8616a322fe"
        ],
        "b7790139-5de0-4592-b743-8d2dfd4688dc": [
            "f158f5bb-9453-4066-be2d-2c649f578325"
        ],
        "11b64665-9baa-42a6-bf16-4b2369d891a9": [
            "f158f5bb-9453-4066-be2d-2c649f578325"
        ],
        "8c88868c-5844-4d83-b106-b2339c965128": [
            "09c6c763-5a8f-4446-91a8-dde2617597aa"
        ],
        "650263b0-bef6-4b4d-af68-c68a7ef26227": [
            "09c6c763-5a8f-4446-91a8-dde2617597aa"
        ],
        "f16e7631-0ae2-4454-94c0-0cebeb863ad0": [
            "fcd22262-80df-48e2-910e-2436c2de7147"
        ],
        "919e739f-0897-428a-aa2c-af1f70546c48": [
            "fcd22262-80df-48e2-910e-2436c2de7147"
        ],
        "f9730318-9da6-47ae-b6bc-586907104662": [
            "56366679-b8ae-4046-b922-07f80062ce65"
        ],
        "820c842f-7586-442c-be4b-e9990221a365": [
            "56366679-b8ae-4046-b922-07f80062ce65"
        ],
        "dc836322-7365-4058-9dd2-b33875bf3793": [
            "56366679-b8ae-4046-b922-07f80062ce65"
        ],
        "0beff110-4292-4b90-8e32-89690c63e098": [
            "56366679-b8ae-4046-b922-07f80062ce65"
        ],
        "c2f52b5d-fd0c-4a3b-9020-8e54b2fc8afd": [
            "64f253ac-90eb-41c9-ab7f-e7f02b0fc3f5"
        ],
        "e1ddc751-ac2f-44a1-a400-bf8069b6c46c": [
            "64f253ac-90eb-41c9-ab7f-e7f02b0fc3f5"
        ],
        "b29b3d4c-1657-4a55-a31f-69ea201a5971": [
            "e94ed99e-d7af-4e00-ba7a-d6dd93fb2e2c"
        ],
        "67e3c17c-7ccb-4afd-b1ed-8795d72e41c8": [
            "e94ed99e-d7af-4e00-ba7a-d6dd93fb2e2c"
        ],
        "aecfdc45-8467-463b-b6f5-935842e609ed": [
            "40259cca-cc3b-4469-a470-03ca733f119b"
        ],
        "ea431f08-d2f6-46e5-b04f-a7809caf8fb6": [
            "40259cca-cc3b-4469-a470-03ca733f119b"
        ],
        "eb47284e-9e40-411e-bee0-74831c085ba5": [
            "992dd8db-9af7-40c1-914b-0d7793b67fa1"
        ],
        "b0fc716a-4119-4038-9528-6c40ee55df3e": [
            "992dd8db-9af7-40c1-914b-0d7793b67fa1"
        ],
        "d4d7e33d-5ada-4720-83fa-251f6fd9808b": [
            "8f3eb13b-2c91-4e76-8743-ce731e71aa55"
        ],
        "6a860386-4068-4a2d-b8f6-c96862210012": [
            "8f3eb13b-2c91-4e76-8743-ce731e71aa55"
        ],
        "bd4ca105-2faa-4e52-85eb-f5960facfed9": [
            "ad79d576-aaa3-40b1-8d5f-cd7018ba4187"
        ],
        "89cbdb22-1837-4749-a6b7-cfb66ef71d08": [
            "ad79d576-aaa3-40b1-8d5f-cd7018ba4187"
        ],
        "e80eba9b-f517-4a57-b346-52de69049bc3": [
            "7820b8eb-f1be-4efe-abc5-a1083d71d6db"
        ],
        "d9f02ad0-b38f-40e0-a745-8d3a28d42801": [
            "7820b8eb-f1be-4efe-abc5-a1083d71d6db"
        ],
        "660753cb-490e-4551-91e0-28d6b92a4ac3": [
            "a1f526e2-34fb-4fa7-82f4-b1649ab89309"
        ],
        "e5bf495e-c534-4589-b85f-b0bf7541ce50": [
            "a1f526e2-34fb-4fa7-82f4-b1649ab89309"
        ],
        "f0ed2e45-caff-4350-9438-cd3b20284e3f": [
            "a9d52e14-7fc9-442e-bbd6-b62c57cc5aaa"
        ],
        "ca5e25b6-67f0-4a1f-ba1f-4a07eeead687": [
            "a9d52e14-7fc9-442e-bbd6-b62c57cc5aaa"
        ],
        "fed797ce-c230-4620-b9df-21229fdd4503": [
            "f560054c-9774-449b-83e8-358f7979b2e1"
        ],
        "04314a87-bd4b-4c34-8eff-124159b4a603": [
            "f560054c-9774-449b-83e8-358f7979b2e1"
        ],
        "703bd7b1-018c-4907-950d-45de8743da62": [
            "e81a0cd0-4be3-462e-ab2c-cb7d58d0f445"
        ],
        "38a582a4-3c86-46e8-90ff-91ce0980b4fe": [
            "e81a0cd0-4be3-462e-ab2c-cb7d58d0f445"
        ],
        "a807953f-e4bf-4afe-b2f5-54febd7df402": [
            "0097dcf4-3d6c-46c1-acd2-b60561de49ff"
        ],
        "1e6fab28-94c2-421f-902c-eb488eb5b36d": [
            "216c877d-8aac-400d-bbab-470991dc8d5c"
        ],
        "2edb03e0-255a-4f10-a9d3-1b7b126367f3": [
            "216c877d-8aac-400d-bbab-470991dc8d5c"
        ],
        "a67fe2db-8de6-4302-a74b-0caae7800b50": [
            "6a6e14a9-3691-4527-bab0-8ddf75a23ef2"
        ],
        "87b9b3be-676c-41b5-b19c-23dd178c3c26": [
            "6a6e14a9-3691-4527-bab0-8ddf75a23ef2"
        ],
        "b86c7118-bc10-48a5-b2f0-1d257336cfeb": [
            "29688276-5e86-4cfd-b0a7-8259cb490c4a"
        ],
        "c25bf986-ea8e-4da2-bb23-bbfc30cca21d": [
            "29688276-5e86-4cfd-b0a7-8259cb490c4a"
        ],
        "ede19713-8142-4866-b2c8-cb7f23ededca": [
            "577ec128-b6bc-4167-8725-d8ba77647e80"
        ],
        "b967858b-46d0-4cfd-9504-b5774cda1a57": [
            "577ec128-b6bc-4167-8725-d8ba77647e80"
        ],
        "0b35d939-dfdb-4410-bc8b-fe94397a62d2": [
            "e7044768-ad32-4f61-953d-31296aa0ed2c"
        ],
        "0fbda270-bb68-4b50-9007-2fe1f259f0aa": [
            "e7044768-ad32-4f61-953d-31296aa0ed2c"
        ],
        "6d663b94-0ce5-4f3b-b1da-cb0f66d33bf0": [
            "c99f2f40-fc6b-491e-9695-aaaf85d57928"
        ],
        "e6c67f3d-da0a-48ed-a73e-6e313361149c": [
            "c99f2f40-fc6b-491e-9695-aaaf85d57928"
        ],
        "3e918f37-38f1-40da-8b94-b774fff562af": [
            "105e7217-ffc2-43a7-8cfb-96996809f6ba"
        ],
        "fe91ef5c-46e1-47f2-b105-42546cc48539": [
            "105e7217-ffc2-43a7-8cfb-96996809f6ba"
        ],
        "26962cf3-367a-4fc8-b96f-dfca8e0ad273": [
            "8ab8ad68-40a2-4c56-8f44-fef70e34e64c"
        ],
        "661ab646-dbad-4793-a45c-cb2d7a833ba3": [
            "8ab8ad68-40a2-4c56-8f44-fef70e34e64c"
        ],
        "d372b776-b8df-4dc1-9a7b-2680a19eb56e": [
            "00c0074c-cd60-421c-90d0-d279dc027ec6"
        ],
        "68d1d775-1fed-4b84-b18f-5cbb404cb4a1": [
            "00c0074c-cd60-421c-90d0-d279dc027ec6"
        ],
        "39fe634d-d73d-4ba7-b7bb-6ffc14de8305": [
            "00c0074c-cd60-421c-90d0-d279dc027ec6"
        ],
        "9149eb61-e266-47e4-8a74-bcbd815b1b2c": [
            "00c0074c-cd60-421c-90d0-d279dc027ec6"
        ],
        "24d406f1-747d-4853-9886-521e0ddb2c2a": [
            "00c0074c-cd60-421c-90d0-d279dc027ec6"
        ],
        "5d8a3f38-9e7a-4d53-b7b3-da8d6e7f9fed": [
            "00c0074c-cd60-421c-90d0-d279dc027ec6"
        ],
        "20dcbcd6-50c2-49b5-b1e2-3bc0cabcab0b": [
            "00c0074c-cd60-421c-90d0-d279dc027ec6"
        ],
        "846dc8a8-6abb-49ec-8863-e08cfb7f5bf9": [
            "52c27e4a-d654-4953-abc0-12ec23ce570e"
        ],
        "fd9c6f63-beee-4f2c-91d3-f02357f586c1": [
            "52c27e4a-d654-4953-abc0-12ec23ce570e"
        ],
        "648bd193-84af-43f1-9eda-06b8dd2b5c0b": [
            "801373ba-e06c-48a2-8dd5-852876e7def3"
        ],
        "2a315e6f-01af-4e5c-abf0-121ff0235c1f": [
            "801373ba-e06c-48a2-8dd5-852876e7def3"
        ],
        "8dae6a09-b3f8-4121-a330-a0747b4dc5bb": [
            "0264dfab-c7d2-4cf7-a8e7-9a6686f97e89"
        ],
        "70b3ad13-f4f2-4646-bec1-f815ee1a9444": [
            "0264dfab-c7d2-4cf7-a8e7-9a6686f97e89"
        ],
        "69f3cd9d-86d4-439b-bc93-a9e082d3da13": [
            "0264dfab-c7d2-4cf7-a8e7-9a6686f97e89"
        ],
        "3b944595-45a8-41f3-8f79-409d1ed6eb2c": [
            "0264dfab-c7d2-4cf7-a8e7-9a6686f97e89"
        ],
        "4cea2e4a-9ead-42d9-a9e8-1b399b6975b8": [
            "0264dfab-c7d2-4cf7-a8e7-9a6686f97e89"
        ],
        "2c4c3373-7400-4013-97a1-c2d556b41432": [
            "0264dfab-c7d2-4cf7-a8e7-9a6686f97e89"
        ],
        "8634bcac-1857-4917-9ce2-f9a69a59d301": [
            "0264dfab-c7d2-4cf7-a8e7-9a6686f97e89"
        ],
        "757d1aba-dc92-48f6-b379-abe0ae9ec41b": [
            "5954a31d-68f6-41e9-a6bb-0a8ccc65aa59"
        ],
        "93feafa5-d342-40ef-a17c-30c5ef4af318": [
            "5954a31d-68f6-41e9-a6bb-0a8ccc65aa59"
        ],
        "b6dd74c9-02e8-4226-aef6-30a236396b51": [
            "5954a31d-68f6-41e9-a6bb-0a8ccc65aa59"
        ],
        "2f12bd36-e81d-41e9-aaec-a4ad74d42658": [
            "5954a31d-68f6-41e9-a6bb-0a8ccc65aa59"
        ],
        "ad777c26-68b1-4d5b-8057-d1966231d0ce": [
            "22ef2bef-7e22-49b5-90cc-c45e1f42fefa"
        ],
        "7f8bc32b-80e3-4ea2-baf9-b5de88ee6410": [
            "22ef2bef-7e22-49b5-90cc-c45e1f42fefa"
        ],
        "0dfd1fb7-e350-4206-850b-84a1d5827be2": [
            "503dfd26-b198-40bb-a6ab-0803bf99ddb2"
        ],
        "80a68577-8e13-4c0a-bd7e-4cc114d183db": [
            "503dfd26-b198-40bb-a6ab-0803bf99ddb2"
        ],
        "3c9a0781-ada2-4c1c-98d1-8bb9dfdfd201": [
            "11d4e423-ee3f-4bf4-85ea-03b832a58154"
        ],
        "ab4d0fcc-5581-4ec5-b13b-ebef0facbc87": [
            "11d4e423-ee3f-4bf4-85ea-03b832a58154"
        ],
        "2dbe1e23-4689-4f6f-803d-4103a30a041b": [
            "355b7d7a-1495-483d-a83a-d789087bc424"
        ],
        "434e915c-d255-4ac8-94c4-cdc5c5163421": [
            "355b7d7a-1495-483d-a83a-d789087bc424"
        ],
        "5f0b0a3f-0ec1-473a-bb06-7ffa0e02eab8": [
            "88dacbab-60f1-4e8e-a148-fd2d81e8a71a"
        ],
        "9b45e27a-3ff1-477a-ba9b-d1fcd089f338": [
            "88dacbab-60f1-4e8e-a148-fd2d81e8a71a"
        ],
        "c58440a1-d2a5-4381-b670-073c0e35896e": [
            "e51270c9-c374-43d2-8b99-980f0efb9934"
        ],
        "772a0fff-6202-45d0-833c-47df97d1ac13": [
            "e51270c9-c374-43d2-8b99-980f0efb9934"
        ],
        "ccc2afcf-7016-4796-809e-b6ad8d7f0981": [
            "085497b9-c2f0-44b5-9bda-c5628df86e6a"
        ],
        "a105f10b-89bc-42d2-a46d-055de568423a": [
            "085497b9-c2f0-44b5-9bda-c5628df86e6a"
        ],
        "7733780e-6ba7-482f-b892-510a7ee06d7c": [
            "4a893f13-4303-433e-8b52-adac128d10cb"
        ],
        "a6903e87-df59-4d4c-8a01-098fa65c9d34": [
            "4a893f13-4303-433e-8b52-adac128d10cb"
        ],
        "a759cd92-428e-485e-9a7b-bb960a4e833c": [
            "157e5d25-665a-4765-a414-2bdcd404701a"
        ],
        "d07d6ad4-4603-481b-8f77-0936c8921c36": [
            "157e5d25-665a-4765-a414-2bdcd404701a"
        ],
        "9ff36bae-efe2-4e0e-8466-41114c7136ab": [
            "7d34e240-6120-4e6a-acfc-acd29b3cd64e"
        ],
        "927abc1d-1cd8-4db0-92d8-21bfb8b9d94e": [
            "7d34e240-6120-4e6a-acfc-acd29b3cd64e"
        ],
        "77234fb2-33ff-42b5-ae0d-8d5182928e70": [
            "6f91449c-280b-49cd-bb6a-e4f7fc43571c"
        ],
        "94e66068-7885-43d7-9174-6cc5300b9f7e": [
            "6f91449c-280b-49cd-bb6a-e4f7fc43571c"
        ],
        "271e9d12-8633-43e4-a066-5bf152dc0e28": [
            "f73ca70e-456e-4aa4-816a-946c7c105e26"
        ],
        "61c69117-8692-4873-b8be-6e31de1579dc": [
            "f73ca70e-456e-4aa4-816a-946c7c105e26"
        ],
        "c1b2c0c1-a4d8-401d-9c5b-0e0151bf57e7": [
            "12a5a85d-b6da-4da7-b741-4bba5f9af1c1"
        ],
        "f996e7d4-f5f9-41fb-96d4-344e314a3234": [
            "12a5a85d-b6da-4da7-b741-4bba5f9af1c1"
        ],
        "6b208601-c511-4f84-a2c3-18d897e6b341": [
            "6ddf1184-0550-47f7-b1e7-f41dceb32d4d"
        ],
        "9ee4142a-bf14-416b-addc-61083ea0094e": [
            "6ddf1184-0550-47f7-b1e7-f41dceb32d4d"
        ],
        "6f8d743f-d0ed-4eb9-a006-e5b2c0b3ca27": [
            "50c2b30d-a63b-499c-8282-b630723473c5"
        ],
        "5254ced1-b38d-420a-9f7a-7aa7c2205ca2": [
            "50c2b30d-a63b-499c-8282-b630723473c5"
        ],
        "098671c0-f2c7-4ebe-8c32-81911fdceb5c": [
            "502e91e6-d477-4e41-9e94-ed39a30f2887"
        ],
        "56bbe48d-296d-4744-a022-ca7356dcd5c9": [
            "502e91e6-d477-4e41-9e94-ed39a30f2887"
        ],
        "b63ff698-1214-4e7d-8f91-cee2720cc2ea": [
            "be1cf7d7-628d-4839-8897-4d2e2af28385"
        ],
        "6402a06b-48be-466c-b9d7-0e276be01147": [
            "be1cf7d7-628d-4839-8897-4d2e2af28385"
        ],
        "592d80c1-bdbd-4ae4-b6d3-c7a02553b1ad": [
            "bbabc408-c4e3-4af4-9f8f-c485d5352ff9"
        ],
        "bea47983-9ba9-4d9c-90cd-636fd8af2916": [
            "bbabc408-c4e3-4af4-9f8f-c485d5352ff9"
        ],
        "dcad5864-c6be-456b-b7a3-7046353ec41f": [
            "50ee80d9-ba2b-4bb2-b87d-fb7be1089a49"
        ],
        "2108f71d-541d-4a0a-83e2-b0622395deb3": [
            "50ee80d9-ba2b-4bb2-b87d-fb7be1089a49"
        ],
        "b4ef629e-1ea1-441a-86a5-de2d10900a84": [
            "6bf67dd4-d336-41e7-90b6-0f1aaa861277"
        ],
        "14ff1867-61f5-4461-a923-f28752ec0153": [
            "6bf67dd4-d336-41e7-90b6-0f1aaa861277"
        ],
        "d8adbace-f409-4ef4-bef7-3da2179a8cff": [
            "6bf67dd4-d336-41e7-90b6-0f1aaa861277"
        ],
        "d4c2fe08-5502-41e7-8bbc-6a73a609fc58": [
            "6bf67dd4-d336-41e7-90b6-0f1aaa861277"
        ],
        "83d7c45e-7cfe-40d4-84c4-8091d7900e63": [
            "6bf67dd4-d336-41e7-90b6-0f1aaa861277"
        ],
        "4a4ab3ab-5a66-480f-a501-222ead4570fc": [
            "6bf67dd4-d336-41e7-90b6-0f1aaa861277"
        ],
        "5d7918d3-b417-4f0d-8cbb-966c605a697b": [
            "6bf67dd4-d336-41e7-90b6-0f1aaa861277"
        ],
        "7b80c401-3b96-4a69-b8e1-1a3f9e1ca0be": [
            "6bf67dd4-d336-41e7-90b6-0f1aaa861277"
        ],
        "34a70323-5018-4deb-8dca-2be8c6da52ab": [
            "6bf67dd4-d336-41e7-90b6-0f1aaa861277"
        ],
        "ca0b2e20-d3d0-4277-952c-7ec23ce56a00": [
            "6bf67dd4-d336-41e7-90b6-0f1aaa861277"
        ],
        "3ea3ffbd-bf59-4d10-91ad-90d6eea6422a": [
            "4436051d-9593-4750-a6c8-0a053042e4cf"
        ],
        "dcd7da0f-7d39-49ef-a55d-26c965c49253": [
            "4436051d-9593-4750-a6c8-0a053042e4cf"
        ],
        "44ef7cd2-f565-498b-a649-bcad038fb2ba": [
            "c3987031-7bae-425d-bcfe-7a9989dee614"
        ],
        "5a38f6a9-0d2e-4fa3-bf75-bf4ee3fcb580": [
            "c3987031-7bae-425d-bcfe-7a9989dee614"
        ],
        "3a05a642-6061-49e1-b9fd-e8072ac8070e": [
            "f0dc7427-dbfa-4067-962f-ffa72b76a019"
        ],
        "63fa84fb-2dfc-4be7-8c7d-34ffdb725a79": [
            "f0dc7427-dbfa-4067-962f-ffa72b76a019"
        ],
        "7423e9bc-62c8-496a-b10c-505877eff588": [
            "16fa0aaa-531b-422e-9606-5d0b99425736"
        ],
        "c0d659e0-c618-42a8-a071-d6bcf5cf9c9a": [
            "16fa0aaa-531b-422e-9606-5d0b99425736"
        ],
        "3fd79908-04c6-43a2-b6f5-8c9d140624d1": [
            "4b3ce2bc-4be2-4ae0-8d71-a54d12af45fc"
        ],
        "a5640da9-45db-4432-8970-d5c61652b2f0": [
            "4b3ce2bc-4be2-4ae0-8d71-a54d12af45fc"
        ],
        "7765c0b6-5ae3-4b45-bfc5-19ce1c0395fa": [
            "9bbe6002-47d6-49ab-9976-dbcd1b6e9a51"
        ],
        "422bf7e6-f642-444e-b28d-73bef25fbda8": [
            "9bbe6002-47d6-49ab-9976-dbcd1b6e9a51"
        ],
        "6e62747b-5bd5-4f1d-a8fb-9bb5f25dfb34": [
            "4f6f3f90-43e9-4671-8de8-1dd3056591b1"
        ],
        "8d2ec26a-0e52-4614-aab3-2c3220fd6cc5": [
            "4f6f3f90-43e9-4671-8de8-1dd3056591b1"
        ],
        "3ebe7668-6c96-443e-b849-147368d01aae": [
            "f4af1c4c-49a4-4ee4-a8d0-cbc362c76dbd"
        ],
        "d0fa68d7-4497-415f-9566-54c6e64f2556": [
            "f4af1c4c-49a4-4ee4-a8d0-cbc362c76dbd"
        ],
        "bfe5bdd6-3e7a-4ccf-95bb-8310ea29828b": [
            "13b921b1-1909-47f7-bac4-75d2e04848e3"
        ],
        "ae7d06c1-3db9-4ad0-b2e7-d243135e0d44": [
            "13b921b1-1909-47f7-bac4-75d2e04848e3"
        ],
        "b19c5f2c-5d13-4c37-9822-c0dc78808a36": [
            "2107cdb3-8d25-4ac4-b503-8bc275b81ec7"
        ],
        "c1202515-b6a6-4f1b-896a-a24a93386c03": [
            "2107cdb3-8d25-4ac4-b503-8bc275b81ec7"
        ],
        "5f05cd8e-c5e5-4d3e-aa7d-e7862138af62": [
            "50c7dee1-c9f2-4c6e-bffe-764d635072ad"
        ],
        "0139d887-537b-4f5b-8366-f5751909ff6d": [
            "50c7dee1-c9f2-4c6e-bffe-764d635072ad"
        ],
        "92317831-dd68-47a2-9fa9-3904999633e6": [
            "d32a181b-3680-41bd-a487-aa19f768f126"
        ],
        "6048d41f-0de6-45b7-9c16-538d2795e948": [
            "d32a181b-3680-41bd-a487-aa19f768f126"
        ],
        "31416ae4-3839-495f-a089-fc773dcd7197": [
            "4eafe9b3-0f3a-4040-b675-4384cfcaaccb"
        ],
        "7614fefa-eb30-4366-9da1-27b171eb4edd": [
            "4eafe9b3-0f3a-4040-b675-4384cfcaaccb"
        ],
        "b64cd763-362e-4e66-99b3-b040cc8c3bc1": [
            "94ae4a8b-f07b-47c3-8d5c-6a338a63568f"
        ],
        "b3936a37-adee-4731-b9b9-3270e20d9083": [
            "94ae4a8b-f07b-47c3-8d5c-6a338a63568f"
        ],
        "59950ae7-6af0-4233-a48c-ab7cb5f4e619": [
            "91ea0206-039b-47e8-87be-5347491698da"
        ],
        "aa799215-66ce-4beb-bf7f-ea670766348e": [
            "91ea0206-039b-47e8-87be-5347491698da"
        ],
        "d92dae59-b683-4381-b194-162d31d7f46a": [
            "c2fa870c-d46c-4caf-94a5-13d710315bb5"
        ],
        "e9c3abf3-0c86-4cd5-af56-d827bf36dbfa": [
            "c2fa870c-d46c-4caf-94a5-13d710315bb5"
        ],
        "eccb009d-f1f1-44ec-8642-3f59a0eb8258": [
            "9f2e29d1-7081-4749-ae57-ac7fb27c6334"
        ],
        "645f3882-3545-4bf1-b990-9e1587a95412": [
            "9f2e29d1-7081-4749-ae57-ac7fb27c6334"
        ],
        "32d67599-1cc8-430d-95c0-fd8faab5f025": [
            "7984dba6-a5c9-4ab7-b92c-6f0155e9c8a6"
        ],
        "59c5517d-9174-4f0d-8add-1a0d89340ee5": [
            "7984dba6-a5c9-4ab7-b92c-6f0155e9c8a6"
        ],
        "4435c5b7-e967-42e1-9723-83decd93ac60": [
            "071904fe-b3b1-4e66-964b-aa26a3eb8381"
        ],
        "f246a149-17ea-46a7-aa1d-857b7f3c7668": [
            "071904fe-b3b1-4e66-964b-aa26a3eb8381"
        ],
        "646fe0b2-50a5-4565-aaa4-ac4e61c44ec9": [
            "21fbb35b-df08-40c8-a02c-dab8a90fde45"
        ],
        "7da32b1a-fd7a-43a5-9ac9-01ea205ee10f": [
            "21fbb35b-df08-40c8-a02c-dab8a90fde45"
        ],
        "a7fdff48-b13b-4e3e-9eee-f3e14ce512ab": [
            "40a29e82-0a7d-472b-b06e-e298f837d1dd"
        ],
        "3e2f6527-517e-4e39-b609-c8fa560ca977": [
            "40a29e82-0a7d-472b-b06e-e298f837d1dd"
        ],
        "0fdb1008-bef5-4b87-8858-e624c414bd53": [
            "55200727-22a4-42cd-9d48-20f7e984c114"
        ],
        "9f57bafc-37fc-4725-82a2-b157a50b9903": [
            "55200727-22a4-42cd-9d48-20f7e984c114"
        ],
        "50fa0123-d149-4067-9fdd-d41c62d3f4f7": [
            "871fce18-2985-425e-bdc8-1153cdc284c6"
        ],
        "8cbaac74-e505-4706-8085-d0dbea699553": [
            "871fce18-2985-425e-bdc8-1153cdc284c6"
        ],
        "be147826-ece4-42d6-a558-dbb6e22f389d": [
            "b66cebe3-2091-4e1c-9524-bdcf3e0be33a"
        ],
        "bf6ea11e-8e5b-4838-9004-1992af41b920": [
            "b66cebe3-2091-4e1c-9524-bdcf3e0be33a"
        ],
        "5722b856-e227-41be-a4b3-f0b9594a5e1a": [
            "f697a72b-6633-43bd-a130-63236a8cc41a"
        ],
        "d914e90c-8848-4b6f-be9f-45c57d9984bf": [
            "f697a72b-6633-43bd-a130-63236a8cc41a"
        ],
        "359b5351-ff65-41b8-8340-52937647cb41": [
            "d8a2051d-d359-4cf4-8925-a62353ca97aa"
        ],
        "3c04a6ad-7945-4a62-8575-ae7c6d09b97d": [
            "d8a2051d-d359-4cf4-8925-a62353ca97aa"
        ],
        "bb9c5355-7f19-4426-ae02-951d5c6ee41c": [
            "e72a911b-5dde-43c6-8058-0e31524bac9c"
        ],
        "2d635d2e-6f48-4e97-960a-0b52a3824579": [
            "e72a911b-5dde-43c6-8058-0e31524bac9c"
        ],
        "dc3b8b32-8f62-490c-8e93-89212c3b1469": [
            "c4c5fd13-8c15-47b3-90d3-36127c1a689b"
        ],
        "0e7493e8-70c0-458a-bec6-6138c756d193": [
            "c4c5fd13-8c15-47b3-90d3-36127c1a689b"
        ],
        "f48f181e-1eec-4ef6-bce0-dbfe2c48a2d9": [
            "e6243a37-3830-4c48-b703-a9b628b8e66c"
        ],
        "e2138c10-ffee-4f7c-bc53-d16a2021938b": [
            "e6243a37-3830-4c48-b703-a9b628b8e66c"
        ],
        "a283079b-edf1-42b2-afa8-d0dd6a7c73fe": [
            "3dc26266-c565-4d91-8927-2a41c9c24e95"
        ],
        "28e55fa3-7bd1-4e11-960c-741bcc28f100": [
            "3dc26266-c565-4d91-8927-2a41c9c24e95"
        ],
        "4147852c-4736-489a-b92a-3ffc1622ca82": [
            "5b1ba475-3f90-4018-88cc-0527f922e0a3"
        ],
        "656899f6-e8fe-4e3a-95fe-025532395d35": [
            "5b1ba475-3f90-4018-88cc-0527f922e0a3"
        ],
        "97afdb3f-0488-4d57-a2f2-92dd974ea61c": [
            "5492d27d-9368-4738-9304-1d91102e2065"
        ],
        "1dd8a668-9908-48f7-9cc1-cd9711bd76fb": [
            "5492d27d-9368-4738-9304-1d91102e2065"
        ],
        "257b542c-27f2-4c51-a3ad-8f9b3dc866f4": [
            "1bd81e41-46d0-4d41-b5ee-77d2b7e281ac"
        ],
        "e2442bfc-c022-458d-b72e-5e6a92d2df30": [
            "1bd81e41-46d0-4d41-b5ee-77d2b7e281ac"
        ],
        "eac91f8d-9558-4600-93cf-bdae52b37162": [
            "4b5b3aba-ee16-4622-afc5-ca3e76fc3ea8"
        ],
        "1a91240a-796a-4b5a-b7e6-d7d16a762846": [
            "4b5b3aba-ee16-4622-afc5-ca3e76fc3ea8"
        ],
        "977967ca-2053-4b8c-b2bf-493e9df0aa93": [
            "4b5b3aba-ee16-4622-afc5-ca3e76fc3ea8"
        ],
        "8475b24d-16fe-4570-b200-b9f76904494c": [
            "4b5b3aba-ee16-4622-afc5-ca3e76fc3ea8"
        ],
        "83ec71af-6863-4325-b794-fdab4c655dbe": [
            "5a22068a-3dff-4f46-964e-7106e3b9d1d1"
        ],
        "3760cab2-95b2-4934-9ba9-50bdf0cfb4f5": [
            "5a22068a-3dff-4f46-964e-7106e3b9d1d1"
        ],
        "34174781-71d5-417b-8ec3-b45a945ca550": [
            "fa3e1310-13e3-45b2-8dd3-afca1efd614d"
        ],
        "682ec822-3bb4-4e8d-b2d6-ddda7874d929": [
            "fa3e1310-13e3-45b2-8dd3-afca1efd614d"
        ]
    },
    "mode": "text"
}